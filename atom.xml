<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2022-05-17T04:00:54.128Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 测试驱动开发介绍</title>
    <link href="https://scottzhang.pro/article/52faaad0.html"/>
    <id>https://scottzhang.pro/article/52faaad0.html</id>
    <published>2022-05-17T03:59:30.000Z</published>
    <updated>2022-05-17T04:00:54.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍了 Python 中各种测试方法与场景。</p></blockquote><span id="more"></span><h1 id="test-runner">Test runner</h1><p>一个特别设计的应用，用来跑测试，检查输出，调试和诊断你的代码。</p><p>Python 有几种测试工具:</p><ul><li>unittest</li><li>nose or nose2</li><li>pytest</li></ul><h2 id="unittest">unittest</h2><p>unittest 要求：</p><ol type="1"><li>把你的测试代码写进 class 或者方法</li><li>在 unittest.TestClass 类中使用一系列特殊断言</li></ol><p>一个简单的测试例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), <span class="number">6</span>, <span class="string">&quot;Should be 6&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_tuple</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="built_in">sum</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)), <span class="number">6</span>, <span class="string">&quot;Should be 6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><h2 id="nose">nose</h2><p>nose 兼容其他测试框架写的代码，nose 会在你的目录寻找所有 <code>py</code> 文件和测试用例进行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install nose2</span><br><span class="line">$ python -m nose2</span><br></pre></td></tr></table></figure><h2 id="pytest">pytest</h2><p>也支持 unitters，它的测试用例是以 <code>test_</code> 开头的一些函数。 pytest 的优点是：</p><ul><li>支持内置的 <code>assert</code> 命令</li><li>可以 filter 测试用例</li><li>支持从上次失败的测试重新开始</li><li>生态系统丰富，支持很多插件</li></ul><p>一个 pytest 的测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_sum():</span><br><span class="line">    assert sum([1, 2, 3]) == 6, &quot;Should be 6&quot;</span><br><span class="line"></span><br><span class="line">def test_sum_tuple():</span><br><span class="line">    assert sum((1, 2, 2)) == 6, &quot;Should be 6&quot; </span><br></pre></td></tr></table></figure><h1 id="编写测试">编写测试</h1><p>一个简单的测试项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">│</span><br><span class="line">├── my_sum/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">|</span><br><span class="line">└── test.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">arg</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> arg:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">    </span><br><span class="line"><span class="comment"># test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> my_sum <span class="keyword">import</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_list_int</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Test that it can sum a list of integers</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        result = <span class="built_in">sum</span>(data)</span><br><span class="line">        self.assertEqual(result, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>断言是你的测试条件，比如你预期，可以通过 <code>.assert*()</code> 编写你的断言，比如 <code>.assertEqual(a, b)</code>，它和 <code>a==b</code> 其实是相等的。</p><p>类似的函数还有：</p><ul><li>assertTrue(x)</li><li>assertFalse(x)</li><li>assertIs(a, b)</li></ul><h1 id="执行测试">执行测试</h1><p>一般通过执行 <code>test.py</code> 文件来测试，在这个文件中你会调用 <code>unittest.main()</code> 函数。</p><p>或者也可以通过命令行的 <code>python -m unittest test</code> 来执行测试。</p><p>通过 <code>python -m unittest -v test</code> 来执行测试并输出每一个测试的内容。</p><p>通过 <code>python -m unittest discover</code> 让其自动发现目前目录戏的 <code>test*.py</code> 文件进行测试，此命名还支持子包的路径: <code>python -m unittest discover -s tests -t src</code>, 其中 src 是子目录名。</p><p>在 PyCharm 中，你可以执行 Run 'Unittests in ..' 来执行测试，在 VS Code 中，进入命令模式，输入 test 即可以看到相关指令。</p><h1 id="web-框架测试">Web 框架测试</h1><blockquote><p>Django, Flask</p></blockquote><p>这类测试很不一样，因为它们内置了一些诸如路由、视图、模型等必要的模块，在启动的时候需要导入，这就好像你要测试一辆车，则需要先将电脑准备好。</p><p>但这类框架也提供了测试工具，比如 Django 在你执行 <code>startapp</code> 的时候，会自动创建 <code>test.py</code> 文件。</p><p>如果你的 Django 项目中没有的话，也可以自己创建，与前面的例子不一样的是，你需要将你的测试类继承自 <code>django.test.TestCase</code>,而不是 <code>unittest.TestCase</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="comment"># Your test methods</span></span><br></pre></td></tr></table></figure><p>在执行的时候，也需要换成 <code>python manage.py test</code>.</p><p>如果你有多个测试文件，则创建一个 test 文件夹，将你的测试文件名更改为 test_*.py，django 会自动发现并执行这些测试。</p><blockquote><p>更多 Django 测试的内容可以参考<a href="https://docs.djangoproject.com/en/2.1/topics/testing/overview/">这里</a></p></blockquote><p>对于 Flask 则又有一些不同，需要设置应用的模式为 test, 然后你可以是实例化一个测试客户端，根据路由去做一些测试。</p><p>实例化的配置都在 setup 方法中，参考下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_app</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        my_app.app.testing = <span class="literal">True</span></span><br><span class="line">        self.app = my_app.app.test_client()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_home</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.app.get(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="comment"># Make your assertions</span></span><br></pre></td></tr></table></figure><p>配置好后，可以直接使用 <code>-m unittest discover</code> 进行测试。</p><blockquote><p>更多 Flask 测试的内容可以参考 <a href="https://flask.palletsprojects.com/en/0.12.x/testing/">Flask Documentation Website</a></p></blockquote><h1 id="高级测试场景">高级测试场景</h1><p>基本的测试步骤：</p><ol type="1"><li>创建你的输入</li><li>执行代码，捕捉输出</li><li>对比输出和预期的结果</li></ol><p>这里输入又叫 fixture， 一般创建后可以重复使用。</p><p>如果你跑一个测试多次，但使用不同的参数，并预期结果是一样的，这叫 parameterization。</p><h1 id="集成测试">集成测试</h1><p>集成测试，顾名思义，会集成多个测试用来检查其每个模块是否都工作，它会站在用户的角度去测试你的软件。</p><p>通常集成测试的代码会和单元测试的分开，因为集成测试需要跑更多的模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">│</span><br><span class="line">├── my_app/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">│</span><br><span class="line">└── tests/</span><br><span class="line">    |</span><br><span class="line">    ├── unit/</span><br><span class="line">    |   ├── __init__.py</span><br><span class="line">    |   └── test_sum.py</span><br><span class="line">    |</span><br><span class="line">    └── integration/</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── test_integration.py</span><br></pre></td></tr></table></figure><p>使用 unitters, 你可以通过 -s 来指定只包含某个部分的代码来进行测试。</p><p><code>python -m unittest discover -s tests/integration</code></p><p>如果你的测试依赖一些文件，可以新建fixtures文件夹，将数据放到里面。</p><h1 id="环境测试">环境测试</h1><p>你想知道你的代码放在不同版本的 python 中是否工作，可以使用 Tox.</p><p>Tox 使用需要配置，它有一个配置文件，里面包括：</p><ul><li>测试需要执行的代码</li><li>执行测试需要的包</li><li>目标环境版本</li></ul><p>你可以执行 <code>tox-quickstart</code> 来启动快速配置脚本，回答问题即可生成 <code>tox.ini</code> 配置文件。</p><h1 id="自动测试">自动测试</h1><p>自动化测试工具，又被称为 CI/CD 工具，意思是 持续集成持续部署(Continuous Integration/Continuous Deployment)。</p><p>Travis CI 是在 Python 下不错的 CI 工具，并且对于所有 Github，GitLab 上开源的项目都免费，它会创建一个 <code>.travis.yml</code> 配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;2.7&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.txt</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">unittest</span> <span class="string">discover</span></span><br></pre></td></tr></table></figure><p>这个配置会测试代码在 python 2.7, 3.7 中是否工作，安装你配置文件中的包，并执行所有自动发现的单元测试。</p><p>当你配置好之后，Travis CI 会在你每次 push 后自动测试你的代码。</p><h1 id="其他测试相关内容">其他测试相关内容</h1><ul><li>使用 Linters， 比如 flake8</li><li>保持干净的测试代码，遵循 DRY( Don’t Repeat Yourself) 原则</li><li>使用 timeit 或是 pytest-benchmark 模块，查看测试性能</li><li>使用 bandit 测试你的包的安全问题.</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍了 Python 中各种测试方法与场景。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="unittest" scheme="https://scottzhang.pro/tags/unittest/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 基本信息速查</title>
    <link href="https://scottzhang.pro/article/96143e16.html"/>
    <id>https://scottzhang.pro/article/96143e16.html</id>
    <published>2022-05-17T03:55:06.000Z</published>
    <updated>2022-05-17T03:56:08.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些关于 Oracle 基本信息查询的常用 sql。</p></blockquote><span id="more"></span><h2 id="数据库信息">数据库信息</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库版本</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v$version;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前数据库名</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> v$database;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前数据库实例名</span></span><br><span class="line"><span class="keyword">select</span> instance_name <span class="keyword">from</span> v$instance;</span><br></pre></td></tr></table></figure><h2 id="表空间">表空间</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表空间信息</span></span><br><span class="line"><span class="comment">-- 参考: https://techgoeasy.com/how-to-check-tablespace-in-oracle-database/</span></span><br><span class="line"><span class="comment">-- 查看表空间</span></span><br><span class="line"><span class="keyword">SELECT</span> TABLESPACE_NAME &quot;TABLESPACE&quot;, EXTENT_MANAGEMENT,FORCE_LOGGING,</span><br><span class="line">BLOCK_SIZE,</span><br><span class="line">SEGMENT_SPACE_MANAGEMENT</span><br><span class="line"><span class="keyword">FROM</span> DBA_TABLESPACES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表空间文件地址</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">FILE_NAME, </span><br><span class="line">BLOCKS, </span><br><span class="line">TABLESPACE_NAME</span><br><span class="line"><span class="keyword">FROM</span> DBA_DATA_FILES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查表空间文件大小，输入表空间名字</span></span><br><span class="line"><span class="comment">-- 结果为 MB</span></span><br><span class="line"><span class="keyword">Select</span> (<span class="built_in">sum</span>(bytes)<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>) Space_allocated</span><br><span class="line"><span class="keyword">from</span> dba_data_files</span><br><span class="line"><span class="keyword">where</span> tablespace_name<span class="operator">=</span><span class="built_in">upper</span>(<span class="string">&#x27;&amp;tname&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="schema-与用户">Schema 与用户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Schema 与用户的区别</span></span><br><span class="line"><span class="comment">-- A schema is a collection of database objects (used by a user.). </span></span><br><span class="line"><span class="comment">-- Schema objects are the logical structures that directly refer to the database’s data.</span></span><br><span class="line"><span class="comment">-- A user is a name defined in the database that can connect to and access objects. </span></span><br><span class="line"><span class="comment">-- Schemas and users help database administrators manage database security.</span></span><br><span class="line"><span class="comment">-- 一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。</span></span><br><span class="line"><span class="comment">-- 查用户信息，包括 schema</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dba_users;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有用户</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_users; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_users; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看用户或角色系统权限</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_sys_privs; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_sys_privs; (查看当前用户所拥有的权限)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/hellojesson/p/3398268.html">如何查询Oracle中所有用户信息</a></p></blockquote><h1 id="查索引">查索引</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- user index</span></span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, TABLE_OWNER, TABLE_NAME, UNIQUENESS <span class="keyword">from</span> USER_INDEXES</span><br><span class="line"></span><br><span class="line"><span class="comment">-- all index</span></span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, TABLE_OWNER, TABLE_NAME, UNIQUENESS <span class="keyword">from</span> ALL_INDEXES</span><br><span class="line"></span><br><span class="line"><span class="comment">-- all index filter by table name</span></span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, TABLE_OWNER, TABLE_NAME, UNIQUENESS <span class="keyword">from</span> ALL_INDEXES</span><br><span class="line"><span class="keyword">where</span> table_owner <span class="keyword">like</span> <span class="string">&#x27;%DC%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- all index group by table owner</span></span><br><span class="line"><span class="keyword">select</span> table_owner, <span class="built_in">COUNT</span>(TABLE_OWNER) <span class="keyword">from</span> ALL_INDEXES</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> table_owner;</span><br></pre></td></tr></table></figure><h1 id="表与视图">表与视图</h1><h2 id="有哪些表和视图">有哪些表和视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- list all user&#x27;s table</span></span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> all_tables <span class="keyword">order</span> <span class="keyword">by</span> table_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list all views</span></span><br><span class="line"><span class="keyword">select</span> view_name <span class="keyword">from</span> all_views <span class="keyword">where</span> view_name <span class="keyword">like</span> <span class="string">&#x27;GRA%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> view_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- check table length</span></span><br><span class="line"><span class="keyword">select</span> table_name, num_rows <span class="keyword">from</span> all_tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- create table from another view or table</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> prs7.t_gra_stores_mapping_dc <span class="keyword">as</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> prs4.GRA_STORE_MAPPING_INFO_DC);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查表占用空间">检查表占用空间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">segment_name,</span><br><span class="line">sum(bytes)/1024/1024/1024 GB </span><br><span class="line">from user_segments </span><br><span class="line">where segment_type=&#x27;TABLE&#x27; and segment_name=upper(&#x27;&amp;TABLE_NAME&#x27;) group by segment_name;</span><br></pre></td></tr></table></figure><h1 id="查看执行计划">查看执行计划</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> a, b, c</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">TABLE</span>(dbms_xplan.display);</span><br></pre></td></tr></table></figure><h1 id="oracle-文档阅读">Oracle 文档阅读</h1><ul><li><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/introduction-to-oracle-database.html#GUID-A42A6EF0-20F8-4F4B-AFF7-09C100AE581E">Introduction to Oracle Database</a></li><li><a href="https://oracle-base.com/articles/misc/naming-conventions#EntitiesTables">Oracle Naming Conventions</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些关于 Oracle 基本信息查询的常用 sql。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="oracle" scheme="https://scottzhang.pro/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 数据处理技巧</title>
    <link href="https://scottzhang.pro/article/23f82ff0.html"/>
    <id>https://scottzhang.pro/article/23f82ff0.html</id>
    <published>2022-05-17T03:31:37.000Z</published>
    <updated>2022-05-17T03:45:44.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些数据处理小技巧，不成体系。</p></blockquote><span id="more"></span><h3 id="了解文件">了解文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 读取数据</span></span><br><span class="line"><span class="comment"># csv, excel, txt, etc...</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">sndata = pd.read_csv(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看数据结构和类型</span></span><br><span class="line">sndata.dtypes</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看index</span></span><br><span class="line">sndata.index</span><br><span class="line">&gt; index是可以定义的，默认是<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,也可以是a,b,c</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看列名</span></span><br><span class="line">sndata.columns</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看缺失的数据</span></span><br><span class="line">sndata.isnull()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 转换成DataFrame</span></span><br><span class="line">pd.DataFrame(sndata)</span><br><span class="line">&gt; The resulting DataFrame will have its index assigned automatically <span class="keyword">as</span> <span class="keyword">with</span> Series, <span class="keyword">and</span></span><br><span class="line">the columns are placed <span class="keyword">in</span> <span class="built_in">sorted</span> order:</span><br><span class="line"></span><br><span class="line"><span class="comment">## 去重复</span></span><br><span class="line">sndata.duplicated([<span class="string">&#x27;MonitorFA&#x27;</span>])</span><br><span class="line">sndata[sndata.duplicated([<span class="string">&#x27;ComputerSN&#x27;</span>],keep = <span class="literal">False</span>)]</span><br><span class="line">Drop_duplicates当中的参数keep=<span class="literal">False</span>，意为重复项全部删除，它还有keep=<span class="string">&quot;first&quot;</span>与keep=<span class="string">&quot;last&quot;</span>，分别对应在有多项重复时，保留第一项（或最后一项）</span><br><span class="line"></span><br><span class="line"><span class="comment">## 找出两个表不一样的地方</span></span><br><span class="line">c=a.append(b)</span><br><span class="line">c.drop_duplicates(keep=<span class="literal">False</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">c.reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除 NA</span></span><br><span class="line">df.dropna(axis=‘columns’,how=‘<span class="built_in">all</span>’)</span><br></pre></td></tr></table></figure><h3 id="检测文件是否有-header">检测文件是否有 Header</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">path = <span class="string">r&#x27;C:\Users\scott\Documents\Test_Data\distribution\myfile.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    dialect = csv.Sniffer().has_header(csvfile.read(<span class="number">1024</span>))</span><br><span class="line"><span class="built_in">print</span>(dialect)</span><br></pre></td></tr></table></figure><h3 id="大数据集处理">大数据集处理</h3><ol type="1"><li>回收垃圾</li><li>提前设置好 dtype</li><li>选择有限的行，列</li><li>使用 chunk 分批导入、处理</li><li>Tips 查看内存消耗: <code>train.memory_usage(deep=True) * 1e-6</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import some file</span></span><br><span class="line">temp = pd.read_csv(<span class="string">&#x27;../input/train_sample.csv&#x27;</span>)</span><br><span class="line"><span class="comment">#do something to the file</span></span><br><span class="line">temp[<span class="string">&#x27;os&#x27;</span>] = temp[<span class="string">&#x27;os&#x27;</span>].astype(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"><span class="comment">#delete when no longer needed</span></span><br><span class="line"><span class="keyword">del</span> temp</span><br><span class="line"><span class="comment">#collect residual garbage</span></span><br><span class="line">gc.collect()</span><br></pre></td></tr></table></figure><p>参考：https://www.kaggle.com/rohanrao/tutorial-on-reading-large-datasets#Large-datasets</p><h3 id="tidy-data-原则">Tidy Data 原则</h3><ol type="1"><li>Columns represent separate variables</li><li>Raws represent individual observations</li><li>Observational units from tables</li></ol><h3 id="cut-方法">Cut 方法</h3><p>用于检测数据的分类，比如19,20,35 对应人员年龄的分层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.cut(a,b)</span><br><span class="line"></span><br><span class="line">a: data</span><br><span class="line">b:category info</span><br></pre></td></tr></table></figure><h3 id="时间日期处理">时间日期处理</h3><blockquote><p>内容太多，只记录了个人的笔记。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间切片</span></span><br><span class="line">ts = pd.to_datetime(<span class="string">&#x27;///&#x27;</span>)</span><br><span class="line">ufo.loc([ufo.time &gt;= ts],:)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 星期、年、等计算</span></span><br><span class="line">ufo.time.dt.dayofyear.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最新时间、计算</span></span><br><span class="line">ufo.time.<span class="built_in">max</span>() - ufo.time.<span class="built_in">min</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期转换时间段</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> monthrange</span><br><span class="line"></span><br><span class="line">start = datetime.strptime(<span class="string">&#x27;20201402&#x27;</span>,<span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">_,days = monthrange(start.year, start.month)</span><br><span class="line">end_str = <span class="string">f&#x27;<span class="subst">&#123;start.year&#125;</span>-<span class="subst">&#123;start.month&#125;</span>-<span class="subst">&#123;days&#125;</span>&#x27;</span></span><br><span class="line">end = datetime.strptime(end_str,<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="category-datatype">Category Datatype</h3><ul><li>object 通常是 string，这个object指向本来的python 的list或者dict对象</li><li>memory usage xxx+ KB, +的意思是最少需要这么多空间去存储这些引用</li><li>drinks.info(memory_usage='deep') ： 查看真实的空间需求</li><li>每一列需要的空间: drinks.memory_usage(deep=True)</li></ul><h3 id="append-和-concat">append 和 concat</h3><p>对于Series：</p><ul><li>append会将index直接加上去，索引还是以前的，如果按照索引去选择，可能会返回多个数据, 最好在 append 后加上 resetindex</li><li>concat默认会重设索引，也可以使用ignore_index保留索引</li></ul><p>对于DataFrame：</p><ul><li>append：如果列名字一样，直接在后面添加，如果不一样，增加相应的列，填充空值。</li><li>concat：指定axis=0，则效果和append一样，axis=1，会合并值一样的行</li></ul><p>append和concat操作中 index的变化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># concat直接将两份数据合并到一起</span></span><br><span class="line"><span class="comment"># 如果你的两份数据分别是13年和14年的，你想要添加索引将其分开，可以使用：</span></span><br><span class="line">rain1314 = pd.concat([rain2013, rain2014], keys=[<span class="number">2013</span>, <span class="number">2014</span>], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样是以row名来分类，当然也可以用column名来分类：</span></span><br><span class="line">rain1314 = pd.concat([rain2013, rain2014], keys=[<span class="number">2013</span>, <span class="number">2014</span>], axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个dataframe不仅可以从数组中构造，也可以从dict中</span></span><br><span class="line"><span class="comment"># 这样就不必后期指定key的值了：</span></span><br><span class="line">rain_dict = &#123;<span class="number">2013</span>: rain2013, <span class="number">2014</span>: rain2014&#125; </span><br><span class="line">rain1314 = pd.concat(rain_dict, axis=<span class="string">&#x27;columns&#x27;</span>) </span><br></pre></td></tr></table></figure><p>对于 join:</p><ul><li>inner join, 把不同表中，索引名字一样的行的列合并，如果某些列没有的，则过滤掉这一行。</li><li>outer join, 把两个表合并，所有索引都合并，如果某些列没有值的，填充值为nanaxis = 1或者0, 对列或者行操作</li></ul><h3 id="merge">Merge</h3><p>merge默认指定的列来合并两个表的其他列，默认根据 index。</p><p>如果类似多索引的两个表，索引部分的值无法一一对应，那么就需要指定根据哪一列来merge，如果只指定了一列，那么肯定会有两个表都对应同一列数据的情况出现，可以用suffixes参数，来对这些列进行区分（一般是根据表名），当然也可以直接指定多个列来merge。</p><p>一般默认会使用index去merge，但更多的是使用lefton和righton参数来指定左右两个表中的列来merge。</p><h3 id="从多标签中切分值">从多标签中切分值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx = pd.IndexSlice</span><br><span class="line">slice_2_8 = february.loc[<span class="string">&#x27;2015-2-2&#x27;</span>:<span class="string">&#x27;2015-2-8&#x27;</span>, idx[:, <span class="string">&#x27;Company&#x27;</span>]]</span><br></pre></td></tr></table></figure><h3 id="多列操作">多列操作</h3><p>从多列创建日期</p><p><img src="https://s2.loli.net/2022/05/17/mxKPnu3bCTiINlq.png" /></p><p>批量转换列的数据类型</p><p><img src="https://s2.loli.net/2022/05/17/6aNR4GMCXSbZiWg.png" /></p><p>批量对列使用聚合函数</p><p><img src="https://s2.loli.net/2022/05/17/LauhgMiFtOXPjrU.png" /></p><p>批量重命名列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns = &#123;<span class="string">&#x27;oldname&#x27;</span>:<span class="string">&#x27;new_name&#x27;</span>&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="避免赋值出现-warning">避免赋值出现 warning</h3><p><img src="https://s2.loli.net/2022/05/17/GTyqipAekfHo2wP.png" /></p><h3 id="关闭科学记数法">关闭科学记数法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/21137150/format-suppress-scientific-notation-from-python-pandas-aggregation-results</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.3f&#x27;</span> % x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置千分符</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x:<span class="string">&#x27;&#123;:,.0f&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br></pre></td></tr></table></figure><h3 id="by-行修改值">By 行修改值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/23330654/update-a-dataframe-in-pandas-while-iterating-row-by-row</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">    <span class="keyword">if</span> &lt;something&gt;:</span><br><span class="line">        df.at[row.Index, <span class="string">&#x27;ifor&#x27;</span>] = x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        df.at[row.Index, <span class="string">&#x27;ifor&#x27;</span>] = x</span><br><span class="line">df.loc[row.Index, <span class="string">&#x27;ifor&#x27;</span>] = x</span><br></pre></td></tr></table></figure><h3 id="pd.iterrows-的限制">pd.iterrows 的限制</h3><blockquote><p>pd.DataFrame.iterrows you are iterating through rows as Series. But these are not the Series that the data frame is storing and so they are new Series that are created for you while you iterate.</p></blockquote><p>Refer <a href="https://stackoverflow.com/questions/23330654/update-a-dataframe-in-pandas-while-iterating-row-by-row">this</a></p><h3 id="pd.xs-方法">pd.xs 方法</h3><p>多个 index 取值，但不能用来设置值，默认它返回原数据中的一份 copy。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># by default, returns a new dataframe with a copy of the data</span></span><br><span class="line">df.xs(<span class="string">&#x27;C&#x27;</span>) </span><br></pre></td></tr></table></figure><p>Refer <a href="https://stackoverflow.com/questions/13842088/set-value-for-particular-cell-in-pandas-dataframe-using-index">this</a></p><h3 id="理解-pandas-的-axis">理解 Pandas 的 Axis</h3><p>对于 Dataframe</p><ul><li>“axis 0” represents rows direction and “axis 1” represents columns direction</li><li>可以使用 “index” 与 “row” 代表 0； “column” 代表 1</li><li>Sum 应用到 “axis 0”，意味着 sum 每列的结果</li><li>Sum 应用到 “axis 1”，意味着 sum 每行的结果</li></ul><p><img src="https://s2.loli.net/2022/05/17/MPx9yEOuhASFN2C.png" /></p><blockquote><p>dropna 可以默认是丢弃有 na 值的行，如果你需要丢弃有 na 值的列，将 axis 设置为 1 即可。</p></blockquote><p>对于 Series</p><blockquote><p>Series and DataFrame share the same direction for “axis 0”</p></blockquote><p><img src="https://s2.loli.net/2022/05/17/u7imoNkQeMXAsaB.png" /></p><h3 id="提高-dataframe-遍历速度">提高 Dataframe 遍历速度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For 循环，iloc 访问 df : 2.65 秒</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_for</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df)):</span><br><span class="line">        temp += df[<span class="string">&#x27;A&#x27;</span>].iloc[index] + df[<span class="string">&#x27;B&#x27;</span>].iloc[index]</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># For 循环，df.iterrows 访问 df：12.4 秒, 会花费大量时间在</span></span><br><span class="line"><span class="comment"># 创建 series 对象（且不会保留 dtype，如果需要建议使用 itertuples）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_iterrows</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">            temp += row.A + row.B</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="comment"># For 循环，df.itertuples 访问 df：136 毫秒，终于来到毫秒级别</span></span><br><span class="line"><span class="comment"># 但它还是会创建 namedtuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_itertuples</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row_tuple <span class="keyword">in</span> df.itertuples():</span><br><span class="line">        temp += row_tuple.A + row_tuple.B</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，我们可以自己实现，避免创建 nameduple,使用 zip 函数</span></span><br><span class="line"><span class="comment"># For 循环，zip 函数访问，30 毫秒，这里的改进来自于避免创建 namedtuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_zip</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(df[<span class="string">&#x27;A&#x27;</span>], df[<span class="string">&#x27;B&#x27;</span>]):</span><br><span class="line">        temp += a + b</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pandas 自带的 apply 函数</span></span><br><span class="line"><span class="comment"># 3.28 秒，看起来和普通的 for 循环差不多</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_apply</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> df.apply(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;A&#x27;</span>] + x[<span class="string">&#x27;B&#x27;</span>], axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pandas 自带的 add 函数</span></span><br><span class="line"><span class="comment"># 849 µs，pandas 自带的这种函数运行效率非常高</span></span><br><span class="line"><span class="comment"># 如果你的操作可以分解成这种就优先使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_add</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (df[<span class="string">&#x27;A&#x27;</span>]+df[<span class="string">&#x27;B&#x27;</span>]).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你还是很在乎性能，可以使用 numpy</span></span><br><span class="line"><span class="comment"># 将数据转化成 numpy 的 array</span></span><br><span class="line"><span class="comment"># 186 µs，提升八倍</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_numpy_builtin</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (df[<span class="string">&#x27;A&#x27;</span>].values + df[<span class="string">&#x27;B&#x27;</span>].values).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同大小的数据，对结果会有影响，如果是大数据集，结果差距会非常明显，附图：</span></span><br><span class="line"><span class="comment"># iterrows 是效率最差的,其次是 apply，和 普通的 for 循环，两者差不多</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一定要用 apply 怎么办呢？</span></span><br><span class="line"><span class="comment"># 可以使用如下的第二种方式, * here is to unpack all values in list </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_apply</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> df.apply(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;A&#x27;</span>] + x[<span class="string">&#x27;B&#x27;</span>] + x[<span class="string">&#x27;C&#x27;</span>] + x[<span class="string">&#x27;D&#x27;</span>], axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_apply_unpack</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]].apply(<span class="keyword">lambda</span> x: <span class="built_in">sum</span>([*x]), axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>速度测试对比：</p><p><img src="https://s2.loli.net/2022/05/17/4Ej1WL9nxTOyXPC.png" /></p><h3 id="测试你代码的速度">测试你代码的速度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 自带</span></span><br><span class="line">%timeit using_numpy_builtin(df)</span><br><span class="line"><span class="comment"># notebook 自带</span></span><br><span class="line">%prun -l <span class="number">4</span> loop_with_iterrows(df)</span><br></pre></td></tr></table></figure><h3 id="使用-pd.wide_to_long">使用 pd.wide_to_long</h3><p>wide_to_long allows us to set stub names that can group columns.</p><p>Remember that wide_to_long() function takes the main arguments: i to set the unique row index, j to set the new variable name, and stubnames to extract the start of the wide columns.</p><p>needed to specify the separating elements. When you didn't do that, pandas didn't recognize the column names and returned an empty DataFrame.</p><p>Also, wide_to_long() always assumes that suffixes are numeric, so don't forget to specify if they are not!</p><h3 id="使用-pd.apply">使用 pd.apply</h3><p>创建列 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Discounted_Price&#x27;</span>] = df.apply(</span><br><span class="line">    <span class="keyword">lambda</span> row: row.Cost - (row.Cost * <span class="number">0.1</span>),</span><br><span class="line">    axis = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Print the DataFrame after addition of new column</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></p><p>对比 map</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># apply 返回 dataframe，增加两列</span></span><br><span class="line">a = p.apply(<span class="keyword">lambda</span> x: pd.Series([x,x+<span class="number">1</span>,x+<span class="number">2</span>]))</span><br><span class="line"><span class="comment"># map，返回3个 Series</span></span><br><span class="line">a,b,c = p.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: pd.Series([x,x+<span class="number">1</span>,x+<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><h3 id="pivot-和-pivottable">Pivot 和 Pivottable</h3><p>When the .pivot() method finds two rows with the same index and column, but different values for the values, it doesn't know how to handle it.</p><h3 id="dataframe-增加总和grand-total">Dataframe 增加总和（Grand Total）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/21752399/pandas-dataframe-total-row</span></span><br><span class="line">df.loc[<span class="string">&#x27;Column_Total&#x27;</span>]= df.<span class="built_in">sum</span>(numeric_only=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">df.loc[:,<span class="string">&#x27;Row_Total&#x27;</span>] = df.<span class="built_in">sum</span>(numeric_only=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="pandas-求众数">Pandas 求众数</h3><p>两种方法都可以，性能差异不大：</p><p><img src="https://s2.loli.net/2022/05/17/uz2aefXxApK1VvO.png" /></p><h3 id="根据条件对列赋值">根据条件对列赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Numpy Where 方法</span></span><br><span class="line">df[<span class="string">&#x27;hasimage&#x27;</span>] = np.where(df[<span class="string">&#x27;photos&#x27;</span>]!= <span class="string">&#x27;[]&#x27;</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Numpy Select 方法</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># read data</span></span><br><span class="line">all_ = pd.read_excel(<span class="string">&#x27;./scott.xlsx&#x27;</span>,sheet_name=<span class="string">&#x27;ALL&#x27;</span>)</span><br><span class="line">enc_ = pd.read_excel(<span class="string">&#x27;./scott.xlsx&#x27;</span>,sheet_name=<span class="string">&#x27;ENC&#x27;</span>)</span><br><span class="line">result = pd.read_excel(<span class="string">&#x27;./scott.xlsx&#x27;</span>,sheet_name=<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enc store list unique array</span></span><br><span class="line">enc_store_list = enc_.STORECODE.unique()</span><br><span class="line"></span><br><span class="line">conditions = [</span><br><span class="line">    all_.STORECODE.isin(enc_store_list),</span><br><span class="line">    ~all_.STORECODE.isin(enc_store_list)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PVAL_OLD values</span></span><br><span class="line">pval_new_values = [</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    all_[conditions[<span class="number">1</span>]].PVAL.values</span><br><span class="line">]</span><br><span class="line">pvol_new_values = [</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    all_[conditions[<span class="number">1</span>]].PVOL.values</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">all_[<span class="string">&#x27;PVOL_NEW&#x27;</span>] = np.select(conditions,pvol_new_values)</span><br><span class="line">all_[<span class="string">&#x27;PVAL_NEW&#x27;</span>] = np.select(conditions,pval_new_values)</span><br><span class="line"></span><br><span class="line">all_.rename(columns=&#123;<span class="string">&#x27;PVOL&#x27;</span>:<span class="string">&#x27;PVOL_OLD&#x27;</span>,<span class="string">&#x27;PVAL&#x27;</span>:<span class="string">&#x27;PVAL_OLD&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用多进程提高数据处理速度">使用多进程提高数据处理速度</h3><p>我们知道 Python 因为 GIL 的关系，对于 CPU 密集操作无法有效利用多核处理器，我们可以使用多进程来打破这个限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有以下代码</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span>  Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_features</span>(<span class="params">df</span>):</span></span><br><span class="line">    df[<span class="string">&#x27;question_text&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> x:<span class="built_in">str</span>(x))</span><br><span class="line">    df[<span class="string">&quot;lower_question_text&quot;</span>] = df[<span class="string">&quot;question_text&quot;</span>].apply(<span class="keyword">lambda</span> x: x.lower())</span><br><span class="line">    df[<span class="string">&#x27;total_length&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="built_in">len</span>)</span><br><span class="line">    df[<span class="string">&#x27;capitals&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> c <span class="keyword">in</span> comment <span class="keyword">if</span> c.isupper()))</span><br><span class="line">    df[<span class="string">&#x27;caps_vs_length&#x27;</span>] = df.apply(<span class="keyword">lambda</span> row: <span class="built_in">float</span>(row[<span class="string">&#x27;capitals&#x27;</span>])/<span class="built_in">float</span>(row[<span class="string">&#x27;total_length&#x27;</span>]),</span><br><span class="line">                                axis=<span class="number">1</span>)</span><br><span class="line">    df[<span class="string">&#x27;num_words&#x27;</span>] = df.question_text.<span class="built_in">str</span>.count(<span class="string">&#x27;\S+&#x27;</span>)</span><br><span class="line">    df[<span class="string">&#x27;num_unique_words&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">len</span>(<span class="built_in">set</span>(w <span class="keyword">for</span> w <span class="keyword">in</span> comment.split())))</span><br><span class="line">    df[<span class="string">&#x27;words_vs_unique&#x27;</span>] = df[<span class="string">&#x27;num_unique_words&#x27;</span>] / df[<span class="string">&#x27;num_words&#x27;</span>] </span><br><span class="line">    df[<span class="string">&#x27;num_exclamation_marks&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: comment.count(<span class="string">&#x27;!&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_question_marks&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: comment.count(<span class="string">&#x27;?&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_punctuation&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> <span class="string">&#x27;.,;:&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_symbols&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> <span class="string">&#x27;*&amp;$%&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_smilies&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> (<span class="string">&#x27;:-)&#x27;</span>, <span class="string">&#x27;:)&#x27;</span>, <span class="string">&#x27;;-)&#x27;</span>, <span class="string">&#x27;;)&#x27;</span>)))</span><br><span class="line">    df[<span class="string">&#x27;num_sad&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> (<span class="string">&#x27;:-&lt;&#x27;</span>, <span class="string">&#x27;:()&#x27;</span>, <span class="string">&#x27;;-()&#x27;</span>, <span class="string">&#x27;;(&#x27;</span>)))</span><br><span class="line">    df[<span class="string">&quot;mean_word_len&quot;</span>] = df[<span class="string">&quot;question_text&quot;</span>].apply(<span class="keyword">lambda</span> x: np.mean([<span class="built_in">len</span>(w) <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">str</span>(x).split()]))</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallelize_dataframe</span>(<span class="params">df, func, n_cores=<span class="number">4</span></span>):</span></span><br><span class="line">    df_split = np.array_split(df, n_cores)</span><br><span class="line">    pool = Pool(n_cores)</span><br><span class="line">    df = pd.concat(pool.<span class="built_in">map</span>(func, df_split))</span><br><span class="line">    <span class="comment"># 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">train = parallelize_dataframe(train_df, add_features)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于多进程，可以<a href="https://scottzhang.pro/article/4300f84b.html">点击</a>了解更多。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些数据处理小技巧，不成体系。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 基础操作</title>
    <link href="https://scottzhang.pro/article/706b7b04.html"/>
    <id>https://scottzhang.pro/article/706b7b04.html</id>
    <published>2022-05-17T01:59:34.000Z</published>
    <updated>2022-05-17T03:45:39.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍了 Pandas 中的 Index，Series, Dataframe 及其基本操作。</p></blockquote><span id="more"></span><h1 id="概念介绍">概念介绍</h1><h2 id="index">Index</h2><p>Index 对象主要保存了关于轴的信息，index 对象类似数组，可以被切片，可以根据下标访问，但是不可以被修改;</p><p>可以通过 pd.Index 构造 index 对象，index 对象可以拥有重复的值。</p><p>index 比较常用的方法:</p><p><img src="https://i.loli.net/2021/03/22/fca94zqHgxJ7Ey8.jpg" /></p><h2 id="series">Series</h2><p>Series 可以直接从数组初始化，如果没有指定 index，则会默认分配数字作为 index，也可以指定 index，但要求其长度与 values 一致。</p><p>当指定了 index 后，可直接通过 index 的名字访问 value，比如 <code>obj['a']</code> 或者 <code>obj[['a','b','c']]</code>，可以通过 <code>obj[obj &gt; 0]</code> 的方式 filter其元素，或者进行运算：<code>'a' in obj</code>， <code>obj * 2</code>;</p><p>可以通过 dict 初始化 Series，结果的顺序与和 dict 中的 key 排序后的一样，如果像自定义顺序，可以在初始化函数中单独指定 index，需要保证传入的 index 在 dict 中的 key 中存在，否则会将值设为空。</p><p>多个 Series 在参与计算的时候，会自动对齐 index，有点类似 database 中的 join。</p><p>Series 对象本身和它的index 都有一个叫 name 的属性, index 可以被其它的值替代。</p><h2 id="dataframe">DataFrame</h2><p>可以理解为 dict 中 value 为 Series，构造 dataframe 的方式也可以直接通过 dict，DataFrame 的 index 也和 Series 一样，会自动指定，column 的顺序也会重新排序，你也可以指定指定列的顺序，就像 Series 一样: <code>pd.DataFrame(data, columns=[...])</code>，如果你传的 columns 数组中，有 data 中没有的值，则会将该列添加到 DataFrame 中，值全部置空。</p><p>DataFrame 中的列，可以通过 <code>df['a']</code> 或者 <code>df.a</code> 两种方式访问，将会返回一个 Series，第一种方式在任何情况下都可以使用，第二种方式则需要 column name 满足 python 对于变量名字的要求。从 DataFrame 拿到的 Series，将会拥有和 DataFrame 一样的 index，它的 name 属性也已经被自动设定。</p><p>DaFrame 中的行，也可以通过位置和名字访问，例如 loc 方法（之后介绍）。</p><p>给 Column 赋的值，可以是一个值，也可以是一个数组，或者 Series 对象。如果是数组，数组长度要与 dataframe 一致；如果是 Series，将按照 index label 赋值给 DataFrame; 给不存在的 column 赋值，会创建一个新的 column (只可以通过 ['column'] 的方式创建);</p><p>删除列，通过 <code>del df['col']</code> 操作，但这种写法不鼓励，可以通过 <code>df.drop(columns=['B', 'C'])</code>。</p><p>DataFrame 的 column 和 index 都可以有 name, <code>df.index.name = 'idx'</code>, <code>df.columns.name = 'col'</code>, df.values 会返回一个 DataFrame 的值的二维数组。</p><h1 id="essential-functionality">Essential Functionality</h1><h2 id="reindexing">Reindexing</h2><p>reindex 是 pandas 里实现数据对齐的基本方法, 沿着指定轴，让现有数据匹配一组新标签，并重新排序。</p><p>可以在无数据但有标签的位置插入缺失值。</p><p>编写注重性能的代码时，最好花些时间深入理解 reindex：预对齐数据后，操作会更快。两个未对齐的 DataFrame 相加，后台操作会执行 reindex。</p><p>提取一个对象，并用另一个具有相同标签的对象 reindex 该对象的轴。这种操作的语法虽然简单，但未免有些啰嗦。这时，最好用 reindex_like() 方法，这是一种既有效，又简单的方式。</p><p>align() 方法是对齐两个对象最快的方式，该方法支持 join 参数,比如你想要根据 df2的列的顺序排序 df1 的列顺序 <code>df1.align(df2, join='left'), axis=1</code>。</p><p>可以直接调用 Series <code>s.rename(str.upper)</code> 来操作 index 上的 string 格式; 也可以操作 df 的 index 和 columns, <code>df.rename(&#123;'one': 'foo', 'two': 'bar'&#125;, axis='columns')</code>。</p><p>reindex，ffill 与 bfill，在 reindex 时候产生的值用前、后的值去取代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">219</span>]: rng = pd.date_range(<span class="string">&#x27;1/3/2000&#x27;</span>, periods=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: ts = pd.Series(np.random.randn(<span class="number">8</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">221</span>]: ts2 = ts[[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: ts</span><br><span class="line">Out[<span class="number">222</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.400528</span></span><br><span class="line"><span class="number">2000</span>-01-05   -<span class="number">0.015083</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">1.414806</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.118428</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>   -<span class="number">0.936077</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">223</span>]: ts2</span><br><span class="line">Out[<span class="number">223</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: ts2.reindex(ts.index)</span><br><span class="line">Out[<span class="number">224</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04         NaN</span><br><span class="line"><span class="number">2000</span>-01-05         NaN</span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07         NaN</span><br><span class="line"><span class="number">2000</span>-01-08         NaN</span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>         NaN</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">225</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line">Out[<span class="number">226</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>         NaN</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>上面的做法亦可通过 <code>ts2.reindex(ts.index).fillna(method='ffill')</code> 实现, 如果索引不是按递增或递减排序，reindex() 会触发 ValueError 错误。fillna() 与 interpolate() 则不检查索引的排序。limit 与 tolerance 参数可以控制 reindex 的填充操作。limit 限定了连续匹配的最大数量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">229</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;ffill&#x27;</span>, limit=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05         NaN</span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08         NaN</span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>tolerance 限定了索引与索引器值之间的最大距离：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">230</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;ffill&#x27;</span>, tolerance=<span class="string">&#x27;1 day&#x27;</span>)</span><br><span class="line">Out[<span class="number">230</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05         NaN</span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08         NaN</span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><blockquote><p>索引为 DatetimeIndex、TimedeltaIndex 或 PeriodIndex 时，tolerance 会尽可能将这些索引强制转换为 Timedelta，这里要求用户用恰当的字符串设定 tolerance 参数。</p></blockquote><h2 id="dropping-entries-from-an-axis">Dropping Entries from an Axis</h2><p>如果有了 index，可以直接 index 名字删除某行 <code>new_obj = obj.drop('c')</code>, 或者同时删除多行 <code>data.drop(['Colorado', 'Ohio'])</code>,<code>axis=1</code> 删除列，0 删除行。</p><h1 id="代码示例">代码示例</h1><h2 id="indexing-value">Indexing value</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用中括号</span></span><br><span class="line">df[<span class="string">&quot;eggs&quot;</span>][<span class="string">&#x27;May&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列名</span></span><br><span class="line">df.eggs[<span class="string">&#x27;May&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 loc</span></span><br><span class="line">df.loc[<span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>]</span><br><span class="line">df.loc[<span class="string">&#x27;May&#x27;</span>][<span class="string">&#x27;eggs&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 iloc</span></span><br><span class="line">df.iloc[<span class="number">4</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="slicing-dataframes">Slicing DataFrames</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eggs 列中的某些值</span></span><br><span class="line">df[<span class="string">&#x27;eggs&#x27;</span>][<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># eggs 列中的某个值</span></span><br><span class="line">df[<span class="string">&#x27;eggs&#x27;</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某些列中的所有行</span></span><br><span class="line">df.loc[:, <span class="string">&#x27;eggs&#x27;</span>:<span class="string">&#x27;salt&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某些行中所有列</span></span><br><span class="line">df.loc[<span class="string">&#x27;Jan&#x27;</span>:<span class="string">&#x27;Feb&#x27;</span>, :]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某些行中某些列</span></span><br><span class="line">df.loc[<span class="string">&#x27;Jan&#x27;</span>:<span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>:<span class="string">&#x27;salt&#x27;</span>]</span><br><span class="line">df.loc[<span class="string">&#x27;Jan&#x27;</span>:<span class="string">&#x27;Mar&#x27;</span>, [<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;salt&#x27;</span>]]  <span class="comment"># 使用列表删选行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 iloc 选择</span></span><br><span class="line">df.iloc[<span class="number">2</span>:<span class="number">5</span>, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># df[&#x27;eggs&#x27;]  -&gt; pandas.core.series.Series</span></span><br><span class="line"><span class="comment"># df[[&#x27;eggs]] -&gt; pandas.core.frame.DataFrame</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="filtering">Filtering</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, df.<span class="built_in">all</span>()]           <span class="comment"># 所有非0值</span></span><br><span class="line">df.loc[:, df.<span class="built_in">any</span>()]           <span class="comment"># 0值行</span></span><br><span class="line">df.loc[:, df.isnull().<span class="built_in">any</span>()]  <span class="comment"># 任何 na 行</span></span><br><span class="line">df.loc[:, df.notnull().<span class="built_in">any</span>()] <span class="comment"># 任何 na 行</span></span><br><span class="line">df.dropna(how=<span class="string">&#x27;any&#x27;</span>)</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="understand-dataframe-index">Understand Dataframe index</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Series</span></span><br><span class="line">prices = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1.5</span>, <span class="number">4</span>, <span class="number">4.5</span>]</span><br><span class="line">shares = pd.Series(prices)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Series，从数组指定索引值</span></span><br><span class="line">days = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thur&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>]</span><br><span class="line">shares = pd.Series(prices, index=days)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可使用下标访问索引值，也可以切片</span></span><br><span class="line">shares.index[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给索引起名</span></span><br><span class="line">shares.name = <span class="string">&quot;Share&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给索引赋值会出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重索引访问索引名</span></span><br><span class="line"><span class="comment"># df.index.name  -&gt; None</span></span><br><span class="line"><span class="comment"># df.index.names -&gt; [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引排序</span></span><br><span class="line">df.sort_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引的顺序进行排序</span></span><br><span class="line">df.reindex([<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照另外一个dataframe index 的顺序排序</span></span><br><span class="line">df2 = pd.DataFrame()</span><br><span class="line">df.reindex(df2.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重索引选择，使用元组</span></span><br><span class="line">df.loc[(<span class="string">&#x27;idx1&#x27;</span>,<span class="string">&#x27;idx2&#x27;</span>), <span class="string">&#x27;col_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只选择单个索引，会返回该索引内部得值（包括子索引）</span></span><br><span class="line">df.loc[<span class="string">&#x27;idx1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 slice 函数，对第一层不设条件，返回第二层 ab 结果</span></span><br><span class="line">df.loc[<span class="built_in">slice</span>(<span class="literal">None</span>), <span class="built_in">slice</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)]</span><br></pre></td></tr></table></figure><h2 id="manipulating">Manipulating</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.eggs[df.salt &gt; <span class="number">55</span>] += <span class="number">5</span>   <span class="comment"># 加</span></span><br><span class="line">df.floordiv(<span class="number">12</span>)              <span class="comment"># 类似 dataframe // other，支持fill_value</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="melt">Melt</h3><ul><li>Melt：适用于列中存在值，需要整理到行中的情况</li><li>Pivoting: 与Melt 相反，将1列中唯一的值放到不同的列上</li></ul><h3 id="pivot">Pivot</h3><ul><li>Pivot 根据列值 Reshape 数据，有重复值会出错</li><li>PivotTable 根据列值 Reshape 数据，有重复值可指定 aggregate 函数(sum, count, etc.)</li><li>都可以指定多个 index 或者 columns</li></ul><h3 id="stack-和-unstack">Stack 和 Unstack</h3><ul><li>UnStack 将行上的多 index 中的某一个放到 column 上，需要指定参数 level= '' ，即index 中的某个值；传给 level 的也可以是一个数字比如 0,1 等，取决于 index 的层数</li><li>Stack 将 column 上的 index 放到行上</li><li>多索引中，可使用 swaplevel 方式交换两个索引的顺序</li></ul><h3 id="group-by">Group by</h3><p>Groupby 一般有几个步骤：</p><ul><li>根据某些列按其值分割成不同的组</li><li>对每个组，指定内部的某些列进行操作</li><li>将这些操作后的结果组合起来</li></ul><p>Groupby 有一些特殊操作方便我们使用：</p><ul><li>第一个分割组的操作，可以传入自定义的 Series, 不限定于列名</li><li>groupby 的时候，使用 category 类型的数据会加快速度</li><li>组合组内部的操作，一般使用 mean, sum, max 等，但也可以一次指定多个函数，如 <code>df.groupby(['a','b']).agg('a':'sum')</code>, 也可以指定自定义的函数</li></ul><p>Groupby 可以和 transformation 结合使用，看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zscore</span>(<span class="params">series</span>):</span></span><br><span class="line">    <span class="string">&quot;对 Series 中的值，每一个都减去其平均值，再除以标准差&quot;</span></span><br><span class="line">   <span class="keyword">return</span> (series - series.mean()) / series.std()</span><br></pre></td></tr></table></figure><p>使用的时候，直接传入 dataframe 的某列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore(df[<span class="string">&#x27;mpg&#x27;</span>]).head()</span><br></pre></td></tr></table></figure><p>所以，我们也可以接 group 去使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;yr&#x27;</span>)[<span class="string">&#x27;mpg&#x27;</span>].transform(zscore).head()</span><br></pre></td></tr></table></figure><p>进一步的，可以把一些操作组合起来放到一个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zscore_with_year_and_name</span>(<span class="params">group</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;针对每一个 group，只取其中的某些列（mpg, year, name）做一些操作并组合成新的 dataframe</span></span><br><span class="line"><span class="string">       对于操作：mpg，算 zscore; yr 重命名为 year; name 不操作.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    df = pd.DataFrame(&#123;</span><br><span class="line">            <span class="string">&#x27;mpg&#x27;</span>: zscore(group[<span class="string">&#x27;mpg&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;year&#x27;</span>: group[<span class="string">&#x27;yr&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: group[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">df.groupby(<span class="string">&#x27;yr&#x27;</span>).apply(zscore_with_year_and_name).head()</span><br></pre></td></tr></table></figure><p>有时候你分组操作后，需要再进行 filter 操作，这需要拿到 groupby 之后的对象进行遍历操作。</p><p>首先我们来看看 groupby 操作后得到的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">splitting = auto.groupby(<span class="string">&#x27;yr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(splitting)</span><br><span class="line"><span class="comment"># pandas.core.groupby.DataFrameGroupBy</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(splitting.groups)</span><br><span class="line"><span class="comment"># dict</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(splitting.groups.keys())</span><br><span class="line"><span class="comment"># dict_keys([70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82])</span></span><br></pre></td></tr></table></figure><p>你可以对 group 对象进行遍历:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> groupname, group <span class="keyword">in</span> splitting:</span><br><span class="line">   avg = group[<span class="string">&#x27;mpg&#x27;</span>].mean()</span><br><span class="line">   <span class="built_in">print</span>(group_name, avg)</span><br></pre></td></tr></table></figure><p>对于一个 group 对象，你也可以对其使用 loc 操作，所以在内部我们可以进行 filter:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 group filter，只找出 name 包含 chevrolet 的组，取出其 mpg 列求 mean</span></span><br><span class="line"><span class="comment"># 返回的是单个值</span></span><br><span class="line">group.loc[group[<span class="string">&#x27;name&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;chevrolet&#x27;</span>), <span class="string">&#x27;mpg&#x27;</span>].mean()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结合操作，得到一个 Series</span></span><br><span class="line">chevy_means = &#123;</span><br><span class="line">    year: group.loc[group[<span class="string">&#x27;name&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;chevrolet&#x27;</span>),<span class="string">&#x27;mpg&#x27;</span>].mean()</span><br><span class="line">    <span class="keyword">for</span> year, group <span class="keyword">in</span> splitting</span><br><span class="line">&#125;</span><br><span class="line">pd.Series(chevy_means)</span><br></pre></td></tr></table></figure><p>一组条件，也可以当作 groupby 的列，如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chevy 一组 True, False，其值反映了df name列中包含 chevrolet 的行</span></span><br><span class="line">chevy = df[<span class="string">&#x27;name&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;chevrolet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 chevy 作为 groupby 条件</span></span><br><span class="line">df.groupby([<span class="string">&#x27;yr&#x27;</span>, chevy])[<span class="string">&#x27;mpg&#x27;</span>].mean()</span><br></pre></td></tr></table></figure><h3 id="concat">Concat</h3><ul><li>Concat 时可以指定 index，如 <code>pd.concat([rain2013, rain2014], keys=[2013, 2014], axis=0)</code>，如果两个 df 本来就有 index，则会产生多 index</li><li>index 也可以在 column 上，如 <code>pd.concat([rain2013, rain2014], keys=[2013, 2014], axis='columns')</code></li><li>可以将两个数组左右拼接到一起，可以使用 <code>np.hstack([B, A])</code> 或者 <code>np.concatenate([B, A], axis=1)</code></li></ul><h3 id="merge">Merge</h3><ul><li>merge 时，指定 suffixis 参数来区分来自不同 dataframe 的列</li><li>对于特殊的 merge，可以了解 <code>pandas.merge_asof</code> 和 <code>pandas.merge_ordered</code> 方法</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍了 Pandas 中的 Index，Series, Dataframe 及其基本操作。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 数据导入</title>
    <link href="https://scottzhang.pro/article/973c6fd9.html"/>
    <id>https://scottzhang.pro/article/973c6fd9.html</id>
    <published>2022-05-17T01:56:08.000Z</published>
    <updated>2022-05-17T01:58:46.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些常用数据导入的代码示例与技巧。</p></blockquote><span id="more"></span><h3 id="从网络">从网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign url of file: url</span></span><br><span class="line">url = <span class="string">&#x27;https://you_url/you_file.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save file locally</span></span><br><span class="line">urlretrieve(url,<span class="string">&#x27;you_file.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read file into a DataFrame and print its head</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;you_file.csv&#x27;</span>, sep=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><h3 id="直接用pd读取">直接用PD读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import packages</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign url of file: url</span></span><br><span class="line">url = <span class="string">&#x27;https://s3.amazonaws.com/assets.datacamp.com/production/course_1606/datasets/winequality-red.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read file into a DataFrame: df</span></span><br><span class="line">df = pd.read_csv(url,sep=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of the DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot first column of df</span></span><br><span class="line">pd.DataFrame.hist(df.ix[:, <span class="number">0</span>:<span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;fixed acidity (g(tartaric acid)/dm$^3$)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="网络读取excel文件">网络读取excel文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign url of file: url</span></span><br><span class="line">url = <span class="string">&#x27;http://s3.amazonaws.com/assets.datacamp.com/course/importing_data_into_r/latitude.xls&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in all sheets of Excel file: xl</span></span><br><span class="line">xl = pd.read_excel(url,sheetname = <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the sheetnames to the shell</span></span><br><span class="line"><span class="built_in">print</span>(xl.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of the first sheet (using its name, NOT its index)</span></span><br><span class="line"><span class="built_in">print</span>(xl[<span class="string">&#x27;1700&#x27;</span>].head())</span><br></pre></td></tr></table></figure><h3 id="从-json文件">从 Json文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load JSON: json_data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a_movie.json&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json_data = json.load(json_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print each key-value pair in json_data</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> json_data.keys():</span><br><span class="line">    <span class="built_in">print</span>(k + <span class="string">&#x27;: &#x27;</span>, json_data[k])</span><br></pre></td></tr></table></figure><h3 id="从-api-请求-json">从 api 请求 json</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign URL to variable: url</span></span><br><span class="line">url = <span class="string">&#x27;http://www.omdbapi.com/?apikey=72bc447a&amp;t=social+network&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Package the request, send the request and catch the response: r</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decode the JSON data into a dictionary: json_data</span></span><br><span class="line">json_data = r.json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print each key-value pair in json_data</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> json_data.keys():</span><br><span class="line">    <span class="built_in">print</span>(k + <span class="string">&#x27;: &#x27;</span>, json_data[k])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从-api-如维基百科">从 API 如:维基百科</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign URL to variable: url</span></span><br><span class="line">url = <span class="string">&#x27;https://en.wikipedia.org/w/api.php?action=query&amp;prop=extracts&amp;format=json&amp;exintro=&amp;titles=pizza&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Package the request, send the request and catch the response: r</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decode the JSON data into a dictionary: json_data</span></span><br><span class="line">json_data = r.json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the Wikipedia page extract</span></span><br><span class="line">pizza_extract = json_data[<span class="string">&#x27;query&#x27;</span>][<span class="string">&#x27;pages&#x27;</span>][<span class="string">&#x27;24768&#x27;</span>][<span class="string">&#x27;extract&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(pizza_extract)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从-api-如-推特">从 API 如: 推特</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> tweepy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store OAuth authentication credentials in relevant variables</span></span><br><span class="line">access_token = <span class="string">&quot;&quot;</span></span><br><span class="line">access_token_secret = <span class="string">&quot;&quot;</span></span><br><span class="line">consumer_key = <span class="string">&quot;&quot;</span></span><br><span class="line">consumer_secret = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pass OAuth details to tweepy&#x27;s OAuth handler</span></span><br><span class="line">auth = tweepy.OAuthHandler(consumer_key, consumer_secret)</span><br><span class="line">auth.set_access_token(access_token,access_token_secret)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="条件导入">条件导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过第一行，至需要第一和第三列</span></span><br><span class="line">data = np.loadtxt(file, delimiter=<span class="string">&#x27;\t&#x27;</span>, skiprows=<span class="number">1</span>, usecols=[<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># delimiter分隔符</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&#x27;titanic.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, names=<span class="literal">True</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># nrows，只需要前面5行，header只可以等于None，而不是Bool</span></span><br><span class="line">pd.read_csv(file,nrows=<span class="number">5</span>, header=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="获取文件列表">获取文件列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">wd = os.getcwd()</span><br><span class="line">os.listdir(wd)</span><br></pre></td></tr></table></figure><h3 id="从-excel">从 excel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign spreadsheet filename: file</span></span><br><span class="line">file = <span class="string">&#x27;battledeath.xlsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load spreadsheet: xl</span></span><br><span class="line">xl = pd.ExcelFile(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print sheet names</span></span><br><span class="line"><span class="built_in">print</span>(xl.sheet_names)</span><br></pre></td></tr></table></figure><h3 id="从-sas-文件">从 SAS 文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From sas7bdat <span class="keyword">import</span> SAS7BDAT</span><br><span class="line"></span><br><span class="line">Data = pd.read_stata(<span class="string">&#x27;urbanpop.dta&#x27;</span>)</span><br><span class="line"><span class="comment"># sas文件变成dataframe</span></span><br><span class="line"><span class="keyword">with</span> SAS7BDAT(<span class="string">&#x27;sales.sas7bdat&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    df_sas = file.to_data_frame()</span><br></pre></td></tr></table></figure><h3 id="从-mat文件">从 mat文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load MATLAB file: mat</span></span><br><span class="line">mat = scipy.io.loadmat(<span class="string">&#x27;albeck_gene_expression.mat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the datatype type of mat</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(mat))</span><br></pre></td></tr></table></figure><h3 id="从数据库">从数据库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import packages</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create engine: engine</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;sqlite:///Chinook.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open engine connection: con</span></span><br><span class="line">con = engine.connect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perform query: rs</span></span><br><span class="line">rs = con.execute(<span class="string">&#x27;select * from Album&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save results of the query to DataFrame: df</span></span><br><span class="line">df = pd.DataFrame(rs.fetchall())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close connection</span></span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print head of DataFrame df</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line">从DB导入指定条数据，重命名列名:</span><br><span class="line"><span class="keyword">with</span> engine.connect() <span class="keyword">as</span> con:</span><br><span class="line">    rs = con.execute(<span class="string">&#x27;SELECT LastName, Title FROM Employee&#x27;</span>)</span><br><span class="line">    df = pd.DataFrame(rs.fetchmany(size=<span class="number">3</span>))</span><br><span class="line">    df.columns = rs.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the length of the DataFrame df</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(df))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of the DataFrame df</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="提高数据导入速度">提高数据导入速度</h3><ul><li><a href="https://www.kaggle.com/c/home-credit-default-risk/discussion/59575">Faster data loading with Pandas</a></li><li><a href="https://medium.com/@bobhaffner/gist-to-medium-test-db3d51b8ba7b">DataFrame IO Performance with Pandas, dask, fastparquet and HDF5</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些常用数据导入的代码示例与技巧。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 安装</title>
    <link href="https://scottzhang.pro/article/6f1b3942.html"/>
    <id>https://scottzhang.pro/article/6f1b3942.html</id>
    <published>2022-05-17T00:07:25.000Z</published>
    <updated>2022-05-17T03:45:13.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章将带你安装 Python 环境以使用 Pandas。</p></blockquote><span id="more"></span><h1 id="环境配置">环境配置</h1><h2 id="检查是否已安装-python">检查是否已安装 Python</h2><p>检查你的 Python 版本:</p><ul><li><code>python --version</code></li><li><code>python -V</code></li></ul><p>检查你的 Python 安装路径(用户):</p><ul><li><code>where.exe python</code></li></ul><p>小技巧: 打开你的 PowerShell:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 敲击电脑上的 Win 键.</span><br><span class="line">2. 键入 PowerShell.</span><br><span class="line">3. 敲击回车 (Enter)键.</span><br></pre></td></tr></table></figure><blockquote><p>你也可以使用 cmd.exe 或者是 <a href="https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab">Windows Terminal</a>.</p></blockquote><h2 id="windows-安装-python-的几种方式">Windows 安装 Python 的几种方式</h2><ul><li>微软官方商店, 微软公司提供的,主要面向学生与 python 初学者, 公司环境下无法从微软商店下载软件.</li><li>Windows Subsystem for Linux (WSL), 让你在 Windows 上可以直接运行 Linux, 公司环境下无法配置</li><li>Python 完整安装包, 推荐.(<a href="https://www.python.org/downloads/windows/">下载地址</a>)</li><li>Anaconda, 一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项, 推荐.</li></ul><p>推荐使用 Anaconda.</p><h2 id="如何安装-anaconda">如何安装 Anaconda</h2><ol type="1"><li>打开安装包</li></ol><p><img src="https://docs.anaconda.com/_images/win-install-destination.png" /></p><ol start="2" type="1"><li>添加到环境变量</li></ol><p><img src="https://docs.anaconda.com/_images/win-install-options.png" /></p><p>关于安装选项:</p><ul><li>add Anaconda3 to my PATH environment variable, 会影响其他依赖 python 的软件,根据自己的需要选择</li><li>Register Anaconda3 as my default Python x, 根据自己的需要选择</li></ul><p>关于安装版本, 32 还是 64? 这取决于你机器的处理器的配置, 记住64位机器可以处理32位程序,反之则不行.</p><p>Anaconda <a href="https://docs.anaconda.com/anaconda/install/windows/">Windows 官方安装指南</a></p><h2 id="如何管理-python-运行环境">如何管理 Python 运行环境</h2><h3 id="为什么要管理环境">为什么要管理环境</h3><ul><li>场景 1: 你的同事给你一份代码, Ta 基于 Python 3.6 写的, Pandas 1.0.1 版本, 你的版本过低或者过高导致无法运行</li><li>场景2: 你看到一个不错的 Python 包, 但是安装它会讲你目前的 Pandas 降级, 但是降级又会影响你平时的工作环境</li><li>场景3: 你需要部署你的工具,你想创建一个完全干净的环境来测试部署流程, 测试程序依赖的包是否可以工作</li></ul><h3 id="管理环境的工具">管理环境的工具</h3><table><colgroup><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /></colgroup><thead><tr class="header"><th></th><th>Python Version</th><th>Dependency Management</th><th>Virtual Environment</th><th>Environment Reproducibility</th></tr></thead><tbody><tr class="odd"><td>pyenv</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr class="even"><td>venv + pip</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td></tr><tr class="odd"><td>venv + pip-tools</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr class="even"><td>Poetry</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr class="odd"><td>Pipenv</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr class="even"><td>Docker</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td></tr><tr class="odd"><td>Conda</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr></tbody></table><h3 id="使用-conda">使用 Conda</h3><p>对于开发者来说, 电脑上有时候需要有多个 python 环境, 可以使用 Conda 进行来管理 Python 的环境与包, Conda 可以帮你创建、复制、克隆、管理一个全新隔离的环境, 同时也可以用来安装包, 它既具有pip的包管理能力，同时也具有vitualenv的环境管理功能 ，因此在功能上Conda可以看作是pip 和 vitualenv 的组合。</p><p>参考 <a href="https://docs.conda.io/projects/conda/en/4.6.0/_downloads/52a95608c49671267e40c689e0bc00ca/conda-cheatsheet.pdf">Conda CheatSheet</a></p><h2 id="如何安装-python-包">如何安装 Python 包</h2><h3 id="python-装包的选择">Python 装包的选择</h3><ul><li>pip</li><li>conda</li><li>其他略过</li></ul><h3 id="区别是什么">区别是什么?</h3><ul><li>包仓库不同, pip 可以找到, conda 不一定有</li><li>Pip安装Python包，而conda安装包可能包含用任何语言编写的软件的包</li><li>conda 会帮你解决包之间的依赖冲突</li><li>从使用角度来说, conda 比较慢 (可以考虑 <a href="https://mamba.readthedocs.io/en/latest/">Mamba</a>, 一个旨在替代 Conda 的工具)</li></ul><h3 id="使用-conda-1">使用 Conda</h3><ul><li>搜索包: <code>conda search PACKAGENAME</code></li><li>安装包: <code>conda install PACKAGENAME</code></li><li>更新包: <code>conda update PACKAGENAME</code></li><li>查看已安装的包: <code>conda list</code></li><li>卸载包: <code>conda remove PACKAGENAME</code></li></ul><h3 id="使用-pip">使用 Pip</h3><ul><li>搜索包: <code>pip search</code>, currently disabled</li><li>安装包: <code>pip install PACKAGENAME</code></li><li>更新包: <code>pip install --upgrade PACKAGENAME</code></li><li>查看已安装包: <code>pip list</code></li><li>卸载包: <code>pip uninstall PACKAGENAME</code></li></ul><h3 id="在-nielseniq-装包">在 NielsenIQ 装包</h3><ul><li>因为众所周知的原因, 国内外网经常抽风,而 pip 和 conda 下载包默认都是从国外的服务器下载</li><li>为了解决这个问题,国内有一些高等院校和知名企业免费托管了很多包资源,只需要将下载服务器更改为国内地址即可加速包的下载</li><li>可以使用清华大学开源软件镜像站来加速, 你也可以使用其他的镜像站<ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">pip</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">anaconda</a></li></ul></li></ul><h2 id="在哪里编写代码">在哪里编写代码?</h2><h3 id="ides-还是代码编辑器">IDEs 还是代码编辑器?</h3><p>IDE (or Integrated Development Environment) 是一个专注于软件开发的程序, 它通常包含了许多软件开发的工具集, 例如:</p><ul><li>处理代码的编辑器(如高亮代码, 自动补全)</li><li>编译、执行, debug 工具</li><li>或有版本控制的工具</li><li>大部分IDE支持多种语言, 或是拥有更多的功能(也有专门为某种语言开发的IDE, 如针对 Golang 的 Goland, Python 的 Pycharm)</li></ul><p>代码编辑器或者说文本编辑器, 大部分都有代码高亮、格式化的功能, 一些优秀的代码编辑器还可以通过插件实现版本控制、多种语言的支持.</p><h3 id="常用-ides-和代码编辑器">常用 IDEs 和代码编辑器</h3><p>IDEs: - Visual Studio, 微软开发的 IDEs, 特性丰富 - Eclipse + PyDev, 知名 java 编辑器 Eclipse 针对 Python 出的版本</p><p>代码编辑器: - Sublime Text, Google 工程师开发的梦想中的编辑器 - Visual Studio Code - Atom, 全平台支持的代码编辑器 - GNU Emacs, Vi / Vim</p><p>针对 Python 的 IDEs:</p><ul><li>PyCharm, 最优秀的 Python IDE 之一, 有付费版和社区免费版</li><li>Spyder, 为 data science 工作流程优化的 IDE, Anaconda 附带.</li><li>Thonny, 为初学者准备的 IDE</li></ul><h3 id="使用-vs-code">使用 VS Code</h3><ul><li>微软为 VS Code 提供了官方的 Python 工具包</li><li>VS Code 也支持编辑 Jupyter-Notebook</li><li>丰富的插件，让你可以许多可定制化的功能，如支持 Git 版本控制、远程编辑服务器上的文件、Debug Jupyter-Notebook 的代码等</li></ul><h3 id="使用-jupyter-notebook-lab">使用 Jupyter Notebook &amp; Lab</h3><p>介绍：</p><ul><li>Jupyter Notebook 交互式笔记本，支持运行40 多种编程语言，代码基于 Cell 组织，按 Cell 运行，所见即所得，主要用户是数据科学家</li><li>Jupiter lab 在 Notebook 的基础上，拥有更灵活的布局、可拖动的 Cell、跨 Notebook 之间的编辑，集成终端等丰富的功能</li></ul><p>启动：</p><ul><li>直接通过应用程序中的 jupyter notebook 打开，默认工作目录是 <code>用户主目录/</code></li><li>若需指定工作目录，可以打开 Powershell，切换到你的目标工作目录，再输入 jupyter-notebook 并回车（jupyter-lab 同理）</li><li>若提示 port error，需指定端口，如 <code>jupyter-notebook --port 8889</code></li><li>Jupyter 的工作环境可以在你使用 Conda 创建的环境中切换</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章将带你安装 Python 环境以使用 Pandas。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 两数之和与三数之和</title>
    <link href="https://scottzhang.pro/article/347c867a.html"/>
    <id>https://scottzhang.pro/article/347c867a.html</id>
    <published>2022-05-16T14:51:09.000Z</published>
    <updated>2022-05-17T01:40:59.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/">📌</a> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p></blockquote><span id="more"></span><h3 id="两数之和">两数之和</h3><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>():</span></span><br><span class="line">    hashtable = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">            <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">        hashtable[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="三数之和">三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><a href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">算法流程</a>：</p><ol type="1"><li>特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。</li><li>对数组进行排序。</li><li>遍历排序后数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 若 nums[i] &gt; 0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</span><br><span class="line">- 对于重复元素：跳过，避免出现重复解</span><br><span class="line">- 令左指针 L=i+1，右指针 R=n−1，当 L&lt;R 时，执行循环：</span><br><span class="line">    - 当 nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</span><br><span class="line">    - 若和大于 0，说明 nums[R] 太大，R 左移</span><br><span class="line">    - 若和小于 0，说明 nums[L] 太小，L 右移</span><br></pre></td></tr></table></figure><p>简单演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-1, 0, 1, 2, -1, -4]</span><br><span class="line">[ I, L, 1, 2, -1,  R]</span><br><span class="line">[ I, 0, L, 2, -1,  R]</span><br><span class="line">[ I, 0, L, 2,  R, -4]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># null, 长度 &lt; 3, 返回 []</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> nums <span class="keyword">or</span> n &lt; <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 排序方便操作</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 连续两个重复值，前面已经尝试过所有组合，所以跳过    </span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># L 从 i+1 开始，R 从数组长度 -1 开始</span></span><br><span class="line">        L = i+<span class="number">1</span></span><br><span class="line">        R = n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(L &lt; R):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[L]+nums[R] == <span class="number">0</span>):</span><br><span class="line">                res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                <span class="keyword">while</span>(L &lt; R <span class="keyword">and</span> nums[L] == nums[L+<span class="number">1</span>]):</span><br><span class="line">                    L = L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span>(L &lt; R <span class="keyword">and</span> nums[R] == nums[R-<span class="number">1</span>]):</span><br><span class="line">                    R = R-<span class="number">1</span></span><br><span class="line">                L = L+<span class="number">1</span></span><br><span class="line">                R = R-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span>(nums[i]+nums[L]+nums[R] &gt; <span class="number">0</span>):</span><br><span class="line">                R = R-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = L+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">threeSum(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle/&quot;&gt;📌&lt;/a&gt; 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 字母异位词分组</title>
    <link href="https://scottzhang.pro/article/2239a89.html"/>
    <id>https://scottzhang.pro/article/2239a89.html</id>
    <published>2022-05-16T14:50:37.000Z</published>
    <updated>2022-05-17T01:36:29.592Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/group-anagrams/">📌</a> 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。Leetcode</p></blockquote><span id="more"></span><h3 id="思考">思考</h3><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>使用题目"有效的字母异位词"思路判断异位词。</p><p>对数组中的每一个元素进行组合执行上面的判断， 需要将所有的异位词放到一个数组，所以需要构建另外一个数组。</p><p>如果找到了一个新的形式，需要将新的放到这个数组，比对的对象可以是第一个，因为所有异位词之间应该都是相等的关系， 那么可以使用第一个遇到的词语作为键和值，后续找到的新的放到值中。</p><h3 id="解法">解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">strs: <span class="built_in">list</span></span>):</span></span><br><span class="line">    angram_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">            is_angram = isAnagramCounter(strs[i], strs[j])</span><br><span class="line">            <span class="keyword">if</span> is_angram:</span><br><span class="line">                <span class="keyword">if</span> strs[i] <span class="keyword">in</span> angram_dict:</span><br><span class="line">                    angram_dict[strs[i]].append(strs[j])</span><br><span class="line">                <span class="keyword">elif</span> strs[i] <span class="keyword">in</span> angram_dict.values():</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    angram_dict[strs[i]] = []</span><br><span class="line">                    angram_dict[strs[i]].append(strs[j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> angram_dict</span><br><span class="line"></span><br><span class="line">groupAnagrams(strs)</span><br></pre></td></tr></table></figure><p>上面的双重循环增加了很多复杂度，可以直接借鉴排序的优秀解法，其中 tuple(sorted(w)) 也可以换成 ''.join(sorted(w))。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记住 d.get(key, []) + [w]</span></span><br><span class="line">strs = [<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>,<span class="string">&quot;tan&quot;</span>,<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;bat&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">strs</span>):</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">sorted</span>(strs):</span><br><span class="line">        key = <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(w))</span><br><span class="line">        d[key] = d.get(key, []) + [w]</span><br><span class="line">    <span class="keyword">return</span> d.values()</span><br><span class="line"></span><br><span class="line">groupAnagrams(strs)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/group-anagrams/&quot;&gt;📌&lt;/a&gt; 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。Leetcode&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字典" scheme="https://scottzhang.pro/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 有效的字母异位词</title>
    <link href="https://scottzhang.pro/article/f2f7dffe.html"/>
    <id>https://scottzhang.pro/article/f2f7dffe.html</id>
    <published>2022-05-16T14:50:24.000Z</published>
    <updated>2022-05-17T01:36:39.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/valid-anagram/">📌</a> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p></blockquote><span id="more"></span><p>直接排序，异位词的顺序不同出现的次数一样，所以使用 sort 方法排序后的值应该相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagramSort</span>(<span class="params">s, t</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    s_sorted = <span class="built_in">sorted</span>(s)</span><br><span class="line">    t_sorted = <span class="built_in">sorted</span>(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s_sorted == t_sorted:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">isAnagramSort(a, b)</span><br></pre></td></tr></table></figure><p>使用 collection 中的 Counter。</p><p>Counter 支持比较运算符 ==, !=, &lt;, &lt;=, &gt;, &gt;=.</p><p>需要注意对于个数为 0的，不算入比较的范围，如 Counter(a=1) == Counter(a=1, b=0) 返回 true.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagramCounter</span>(<span class="params">s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">return</span> collections.Counter(s) == collections.Counter(t)</span><br></pre></td></tr></table></figure><p>链接：</p><ul><li><a href="https://leetcode.com/problems/valid-anagram/">英文站</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-anagram/&quot;&gt;📌&lt;/a&gt; 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="collections" scheme="https://scottzhang.pro/tags/collections/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 用队列实现栈</title>
    <link href="https://scottzhang.pro/article/5a9968.html"/>
    <id>https://scottzhang.pro/article/5a9968.html</id>
    <published>2022-05-16T14:45:32.000Z</published>
    <updated>2022-05-17T01:37:20.384Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">📌</a> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）</p></blockquote><span id="more"></span><p>实现 MyStack 类：</p><ul><li>void push(int x) 将元素 x 压入栈顶。</li><li>int pop() 移除并返回栈顶元素。</li><li>int top() 返回栈顶元素。</li><li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。  </li></ul><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue1 = []</span><br><span class="line">        self.queue2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.queue1.append(x)</span><br><span class="line">        self.queue2 = <span class="built_in">list</span>(<span class="built_in">reversed</span>(self.queue1))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue2.pop()</span><br><span class="line">        <span class="keyword">del</span> self.queue1[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue1) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mystack = MyStack()</span><br><span class="line">mystack.push(<span class="number">1</span>)</span><br><span class="line">mystack.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">mystack.queue2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-stack-using-queues/&quot;&gt;📌&lt;/a&gt; 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://scottzhang.pro/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 最小栈问题</title>
    <link href="https://scottzhang.pro/article/302a7493.html"/>
    <id>https://scottzhang.pro/article/302a7493.html</id>
    <published>2022-05-16T14:45:17.000Z</published>
    <updated>2022-05-17T01:36:36.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/min-stack/">📌</a> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p></blockquote><span id="more"></span><p>实现 MinStack 类:</p><ul><li>MinStack() 初始化堆栈对象。</li><li>void push(int val) 将元素val推入堆栈。</li><li>void pop() 删除堆栈顶部的元素。</li><li>int top() 获取堆栈顶部的元素。</li><li>int getMin() 获取堆栈中的最小元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack2Arr</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;内部使用了两个栈（一个辅助栈）&quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/min-stack/&quot;&gt;📌&lt;/a&gt; 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 有效的括号</title>
    <link href="https://scottzhang.pro/article/6d4e3bea.html"/>
    <id>https://scottzhang.pro/article/6d4e3bea.html</id>
    <published>2022-05-16T14:45:03.000Z</published>
    <updated>2022-05-17T01:36:42.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/valid-parentheses/">📌</a> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p></blockquote><span id="more"></span><p>注意：有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。</p><p>左括号必须以正确的顺序闭合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;注意理解栈的原理&quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="built_in">dict</span> = &#123;<span class="string">&quot;]&quot;</span>:<span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>:<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;)&quot;</span>:<span class="string">&quot;(&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># 查 value，如果出现左括号，将其放到栈中</span></span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> <span class="built_in">dict</span>.values():</span><br><span class="line">            stack.append(char)</span><br><span class="line">        <span class="comment"># 如果是出现了右括号、若栈是空的或者</span></span><br><span class="line">        <span class="comment"># 根据右边括号找到对应的左括号不等于栈顶元素，返回 False</span></span><br><span class="line">        <span class="keyword">elif</span> char <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">            <span class="keyword">if</span> stack == [] <span class="keyword">or</span> <span class="built_in">dict</span>[char] != stack.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 其他情况，返回 False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> stack == []</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/valid-parentheses/&quot;&gt;📌&lt;/a&gt; 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 判断环形链表</title>
    <link href="https://scottzhang.pro/article/50c0087b.html"/>
    <id>https://scottzhang.pro/article/50c0087b.html</id>
    <published>2022-05-16T14:40:24.000Z</published>
    <updated>2022-05-17T01:36:24.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/">📌</a> 给你一个链表的头节点 head ，判断链表中是否有环。</p></blockquote><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_cycle_set</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用集合或者哈希表，记录访问过的节点，若再次出现则有环</span></span><br><span class="line"><span class="string">       1. 时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</span></span><br><span class="line"><span class="string">       2. 空间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seen.add(head)</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_cycle_fast_slow_pointer</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用两个指针，一快一慢遍历链表，如果链表存在环，则最终快指针肯定会与慢指针相遇</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果头节点为空或者头结点没有下一个结点，则不存在环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义两个快慢指针遍历，这里快指针比慢指针先出发</span></span><br><span class="line">    <span class="comment"># 不是同一个位置出发，这么写的原因是 while 的条件需要一开始</span></span><br><span class="line">    <span class="comment"># 处于不满足的情况</span></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        <span class="comment"># 如果 fast 为空或没有下一个结点，说明遍历到了链表尾部</span></span><br><span class="line">        <span class="comment"># 说明不存在环，有环的话会循环到前面的结点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动快慢指针</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># while 后的条件为 True，即 slow == fast, 说明存在环</span></span><br><span class="line">    <span class="comment"># 此时 slow 指向的结点 == fast 指向的结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>链表的访问是从第一个结点开始的，不要用数组的思维去理解链表</p><p>在链表操作中，通常会创建一个伪结点，又称 dummy 结点，使用 dummy 结点的好处是 1. 在链表初始化的时候，没有合适的结点可以使用，用一个伪结点开始初始化比较方便，但需要注意在返回的时候需要返回 dummy.next. 2. 可以使用 <code>while node</code> 或者是 <code>if node</code> ，来判断某个结点是否有 next</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle/&quot;&gt;📌&lt;/a&gt; 给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="链表" scheme="https://scottzhang.pro/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 合并 K 个排序链表</title>
    <link href="https://scottzhang.pro/article/6b8b3431.html"/>
    <id>https://scottzhang.pro/article/6b8b3431.html</id>
    <published>2022-05-16T14:38:39.000Z</published>
    <updated>2022-05-17T01:36:26.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">📌</a> 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><span id="more"></span><h3 id="合并-k-个排序链表">合并 K 个排序链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</span><br><span class="line">输出：[1, 1, 2, 3, 4, 4, 5, 6]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;顺序合并，效率不是很高&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">        d = c = ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                c.<span class="built_in">next</span>, l1 = l1, l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c.<span class="built_in">next</span>, l2 = l2, l2.<span class="built_in">next</span></span><br><span class="line">            c = c.<span class="built_in">next</span></span><br><span class="line">        c.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> d.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        ans = merge(ans, i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">mergeKLists([l1, l2])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    p = dummy</span><br><span class="line">    head = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">        <span class="keyword">if</span> lists[i]:</span><br><span class="line">            heapq.heappush(head, (lists[i].val, i))</span><br><span class="line">            lists[i] = lists[i].<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        val, idx = heapq.heappop(head)</span><br><span class="line">        p.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> lists[idx]:</span><br><span class="line">            heapq.heappush(head, (lists[idx].val, idx))</span><br><span class="line">            lists[idx] = lists[idx].<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-k-sorted-lists/&quot;&gt;📌&lt;/a&gt; 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="链表" scheme="https://scottzhang.pro/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 无重复字符串的最长子串</title>
    <link href="https://scottzhang.pro/article/aaafc94b.html"/>
    <id>https://scottzhang.pro/article/aaafc94b.html</id>
    <published>2022-05-16T14:24:34.000Z</published>
    <updated>2022-05-17T01:36:33.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">📌</a> 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。</p></blockquote><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    output = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        If s[r] not in seen, we can keep increasing the window size by moving right pointer</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s[r] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            output = <span class="built_in">max</span>(output, r-l+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># There are two cases if s[r] in seen:</span></span><br><span class="line">        <span class="comment"># case1: s[r] is inside the current window, we need to change the window by moving left pointer to seen[s[r]] + 1.</span></span><br><span class="line">        <span class="comment"># case2: s[r] is not inside the current window, we can keep increase the window</span></span><br><span class="line">            <span class="keyword">if</span> seen[s[r]] &lt; l:</span><br><span class="line">                output = <span class="built_in">max</span>(output,r-l+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = seen[s[r]] + <span class="number">1</span></span><br><span class="line">        seen[s[r]] = r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lengthOfLongestSubstring(<span class="string">&quot;pwwkew&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-substring-without-repeating-characters/&quot;&gt;📌&lt;/a&gt; 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 盛水最多的容器</title>
    <link href="https://scottzhang.pro/article/45859c42.html"/>
    <id>https://scottzhang.pro/article/45859c42.html</id>
    <published>2022-05-16T14:20:11.000Z</published>
    <updated>2022-05-17T01:37:08.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">📌</a> 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p></blockquote><span id="more"></span><p>说明：你不能倾斜容器。</p><p>双指针往中间靠拢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_area_towards_center</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数组：一开始就将 left bar 和 right bar 设置到最左和最右</span></span><br><span class="line"><span class="string">    慢慢收敛，因为宽度已是最大，只需要控制高度即可</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        area = <span class="built_in">min</span>(arr[l], arr[r]) * (r - l)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, area)</span><br><span class="line">        <span class="keyword">if</span> arr[l] &lt;= arr[r]:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">max_area_towards_center([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>使用 for 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_area_2_loop</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数组：枚举所有元素，双重 for 循环，找出 area 最大的</span></span><br><span class="line"><span class="string">    缺点，时间复杂度比较高</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    area_max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            area = (j-i) * <span class="built_in">min</span>(arr[i], arr[j])</span><br><span class="line">            area_max = <span class="built_in">max</span>(area_max, area)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area_max</span><br><span class="line"></span><br><span class="line">max_area_2_loop([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><ul><li>🇺🇸 <a href="https://leetcode.com/problems/container-with-most-water/">英文站</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;📌&lt;/a&gt; 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法题：移动0</title>
    <link href="https://scottzhang.pro/article/22174669.html"/>
    <id>https://scottzhang.pro/article/22174669.html</id>
    <published>2022-05-16T14:17:58.000Z</published>
    <updated>2022-05-17T01:37:15.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/move-zeroes/">📌</a> 给定一个数组，将所有其中的 0，移动到末尾。Leetcode</p></blockquote><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">my_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_zero</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;数组：利用快慢指针交换值.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    zero_idx = <span class="number">0</span>  <span class="comment"># 慢指针，其数值表示0所在的位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 要做的操作与慢指针移动的条件</span></span><br><span class="line">        <span class="comment"># 若不满足慢指针移动条件，慢指针停留不动，快指针继续移动</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] != <span class="number">0</span>:</span><br><span class="line">            arr[i], arr[zero_idx] = arr[zero_idx], arr[i]</span><br><span class="line">            zero_idx += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(f&quot;&#123;arr&#125;, i:&#123;i&#125;, zero_idx:&#123;zero_idx&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">move_zero(my_arr)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/move-zeroes/&quot;&gt;📌&lt;/a&gt; 给定一个数组，将所有其中的 0，移动到末尾。Leetcode&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程与生成器</title>
    <link href="https://scottzhang.pro/article/d7273f24.html"/>
    <id>https://scottzhang.pro/article/d7273f24.html</id>
    <published>2022-05-14T04:41:02.000Z</published>
    <updated>2022-05-15T13:50:32.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的出现，就是为了解决回调编写难的问题。</p></blockquote><span id="more"></span><h1 id="协程">协程</h1><p>比如，回调模式编码复杂度高、同步编程的并发性不高，多线程编程需要线程间同步，有 Lock 的限制。</p><p>那么能不能采用同步的方式去编写异步的代码呢？</p><p>一个办法是使用单线程去切换任务，这样就不需要操作系统切换线程，也不需要锁，而且实现了并发性很高（但需要程序员自己去调度任务）类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_part1</span>(<span class="params">arg</span>):</span></span><br><span class="line">    <span class="comment"># job B 为 IO 操作，会阻塞</span></span><br><span class="line">    <span class="comment"># 我们希望在执行到 A 的时候，可以跳出去</span></span><br><span class="line">    <span class="comment"># 继续执行耗费 CPU 的部分</span></span><br><span class="line">    a = do_job_A(arg)</span><br><span class="line">    b = do_job_B(a)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_all_job</span>():</span></span><br><span class="line">    p1 = do_part1(<span class="number">1</span>)</span><br><span class="line">    result = do_part2(p1)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>说白了，我们需要一个这样的函数，即它可以暂停，并且在适当的时候恢复。</p><h1 id="生成器进阶">生成器进阶</h1><h2 id="send">send</h2><p>生成器不只是可以产出值，还可以接收值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    addr = <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">addr = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="comment"># send 的值，将函数赋值给内部的 addr</span></span><br><span class="line">after_send = g.send(<span class="string">&quot;apple.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里第一次需要调用 next 方法，否则会报 TypeError, 如果不调用 next，也可以在开始的时候 send 一个 None.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    addr = <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">g.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># send 的值，将函数赋值给内部的 addr</span></span><br><span class="line">after_send = g.send(<span class="string">&quot;apple.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是因为在调用 send 发送非 None 值之前，我们必须启动一次生成器。</p><p>有两种方式：</p><ol type="1"><li>使用 next</li><li>或调用生成器对象的 send 方法传入 None 值</li></ol><p>另外生成器，还有一个 close 方法，可以将生成器关闭。</p><p>如果一个生成器会 yield 三次，如果在第一次的时候 close 了，那么在第二次的时候调用 next 就会报 GeneratorExit 错误。</p><h2 id="throw">throw</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="comment"># 为什么不是 try microsoft</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Pass Test Error&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;scottzhang.pro&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">g.throw(Exception, <span class="string">&quot;TestError&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure><h2 id="yield-from">yield from</h2><blockquote><p>Python 3.3 新语法。</p></blockquote><p>yield from 可以理解为 yiled 的简化，比如下面这两种写法差不多是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> v1 <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">for</span> v2 <span class="keyword">in</span> v1:</span><br><span class="line">            <span class="keyword">yield</span> v2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> v1 <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> v1</span><br></pre></td></tr></table></figure><p>yield from 还有另外一个功能，先看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_gen</span>(<span class="params">gen</span>):</span></span><br><span class="line">    <span class="comment"># gen 是一个可迭代对象</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> gen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    g = my_gen()</span><br><span class="line">    g.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这里有几个概念需要区分清楚：</p><ul><li>main 叫做调用者</li><li>my_gen 叫做委托生成器</li><li>gen 叫做子生成器</li></ul><p><code>yield from</code> 的另外一个特性就是能在调用者和子生成器之间建立一个通道，而且是双向的。</p><p>一个基于上面的模式编程的例子，要求是统计一个字典中值的个数， 并将值重新赋值为(num, [values]) 的形式，即值变为个数与值的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果字典</span></span><br><span class="line">final_result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sales_sum</span>(<span class="params">pro_name</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(pro_name+<span class="string">&quot;销量: &quot;</span>, x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">        nums.append(x)</span><br><span class="line">    <span class="keyword">return</span> total, nums</span><br><span class="line"></span><br><span class="line"><span class="comment"># 委托生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middle</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        final_result[key] = <span class="keyword">yield</span> <span class="keyword">from</span> sales_sum(key)</span><br><span class="line">        <span class="built_in">print</span>(key + <span class="string">&quot;销量统计完成！！.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 产品销量字典</span></span><br><span class="line">    data_sets = &#123;</span><br><span class="line">        <span class="string">&quot;产品A&quot;</span>: [<span class="number">1200</span>, <span class="number">1500</span>, <span class="number">3000</span>],</span><br><span class="line">        <span class="string">&quot;产品B&quot;</span>: [<span class="number">28</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">108</span> ],</span><br><span class="line">        <span class="string">&quot;产品C&quot;</span>: [<span class="number">280</span>,<span class="number">560</span>,<span class="number">778</span>,<span class="number">70</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, data_set <span class="keyword">in</span> data_sets.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start key:&quot;</span>, key)</span><br><span class="line">        m = middle(key)</span><br><span class="line">        m.send(<span class="literal">None</span>) <span class="comment"># 预激 middle 协程</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> data_set:</span><br><span class="line">            m.send(value)   <span class="comment"># 给协程传递每一组的值</span></span><br><span class="line">        m.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;final_result:&quot;</span>, final_result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>可能你会有疑问为什么这里不把子生成器和委托生成器合二为一，这样直接使用 yield 也可以实现。</p><p>但这样你就得在生成器快结束的时候，自己处理生成器对象的异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">my_gen.send(last_value)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        my_gen.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        result = e.value</span><br></pre></td></tr></table></figure><p>而 yield from 会帮我们自动处理这些逻辑，但还不止这些。</p><p>我们来看下 yield from 背后源码的原理, 看源码之前，我们先认识下所用到的变量。</p><blockquote><p>PEP380</p></blockquote><ul><li>_i：子生成器，同时也是一个迭代器</li><li>_y：子生成器生产的值</li><li>_r：yield from 表达式最终的值</li><li>_s：调用方通过send()发送的值</li><li>_e：异常对象</li></ul><p>摘录一段简单的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_i = <span class="built_in">iter</span>(EXPR)      <span class="comment"># EXPR是一个可迭代对象，_i其实是子生成器；</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = <span class="built_in">next</span>(_i)   <span class="comment"># 预激子生成器，把产出的第一个值存在_y中；</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value   <span class="comment"># 如果抛出了`StopIteration`异常，那么就将异常对象的`value`属性保存到_r，这是最简单的情况的返回值；</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:    <span class="comment"># 尝试执行这个循环，委托生成器会阻塞；</span></span><br><span class="line">        _s = <span class="keyword">yield</span> _y   <span class="comment"># 生产子生成器的值，等待调用方`send()`值，发送过来的值将保存在_s中；</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _y = _i.send(_s)    <span class="comment"># 转发_s，并且尝试向下执行；</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">            _r = _e.value       <span class="comment"># 如果子生成器抛出异常，那么就获取异常对象的`value`属性存到_r，退出循环，恢复委托生成器的运行；</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">RESULT = _r     <span class="comment"># _r就是整个yield from表达式返回的值。</span></span><br></pre></td></tr></table></figure><p>此外，yield from 还需要处理这些逻辑：</p><ol type="1"><li>子生成器可能只是一个迭代器，并不是一个作为协程的生成器，所以它不支持.throw()和.close()方法；</li><li>如果子生成器支持.throw()和.close()方法，但是在子生成器内部，这两个方法都会抛出异常；</li><li>调用方让子生成器自己抛出异常</li><li>当调用方使用next()或者.send(None)时，都要在子生成器上调用next()函数，当调用方使用.send()发送非 None 值时，才调用子生成器的.send()方法；</li></ol><p>总结一下：</p><p>总结一下关键点：</p><ol type="1"><li>子生成器生产的值，都是直接传给调用方的；调用方通过.send()发送的值都是直接传递给子生成器的；如果发送的是 None，会调用子生成器的__next__()方法，如果不是 None，会调用子生成器的.send()方法；</li><li>子生成器退出的时候，最后的return EXPR，会触发一个StopIteration(EXPR)异常；</li><li>yield from表达式的值，是子生成器终止时，传递给StopIteration异常的第一个参数；</li><li>如果调用的时候出现StopIteration异常，委托生成器会恢复运行，同时其他的异常会向上 "冒泡"；</li><li>传入委托生成器的异常里，除了GeneratorExit之外，其他的所有异常全部传递给子生成器的.throw()方法；如果调用.throw()的时候出现了StopIteration异常，那么就恢复委托生成器的运行，其他的异常全部向上 "冒泡"；</li><li>如果在委托生成器上调用.close()或传入GeneratorExit异常，会调用子生成器的.close()方法，没有的话就不调用。如果在调用.close()的时候抛出了异常，那么就向上 "冒泡"，否则的话委托生成器会抛出GeneratorExit异常。</li></ol><h1 id="async-和-await">async 和 await</h1><p>Python 3.5+ 后，引入了 async 和 await 两个关键字，定义了原生的协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Fake Result&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="comment"># 将任务交给子协程完成</span></span><br><span class="line">    <span class="comment"># await 后面跟的是 collections.Awaittable 对象</span></span><br><span class="line">    <span class="comment"># 也可以实现 __await__ 魔法方法来支持</span></span><br><span class="line">    <span class="comment"># await 可以理解为 yield from</span></span><br><span class="line">    result = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    coro = download_url(<span class="string">&quot;www.scottzhang.pro&quot;</span>)</span><br><span class="line">    coro.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>注意生成器是不可以直接传给 await，下面的代码会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Fake Result&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    result = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    coro = download_url(<span class="string">&quot;www.scottzhang.pro&quot;</span>)</span><br><span class="line">    coro.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>解决办法是，加一个装饰器, 这个装饰器会将这个函数实现 <code>__await__</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="meta">@types.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Fake Result&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;协程的出现，就是为了解决回调编写难的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="协程" scheme="https://scottzhang.pro/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="生成器" scheme="https://scottzhang.pro/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程和异步IO</title>
    <link href="https://scottzhang.pro/article/4bf14380.html"/>
    <id>https://scottzhang.pro/article/4bf14380.html</id>
    <published>2022-05-11T03:40:41.000Z</published>
    <updated>2022-05-14T04:42:10.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍了一些异步IO的基本概念与 Select 即回调函数的使用。</p></blockquote><span id="more"></span><h1 id="一些基本概念">一些基本概念</h1><p>在学习协程之前，建议先复习一下 socket 编程和多线程的知识。</p><p><strong>并发与并行</strong></p><p>并发：一个时间段、有几个程序在同一个 CPU 上运行，任意时刻只有一个程序在CPU上运行。</p><p>并行：任意时刻，有多个程序运行在多个 CPU 上。</p><p><strong>同步和异步</strong></p><blockquote><p>是一种消息通信机制，把操作看成消息在不同线程、协程中发送，然后得到 Future进行后续操作。</p></blockquote><p>同步：代码调用IO操作时，必须等待IO操作完成菜返回的调用方式。</p><p>异步：代码调用IO操作时，不必等操作完成就返回的调用方式。</p><p><strong>阻塞和非阻塞</strong></p><blockquote><p>是一种函数调用的机制。</p></blockquote><p>阻塞：调用函数是当前线程被挂起。</p><p>非阻塞：调用函数时，当前线程不会被挂起，而是立即返回。</p><h1 id="什么是-c10k-问题">什么是 C10K 问题？</h1><p><a href="https://en.wikipedia.org/wiki/C10k_problem">C10K</a>，一个1999 年提出来的技术挑战，即我们如何在1颗 1GHz CPU，2G 内存，1gbps 网络环境下，让单台服务器同时为1万个客户端提供FTP服务。</p><h1 id="io-多路复用">IO 多路复用</h1><p>Unix 下的五种 I/O 模型:</p><ul><li>阻塞 I/O</li><li>非阻塞 I/O</li><li>多路复用 I/O</li><li>信号驱动是 I/O</li><li>异步I/O (POSIX 的 aio_系列函数)</li></ul><p>以 socket 中的连接建立为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 阻塞 I/O</span></span><br><span class="line"><span class="comment"># 基础的用的最多的，socket.connect 连接成功后再返回，这时候产生阻塞</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((host, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---  非阻塞 I/O</span></span><br><span class="line"><span class="comment"># 发出 socket.connect 后马上返回（不阻塞，但没有结果）</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.setblocking(<span class="literal">False</span>)</span><br><span class="line">client.connect((host, <span class="number">80</span>))</span><br><span class="line"><span class="comment"># 随后不停询问服务端连接是否，成功后才可以发送消息</span></span><br><span class="line"><span class="comment"># 不过此时，也可以直接就开始干别的事情</span></span><br><span class="line"><span class="keyword">while</span> (client connected):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">client.send(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---多路复用 I/O</span></span><br><span class="line"><span class="comment"># 调用操作系统的 select 方法，操作系统会告诉我们哪些 socket 的端口</span></span><br><span class="line"><span class="comment"># 和文件句柄已经准备好了，它支持监听多个文件和 socket（select 本质上也是阻塞方法)</span></span><br><span class="line"><span class="comment"># 比如我们可以监听100个端口，只要其中某个端口可用，我们就可以立即处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---信号驱动式 I/O</span></span><br><span class="line"><span class="comment"># 应用较少，暂时不做介绍</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---异步 I/O</span></span><br><span class="line"><span class="comment"># aio_read 真正的异步</span></span><br></pre></td></tr></table></figure><p>select,poll,epoll 都是 I/0 多路复用的机制。I/0 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><p>但select,poll, epoll 本质上都是同步 I/0，因为他们都需要在读写事件就绪后自己负责 进行读写，也就是说这个读写过程是阻塞的，而异步V/0则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。</p><h2 id="select">Select</h2><p>select 函数监视的文件描述符分3类，分别是 writefds、readfds, 和 exceptfds。</p><p>调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指指定等待时间，如果立即返回设为null即可），函数返回。</p><p>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p><p>select的一个缺点在于，单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><h2 id="poll">Poll</h2><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。</p><p>polfd结构包含了要监视的event和发生的event，不再使用select "参数-值" 传递的方式。</p><p>同时，pollfd并没有最大数量限制（ 但是数量过大后性能也是会下降）。和select西数一样，pol返回后需要轮询polfd来获取就绪的描述符。从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取 已经就绪的socket。</p><p>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态 ，因此随着监视的描述符数量的增长，其效率也会线性下降</p><h2 id="epoll">Epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和pol的增强版本。</p><p>相对于select和poll来说，epol更加灵活，没有描述符限制。epoll使用-一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><p>epoll 实现使用了红黑树。</p><h2 id="对比">对比</h2><p>在并发高的情况下，连接活跃度不是很高，epoll 比 selelct 好；</p><p>并发不高，连接很活跃的时候，select 比 epoll 好；</p><h1 id="实例非阻塞io">实例：非阻塞I/O</h1><p>先看一段使用非阻塞IO完成 socket 请求与接受的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用非阻塞io完成http请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立socket连接</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((host, <span class="number">80</span>)) <span class="comment">#阻塞不会消耗cpu</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不停的询问连接是否建立好， 需要while循环不停的去检查状态</span></span><br><span class="line">    <span class="comment"># 做计算任务或者再次发起其他的连接请求</span></span><br><span class="line"></span><br><span class="line">    send_to = <span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(path, host).encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client.send(send_to)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    data = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    data = data.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    html_data = data.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    get_url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实例select-回调">实例：Select 回调</h1><p>下面这个是使用 Select 的版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需处理系统兼容性问题</span></span><br><span class="line"><span class="comment"># 如 Windows 和 Linux 不一样, 推荐使用 selectors</span></span><br><span class="line"><span class="comment"># import select</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()</span><br><span class="line"><span class="comment"># 使用select完成http请求</span></span><br><span class="line"><span class="comment"># 一个线程发出url请求后即可不管，操作系统 select</span></span><br><span class="line"><span class="comment"># 会自动使用可用的 socket 处理，对比多线程中一个线程对应一个 url</span></span><br><span class="line"><span class="comment"># 省去了线程切换的开销，以及其占用的内存</span></span><br><span class="line">urls = []</span><br><span class="line">stop = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        selector.unregister(key.fd)</span><br><span class="line">        self.client.send(<span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(self.path, self.host).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        selector.register(self.client.fileno(), EVENT_READ, self.readable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readable</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        d = self.client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            self.data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selector.unregister(key.fd)</span><br><span class="line">            data = self.data.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">            html_data = data.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(html_data)</span><br><span class="line">            self.client.close()</span><br><span class="line">            urls.remove(self.spider_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> urls:</span><br><span class="line">                <span class="keyword">global</span> stop</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.spider_url = url</span><br><span class="line">        url = urlparse(url)</span><br><span class="line">        self.host = url.netloc</span><br><span class="line">        self.path = url.path</span><br><span class="line">        self.data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            self.path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立socket连接</span></span><br><span class="line">        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.client.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.client.connect((self.host, <span class="number">80</span>))  <span class="comment"># 阻塞不会消耗cpu</span></span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#注册</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    <span class="comment">#事件循环，不停的请求socket的状态并调用对应的回调函数</span></span><br><span class="line">    <span class="comment"># 1. select本身是不支持register模式</span></span><br><span class="line">    <span class="comment"># 2. socket状态变化以后的回调是由程序员完成的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop:</span><br><span class="line">        ready = selector.select()</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> ready:</span><br><span class="line">            call_back = key.data</span><br><span class="line">            call_back(key)</span><br><span class="line">    <span class="comment"># 回调+事件循环+select(poll\epoll)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    fetcher = Fetcher()</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">&quot;http://shop.projectsedu.com/goods/&#123;&#125;/&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">        urls.append(url)</span><br><span class="line">        fetcher = Fetcher()</span><br><span class="line">        fetcher.get_url(url)</span><br><span class="line">    loop()</span><br><span class="line">    <span class="built_in">print</span>(time.time()-start_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="回调的问题">回调的问题</h1><p>使用回调虽然可以带来效率上的提升，但是也会有一些问题，包括：</p><ul><li>回调函数执行不正常怎么办？</li><li>回调函数里还要嵌套回调怎么办？嵌套多层怎么办？</li><li>多层嵌套中，某个环节出错了怎么办？</li><li>有个数据，需要每个回调函数都处理怎么办？</li><li>怎么使用当前函数中的局部变量？</li></ul><p>归纳来看，可以说回调的问题在于：</p><ol type="1"><li>代码可读性变差</li><li>共享状态的管理困难</li><li>处理异常比较麻烦</li></ol><p>要处理这个问题，这时候就轮到协程出场了。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍了一些异步IO的基本概念与 Select 即回调函数的使用。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="socket" scheme="https://scottzhang.pro/tags/socket/"/>
    
    <category term="select" scheme="https://scottzhang.pro/tags/select/"/>
    
    <category term="poll" scheme="https://scottzhang.pro/tags/poll/"/>
    
    <category term="epoll" scheme="https://scottzhang.pro/tags/epoll/"/>
    
    <category term="回调函数" scheme="https://scottzhang.pro/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 多进程</title>
    <link href="https://scottzhang.pro/article/4300f84b.html"/>
    <id>https://scottzhang.pro/article/4300f84b.html</id>
    <published>2022-05-11T03:23:35.000Z</published>
    <updated>2022-05-11T03:25:47.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python 多进程编程参考，适合 CPU 密集型操作。</p></blockquote><span id="more"></span><h1 id="多进程">多进程</h1><p>在 Python 中，对于IO密集型操作，可以考虑多线程。而 CPU 密集型操作则应考虑多进程。</p><p>在 Linux 中, <code>os.fork()</code> 子进程会将父进程中所有数据拷贝过来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi, This is Scott!&quot;</span>)</span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位于子进程: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;父进程为: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位于父进程: <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里的运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hi, This is Scott!</span><br><span class="line">位于父进程: 3021</span><br><span class="line">Hi, This is Scott!</span><br><span class="line">位于子进程: 3021</span><br><span class="line">父进程为: 3020</span><br></pre></td></tr></table></figure><h1 id="multiprocessing">Multiprocessing</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do something in sub_progress&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    progress = multiprocessing.Process(</span><br><span class="line">        target=do_something,</span><br><span class="line">        args=(<span class="number">2</span>,)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;progress pid: <span class="subst">&#123;progress.pid&#125;</span>&quot;</span>)</span><br><span class="line">    progress.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;progress pid: <span class="subst">&#123;progress.pid&#125;</span>&quot;</span>)</span><br><span class="line">    progress.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;main progress finished&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">progress pid: None</span><br><span class="line">progress pid: 3391</span><br><span class="line">do something in sub_progress</span><br><span class="line">main progress finished</span><br></pre></td></tr></table></figure><p>当然也可以使用继承的方式，重写内部的 run 方法，这部分和多线程中的代码类似。</p><h1 id="进程池">进程池</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do something in sub_progress&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># using a pool to manage process</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    result = pool.apply_async(do_something, args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># waiting all tasks finished</span></span><br><span class="line">    <span class="comment"># must close a pool before join it, for new task added to pool</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="built_in">print</span>(result.get())</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ python multiprocessing_test.py</span><br><span class="line">do something in sub_progress</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>pool 中还有 <code>imap</code> 方法，类似线程中 <code>excuter.map</code> 方法，result 为每个函数的返回值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入顺序</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> pool.imap(do_something, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;do something in <span class="subst">&#123;result&#125;</span>s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成顺序</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> pool.imap_unordered(do_something, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;do something in <span class="subst">&#123;result&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ python multiprocessing_test.py</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 1s</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 3s</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 5s</span><br></pre></td></tr></table></figure><h1 id="进程间通信">进程间通信</h1><p>多进程中，使用全局变量是无法共享数据的，因为进程间的数据是互相隔离的。</p><h2 id="使用-queue">使用 Queue</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="comment"># 下面的 queue 在多进程中无法使用</span></span><br><span class="line"><span class="comment"># from queue import Queue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line"></span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用进程池">使用进程池</h2><p>Pool 中的进程间通信，需要使用 manager 中的 queue.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># pool 中的 queue 需要使用 manager 中的</span></span><br><span class="line">    queue = Manager().Queue(<span class="number">10</span>)</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pool.apply_async(producer, args=(queue,))</span><br><span class="line">    pool.apply_async(consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>至此我们这里出现了三个 queue，注意区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line">queue = Manager().Queue</span><br></pre></td></tr></table></figure><h2 id="使用管道">使用管道</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe, Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&#x27;scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># pipe 只能适用于两个进程, 但更高效，相比 queue 它没那么多锁</span></span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line"></span><br><span class="line">    my_producer = Process(target=producer, args=(send_pipe,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用共享内存">使用共享内存</h2><p>Manager 中有一些支持共享内存的数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&#x27;scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    share_var = Manager().<span class="built_in">dict</span></span><br><span class="line">    share_var = Manager().Array</span><br><span class="line">    share_var = Manager().<span class="built_in">list</span></span><br><span class="line">    <span class="comment"># and more</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Python 多进程编程参考，适合 CPU 密集型操作。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Python 多进程" scheme="https://scottzhang.pro/tags/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="Multiprocessing" scheme="https://scottzhang.pro/tags/Multiprocessing/"/>
    
  </entry>
  
</feed>
