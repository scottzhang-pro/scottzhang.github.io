<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2022-02-15T14:35:26.263Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录开源 BI 工具 Metabase 的部署</title>
    <link href="https://scottzhang.pro/article/75e7492b.html"/>
    <id>https://scottzhang.pro/article/75e7492b.html</id>
    <published>2022-02-15T12:58:36.000Z</published>
    <updated>2022-02-15T14:35:26.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用最简单、快速的方式让你们公司的每一位拥有商业智能与分析。</p></blockquote><span id="more"></span><h1 id="metabase-介绍">Metabase 介绍</h1><p>Metabase 有两个版本，开源版和企业版，有两种方式将它们部署到生成环境：</p><ol type="1"><li>Metabase 云，有钱不想自己折腾的选择，但数据访问比较受限制</li><li>自己托管，在自己的机器上或者是云服务商的主机上</li></ol><p>对于 Metabase 云，他们会帮你搞定设置，备份，升级，你只需要专注在使用上，而不需要管如何部署等等。</p><p>对于自己托管的方案，我们需要准备两个东西：</p><ol type="1"><li>一台服务器运行 Metabase 应用</li><li>一个应用的服务器，用来存储 Metabase 运行期间产生的数据</li></ol><p>对于部署方式，用户是感觉不到任何差别的，实际上 Metabase 文档也写了，在底层即便是使用 Docker，Metabase 也是使用 Metabase JAR 的方式运行。</p><p>另外对于这一点的选择，也与 team 内部成员的技术储备有关，如果你的 team 成员比较懂 Docker，比如 服务器、网络等技术，则选择 Docker，否则选择 JAR；如果你的 taem 成员对两者都是差不多的懂，则选择 JAR，因为它需要学习的内容相对较少。</p><p>对于数据库，建议使用 PostgreSQL，MySQL，或者 MariaDb。</p><p>如果你使用云主机，则它们会自动帮你处理备份，否则你就需要自己备份。</p><h1 id="使用-docker-部署">使用 docker 部署</h1><p>使用 docker 部署 metabase 非常简单，打开 Metabase 官方的 docker image <a href="https://hub.docker.com/r/metabase/metabase">页面</a>。</p><p>复制下面的语句，将 docker image 拉取下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull metabase/metabase</span><br></pre></td></tr></table></figure><p>然后，直接启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我 windows 机器上，3000 端口无法打开，所以将其设置为 8889</span></span><br><span class="line"><span class="comment"># docker -p 中，顺序是 宿主机端口:docker内端口</span></span><br><span class="line">docker run -d -p 8889:3000 --name metabase metabase/metabase</span><br></pre></td></tr></table></figure><p>然后访问本机的 8889 端口就可以看到欢迎界面了。</p><figure><img src="https://s2.loli.net/2022/02/15/BGpNfu5T7RVQXiE.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>但是在添加数据库的界面中，是没有 Oracle 的，对我来说这是刚需，没办法得配置一下。</p><p>需要我们去 Oracle 下载 JDBC Driver JAR 文件，并放到容器内的 plugins 文件夹。</p><ol type="1"><li>访问 Oracle JDBC <a href="https://www.oracle.com/database/technologies/appdev/jdbc-ucp-19-13-c-downloads.html">下载页面</a>，这里是文档内推荐的版本</li><li>往下面找到 ojdbc8.jar</li><li>使用 docker cp 命令从宿主机拷贝该包到容器内</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp C:\Users\Scott\Downloads\ojdbc8.jar 614bccac20ce:/plugins/</span><br></pre></td></tr></table></figure><p>然后打开 metabase ，添加数据库连接，即可看到 Oracle 也出现在列表中了。</p><p><img src="https://s2.loli.net/2022/02/15/5dOZYaUimMJfKVe.png" /></p><p>至此，使用 Docker 对于 Meta 的部署就结束了。</p><p>还有一些高级的内容，比如如何将应用的数据存储在 docker 外部，或者是存储在 postgres 数据库中，可以参考官网的<a href="https://www.metabase.com/docs/latest/operations-guide/running-metabase-on-docker.html">文档</a>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;用最简单、快速的方式让你们公司的每一位拥有商业智能与分析。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Metabase" scheme="https://scottzhang.pro/tags/Metabase/"/>
    
    <category term="Docker" scheme="https://scottzhang.pro/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>记录开源 BI 工具 Superset 的部署</title>
    <link href="https://scottzhang.pro/article/35c1cbc9.html"/>
    <id>https://scottzhang.pro/article/35c1cbc9.html</id>
    <published>2022-02-15T09:51:50.000Z</published>
    <updated>2022-02-15T09:58:11.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apache Superset 是一个开源的数据探查与可视化平台，该工具在可视化、易用性和交互性上非常有特色，用户可以轻松对数据进行可视化分析。</p></blockquote><span id="more"></span><h1 id="使用-docker-安装-superset">使用 Docker 安装 Superset</h1><ol type="1"><li>第一步需要安装 Docker Engine 和 Docker Compose，在 Mac 上，可以使用 Docker Desktop，其中包括了 Docker Engine 和 Docker Compose。安装好 Docker 后，需要进入 Docker 设置将默认的内存设置为 6 GB</li><li>克隆 Superset 的仓库到本地:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/superset.git</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>将仓库拷贝到本地后，执行下面两条语句：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-non-dev.yml pull</span><br><span class="line">docker-compose -f docker-compose-non-dev.yml up</span><br></pre></td></tr></table></figure><p>关于 <code>docker compose</code> 的 CLI 命令参数与相关的解释，参考 <a href="https://docs.docker.com/compose/reference/#command-options-overview-and-help">Overview of docker-compose CLI</a>.</p><p>如果需要指定版本的 superset，需要在这一步指定，方法是在前面加上 tag 参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 1.4.0</span><br><span class="line">TAG=1.4.0 docker-compose -f docker-compose-non-dev.yml pull</span><br><span class="line">TAG=1.4.0 docker-compose -f docker-compose-non-dev.yml up</span><br></pre></td></tr></table></figure><p>在启动日志中，可能会看到检测到默认的 secret string，提示我们使用自己生成的字符，还贴心的给了我们生成示例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -base64 42</span><br></pre></td></tr></table></figure><p>其次，superset_worker 提示我们在使用超级用户启动 worker, 并提示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">You&#x27;re running the worker with superuser privileges: </span><br><span class="line">this is absolutely not recommended!&quot;</span><br><span class="line"></span><br><span class="line">Please specify a different user using the --uid option.</span><br><span class="line">User information: uid=0 euid=0 gid=0 egid=0</span><br></pre></td></tr></table></figure><p>我们之后再来看这个问题。</p><p>同时在 superset_init 中，我们还看到它的初始化配置文件地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/app/docker/pythonpath_dev/superset_config.py</span><br></pre></td></tr></table></figure><p>此时，我们其实已经可以打开 <code>http://0.0.0.0:8088</code> 访问 superset 的服务了, 默认的用户名和密码都是 <code>admin</code>。</p><h1 id="windows-使用-wsl-安装">Windows 使用 WSL 安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install build-essential libssl-dev libffi-dev python-dev python-pip libsasl2-dev libldap2-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 python 和 pip 后，安装虚拟环境</span></span><br><span class="line">pip install virtualenv</span><br><span class="line">python3 -m venv venv</span><br><span class="line">. venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 superset</span></span><br><span class="line">pip install apache-superset</span><br><span class="line"><span class="comment"># 初始化 db</span></span><br><span class="line">superset db upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置管理员账号</span></span><br><span class="line"><span class="built_in">export</span> FLASK_APP=superset</span><br><span class="line">superset fab create-admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载例子，可选</span></span><br><span class="line">superset load_examples</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">superset init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接启动</span></span><br><span class="line">superset run -p 8088 --with-threads --reload --debugger</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 wsgi 服务</span></span><br><span class="line"><span class="comment"># 安装相关服务</span></span><br><span class="line">pip install gunicorn</span><br><span class="line">pip install gevent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 wsgi 服务启动</span></span><br><span class="line">gunicorn  -w 10 -k gevent --timeout 120 -b 0.0.0.0:7668 --limit-request-line 0 --limit-request-field_size 0 <span class="string">&quot;superset.app:create_app()&quot;</span></span><br></pre></td></tr></table></figure><h1 id="配置-superset">配置 Superset</h1><p>配置 superset 需要使用一个配置文件，即上面我们日志中看到过的那个文件，它需要被添加到你的 PYTHONPATH 中。</p><p>看一下这个文件中的内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in superset_config.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Superset specific config</span></span><br><span class="line">ROW_LIMIT = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">SUPERSET_WEBSERVER_PORT = <span class="number">8088</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask App Builder configuration</span></span><br><span class="line"><span class="comment"># Your App secret key</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;\2\1thisismyscretkey\1\2\e\y\y\h&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The SQLAlchemy connection string to your database backend</span></span><br><span class="line"><span class="comment"># This connection defines the path to the database that stores your</span></span><br><span class="line"><span class="comment"># superset metadata (slices, connections, tables, dashboards, ...).</span></span><br><span class="line"><span class="comment"># Note that the connection information to connect to the datasources</span></span><br><span class="line"><span class="comment"># you want to explore are managed directly in the web UI</span></span><br><span class="line">SQLALCHEMY_DATABASE_URI = <span class="string">&#x27;sqlite:////path/to/superset.db&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask-WTF flag for CSRF</span></span><br><span class="line">WTF_CSRF_ENABLED = <span class="literal">True</span></span><br><span class="line"><span class="comment"># Add endpoints that need to be exempt from CSRF protection</span></span><br><span class="line">WTF_CSRF_EXEMPT_LIST = []</span><br><span class="line"><span class="comment"># A CSRF token that expires in 1 year</span></span><br><span class="line">WTF_CSRF_TIME_LIMIT = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set this API key to enable Mapbox visualizations</span></span><br><span class="line">MAPBOX_API_KEY = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>你可以在<a href="https://github.com/apache/superset/blob/master/superset/config.py">这里</a>找到所有可选的配置添加到配置文件中。</p><h1 id="连接数据库">连接数据库</h1><p>由于我需要测试的数据库是 Oracle，而 superset 安装后内部并不会带有数据库驱动，我们需要手动安装，方法是在仓库内部的 docker 目录下面，新建 <code>requirements-local.txt</code> 文件，并填入包的名字，如对于 oracle 是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx_Oracle</span><br></pre></td></tr></table></figure><p>然后关掉 superset 服务，重新生成镜像再启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build --force-rm</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>连接 oracle，只安装 cx_Oracle 是不够的，可能还需要有 instantclient 客户端。</p><p>在 web 界面添加数据库可能会看到这个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot locate a 64-bit Oracle Client library: &quot;libclntsh.so: cannot open shared object file: No such file or directory&quot;. See https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html for help</span><br><span class="line">(Background on this error at: http://sqlalche.me/e/13/4xp6)</span><br></pre></td></tr></table></figure><p>原因是没有配置 Oracle 的 instant client，需要在环境中安装才可以连接 Oracle。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 成功启动后，还需要安装 cx_Oracle 和 instant client 才可以连接 oracle</span><br><span class="line"># 首先需要下载 instant client, 这里不再赘述，去 Oracle 官网下载对应版本即可，我下载的版本是 instantclient-basic-linux.x64-12.2.0.1.0.zip</span><br><span class="line"></span><br><span class="line">apt-get update &amp;&amp; apt-get install -y libaio1       # 装依赖</span><br><span class="line">Unzip instantclient-basic-linux.x64-12.2.0.1.0.zip # 解压</span><br><span class="line"></span><br><span class="line"># 删除不需要的文件</span><br><span class="line">cd /opt/oracle/instantclient* \</span><br><span class="line">rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \</span><br><span class="line">echo /instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf \</span><br><span class="line"></span><br><span class="line"># 配置 tnsnames</span><br><span class="line">&amp;&amp; ldconfig \</span><br><span class="line">&amp;&amp; mkdir -p instantclient_12_2/network/admin \</span><br><span class="line">&amp;&amp; cp tnsnames.ora instantclient_12_2/network/admin/ \</span><br><span class="line">&amp;&amp; cp /sqlnet.ora instantclient_12_2/network/admin/</span><br></pre></td></tr></table></figure><p>另外，如果使用 tnsnames, tnsnames.ora 文件中的数据库地址配置可能在 wsl 中无法连接，这里折腾了一会，在宿主机上 ping 该地址得到了一个 domain.org 形式的地址，重新填入解决了。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Apache Superset 是一个开源的数据探查与可视化平台，该工具在可视化、易用性和交互性上非常有特色，用户可以轻松对数据进行可视化分析。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="superset" scheme="https://scottzhang.pro/tags/superset/"/>
    
    <category term="cx_oracle" scheme="https://scottzhang.pro/tags/cx-oracle/"/>
    
  </entry>
  
  <entry>
    <title>优先队列与堆</title>
    <link href="https://scottzhang.pro/article/c172b52c.html"/>
    <id>https://scottzhang.pro/article/c172b52c.html</id>
    <published>2022-02-09T13:42:44.000Z</published>
    <updated>2022-02-15T09:50:15.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>优先队列 Priority Queue (PQ) 是一个抽象的数据结构，堆（heap）是一个具体的数据结构，可以说是优先队列的一个实现。</p></blockquote><span id="more"></span><h1 id="优先队列">优先队列</h1><p>优先队列至少需要有以下这些操作：</p><ul><li>is_empty, 队列是否为空</li><li>add_element, 增加元素</li><li>pop_element, 弹出元素</li></ul><p>Python 有一个优先队列的实现，即堆（heapq），其中最小的元素拥有最高的优先级。它的每个父节点的值都只会小于或等于所有孩子节点（的值）; 最小的元素总是在根结点：heap[0]</p><p>Python heapq 模块和一般的堆数据结构，在设计时不允许查找除最小元素之外的任何元素。对于按大小检索任何元素，更好的选择是二叉搜索树。</p><p>堆使用了完全二叉树来实现优先队列，这意味着树的深度等于2为底，元素个数的对数。堆中每个父节点的值都小于或等于其任何子节点，这一点与二叉搜索树不一样（子节点中左节点小于右节点）</p><p><img src="https://files.realpython.com/media/heap-tree.4b4413ff133c.png" /></p><p>优先队列在编程中应用广泛，特别是那些需要在一些元素中查找极端值的情况，比如：</p><ul><li>根据点击量，查找博客中最受欢迎的5篇文章</li><li>找出从 a 点到 b 点最快的路径</li><li>你有发送邮件的一些任务，其中一些邮件需要每5分钟发一次，另外的一些需要每4分钟发一次</li></ul><h1 id="在-heapq-模块中作为列表的堆">在 heapq 模块中作为列表的堆</h1><p>堆是一个完全二叉树，我们可以使用列表来表示（<a href="%5B最小堆排序_Python_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV1ph411r7A6?from=search&amp;seid=14588240802172044798)">下图</a>表示的为最大堆）：</p><figure><img src="https://s2.loli.net/2022/02/08/ftlG2QF6pxjYuhe.png" alt="数组表示堆" /><figcaption aria-hidden="true">数组表示堆</figcaption></figure><ul><li>用 i 来表示索引值（也有用 k）</li><li>作为父节点，它的第一个子节点的数组下标为 2*i + 1.</li><li>作为父节点，它的第二个子节点数组下标为 2*i + 2.</li><li>作为子节点，它的父节点为 (i - 1) // 2.</li></ul><p>Python 中最小堆的一个特性，即子节点都要大于父节点，可以表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[i] &lt;= h[2*i + 1] and h[i] &lt;= h[2*i + 2]</span><br></pre></td></tr></table></figure><h1 id="操作堆">操作堆</h1><p>Python 中堆的实现是依赖于 list 的，它没有使用自定义的类。</p><p>可以从一个空堆开始初始化数据，但是如果你已经有一个list需要将其中的元素放到堆中，则可通过 heaptify() 来把一个 list 转成堆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">a = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># heapify() 修改列表，但不对它进行排序。</span></span><br><span class="line">heapq.heapify(a)</span><br><span class="line">a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>可以通过堆来实现优先级任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h = []</span><br><span class="line">heappush(h, (<span class="number">5</span>, <span class="string">&#x27;write code&#x27;</span>))</span><br><span class="line">heappush(h, (<span class="number">7</span>, <span class="string">&#x27;release product&#x27;</span>))</span><br><span class="line">heappush(h, (<span class="number">1</span>, <span class="string">&#x27;write spec&#x27;</span>))</span><br><span class="line">heappush(h, (<span class="number">3</span>, <span class="string">&#x27;create tests&#x27;</span>))</span><br><span class="line">heappop(h)</span><br></pre></td></tr></table></figure><p>再来看一个前面提到的发送 email 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">email</span>(<span class="params">frequency, details</span>):</span></span><br><span class="line">    current = datetime.datetime.now()</span><br><span class="line">    <span class="comment"># 产生一个无限循环的生成器</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        current += frequency</span><br><span class="line">        <span class="keyword">yield</span> current.strftime(<span class="string">&quot;%Y/%m/%d %H:%M&quot;</span>) , details</span><br><span class="line"></span><br><span class="line">fast_email = email(datetime.timedelta(minutes=<span class="number">15</span>), <span class="string">&quot;fast email&quot;</span>)</span><br><span class="line">slow_email = email(datetime.timedelta(minutes=<span class="number">40</span>), <span class="string">&quot;slow email&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将两个生成器在 heapq 中 merge</span></span><br><span class="line">unified = heapq.merge(fast_email, slow_email)</span><br></pre></td></tr></table></figure><p>我们调用结合后的生成器 10 次看看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(unified))</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;2022/02/08 17:40&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 17:55&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:05&#x27;, &#x27;slow email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:10&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:25&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:40&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:45&#x27;, &#x27;slow email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:55&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 19:10&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 19:25&#x27;, &#x27;fast email&#x27;)</span><br></pre></td></tr></table></figure><p>可以看到 fast email 是间隔 15 分钟每次发送，而 slow email 则是40 分钟一次，它们完美的交错成一个任务列表。</p><p>merge 并不会一次性将所有输入全部读取，所以即使我们传入的无限重复的生成器，它也非常快且不占用很多内存。</p><h1 id="使用堆的其他场景">使用堆的其他场景</h1><p>堆还擅长解决统计最大或者最小的问题，比如下面这个统计得奖次数得例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">results=<span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">Christania Williams      11.80</span></span><br><span class="line"><span class="string">Marie-Josee Ta Lou       10.86</span></span><br><span class="line"><span class="string">Elaine Thompson          10.71</span></span><br><span class="line"><span class="string">Tori Bowie               10.83</span></span><br><span class="line"><span class="string">Shelly-Ann Fraser-Pryce  10.86</span></span><br><span class="line"><span class="string">English Gardner          10.94</span></span><br><span class="line"><span class="string">Michelle-Lee Ahye        10.92</span></span><br><span class="line"><span class="string">Dafne Schippers          10.90</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">top_3 = heapq.nsmallest(</span><br><span class="line">    <span class="number">3</span>,                                  <span class="comment"># 指示返回多少个元素</span></span><br><span class="line">    results.splitlines(),               <span class="comment"># 分割成数组，要比较的元素或数据集</span></span><br><span class="line">    key=<span class="keyword">lambda</span> x: <span class="built_in">float</span>(x.split()[-<span class="number">1</span>])  <span class="comment"># 确定如何比较元素的可调用函数</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(top_3))</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Elaine Thompson          10.71</span><br><span class="line">Tori Bowie               10.83</span><br><span class="line">Marie-Josee Ta Lou       10.86</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;优先队列 Priority Queue (PQ) 是一个抽象的数据结构，堆（heap）是一个具体的数据结构，可以说是优先队列的一个实现。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="heapq" scheme="https://scottzhang.pro/tags/heapq/"/>
    
    <category term="queue" scheme="https://scottzhang.pro/tags/queue/"/>
    
    <category term="PQ" scheme="https://scottzhang.pro/tags/PQ/"/>
    
    <category term="heap" scheme="https://scottzhang.pro/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Python 什么是GIL锁</title>
    <link href="https://scottzhang.pro/article/eefff7f1.html"/>
    <id>https://scottzhang.pro/article/eefff7f1.html</id>
    <published>2022-01-17T12:54:03.000Z</published>
    <updated>2022-02-15T09:50:15.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>理解 Python 中的 GIL 锁对于想要了解 Python 多线程是非常重要的。</p></blockquote><span id="more"></span><h1 id="什么是-gil">什么是 GIL</h1><p>Python 全局解释器锁或 GIL(Global Interpreter Lock)，简单来说，是一个互斥体（或锁），它只允许一个线程持有 Python 解释器的控制权。</p><p>这意味着，在同一时刻，只有一个线程可以在 CPU 上可以执行字节码，即便是在拥有多核 CPU 的情况下，这也是 Python 被诟病的一个点。</p><h1 id="gil-解决了什么问题">GIL 解决了什么问题？</h1><p>既然 GIL 会带来性能利用上的问题，那为什么还要这样设计呢？</p><p>在谈这个问题之前，先来说说 Python 中的内存管理，Python 使用引用计数来实现内存管理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">a = []</span><br><span class="line">b = a</span><br><span class="line">sys.getrefcount(a)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>当一个对象的引用计数为0的时候，也就是没有变量指向它的时候，它就会被销毁。</p><p>这种引用计数的机制需要一个保护机制，以确保当多个线程同时对同一个对象进行操作时，不会发生错误（比如 A 线程对 X 加一百万次，B 线程对 X 减一百万次），如果放任不管，可能会造成内存泄漏（内存永远无法释放），或者是错误释放了还存在引用的内存。</p><p>如果给在不同线程之间共享的数据结构的引用计数加一把锁，这样它们就不会被不一致地修改。</p><p>但是给每一个对象（或者是一组对象）都加锁可能会导致死锁，而且在多把锁的情况下，对于锁的申请与释放又会导致性能下降。</p><p>GIL 规定执行任何 Python 字节码都需要先获得解释器锁, 这就避免了死锁和性能大幅下降的情况，坏处是 Python 程序只能以单线程的形式运行。</p><h1 id="为什么选择-gil-作为解决方案">为什么选择 GIL 作为解决方案？</h1><p>那么，为什么在 Python 中使用了一种看似如此笨拙的方法呢？ Python 的开发人员做出了一个错误的决定吗？毕竟现在动不动给就是 8 核 CPU。</p><p>在 <a href="https://www.youtube.com/watch?v=KVKufdTphKs&amp;t=731s">Larry Hastings</a> 关于 GIL 的演讲中，他说：“选择 GIl 的这个决定正是让 Python 如此流行的原因”</p><p>在操作系统出现线程这个概念以前，Python就存在。Python 被设计的易于使用，以使得开发更快。早期的 Python 依赖许多 C 的库，为了避免问题的产生，这些 C 程序需要一个线程安全的内存管理，而 GIL 让这成为了可能。可以说 GIL 是 CPython 开发人员在 Python 早期面临的难题的一个实用的解决方案。</p><h1 id="什么是-cpython">什么是 CPython</h1><p>Cpython 是用 C 写的一个解释器。</p><p>PYthon 有很多个解释器，如 CPython, Jython, IronPython 以及 PyPy, 分别使用 C, Java, C# 和 Python 实现。</p><p>我们知道 C 并不是一门面向对象的编程语言。你可能听说过在 Python 中一切皆对象（比如 int, str)，这在 CPython 层面的实现也是一样的，在 CPython 中，有一个 struct 叫做 PyObject，CPython 中的每一个对象都使用它。</p><blockquote><p>Note: A struct, or structure, in C is a custom data type that groups together different data types. To compare to object-oriented languages, it’s like a class with attributes and no methods.</p></blockquote><p>PyObject，也就是所有 Python 对象的爷爷，包含了两个东西:</p><ul><li><code>ob_refcnt</code>, 引用计数，实现垃圾回收机制</li><li><code>ob_type</code>, 指针指向另一个结构体，结构体中保存了实际的对象类型</li></ul><p>关于 CPython 的内存管理，可以参考 RealPython 的<a href="https://realpython.com/python-memory-management/#garbage-collection">这篇</a>文章。</p><h1 id="gil-的影响">GIL 的影响</h1><p>Python 中，如果你使用线程来同时对一个变量进行加减操作，会发现结果是不一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次的结果都不一样</span></span><br><span class="line"><span class="comment"># GIL 并不是上面某个函数一直占有，而是在某个函数转化成字节码后</span></span><br><span class="line"><span class="comment"># 执行一段长度的字节码后，会释放 GIL 码，然后给其他线程执行</span></span><br><span class="line"><span class="built_in">print</span>(total)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GIL 让你在同一时刻只能利用到一个线程，对于 CPU 密集型程序，使用单线程和多线程，其执行效率是一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># single_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">countdown(COUNT)</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所需时间(秒) -&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>在四核的机器上，它需要的时间是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python single_threaded.py</span><br><span class="line">所需时间(秒) - 6.20024037361145</span><br></pre></td></tr></table></figure><p>现在使用两个线程编写一个一样的程序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># multi_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line">t2 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所需时间(秒) -&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>运行查看结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python multi_threaded.py</span><br><span class="line">所需时间(秒) - <span class="number">6.924342632293701</span></span><br></pre></td></tr></table></figure><p>可以看到使用多线程和不适用多线程花的时间是差不多的。</p><p>GIL 对于 CPU 密集型的程序有限制的，对于 IO 密集型的则没有很大影响。</p><p>如果你编写了使用线程去处理图象中的每一个部分，那么甚至会让你的运行时间增加，这是因为申请和释放锁还需要额外的开销。</p><p>在 Python 3 更新的时候，许多人都希望将 GIL 移除，确实也有很多人做过尝试，但发现这么做除了导致很多的 C 语言库不支持意外，还让单线程下的 Python 相比较 Python2 更慢。</p><p>所以 Python 的创始人在谈及 GIL 时说：</p><blockquote><p>“I’d welcome a set of patches into Py3k only if the performance for a single-threaded program (and for a multi-threaded but I/O-bound program) does not decrease”.</p></blockquote><p>但 Python3 对 GIl 有过一次升级，即将 IO 密集型的线程申请锁的优先级降低。</p><p>Python 的 GIL 会饿死 I/O 密集型线程，因为它们不给它们从 CPU 密集型线程获取 GIL 的机会。</p><p>这是因为 Python 内置了一种机制，该机制强制线程在固定的连续使用间隔后释放 GIL，如果没有其他人获得 GIL，同一个线程可以继续使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># The interval is set to 100 instructions:</span></span><br><span class="line">sys.getcheckinterval()</span><br></pre></td></tr></table></figure><p>这种机制的问题在于，大多数情况下，CPU 密集型线程会在其他线程获取 GIL 之前重新获取 GIL，在 2009 年的时候，这个 bug 在 Python 3.2 中由 Antoine Pitrou 修复了，他设计了一种机制去查看其他线程申请锁但被拒绝的次数，目的就是防止 CPU 密集型线程长期占用 GIL 锁。</p><h1 id="如何解决-gil-带来的问题">如何解决 GIL 带来的问题</h1><p>如果确定 GIL 是你程序的瓶颈，可以有几个优化的方向：</p><p><strong>使用多进程</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(processes=<span class="number">2</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    r1 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    r2 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所需时间(秒)&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>使用多进程，所需时间只需要 4 秒。在进程中，每个进程都有自己的 GIL 锁用于内部线程的控制，所以互不影响。</p><blockquote><p>参考阮一峰关于: <a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">进程与线程的一个简单解释</a>。</p></blockquote><p><strong>更换解释器</strong></p><p>GIL 的问题，只存在于最开始的 CPython 中。</p><p>这篇文章对 Python 的 GIL 做了一个简单的介绍，如果你还想了解 GIL 更底层的东西，可以看一下 David Beazley 关于 GIL 的讲座: <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s">Understanding the Python GIL</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;理解 Python 中的 GIL 锁对于想要了解 Python 多线程是非常重要的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="GIL" scheme="https://scottzhang.pro/tags/GIL/"/>
    
  </entry>
  
  <entry>
    <title>了解 Python Magic Method</title>
    <link href="https://scottzhang.pro/article/23c3a2e1.html"/>
    <id>https://scottzhang.pro/article/23c3a2e1.html</id>
    <published>2022-01-16T14:07:47.000Z</published>
    <updated>2022-02-15T09:50:15.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了魔法方法，并带你使用魔法方法实现自定义的序列。</p></blockquote><span id="more"></span><h1 id="魔法方法">魔法方法</h1><p>魔法方法是为了增强某个类的特性，它有约定俗成的名字，你只需要实现这个方法即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, employee_list</span>):</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让此类的实例，支持被 for 循环访问内部 employee</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line">company = Company([<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;MicroSoft&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持 for 循环</span></span><br><span class="line"><span class="keyword">for</span> company_name <span class="keyword">in</span> company:</span><br><span class="line">    <span class="built_in">print</span>(company_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持切片</span></span><br><span class="line">company[:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h1 id="有哪些魔法方法">有哪些魔法方法</h1><p>首先可以分为非数学运算与数学相关。</p><p>非数学运算中又有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 字符串表示，__repr__, __str__</span><br><span class="line">- 集合序列相关，__len__, __get/set/delitem__, __contains__</span><br><span class="line">- 迭代相关, __iter__, __next__</span><br><span class="line">- 可调用, __call__</span><br><span class="line">- with 上下文管理器, __enter__, __exit__</span><br><span class="line">- 数值转换，__abs__, __int/float/bool/...__, __hash__</span><br><span class="line">- 元类相关, __new__, __init__</span><br><span class="line">- 属性相关，__get/setattr__, __get/setattribute__. __dir__</span><br><span class="line">- 属性描述符, __get__, __set__, __delete__</span><br><span class="line">- 协程, __await__, __aiter__, __anext__, __aenter__, __aexit__</span><br></pre></td></tr></table></figure><p>数学运算则有一元、二元运算符，算数运算符，位运算符等等，暂时不做过多介绍。</p><p>在 Python 中，len 方法有其特殊性。当 len 作用在内置类型如 set, list, dict 上的时候，因为这些结构都是用 C 语言实现的，性能非常高，当 len 计算这些数据结构的长度的时候，会直接读取这个数据结构的长度值（C 会维护一个长度值），而不会遍历该树结构。</p><h1 id="应用自定义序列">应用：自定义序列</h1><h2 id="序列类型">序列类型</h2><p>在了解如何自定义序列类之前，我们先看 python 有哪些内置的序列类，我们将其中分为这几类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个容器，可以往里面放东西</span></span><br><span class="line">- 容器序列：<span class="built_in">list</span>, <span class="built_in">tuple</span>, deque</span><br><span class="line"><span class="comment"># 非容器</span></span><br><span class="line">- 扁平序列：<span class="built_in">str</span>, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>, array.array</span><br><span class="line"><span class="comment"># 序列内部元素可以变化</span></span><br><span class="line">- 可变序列： <span class="built_in">list</span>, deque, <span class="built_in">bytearray</span>, array</span><br><span class="line"><span class="comment"># 序列内部元素不可变化</span></span><br><span class="line">- 不可变：<span class="built_in">str</span>, <span class="built_in">tuple</span>, <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><p>上面这些序列类，你都可以通过 for 循环去访问其内部的元素。</p><p>要想实现序列类，则需要实现序列的协议。</p><p>可以通过 <code>_collections_abc</code> 了解要实现序列协议所需要的函数。</p><p>在序列中，一般都支持 <code>+ += extend</code> 方法，但你知道他们的区别吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化列表</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># +, c = [1, 2, 3, 4]</span></span><br><span class="line">c = a + [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># +=, a = [1, 2, 3, 4]</span></span><br><span class="line">a += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将 += 后面换成元组呢？</span></span><br><span class="line"><span class="comment"># 结果是一样的</span></span><br><span class="line">a += (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是 + 呢？</span></span><br><span class="line"><span class="comment"># 会报错</span></span><br><span class="line">c = a + (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>+=</code> 支持任意序列类型，其背后原理是调用一个魔法函数 <code>__iadd__</code>, 其中又是依赖 <code>__extend__</code> 方法，内部使用的是 for 循环对元素取值并相加，所以只要是可以迭代的类型，都支持用 <code>+=</code> 操作。</p></blockquote><p>另外要注意 list 的 <code>append</code> 和 <code>extend</code> 方法的区别，extend 是将数组内的值一个一个放入另一个数组，而 append 是将整个数组放入另一个数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">arr.extend([<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">arr.append([<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line">arr.append((<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># [1, 2, (3, 4)]</span></span><br></pre></td></tr></table></figure><h2 id="实现可切片对象">实现可切片对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DCGroup</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dpt, industry, staff</span>):</span></span><br><span class="line">        self.dpt = dpt</span><br><span class="line">        self.industry = industry</span><br><span class="line">        self.staff = staff</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现序列协议需要的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.staff.reverse()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个是实现切片的关键，若没有，切片操作会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># 若这样返回，则直接叫切片操作交给了内置的 list 操作</span></span><br><span class="line">        <span class="comment"># return self.staff[item]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 但如果你想要返回的东西是一个 Group 对象呢？</span></span><br><span class="line">        <span class="comment"># 这样你就可以一直切片</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这就需要理解 传入的 item（本质上是一个 slice 对象）</span></span><br><span class="line">        <span class="comment"># 如果是根据 index 访问，则是 int 值</span></span><br><span class="line"></span><br><span class="line">        cls = <span class="built_in">type</span>(self)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">slice</span>):</span><br><span class="line">            <span class="keyword">return</span> cls(</span><br><span class="line">                dpt=self.dpt,</span><br><span class="line">                industry=self.industry,</span><br><span class="line">                staff=self.staff[item]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(item, numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> cls(</span><br><span class="line">                dpt=self.dpt,</span><br><span class="line">                industry=self.industry,</span><br><span class="line">                staff=[self.staff[item]]</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.staff)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.staff)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> self.staff:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">dc = DCGroup(dpt=<span class="string">&#x27;DC&#x27;</span>, industry=<span class="string">&#x27;IMF&#x27;</span>, staff=[<span class="string">&#x27;Scott&#x27;</span>, <span class="string">&#x27;Austin&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">dc[:<span class="number">1</span>].staff  <span class="comment"># [&#x27;Scott&#x27;]</span></span><br><span class="line"><span class="string">&#x27;Scott&#x27;</span> <span class="keyword">in</span> dc <span class="comment"># True</span></span><br><span class="line"><span class="built_in">len</span>(dc)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> dc:</span><br><span class="line">    <span class="built_in">print</span>(user)</span><br><span class="line"></span><br><span class="line"><span class="built_in">reversed</span>(dc)</span><br></pre></td></tr></table></figure><h2 id="拓展维护已排序序列">拓展：维护已排序序列</h2><p><code>bisect</code> 是用来处理已排序的升序序列的包，使用的是二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="comment"># insort 插入</span></span><br><span class="line">int_list = []</span><br><span class="line">bisect.insort(int_list, <span class="number">3</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">2</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">1</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">5</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(int_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找插入的位置会是什么下标</span></span><br><span class="line"><span class="built_in">print</span>(bisect.bisect(int_list, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bisect.bisect_left(int_list, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(bisect.bisect_right(int_list, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 5, 9]</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>Python 中还有其他的数据结构，比如 array, deque.</p><p>list 相当于容器，可以存放任意类型，而array 只能存放指定数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># array 非常快，list 很灵活</span></span><br><span class="line">my_array = array.array(<span class="string">&quot;i&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了魔法方法，并带你使用魔法方法实现自定义的序列。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="魔法函数" scheme="https://scottzhang.pro/tags/%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/"/>
    
    <category term="magic method" scheme="https://scottzhang.pro/tags/magic-method/"/>
    
    <category term="dunder method" scheme="https://scottzhang.pro/tags/dunder-method/"/>
    
  </entry>
  
  <entry>
    <title>Python 深入理解类与对象</title>
    <link href="https://scottzhang.pro/article/4bcdc7f7.html"/>
    <id>https://scottzhang.pro/article/4bcdc7f7.html</id>
    <published>2022-01-16T13:54:41.000Z</published>
    <updated>2022-02-15T09:50:15.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>深入理解 Python 中的类与对象。</p></blockquote><span id="more"></span><h1 id="类和对象">类和对象</h1><p>对象是一个有着相应行为的数据的集合，比如苹果和橘子可以说都是对象。</p><p>假设我们在编写一个农场游戏，苹果会放到篮子里，橘子会放到桶中，那么现在就有四个对象。</p><p>对象和类有什么不同呢？类描述了对象，它们就像是创建对象的模板。</p><h1 id="静态方法与类方法">静态方法与类方法</h1><p>理解方法是怎么工作的，Python 中的静态方法、类方法以及抽象方法，可以参考之前设计模式系列文章-<a href="https://scottzhang.pro/article/18dbdeeb.html">单例模式及其实现原理</a>。</p><h1 id="type-object-和-class-的关系">type, object 和 class 的关系</h1><p>type 有两种用法：一个是生成一个类；另外一个是查看某个对象的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="number">1</span>)   <span class="comment"># class int</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">int</span>) <span class="comment"># class type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -&gt; int -&gt;1</span></span><br><span class="line"><span class="comment"># type -&gt; class -&gt; obj</span></span><br></pre></td></tr></table></figure><p>object 是所有类的基类，object 的基类是空， object 是 type 生成的。</p><p>但 type 本身也是一个类，同时 type 也是一个对象，type 的基类又是 object。</p><p>为了理解其中的关系，可以参考下图：</p><figure><img src="https://s2.loli.net/2022/01/09/NrGE3UmuzJpbdIk.png" alt="object, type and class" /><figcaption aria-hidden="true">object, type and class</figcaption></figure><ul><li>虚线描述的是实例关系，实线描述的是继承关系</li><li>type 创建了所有的对象；type 继承自 object，而 object 又是 type 的一个实例；type 还是自己的实例（连自己都不放过）；</li></ul><p>举例：list 继承自 object，"abc" 继承自 str, str 又继承自 object；list类继承自 object 类，同时 list 也是 type 的一个实例对象，所以其实 list 既是类也是实例，即 python 中一切皆对象的一个理解。</p><p>为什么 list 是一个 class的同时，也要是一个对象，因为如果它变成一个对象，就可以动态的修改。而在静态语言中，类一旦创建放到内存中，修改起来就很麻烦了。而 python 中将其变成对象，就很简单了。</p><h1 id="鸭子类型和多态">鸭子类型和多态</h1><p>当你看见一只鸟走起来像鸭子、游泳像鸭子、叫起来也像鸭子，那么这只鸟就是鸭子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am a dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am a Duck&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> [Dog, Duck]:</span><br><span class="line">    obj().say()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="抽象基类">抽象基类</h1><p>抽象基类，其他类可以继承此类，并必须要实现其规定的方法，抽象基类本身无法实例化出任何对象。</p><p>在 Python 中，检查某个类是否有某个方法，可以通过 hasattr 方法检查，比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, employee_list</span>):</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.employee)</span><br><span class="line"></span><br><span class="line">com = Company([<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 hasattr 检查类是否有某个方法</span></span><br><span class="line"><span class="built_in">hasattr</span>(com, <span class="string">&quot;__len__&quot;</span>)</span><br></pre></td></tr></table></figure><p>其结果与下面代码一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sized</span><br><span class="line"><span class="comment"># 问题：com 没有继承自 Sized，为何可以使用 isinstance 判断？</span></span><br><span class="line"><span class="comment"># Sized 内部有一个 __subclasshot 方法，其中会直接判断 com 有没有 len 方法</span></span><br><span class="line"><span class="built_in">isinstance</span>(com, Sized)</span><br></pre></td></tr></table></figure><p>其中 Sized 是一个抽象基类。背后的逻辑是，com 实现了 <code>__len__</code> 方法，所以它继承了 Sized 抽象基类，所以判断为真。</p><p>另外一种抽象基类的应用是限制子类必须实现某些方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抽象基类：限制子类必须实现某个方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheBase</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个 RedisCache 类，继承自 CacheBase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>(<span class="params">CacheBase</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 RedisCache</span></span><br><span class="line"><span class="comment"># 下面这步不会报错</span></span><br><span class="line">redis_cache = RedisCache()</span><br><span class="line"><span class="comment"># 调用 get 或者 set 的时候才会报错</span></span><br><span class="line">redis_cache.get(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你希望在 RedisCache 初始化的时候就报错，则需要使用 abc 抽象基类模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheBaseABC</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处会报错</span></span><br><span class="line">redis_cache_abc = CacheBaseABC()</span><br></pre></td></tr></table></figure><blockquote><p>Python 中，abc 模块，有系统全局的abc，也有 collections.abc</p></blockquote><p>在平时的编码实践中，注意不要过度依赖 abc 模块，容易导致过度设计, 可以考虑使用 mixin 的方式。</p><h1 id="isinstance-和-type">isinstance 和 type</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印两个都是 true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, B))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, A))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b) <span class="keyword">is</span> B)</span><br><span class="line"><span class="comment"># 也是 True</span></span><br><span class="line"><span class="comment"># 注意 is 和 == 的区别</span></span><br><span class="line"><span class="comment"># is 的意思是，判断两个对象是不是同一个对象，即 id() 返回的值是不是一样</span></span><br><span class="line"><span class="comment"># == 的意思是，判断值是否相等</span></span><br></pre></td></tr></table></figure><h1 id="类变量与实例变量">类变量与实例变量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例会向上查找找不到的值，比如这里的z</span></span><br><span class="line"><span class="built_in">print</span>(a.z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类自然也可以找到属于自己的值</span></span><br><span class="line"><span class="built_in">print</span>(A.z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类无法找到属于实例的值, 此处报错</span></span><br><span class="line"><span class="built_in">print</span>(a.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改实例的值，并不会修改类中的值</span></span><br><span class="line">a.z = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(a.z)  <span class="comment"># 99</span></span><br><span class="line"><span class="built_in">print</span>(A.z)     <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例创建之前，修改类内部的值，实例的值也会变化</span></span><br><span class="line">A.z = <span class="number">100</span></span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a.z  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure><h1 id="属性和查找顺序">属性和查找顺序</h1><p>属性分为类属性、实例属性。在上面的例子中，我们看到实例不存在的属性，在类中若可以找到则会被返回，这个查找顺序是怎样的呢？</p><p>简单的情况下，很容易理解，如果没有实例的 name 会使用类的 name，即 A。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">&quot;A&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;obj&quot;</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.name <span class="comment"># obj</span></span><br></pre></td></tr></table></figure><p>但如果是多继承是什么样的呢？比如下面的例子，A 是B, C, D, E的父类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D     E</span><br><span class="line">|     |</span><br><span class="line">B     C</span><br><span class="line"> \   /</span><br><span class="line">   A</span><br><span class="line"></span><br><span class="line"># DFS 的搜索顺序</span><br><span class="line">Deep First Search(DFS): A -&gt; B -&gt; D -&gt; C -&gt; E</span><br><span class="line"></span><br><span class="line">   D</span><br><span class="line"> /   \</span><br><span class="line">B     C</span><br><span class="line"> \   /</span><br><span class="line">   A</span><br><span class="line"></span><br><span class="line"># DFS 存在的问题</span><br><span class="line">这里的搜索顺序是A -&gt; B -&gt; D -&gt; C</span><br><span class="line">C 中有一个函数是重载 D 的，会导致无法重载</span><br><span class="line"></span><br><span class="line"># 引入广度优先算法</span><br><span class="line">对于图2，BFS: A -&gt; B -&gt; C -&gt; D</span><br><span class="line">对于图2，又有了新问题，假设 B，C，D 都有一个 get 方法</span><br><span class="line">那么如果 B 找不到，广度优先会去 C 中找，C 的 get 就会覆盖 D 的</span><br><span class="line">按理说应该 B 和 D 是一块</span><br><span class="line"></span><br><span class="line"># 引入 C3 算法</span><br><span class="line"># todo</span><br><span class="line"></span><br><span class="line">在 python 中，可以通过 class.__mro__ 查看查找顺序</span><br></pre></td></tr></table></figure><h1 id="多继承">多继承</h1><p>Python 也支持多线程，不过更推荐使用 Mixin 的模式。</p><p>本质上说就是让你的类继承自各种单一功能的类。可以简单理解为 java 中的函数，设计模式中的组合模式。</p><p>在设计 mixin 类的时候，尽量让它功能单一；不要让它和基类关联，这样就可以和任意基类组合；其次在 mixin 中，不要使用 super 这种用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># minxin.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListDirMixin</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListFileMixin</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> minxin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params">mixin.ListDirMixin, mixin.ListFileMixin</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="上下文管理器">上下文管理器</h1><p>首先通过两段代码来看 try except 在 Python 中的工作机制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个捕捉异常的例子</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> KeyError</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;KeyError&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try 还可以有其他的逻辑分支：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 raise 的 Error 和 except 的不一样则无法捕捉</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> IndexError</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;KeyError&quot;</span>)</span><br><span class="line"><span class="comment"># else，try 内没有 raise error，才会执行</span></span><br><span class="line"><span class="comment"># 这里永远不会运行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Other Error&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># finally 永远都会运行</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Always run&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果你用 python 打开一个文件，最后不管如何都需要关闭这个文件，你可能会在 try 中打开并读取文件， 然后在 finally 中关闭该文件。</p><p>这里有个问题是，如果你在 try 中打开文件之前报错了，那么在 finally 中则会无法关闭该文件，因为文件对象 还没来得及创建。</p><p>再来一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_test</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么返回 4 ？</span></span><br><span class="line"><span class="comment"># 如果有 finally 语句，就会返回 finally 中的值，即 4</span></span><br><span class="line"><span class="comment"># 如果没有，则返回之前 return 返回的值，即 2</span></span><br><span class="line">try_test()</span><br></pre></td></tr></table></figure><p>with 语句的出现，可以简化我们的 try, finally 的使用。而 with 语句本身属于上下文管理器的一种实现，本质上来说，它遵从了一种类协议（实现了 2 个魔法函数).</p><p>这里涉及了两个魔法函数, <code>__enter__</code>, <code>__exit__</code>。（魔法函数将会在接下来的文章更新）</p><p>如果你实现了某个类的这两个函数，即实现了上下文管理器协议，你就可以使用 with 语句调用你的类，比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>:</span></span><br><span class="line">    <span class="comment"># 进入 with 的时候，先调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 跳出 with 语句后会自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;doing something&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Sample() <span class="keyword">as</span> sample:</span><br><span class="line">    sample.do_something()</span><br></pre></td></tr></table></figure><p>你还可以通过 contextlib 进一步简化上下文管理器，这是 python 提供的内置模块, 它可以将一个 函数变成上下文管理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_open</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;open a file&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> &#123;&#125;  <span class="comment"># 必须使用生成器</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exit logic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> file_open(<span class="string">&quot;file.txt&quot;</span>) <span class="keyword">as</span> f_opend:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;processing...&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;深入理解 Python 中的类与对象。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>理解 Python 一切皆对象</title>
    <link href="https://scottzhang.pro/article/7cdaf89.html"/>
    <id>https://scottzhang.pro/article/7cdaf89.html</id>
    <published>2022-01-16T13:14:17.000Z</published>
    <updated>2022-02-15T09:50:15.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是对象？Python 中的对象又与其他编程语言中的对象有何不同？</p></blockquote><span id="more"></span><h1 id="什么是对象">什么是对象？</h1><p>一般来说，对象指的是拥有数据（或属性）和操作数据的方法的一个实体。</p><p>不同的编程语言对它的定义不一样，有的编程语言规定对象必须有属性和方法，有的编程语言则规定对象必须是subclassable 的（暂时没想到中文），Python 的定义则比较宽松，因为 Python 中不要求对象一定要有数据或方法，也不要求对象是 subclassable 的。</p><h1 id="一切皆对象">一切皆对象</h1><p>在其他的静态语言中，有对象和类，对象是类的一个实例，但是在 Python 中，这两者都是对象。</p><p>“Python 中一切皆对象”这句话，它的意思暗示了在 Python 中，所有元素都是对象，string, list, 函数、类甚至是模块都是对象，属于 Python 的一等公民，这意味着它可以：</p><ul><li>被赋值给一个变量</li><li>可以添加到集合对象中</li><li>可以作为参数传递给函数</li><li>可以当作函数的返回值</li></ul><p>这就提供了一种动态性，你可以在运行的时候修改它。</p><blockquote><p>对象的三个特征：身份(内存中的地址)、类型（1 是 int 类型）、值（a=1 中的1）。</p></blockquote><h1 id="以-list-为例">以 list 为例</h1><p>对象有数据和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 是一个对象</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type 可以告诉我们变量属于什么对象</span></span><br><span class="line"><span class="comment"># output: int</span></span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 x 对象的一个属性</span></span><br><span class="line"><span class="comment"># 对于 Int 类型，它有 Real and imaginary part of the value</span></span><br><span class="line"><span class="comment"># if viewed as a complex number</span></span><br><span class="line"><span class="built_in">print</span>(x.real)</span><br><span class="line"><span class="built_in">print</span>(x.imag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 x 对象的一个方法</span></span><br><span class="line"><span class="built_in">print</span>(x.is_integer())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说一切皆对象，真的就是所有都是对象</span></span><br><span class="line"><span class="comment"># 比如 x.is_interger 这个方法本身，也是对象</span></span><br><span class="line"><span class="comment"># output: builtin_function_or_method</span></span><br><span class="line"><span class="built_in">type</span>(x.is_interger)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="以函数为例">以函数为例</h1><p>如果你定义了一个函数，你也可以将它赋值给一个新的变量，新的变量将拥有对这个函数的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数赋值给新的变量</span></span><br><span class="line">my_add = add</span><br><span class="line">my_add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数作为参数返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_number_creator</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_number</span>(<span class="params">a</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a+ number</span><br><span class="line">    <span class="keyword">return</span> add_number</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://www.codingninjas.com/blog/2020/08/27/how-everything-in-python-is-an-object/">How everything in Python is an Object?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是对象？Python 中的对象又与其他编程语言中的对象有何不同？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python Socket 入门</title>
    <link href="https://scottzhang.pro/article/4317dd1.html"/>
    <id>https://scottzhang.pro/article/4317dd1.html</id>
    <published>2022-01-15T13:43:59.000Z</published>
    <updated>2022-02-15T09:50:15.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章带你了解如何建立 Python Socket 服务端与客户端，编写一个简单的多用户聊天程序，以及如何使用 Socket 模拟 http 请求。</p></blockquote><span id="more"></span><h1 id="理论介绍">理论介绍</h1><p>计算机网络基础知识，推荐一本书《TCP/IP 详解》。</p><p>HTTP，Socket，TCP 的区别，HTTP 是应用层的协议。Socket可理解为操作系统提供的应用层与传输层打交道的插座。而 TCP 属于传输层。 通过 Socket 编程，我们可以自己与传输层打交道，定义自己的协议进行通信。</p><p>Client 端涉及的操作：</p><figure><img src="https://s2.loli.net/2022/01/15/sXuIOz8T12n5DfB.png" alt="Socket编程" /><figcaption aria-hidden="true">Socket编程</figcaption></figure><p>服务端：</p><ul><li>socket：socket 是应用层和传输层之间的接口，传输层有 tcp 和 udp；</li><li>bind(协议，地址，端口)：地址可在本机 IP，也可以指定；每一个应用程序只能占用一个端口，网络 来的数据，操作系统会转发给相应的端口。</li><li>listen(监听客户端 socket 请求)</li><li>accept()</li><li>阻塞等待连续请求（新套接字）</li><li>recv()</li><li>send(), socket 建立了连接后，可以一直发送数据；http 则不行。</li><li>close()</li></ul><p>客户端：</p><ul><li>socket</li><li>connect()</li><li>send()</li><li>recv()</li><li>close()</li></ul><h1 id="socket-实现聊天">Socket 实现聊天</h1><p>来看一个 socket 实现聊天的例子，第一个是服务端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Socket Server</span></span><br><span class="line"><span class="comment"># 先启动 Server，否则 Client 会无法连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”.  &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    response_str = <span class="string">&quot;From Server, Admin:&quot;</span> + response_str</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen()</span><br><span class="line">sock_client, addr = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 这里才是用户拿到的 sock，上面的 server 则是用来监听的</span></span><br><span class="line">    data = sock_client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    respond(sock_client)</span><br></pre></td></tr></table></figure><p>然后是客户端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># Client, 第一次会尝试连接 Server Say Hi</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">client.send(<span class="string">f&quot;From Client, Scott: Hi!&quot;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 客户端，先发信息</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    client_id = <span class="string">&quot;From Client, Scott:&quot;</span></span><br><span class="line">    client_new_msg = client_id + <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    client.send(client_new_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>当客户端起来之后，服务端会收到一条消息，来看看他们的对话吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 服务端</span><br><span class="line">From Client, Scott: Hi!</span><br><span class="line">New msg:Hi Scott!</span><br><span class="line">From Client, Scott:Are you admin from the server?</span><br><span class="line">New msg:Yes, i am.</span><br><span class="line">From Client, Scott:Nice to meet you!!!</span><br><span class="line">New msg:Me too. How can i help you?</span><br><span class="line">From Client, Scott:Just test the connection, bye~</span><br><span class="line">New msg:Ok, Have a great day!</span><br><span class="line">From Client, Scott:You too!</span><br><span class="line"></span><br><span class="line"># 客户端</span><br><span class="line">From Server, Admin:Hi Scott!</span><br><span class="line">New msg:Are you admin from the server?</span><br><span class="line">From Server, Admin:Yes, i am.</span><br><span class="line">New msg:Nice to meet you!!!</span><br><span class="line">From Server, Admin:Me too. How can i help you?</span><br><span class="line">New msg:Just test the connection, bye~</span><br><span class="line">From Server, Admin:Ok, Have a great day!</span><br><span class="line">New msg:You too!</span><br></pre></td></tr></table></figure><h1 id="socket-实现多用户聊天">Socket 实现多用户聊天</h1><p>上面的 server 只支持一个用户，如何支持多个用户呢？可以使用线程来实现，背后的思想是，每当遇到一个新的连接 请求，就让一个线程去处理, 也就是这一段 <code>sock_client, addr = server.accept()</code> 交给一个新的线程去处理。</p><p>这是一个多线程的 server，客户端的代码是一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Socket Server</span></span><br><span class="line"><span class="comment"># 先启动 Server，否则 Client 会无法连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”.  &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    response_str = <span class="string">&quot;From Server, Admin:&quot;</span> + response_str</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_sock</span>(<span class="params">sock_client, addr</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 这里才是用户拿到的 sock，上面的 server 则是用来监听的</span></span><br><span class="line">        data = sock_client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        respond(sock_client)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">    server.listen()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sock_client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 用线程处理新来的用户</span></span><br><span class="line">        client_thread = threading.Thread(</span><br><span class="line">            target=handle_sock,</span><br><span class="line">            args=(sock_client, addr)</span><br><span class="line">        )</span><br><span class="line">        client_thread.start()</span><br></pre></td></tr></table></figure><p>来看服务端与不同客户端的通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">From Client 1, Scott: Hi!</span><br><span class="line">New msg:Hi Scott!</span><br><span class="line">From Client 2, The Weeknd: Hi!</span><br><span class="line">New msg:Hi The Weeknd!</span><br><span class="line">From Client 1, Scott:I really like the weeknd!</span><br><span class="line">New msg:Me too!</span><br><span class="line">From Client 2, The Weeknd:I just adds three tracks to my new album: Dawn FM.</span><br><span class="line">New msg:Great!</span><br></pre></td></tr></table></figure><h1 id="socket-模拟-http-请求">Socket 模拟 http 请求</h1><p>你应该听说过 Python 中 request 这个包，它其实底层是依赖 urllib 实现的，而 urllib 又是依赖于 socket。</p><p>既然是模拟 http 请求，还是需要做 url 解析，我们将会用到 urllib 中的部分函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 解析 url</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc   <span class="comment"># host</span></span><br><span class="line">    path = url.path     <span class="comment"># 子路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:      <span class="comment"># 子路径为空</span></span><br><span class="line">        path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立 socket 连接, 一般网站都使用 8000 端口</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造请求内容，并开始发送请求</span></span><br><span class="line">    <span class="comment"># 关于请求的内容，可以通过 Chrome 的调试工具打开目标网站</span></span><br><span class="line">    <span class="comment"># 再查看 Headers，具体某个网站必须构造哪些请求内容，各有不同</span></span><br><span class="line">    <span class="comment"># 比如百度必须有: host, connection,</span></span><br><span class="line">    client.send(</span><br><span class="line">        <span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            path, host</span><br><span class="line">    ).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回的数据不一定是 1024， 有可能是 &gt; 1024 的</span></span><br><span class="line">    <span class="comment"># client.recv(1024), 这样写会出问题，特殊处理一下</span></span><br><span class="line">    data = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 先接受 1024 个数据</span></span><br><span class="line">        d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    data = data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章带你了解如何建立 Python Socket 服务端与客户端，编写一个简单的多用户聊天程序，以及如何使用 Socket 模拟 http 请求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 浅拷贝与深拷贝</title>
    <link href="https://scottzhang.pro/article/c5dc05db.html"/>
    <id>https://scottzhang.pro/article/c5dc05db.html</id>
    <published>2022-01-15T13:38:58.000Z</published>
    <updated>2022-02-15T09:50:15.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章以 list，dict，class 为例，带你了解 Python 中的浅拷贝与深拷贝。</p></blockquote><span id="more"></span><h1 id="变量与指针">变量与指针</h1><p>在理解下面的例子之前，我们需要对 Python 中的变量有一个基本的理解。</p><p>对变量赋值，在其他语言中，我们可能理解为开辟一个区域（理解为容器、或者是一个篮子），再将值放进去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言：在内存中开辟一个区域，将值放进去</span></span><br><span class="line"><span class="keyword">int</span> x <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>在 Python 中，写法是一样的，但是最好的理解是将一个指针指向了这个区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python：定义了一个指针 x，指向了内存中</span></span><br><span class="line"><span class="comment"># 这个包含 4 的容器的地方</span></span><br><span class="line">x = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>因为 Python 变量相当于一个指针，指向这个内存区域，所以无需提前声明好变量是什么类型，指针中间也可以指向别的值，这也是人们说的 Python 的动态类型。</p><p>所以你可以这么做:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>         <span class="comment"># x is an integer</span></span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>   <span class="comment"># now x is a string</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># now x is a list</span></span><br></pre></td></tr></table></figure><p>但是动态类型也有缺点，那就是如果两个变量名指向同一个数据，那么一个变量所做的修改，另一个变量所指向的值也会发生变化。</p><p>下面来看具体的例子：</p><h1 id="以-list-为例">以 list 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------- 浅拷贝 ------------------ #</span></span><br><span class="line"><span class="comment"># 构造一个列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- New List XS, YS&quot;</span>)</span><br><span class="line">xs = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">ys = <span class="built_in">list</span>(xs)  <span class="comment"># Make a shallow copy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 添加元素: 不会影响 ys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Append Element To XS&quot;</span>)</span><br><span class="line">xs.append([<span class="string">&#x27;I am new&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 修改元素：两者都会影响</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To XS&quot;</span>)</span><br><span class="line">xs[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 yx 修改元素：两者会影响</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To YS&quot;</span>)</span><br><span class="line">ys[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;y&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- Deep Copy --------------- #</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">zs = copy.deepcopy(xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Deep Copy ZS from XS&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span>, xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 zs 修改元素，不会影响 xz</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To ZS&quot;</span>)</span><br><span class="line">zs[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 修改元素，也不会影响 xs</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To XS&quot;</span>)</span><br><span class="line">xs[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span>, xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------- New List XS, YS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">--------- Append Element To XS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">--------- Modified To XS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9]]</span><br><span class="line">--------- Modified To YS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">--------- Deep Copy ZS from XS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">--------- Modified To ZS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [&#x27;z&#x27;, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">--------- Modified To XS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, &#x27;z&#x27;, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [&#x27;z&#x27;, 8, 9], [&#x27;I am new&#x27;]]</span><br></pre></td></tr></table></figure><h1 id="以-dict-为例">以 dict 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个 dict，用来演示深拷贝与浅拷贝</span></span><br><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&#x27;name1&#x27;</span>: &#123;<span class="string">&quot;scott zhang&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;name2&#x27;</span>: &#123;<span class="string">&quot;the weeknd&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A new dict:&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 d 中 name1 的 id</span></span><br><span class="line">d_id = <span class="built_in">id</span>(d[<span class="string">&#x27;name1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(d_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝，更详细的说是</span></span><br><span class="line"><span class="comment"># 将 d[&#x27;name1&#x27;] 所在内存区域的地址绑定给 d_copy1</span></span><br><span class="line"><span class="comment"># 摘自 realpython：</span></span><br><span class="line"><span class="comment"># (Assignment statements in Python do not create copies of objects</span></span><br><span class="line"><span class="comment"># they only bind names to an object.)</span></span><br><span class="line"><span class="comment"># 浅拷贝内部值只是指针, 所以对 d_copy1 内部 name1 字典内的修改，会将 d 中的值也修改</span></span><br><span class="line">d_copy1 = d.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示</span></span><br><span class="line"><span class="comment"># 对 copy 过来的 dict 修改，再打印原来的数据</span></span><br><span class="line">d_copy1[<span class="string">&#x27;name1&#x27;</span>][<span class="string">&#x27;scott zhang&#x27;</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么？</span></span><br><span class="line"><span class="comment"># 因为其实内部指向的是同一个 dict</span></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">id</span>(d_copy1[<span class="string">&#x27;name1&#x27;</span>]) == <span class="built_in">id</span>(d[<span class="string">&#x27;name1&#x27;</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要指向同一个 dict?</span></span><br><span class="line"><span class="comment"># 因为浅拷贝指向的是指针，深拷贝会将数据重新赋值，非常耗费系统资源。</span></span><br></pre></td></tr></table></figure><p>上面代码的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A new dict: &#123;&#x27;name1&#x27;: &#123;&#x27;scott zhang&#x27;: 1&#125;, &#x27;name2&#x27;: &#123;&#x27;the weeknd&#x27;: 2&#125;&#125;</span><br><span class="line">1901449775104</span><br><span class="line">&#123;&#x27;name1&#x27;: &#123;&#x27;scott zhang&#x27;: 0&#125;, &#x27;name2&#x27;: &#123;&#x27;the weeknd&#x27;: 2&#125;&#125;</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h1 id="以-class-为例">以 class 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Point(<span class="subst">&#123;self.x!r&#125;</span>, <span class="subst">&#123;self.y!r&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># A Rectagle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, topleft, bottomright</span>):</span></span><br><span class="line">        self.topleft = topleft</span><br><span class="line">        self.bottomright = bottomright</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&#x27;Rectangle(<span class="subst">&#123;self.topleft!r&#125;</span>, &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;<span class="subst">&#123;self.bottomright!r&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Make a point and it copy obj</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Point&quot;</span>)</span><br><span class="line">    point = Point(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    point_copy = copy.copy(point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point:&quot;</span>, point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point copy:&quot;</span>, point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># point is point_copy?</span></span><br><span class="line">    <span class="comment"># no, because class Point using int in x and y</span></span><br><span class="line">    <span class="comment"># int is immutable type in python</span></span><br><span class="line">    <span class="comment"># so there is no difference between deep/shallow copy for Point class</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point is point copy？&quot;</span>, point <span class="keyword">is</span> point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># modified point</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified Point&quot;</span>)</span><br><span class="line">    point.x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point:&quot;</span>, point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point copy:&quot;</span>, point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是 Rectangle 内部的 Pointer 呢?</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Rectangle&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># new rectangle and a copy from it</span></span><br><span class="line">    rect = Rectangle(topleft=Point(<span class="number">0</span>, <span class="number">1</span>), bottomright=Point(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    rect_copy = copy.copy(rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect:&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy:&quot;</span>, rect_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># rect is rect_copy?</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect_copy is rect?&quot;</span>, rect_copy <span class="keyword">is</span> rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified rect&quot;</span>)</span><br><span class="line">    rect.topleft.x = <span class="number">999</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect:&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy:&quot;</span>, rect_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># using deep copy</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- New Deep Copy Rect&quot;</span>)</span><br><span class="line">    rect_copy_deep = copy.deepcopy(rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy deep:&quot;</span>, rect_copy_deep)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># modified a deep copy obj</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified Deep Copy Rect&quot;</span>)</span><br><span class="line">    rect.bottomright.x = <span class="number">666</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy deep:&quot;</span>, rect_copy_deep)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---- Point</span><br><span class="line">point: Point(0, 0)</span><br><span class="line">point copy: Point(0, 0)</span><br><span class="line">point is point copy？ False</span><br><span class="line">---- Modified Point</span><br><span class="line">point: Point(1, 0)</span><br><span class="line">point copy: Point(0, 0)</span><br><span class="line"></span><br><span class="line">---- Rectangle</span><br><span class="line">rect: Rectangle(Point(0, 1), Point(1, 0))</span><br><span class="line">rect copy: Rectangle(Point(0, 1), Point(1, 0))</span><br><span class="line">rect_copy is rect? False</span><br><span class="line">---- Modified rect</span><br><span class="line">rect: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">rect copy: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">---- New Deep Copy Rect</span><br><span class="line">rect Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">rect copy deep: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">---- Modified Deep Copy Rect</span><br><span class="line">rect Rectangle(Point(999, 1), Point(666, 0))</span><br><span class="line">rect copy deep: Rectangle(Point(999, 1), Point(1, 0))</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><ul><li>浅拷贝（shallow copy）并不会克隆对象中的子对象，因此原对象和对象中，被拷贝的内部对象不是独立两份，而是同一份。</li><li>深拷贝（Deep copy）会递归的拷贝所有子对象，这保证了内部对象的独立性，但是这样速度很慢。</li><li>你可以使用 copy 模块拷贝任意对象（包括你自定义的类），你还可以通过实现 <code>__copy()__</code> 或 <code>__deepcopy()__</code> 来自定义拷贝的过程。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章以 list，dict，class 为例，带你了解 Python 中的浅拷贝与深拷贝。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P3</title>
    <link href="https://scottzhang.pro/article/4074d0e9.html"/>
    <id>https://scottzhang.pro/article/4074d0e9.html</id>
    <published>2021-12-20T09:13:01.000Z</published>
    <updated>2021-12-20T09:19:39.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.</p></blockquote><span id="more"></span><h1 id="方法">方法</h1><p>Go 没有类。不过你可以为结构体类型定义方法，Go 中方法是带特殊的 {接收者} 参数的函数（方法其实就是函数，只是带了个接收者）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------后续代码将省略上面的部分------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 位于 func 关键字和方法名之间</span></span><br><span class="line"><span class="comment">// 在下面的例子中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：方法相当于函数，所以下面的写法功能是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是在使用的时候，不再是 v.Abs(), 而是 Abs(v)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非结构体也是可以声明方法的，比如对于 float：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 为 (f MyFloat)，方法名为 Abs, 返回 float64</span></span><br><span class="line"><span class="comment">// 没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">f := MyFloat(<span class="number">-1</span>)</span><br><span class="line">f.Abs()</span><br></pre></td></tr></table></figure><p>但是，你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。</p><p>上面的接收者为值接收者，实际上接收者还有一种叫做指针接收者，因为使用指针接收者，你可以在方法内部修改值，所以指针接收者比值接收者更常用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值接收者 (v Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取值、计算</span></span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者 (v *Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析输出</span></span><br><span class="line"><span class="comment">// 如果是指针接收者:</span></span><br><span class="line"><span class="comment">// Scale: 3*10 = 30; 4*10 = 40</span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果将指针接收者改为值接收者</span></span><br><span class="line"><span class="comment">// 即 (v *Vertex) -&gt; (v Vertex)</span></span><br><span class="line"><span class="comment">// Scale: 3 ; 4 </span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法和指针重定向; 在函数中，如果要求的参数是指针，传值会报错；如果使用指针接收者，则既可以传值，也可以传指针；反之如果要求的参数是值，在函数中传指针也会出错，指针接收者则也可以避免这种情况。</p><p>使用指针接收者的好处是：</p><ol type="1"><li>指针能够修改传进来的值</li><li>因为传的是指针，避免了值的复制，更高效</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 因为参数指定为指针，直接传值会出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="comment">// 下面这两种方式都可以工作</span></span><br><span class="line"><span class="comment">// v.Scale(10), (&amp;v).scale(10)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口">接口</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个几何形状的接口，拥有面积和</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形和圆的结构体</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 rect 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 circle 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// measure 函数，基于 geometory 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">    c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    measure(r)</span><br><span class="line">    measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接口的另一个例子, 首先是完整的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们逐一来看，方便研究，首先是直接将变量赋值给接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">a = f</span><br><span class="line"></span><br><span class="line">fmt.Println(f.Abs()) <span class="comment">// 为 MyFload 实现了 Abs 方法, 即</span></span><br><span class="line">fmt.Println(a.Abs()) <span class="comment">// MyFloat 实现了 Abser</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是将结构体赋值给接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line"></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它们不同的地方在于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件</span></span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义不同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;  <span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同</span></span><br><span class="line">a = f  <span class="comment">// a.Abs(), work; a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a.Abs(), work; a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">a = v </span><br><span class="line"><span class="comment">// a.Abs(), Error; Vertex does not implement Abser; 如果将</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() float64 改为</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() 则可以正常运行</span></span><br></pre></td></tr></table></figure><p>接口的隐式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事</span></span><br><span class="line"><span class="comment">// 直接将 func 的名字设置成 接口中的名字即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也是值，所以可以像值一样传递。可以用作参数和函数的返回值。</p><p>接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组 <code>(value, type)</code>, 接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 接口 I，其中规定了需要实现 M() 方法</span></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体 T，其中有 string 类型的 S</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为结构体 T 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (t *T) 为指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 float64 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (f F) 为值接收者</span></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印函数，参数为接口 I</span></span><br><span class="line"><span class="comment">// %v：值的 value</span></span><br><span class="line"><span class="comment">// %T: 值的 type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复习</span></span><br><span class="line"><span class="comment">// &amp; 符号的意思是对变量取地址，如：变量a的地址是&amp;a</span></span><br><span class="line"><span class="comment">// * 符号的意思是对指针取值，如:*&amp;a，就是a变量所在地址的值，当然也就是a的值了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I        <span class="comment">// 声明接口 i</span></span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125; <span class="comment">// 定了结构体 -&gt; 取该结构体的地址 -&gt; 给 i</span></span><br><span class="line">describe(i)     <span class="comment">// 打印结构体地址的值，以及 type</span></span><br><span class="line">i.M()           <span class="comment">// 结构体增加了 M() 方法，运行成功</span></span><br><span class="line"></span><br><span class="line">i = F(math.Pi)  <span class="comment">// F 是自定义的 float64，初始化值为 math.pi -&gt; 给 i</span></span><br><span class="line">describe(i)        <span class="comment">// 打印 i 的值和地址</span></span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层值为 nil 的接口值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I     <span class="comment">// 声明接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T    <span class="comment">// 初始化一个结构体指针 t，零值为 nil</span></span><br><span class="line">i = t       <span class="comment">// 隐式实现了接口，使得 i 有了 M() 方法</span></span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, *main.T)</span></span><br><span class="line"><span class="comment">&lt;nil&gt;</span></span><br><span class="line"><span class="comment">(&amp;&#123;hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>空接口, 它没有规定接口的方法，空接口可保存任何类型的值； 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 指定了零个方法的接口值</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于类型断言，它提供了访问接口值底层值的具体方式，并可以进行检测断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型选择，可以按顺序从接口值中选择值的类型，文法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个类型选择的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 类型选择中的 case 为类型（而非值</span></span><br><span class="line"><span class="comment">// 类型选择中的声明与类型断言 i.(T) 的语法相同</span></span><br><span class="line"><span class="comment">// 只是具体类型 T 被替换成了关键字 type</span></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Twice 21 is 42</span></span><br><span class="line"><span class="comment">&quot;hello&quot; is 5 bytes long</span></span><br><span class="line"><span class="comment">I don&#x27;t know about type bool!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面介绍一个普遍使用的接口，即 fmt 包中的 Stringer。一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">fmt.Println(a.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关于 Go 中的错误处理:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rror 为 nil 时表示成功；非 nil 的 error 表示失败。</span></span><br><span class="line">i, err := strconv.Atoi(<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure><p>关于文件读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line">        <span class="comment">// 在遇到数据流的结尾时，它会返回一个 io.EOF 错误</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于图像处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;image&quot;</span>  <span class="comment">// image 包定义了 Image 接口</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">// Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明</span></span><br><span class="line">fmt.Println(m.Bounds())</span><br><span class="line">fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并发">并发</h1><p>说到并发，首先介绍Go 中的 Go 程（goroutine），它是由 Go 运行时管理的轻量级线程。当你写 <code>go f(x, y, z)</code> 会启动一个新的 Go 程并执行 <code>f(x, y, z)</code>。</p><p>在 Go 程的运行过程中，f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p></blockquote><p>关于信道，在 Go 中，实质上是带有类型的管道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>信道操作符有 <code>-&gt;</code>, <code>&lt;-</code>，箭头的方向预示着数据流的方向。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收值并赋予 v。</span></span><br></pre></td></tr></table></figure><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于带缓冲的信道, 使用 make 创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br><span class="line"><span class="comment">// ch &lt;- 3</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于使用信道来说，还有两个基本的操作，即关闭信道，或者是检查一个信道是否关闭了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个求斐波拉契数列的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)  <span class="comment">// 使用 close 关闭信道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// 循环 for i := range c 会不断从信道接收值，直到它被关闭</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>注意：只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p></li><li><p>信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。</p></li></ul><p>关于 Go 总的 Select 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go&#x27;s _select_ lets you wait on multiple channel</span></span><br><span class="line"><span class="comment">// operations. Combining goroutines and channels with</span></span><br><span class="line"><span class="comment">// select is a powerful feature of Go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For our example we&#x27;ll select across two channels.</span></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each channel will receive a value after some amount</span></span><br><span class="line"><span class="comment">// of time, to simulate e.g. blocking RPC operations</span></span><br><span class="line"><span class="comment">// executing in concurrent goroutines.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// We&#x27;ll use `select` to await both of these values</span></span><br><span class="line"><span class="comment">// simultaneously, printing each one as it arrives.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中信道非常适合在不同的 Go 程中进行通信。但如果我们不需要通信呢？若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这个概念叫互斥，Go 中有一个专门的数据结构来提供这一功能，互斥锁 Mutex，<code>sync.Mutex</code>.</p><p><code>sync.Mutex</code> 中有两个方法，Lock 和 Ulock。</p><p>我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行</p><p>我们也可以用 defer 语句来保证互斥锁一定会被解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P2</title>
    <link href="https://scottzhang.pro/article/3773e07f.html"/>
    <id>https://scottzhang.pro/article/3773e07f.html</id>
    <published>2021-12-15T14:07:40.000Z</published>
    <updated>2022-01-07T14:06:02.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P2, 包括了指针、结构体、数组、切片、映射和闭包等内容。</p></blockquote><span id="more"></span><h1 id="指针">指针</h1><p>指针, 指针保存了值的地址:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针声明</span></span><br><span class="line"><span class="comment">// *int 是指向 int 类型的指针，其初始值（零值）为 nil</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp; 操作符会生成一个指向其操作数的指针</span></span><br><span class="line"><span class="comment">// 此处生成一个指向整数 42 的指针，赋值给 p</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取指针指向的值，操作也是 *</span></span><br><span class="line">fmt.Print(*p) <span class="comment">// 通过指针读取值</span></span><br><span class="line">*p = <span class="number">52</span>       <span class="comment">// 通过指针设置值</span></span><br></pre></td></tr></table></figure><h1 id="结构体">结构体</h1><p>结构体 struct，即一组字段 field:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">v = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 初始化赋值</span></span><br><span class="line">v.X = <span class="number">4</span>          <span class="comment">// 结构内元素赋值</span></span><br><span class="line">fmt.Print(v.X)   <span class="comment">// 取值</span></span><br><span class="line">fmt.Print(v.Y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的特殊文法：</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们第一次看到了 <code>type</code>，可以<a href="https://thenewstack.io/understanding-golang-type-system/">点击</a>这篇文章了解更多。</p><p>使用指针访问结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问结构体，需要结构提指针</span></span><br><span class="line"><span class="comment">// 还是以上面定义的结构体 Vertex 为例</span></span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结构体指针 p</span></span><br><span class="line"><span class="comment">// 赋值，本质是 (*p).X，为了避免繁琐，简化了操作（隐式间接调用）</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结构体的多种方式</span></span><br><span class="line"><span class="keyword">var</span> s1 Vertex&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s2 Vertex</span><br><span class="line"><span class="keyword">var</span> s3 *Vertex = <span class="built_in">new</span>(Vertex)</span><br></pre></td></tr></table></figure><blockquote><p>注意：结构体内部的变量名的大小写，会影响外部访问结构体内部的权限。</p></blockquote><p>结构体占用内存的大小是如何计算的？在 Go 中可以使用 sizeof 函数查看对象占用的对象类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占用 8 字节</span></span><br><span class="line">unsafe.Sizeof(x: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 不管字符串多长，都是 16，为什么？</span></span><br><span class="line">unsafe.Sizeof(x: <span class="string">&quot;scottzhang.pro&quot;</span>)</span><br></pre></td></tr></table></figure><p>其实 go 语言中的 string 是一个结构体:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">string</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span>  <span class="comment">// 指针，占用8个字节</span></span><br><span class="line">    Len <span class="keyword">int</span>       <span class="comment">//长度，64位占用8个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至 slice 也是一个结构体，类似这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 底层数组的地址 8</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>              <span class="comment">// 长度          8</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span>              <span class="comment">// 容量          8</span></span><br><span class="line">&#125;                        <span class="comment">//    永远都是 = 24</span></span><br></pre></td></tr></table></figure><h1 id="数组">数组</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明形式 [n]T</span></span><br><span class="line"><span class="comment">// 数组的长度是其类型的一部分，因此数组不能改变大小</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问内容的文法与其它语言一致</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;Scott&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的同时设置初始值</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(primes)</span><br></pre></td></tr></table></figure><h1 id="切片">切片</h1><p>切片为数组提供动态大小, 在实践中，切片比数组更常用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片与 Python Pandas 中 iloc 的语法类似</span></span><br><span class="line"><span class="comment">// 语法为 []T, 包括第一个元素，排除最后一个元素</span></span><br><span class="line">a[low:high]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择下标1-3的元素</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个例子</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片只是提供一个视角，所以它并不存储数据</span></span><br><span class="line"><span class="comment">// 但是对切片的修改，会修改底层数据</span></span><br><span class="line">names := [<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;Scott&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sam&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片的文法与没有写数组长度的类似</span></span><br><span class="line">[<span class="number">3</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;  <span class="comment">// 数组文法</span></span><br><span class="line">[]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;   <span class="comment">// 切片文法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 numpy, pandas 类似，取同样的值有多种写法</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">a[:]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片本身有属性，如长度和容量</span></span><br><span class="line"><span class="comment">// 长度：包含的元素个数</span></span><br><span class="line"><span class="comment">// 容量: 从它的第一个元素开始数，到其底层数组元素末尾的个数（注意区别 numpy）</span></span><br><span class="line"><span class="comment">// 长度和容量可通过表达式 len(s) 和 cap(s) 来获取</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 拓展其长度</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 舍弃前两个值</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//nil 切片</span></span><br><span class="line"><span class="comment">// 切片的零值是 nil</span></span><br><span class="line"><span class="comment">// nil 切片的长度和容量为 0 且没有底层数组</span></span><br></pre></td></tr></table></figure><p>使用 make 创建切片, make 函数会分配一个元素为零值的数组并返回一个引用了它的切片, 这也是在 Go 中使用动态数组的方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 make</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分别打印 abcd</span></span><br><span class="line"><span class="comment">a len=5 cap=5 [0 0 0 0 0]</span></span><br><span class="line"><span class="comment">b len=0 cap=5 []</span></span><br><span class="line"><span class="comment">c len=2 cap=5 [0 0]</span></span><br><span class="line"><span class="comment">d len=3 cap=3 [0 0 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>切片的切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似操作 dataframe</span></span><br><span class="line">board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个下标设置值后得到改变后的图案</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X _ X</span></span><br><span class="line"><span class="comment">O _ X</span></span><br><span class="line"><span class="comment">_ _ O</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>向切片追加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>for 循环的 range 形式, 类似于 Python 中的 enumrate，但它是一个关键字而不是函数：</p><h1 id="映射">映射</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次迭代都会返回两个值</span></span><br><span class="line"><span class="comment">// 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</span></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">    fmt.Printf(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想忽略某个值，可以使用 _ </span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你只需要索引</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure><p>映射，类似 Python 中的字典，但需要规定 Key 和 Value 的类型，假设值是 struct，则需提前定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构体，用来存值</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明映射，键是 string，值是 struct</span></span><br><span class="line"><span class="comment">// 映射的零值为 nil 。nil 映射既没有键，也不能添加键。</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构体</span></span><br><span class="line"><span class="comment">// make 函数会返回给定类型的映射，并将其初始化备用</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">    <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 make 函数</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体内部，Vertex 可以省略</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取、编辑映射内部的值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除值</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双赋值检测, elem, ok = m[key]</span></span><br><span class="line"><span class="comment">// 若 key 在 m 中，ok 为 true ；否则，ok 为 false。</span></span><br><span class="line"><span class="comment">// 若 key 不在映射中，那么 elem 是该映射元素类型的零值。</span></span><br><span class="line"><span class="comment">// 同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</span></span><br><span class="line"><span class="comment">// 若 elem 或 ok 还未声明，你可以使用短变量声明：elem, ok := m[key]</span></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br></pre></td></tr></table></figure><h1 id="闭包">闭包</h1><p>函数值，Go 中函数也可以被传到另一个函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compute 函数接收另外一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute 接收了 hypot 作为参数</span></span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(compute(hypot))</span><br></pre></td></tr></table></figure><p>函数的闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><p>来一步一步理解 Go 中的闭包： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个普通的函数 send 并调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">&#125;</span><br><span class="line">send(<span class="string">&quot;hi, scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个匿名版本的 send 函数并立即调用</span></span><br><span class="line"><span class="comment">// 注意这个函数并没有函数名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">&#125;(<span class="string">&quot;hi, scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，返回一个函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func give_me_a_func() |func(string)| &lt;---- 这里规定了返回值</span></span><br><span class="line"><span class="comment">                                           即为一个接收 string 的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">give_me_a_func</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以把 give_me_a_func() 传给另外一个函数</span></span><br><span class="line">send_func := give_me_a_func()</span><br><span class="line">send_func(<span class="string">&quot;hi scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解了上面函数的工作方式后，我们来介绍闭包</span></span><br><span class="line"><span class="comment">// 先定义一个函数, 它返回一个函数(return int)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在定义另外一个变量来存储 incrementor 返回的函数</span></span><br><span class="line">next := incrementor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印每次调用 next() 返回的值</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 1</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 2</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="comment">// 这里 i 看起来应该无法工作的</span></span><br><span class="line">        <span class="comment">// 因为 i 是定义在 incrementor 中的</span></span><br><span class="line">        <span class="comment">// 但闭包拥有其被创建环境下的作用域</span></span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://thenewstack.io/understanding-golang-type-system/">Understanding Golang Type System</a></li><li><a href="https://medium.com/m/global-identity?redirectUrl=https%3A%2F%2Fbetterprogramming.pub%2Fclosures-made-simple-with-golang-69db3017cd7b">Closures Made Simple With Golang</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P2, 包括了指针、结构体、数组、切片、映射和闭包等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P1</title>
    <link href="https://scottzhang.pro/article/ae7ab1c5.html"/>
    <id>https://scottzhang.pro/article/ae7ab1c5.html</id>
    <published>2021-12-14T15:55:09.000Z</published>
    <updated>2021-12-20T09:19:01.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P1, 包含两大部分的语法介绍：一个是包、变量和函数，另外一个是流程控制语句，如 for, if-else, switch。</p></blockquote><span id="more"></span><h1 id="包变量和函数">包、变量和函数</h1><p>关于包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// 每个程序由包构成，从 main 开始</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span> </span><br><span class="line">    <span class="comment">// 在这个包中，肯定以 package rand 开始</span></span><br><span class="line">    <span class="comment">// 申明包的名字</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>关于导出名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(math.Pi) <span class="comment">//一个名字以大写字母开头，那么它就是已导出的</span></span><br><span class="line">fmt.Println(math.pi) <span class="comment">//未导出</span></span><br></pre></td></tr></table></figure><p>函数的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型相同的参数可以简写</span></span><br><span class="line">x <span class="keyword">int</span>, y <span class="keyword">int</span></span><br><span class="line">x,y <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以返回任意数量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接写 return 会返回函数中定义了的所有变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">    <span class="comment">// 返回 x 和 y, 此处是 7,10</span></span><br><span class="line">    <span class="comment">// 此处返回值会转成 int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span> <span class="comment">// 默认赋值为 false</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> <span class="comment">// 默认赋值为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始值</span></span><br><span class="line">vari, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span> <span class="comment">// 可以设置初始值</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&#x27;no!&#x27;</span> <span class="comment">// 不指定类型而直接指定初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量简单法，用 := 替代 var</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用语法块声明变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有给初始值，默认会赋值, 数值是0， 布尔 false，字符串是空字符</span></span><br></pre></td></tr></table></figure><p>类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int -&gt; float -&gt; uint</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f float = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的形式</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)</span><br><span class="line">u := <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>类型推导:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以准确推导的情况下，直接使用</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">j := i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能准确推导或者因为值运算的结果，需要改变精度</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">j := <span class="number">3.142</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> </span><br><span class="line"><span class="comment">// 注意: g = 0.867 + 0.5i 会报错</span></span><br></pre></td></tr></table></figure><p>常量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> Pi := <span class="number">3.14</span> <span class="comment">//syntax error: unexpected :=, expecting =</span></span><br></pre></td></tr></table></figure><p>数值常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line"><span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br></pre></td></tr></table></figure><h1 id="流程控制">流程控制</h1><p>Go 只有一种循环结构即 for 循环，分成三部分</p><ul><li><p>初始化语句：在第一次迭代前执行</p></li><li><p>条件表达式：在每次迭代前求值</p></li><li><p>后置语句：在每次迭代的结尾执行</p></li></ul><p>它有三种写法，for 后面没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的</p><ul><li><strong>for init; condition; post{}</strong></li><li><strong>for condition {}</strong></li><li><strong>for {}</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for init; condition; post&#123;&#125;</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for condition &#123;&#125;</span></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for &#123;&#125; 无限循环</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 If 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无(), 必须有 &#123;&#125;</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件表达式前可以执行一个简单的语句</span></span><br><span class="line"><span class="keyword">if</span> v := add(x, y); v &lt; <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else 语法</span></span><br><span class="line"><span class="keyword">if</span> v:= add(x, y) &#123;</span><br><span class="line">    <span class="comment">// do a</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处不可以使用 v 了</span></span><br></pre></td></tr></table></figure><p>关于 switch:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// freebsd, openbsd,</span></span><br><span class="line">        <span class="comment">// plan9, windows...</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Go 只运行选定的 case，而非之后所有的 case</span></span><br><span class="line"><span class="comment">// switch 的 case 无需为常量，且取值不必为整数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求值顺序从上到下，找到匹配成功</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> f(): <span class="comment">// f() 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有条件的 switch</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 defer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer 会将函数推迟到外层函数返回之后执行</span></span><br><span class="line"><span class="comment">// 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</span></span><br><span class="line"><span class="comment">// 下面的代码输出 hello \n world</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推迟的函数被压入栈，先进后出</span></span><br><span class="line"><span class="comment">// 所以下面的函数会以 987.. 的顺序打印</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P1, 包含两大部分的语法介绍：一个是包、变量和函数，另外一个是流程控制语句，如 for, if-else, switch。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 笔记: Module</title>
    <link href="https://scottzhang.pro/article/4b8d4d9.html"/>
    <id>https://scottzhang.pro/article/4b8d4d9.html</id>
    <published>2021-12-14T14:33:51.000Z</published>
    <updated>2021-12-20T09:11:58.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Understand Module in Golang.</p></blockquote><span id="more"></span><h1 id="code-example">Code example</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">quoteV3 <span class="string">&quot;rsc.io/quote/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> quoteV3.HelloV3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Proverb</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> quoteV3.Concurrency()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">want := <span class="string">&quot;Hello, world.&quot;</span></span><br><span class="line"><span class="keyword">if</span> got := Hello(); got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Hello() = %q, want %q&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProverb</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">want := <span class="string">&quot;Concurrency is not parallelism.&quot;</span></span><br><span class="line"><span class="keyword">if</span> got := Proverb(); got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Proverb() = %q, want %q&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go.mod</span></span><br><span class="line">module scottzhang.pro/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.17</span></span><br><span class="line"></span><br><span class="line">require rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="use-go-modules">Use Go Modules</h1><p>What is module?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module：a collection of Go packages</span><br><span class="line">  |</span><br><span class="line">go.mod:</span><br><span class="line">    - module&#x27;s module path</span><br><span class="line">    - dependency requirements</span><br></pre></td></tr></table></figure><p>The Running ENV for a module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. outside $GOPATH/src &lt;--</span><br><span class="line">2. inside any folder     |</span><br><span class="line">   with:                 |</span><br><span class="line">       - go.mod --------&gt;|</span><br></pre></td></tr></table></figure><p>How to creating a new module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. create you file.  // status: contains a package</span><br><span class="line">2. cmd: go mod init scottzhang.pro/hello  // make the current directory the root of a module</span><br><span class="line">3. cmd: go test  // test the module</span><br></pre></td></tr></table></figure><ul><li>Packages in subdirectories have import paths consisting of the module path plus the path to the subdirectory.</li><li>So you don't need to run <strong>go mod init</strong> in subdirectories.</li></ul><p>Understand go.mod content:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example.com/hello //main module</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c //an example of a pseudo-version</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.3.0</span><br><span class="line"></span><br><span class="line">// go <span class="built_in">command</span> maintains a file named go.sum</span><br><span class="line">// containing the expected cryptographic hashes of the content of specific module versions.</span><br><span class="line">// ensure that future downloads of these modules retrieve the same bits as the first download</span><br></pre></td></tr></table></figure><p>How to import dependencies module:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;rsc.io/quote&quot;</span></span><br><span class="line"><span class="comment">// to check  indirect dependencies</span></span><br><span class="line"><span class="comment">// cmd: go list -m all</span></span><br></pre></td></tr></table></figure><p>How to upgrading dependencies:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// here is a example to upgrade text and sampler</span><br><span class="line">cmd: go get golang.org/x/text</span><br><span class="line">cmd: go get rsc.io/sampler</span><br></pre></td></tr></table></figure><p>Now depends on both <strong>rsc.io/quote</strong> and <strong>rsc.io/quote/v3</strong>.</p><p>why here is V3?, because:</p><ul><li>Each different major version (v1, v2, and so on) of a Go module uses a different module path</li><li>v3 of rsc.io/quote = rsc.io/quote/v3, Know more visit <a href="https://research.swtch.com/vgo-import">here</a></li></ul><blockquote><p>You can have v1, v2, v3 in same module, but can't with v1.1 and v1.2</p></blockquote><p>To know what new changes in new version, type <strong>go doc rsc.io/quote/v3</strong>.</p><p>Remove no need module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go list -m all  # check</span><br><span class="line">go mod tidy  # cleans up these unused dependencies</span><br></pre></td></tr></table></figure><h1 id="conclusion">Conclusion</h1><ul><li><strong>go mod init</strong> creates a new module, initializing the go.mod file that describes it.</li><li><strong>go build</strong>, go test, and other package-building commands add new dependencies to go.mod as needed.</li><li><strong>go list -m all</strong> prints the current module’s dependencies.</li><li><strong>go get</strong> changes the required version of a dependency (or adds a new dependency).</li><li><strong>go mod tidy</strong> removes unused dependencies.</li></ul><h1 id="ref">Ref</h1><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-go-modules">How to Use Go Modules</a></li><li><a href="https://go.dev/blog/using-go-modules">Using Go Modules</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Understand Module in Golang.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-抽象工厂与组合模式</title>
    <link href="https://scottzhang.pro/article/72c6f483.html"/>
    <id>https://scottzhang.pro/article/72c6f483.html</id>
    <published>2021-11-28T13:44:50.000Z</published>
    <updated>2021-11-28T13:50:30.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="抽象工厂模式">抽象工厂模式</h1><p>想让你的系统根据配置或平台的问题有多个可能的实现，就可以利用抽象工厂模式。</p><p>你调用抽象工厂会返回一个对象，这个对象的实现会基于你的需求而变化。</p><ul><li>对于一个在线的商城，它对于不同的国家有不同的语言、货币以及税收的计算方式。</li><li>对于一套 GUI 工具，在 Windows 上可能返回的是 WinForm，在 Mac 上返回的则是 Cocoa 组件。</li><li>对于 Django，它会根据当前站点的配置而返回相关的对象以对不同数据库后端的支持。</li></ul><p>想象一个格式化日期与货币的需求，我们需要支持中英文两种情况下的货币和日期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaDateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot; &#123;&#125; 年 &#123;&#125; 月 &#123;&#125; 日 &quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USADateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27; 2021 年 01 月 01 日 &#x27;</span></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;27&#x27;</span>)  <span class="comment"># &#x27; 2021 年 11 月 27 日 &#x27;</span></span><br><span class="line"></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>) <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>再来定义两个处理货币的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaCurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¥ &#123;&#125;.&#123;&#125; 元&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USACurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;$ &#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChinaCurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;¥ 143,958,766,111,111.05 元&#x27;</span></span><br><span class="line">USACurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;$ 143,958,766,111,111.05&#x27;</span></span><br></pre></td></tr></table></figure><p>将上面的代码按照国家组织在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USAFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USADateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USACurrencyFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaDateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaCurrencyFormatter()</span><br></pre></td></tr></table></figure><p>在使用的时候，可以直接使用字典去找对应的抽象工厂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factory_map = &#123;</span><br><span class="line">    <span class="string">&#x27;US&#x27;</span>: USAFormatterFactory,</span><br><span class="line">    <span class="string">&#x27;China&#x27;</span>: ChinaFormatterFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置区域为中国：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = &#x27;China&#x27;</span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(&#x27;21&#x27;, &#x27;1&#x27;, &#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line"># &#x27; 2021 年 01 月 01 日 &#x27;</span><br></pre></td></tr></table></figure><p>设置区域为美国：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = <span class="string">&#x27;US&#x27;</span></span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>在实际的项目架构中，我们会有一个后端的模块来支持对不同国家提供服务，它的结构可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">localize/</span><br><span class="line">__init__.py</span><br><span class="line">backends/</span><br><span class="line">__init__.py</span><br><span class="line">USA.py</span><br><span class="line">China.py</span><br></pre></td></tr></table></figure><p>那么我们可以在 localize 下面的 <code>__init__.py</code> 文件中，动态的选择区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .backends <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> country_code == <span class="string">&#x27;China&#x27;</span>:</span><br><span class="line">current_backend = <span class="string">&#x27;China&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="组合模式">组合模式</h1><p>组合模式一般通过组建来构造复杂的树状结构，它在文件夹和文件夹树中的应用比较多。</p><p>文件目录中通常有两种类型的对象，文件和文件夹。首先来定义这两个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.children = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">sejlf</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把一些常用的方法抽象到基类中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compoment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      get_path 方法会在外部实现</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">        new_folder = get_path(new_path)</span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br><span class="line">        new_folder.children[self.name] = self</span><br><span class="line">        self.parent = new_folder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br></pre></td></tr></table></figure><p>这样 File 和 Folder 类就可以少去一些代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        child.parent = self</span><br><span class="line">        self.children[child.name] = child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这种方式，我们使用的时候，可以进行任意的组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root = Folder(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">folder1 = Folder(<span class="string">&#x27;F1&#x27;</span>)</span><br><span class="line">folder2 = Folder(<span class="string">&#x27;F2&#x27;</span>)</span><br><span class="line">hello_file = File(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line">folder2.add_child(hello_file)</span><br><span class="line">folder1.add_child(folder2)</span><br><span class="line">root.add_child(folder1)</span><br><span class="line"></span><br><span class="line">root.children[<span class="string">&#x27;F1&#x27;</span>].children[<span class="string">&#x27;F2&#x27;</span>].children[<span class="string">&#x27;hello&#x27;</span>].contents</span><br></pre></td></tr></table></figure><p>当你在编程的时候，遇到了树状结构的时候，可以想想是否可以应用组合模式。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-适配器与外观模式</title>
    <link href="https://scottzhang.pro/article/2b511f30.html"/>
    <id>https://scottzhang.pro/article/2b511f30.html</id>
    <published>2021-11-26T09:46:19.000Z</published>
    <updated>2021-11-28T13:50:12.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="适配器模式">适配器模式</h1><p>适配器模式，顾名思义就好像是电脑的转接头一样，目的就是让不同的系统之间可以协同工作。</p><p>比如现在已经存在一些代码了，但你不想对它做任何更改，因为这意味着你要修改大量的内容，这时候你可以写一个适配器，将输入转化成现有代码可以直接使用的，这就叫适配器。</p><p>举个例子，假设我们有一个奇怪的日期格式，它的年和月中间有一个14，现在有一个代码的逻辑是得到初始日期和结束日期中间的天数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysCalculator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        start = datetime.datetime.strptime(self.start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strptime(self.end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (end - start).days</span><br><span class="line"></span><br><span class="line">DaysCalculator(start=<span class="string">&#x27;20211403&#x27;</span>, end=<span class="string">&#x27;20211409&#x27;</span>).get_days()</span><br><span class="line"><span class="comment"># 输出 184</span></span><br></pre></td></tr></table></figure><p>现在你有一些方法需要依赖这段代码，你不得不也按照这个奇怪的格式工作，那么这时候你可以写一个适配器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysAdaptor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        start = datetime.datetime.strftime(start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strftime(end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        self.calculator = DaysCalculator(start, end)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.calculator.get_days()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造两个标准日期对象作为输入</span></span><br><span class="line">start = datetime.datetime.strptime(<span class="string">&#x27;2021/3&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line">end = datetime.datetime.strptime(<span class="string">&#x27;2021/9&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里传入的日期类的日期，但也可以正常工作</span></span><br><span class="line">DaysAdaptor(start, end).get_days()</span><br></pre></td></tr></table></figure><h1 id="外观模式">外观模式</h1><p>外观模式更关注外部的体验，为了用户体验的方便，它将复杂的内部代码封装起来，只暴露一个简单的方法接受参数供用户调用，从而实现不同的功能。</p><p>一个例子是，你想编写一个接受/发送邮件的客户端，对于用户而言，它只需关心：</p><ul><li>发件人地址</li><li>邮件内容</li><li>接受人地址</li></ul><p>所以我们可以编写一个简单的方法，只关心这几个参数，而其余的对于地址的处理、检查，对于用户密码的验证等等则隐藏在函数内部。</p><p>相信你已经在自己的代码中使用过外观模式，此处不在举例。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-享元与命令模式</title>
    <link href="https://scottzhang.pro/article/56f28bda.html"/>
    <id>https://scottzhang.pro/article/56f28bda.html</id>
    <published>2021-11-26T09:42:59.000Z</published>
    <updated>2021-11-28T13:50:17.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章讨论了享元模式与命令模式。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="享元模式">享元模式</h1><p>元、气之始，引申为元气。享元模式即共享最初的那部分，哪部分呢？</p><p>假设你有一个需求需要创建大量的类实例，利用享元模式，就可以保证<strong>共享同一状态的对象，可以同时使用该共享状态的内存。</strong></p><p>举个例子，之前聊过的汽车销售系统。对于每一辆车，我们可以加装不同的配置，比如有尊享版、豪华版等等。</p><p>不同版本之间，其实是大同小异。</p><p>如果对于每辆车我们都去统计它有什么功能，没有什么功能，则会产生巨大的浪费。</p><p>我们可以通过共享对象去存储那些与型号相关的特性列表。</p><p>享元在 Python 中的实现类似单例模式。</p><p>但单例模式返回的是一个类的实例，而享元模式则是根据指定的不同参数，返回对应的实例。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc  <span class="comment"># 垃圾回收器</span></span><br><span class="line"><span class="keyword">import</span> weakref <span class="comment"># 弱引用数据结构包</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarModel</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;弱引用的字典，内部的对象弱没有被引用，则会被回收。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _models = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, model_name, *avgs, **kvargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;这里对新实例的创建自定义，与单例模式有点类似</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        model = cls._models.get(model_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> model:</span><br><span class="line">            model = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">            cls._models[model_name] = model</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name, air=<span class="literal">False</span>, title=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 cruise_control=<span class="literal">False</span>, power_locks=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 allow_whells=<span class="literal">False</span>, use_charger=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例的初始化，在这里完成</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.model_name = model_name</span><br><span class="line">        self.air = air</span><br><span class="line">        self.title = title</span><br><span class="line">        self.cruise_control = cruise_control</span><br><span class="line">        self.power_locks = power_locks</span><br><span class="line">        self.allow_whells = allow_whells</span><br><span class="line">        self.use_charger = use_charger</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self, serial_number</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Sorry We are anble to check&quot;</span>,</span><br><span class="line">            <span class="string">&quot;the seria number &#123;0&#125; on the &#123;1&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;at this time&quot;</span>.<span class="built_in">format</span>(self.number, self.model_name)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model, color, serial</span>):</span></span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = color</span><br><span class="line">        self.serial = serial</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model.check_serial(self.serial)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>上面定义了两个类，一个是汽车模版，一个是汽车。我们来生产几辆车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dx = CarModel(<span class="string">&quot;FIT DX&quot;</span>)</span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产一些车</span></span><br><span class="line">car1 = Car(model=dx, color=<span class="string">&#x27;blue&#x27;</span>, serial=<span class="string">&#x27;DX001&#x27;</span>)</span><br><span class="line">car2 = Car(model=dx, color=<span class="string">&#x27;black&#x27;</span>, serial=<span class="string">&#x27;DX002&#x27;</span>)</span><br><span class="line">car3 = Car(model=lx, color=<span class="string">&quot;red&quot;</span>, serial=<span class="string">&quot;LX003&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在来观察他们的内存地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># display(id(lx)) -&gt; 4402294352</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 lx 和对它的引用，让垃圾回收器回收</span></span><br><span class="line"><span class="keyword">del</span> lx</span><br><span class="line"><span class="keyword">del</span> car3</span><br><span class="line">gc.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新创建一个新的 lx，其地址已经变了，因为生成了新的 lx</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个其它版本的 lx，没有 air 和其他的选项，发现返回的还是第二遍创建的</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br></pre></td></tr></table></figure><p>享元模式使用起来比普通的类实现更负责，但如果你有成百上千的类实例需要创建的时候，享元模式可以极大的节省你的内存，可以说享元模式是专为节省内存而设计的。</p><h1 id="命令模式">命令模式</h1><p>命令模式在<strong>必须被完成的行为</strong>和<strong>调用这些动作的对象</strong>之间添加了一个抽象层，这句话可能比较难理解，我们看一个例子。</p><p>这个模式在图形窗口中的操作中应用的比较多。</p><p>我们实现一个窗口程序，它有退出和保存的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_name</span>):</span></span><br><span class="line">        self.file_name = file_name</span><br><span class="line">        self.content = <span class="string">&quot;This file can not be modified&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToolBarButton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, iconname</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.iconname = iconname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, menu_name, manu_itemname</span>):</span></span><br><span class="line">        self.manu_name = menu_name</span><br><span class="line">        self.menu_itemname = manu_itemname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyboardShortCut</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, modifier</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.modifier = modifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keypress</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExitCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个窗口</span></span><br><span class="line">window = Window()</span><br><span class="line"><span class="comment"># 新建一个文档</span></span><br><span class="line">document = Document(<span class="string">&quot;A Great Document!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建两个指令，需要传入文档</span></span><br><span class="line">save_command = SaveCommand(document)</span><br><span class="line">exit_command = ExitCommand(document)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定操作</span></span><br><span class="line"><span class="comment"># 举例：当 ToolBarButton 内部的 click 被调用</span></span><br><span class="line"><span class="comment"># click -&gt; save_command.execute（内部引用了document） -&gt; document.save</span></span><br><span class="line">save_button = ToolBarButton(<span class="string">&#x27;save&#x27;</span>, <span class="string">&#x27;save.png&#x27;</span>)</span><br><span class="line">save_button.command = save_command</span><br><span class="line"></span><br><span class="line">save_keystroke = KeyboardShortCut(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;ctrl&#x27;</span>)</span><br><span class="line">save_keystroke.command = save_command</span><br><span class="line"></span><br><span class="line">exit_menu = MenuItem(<span class="string">&#x27;File&#x27;</span>, <span class="string">&#x27;Exit&#x27;</span>)</span><br><span class="line">exit_menu.command = exit_command</span><br></pre></td></tr></table></figure><p>还有一种更简洁、更 Python 的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command()</span><br><span class="line"></span><br><span class="line">window = Window()</span><br><span class="line">menu_item = MenuItem()</span><br><span class="line">menu_item.command = window.exit</span><br></pre></td></tr></table></figure><p>或者直接调用类，只需实现 <code>__call__</code> 方法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;实现了 call 方法的类可以直接被调用&quot;&quot;&quot;</span></span><br><span class="line">        self.document.save()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章讨论了享元模式与命令模式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记录 Airflow 的部署</title>
    <link href="https://scottzhang.pro/article/c6a5215a.html"/>
    <id>https://scottzhang.pro/article/c6a5215a.html</id>
    <published>2021-11-26T07:06:25.000Z</published>
    <updated>2021-11-27T08:28:31.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个 Python 编写的调度工具，在此记录它的部署过程。</p></blockquote><span id="more"></span><h1 id="部署">部署</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy new server</span></span><br><span class="line">From vultr</span><br><span class="line"></span><br><span class="line"><span class="comment"># win10 generate ssh key</span></span><br><span class="line">ssh-keygen</span><br><span class="line">cat | Users/YourUserName/.ssh/id_rsa.pub | set-clibboard</span><br><span class="line"></span><br><span class="line">使用 Docker 配置 Airflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull puckel/docker-airflow</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -d -p 8080:8080 puckel/docker-airflow webserver</span><br><span class="line"><span class="comment"># 进入启动的容器并启动 shell</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置登录密码</span></span><br><span class="line"><span class="comment">## 创建 py 文件</span></span><br><span class="line">vim set_password.py</span><br><span class="line"></span><br><span class="line"><span class="comment">## 贴入代码</span></span><br><span class="line">import airflow</span><br><span class="line">from airflow import models, settings</span><br><span class="line">from airflow.contrib.auth.backends.password_auth import PasswordUser</span><br><span class="line"></span><br><span class="line">user = PasswordUser(models.User())</span><br><span class="line">user.username = <span class="string">&#x27;new_user_name&#x27;</span></span><br><span class="line">user.email = <span class="string">&#x27;new_user_email@example.com&#x27;</span></span><br><span class="line">user.password = <span class="string">&#x27;set_the_password&#x27;</span></span><br><span class="line">session = settings.Session()</span><br><span class="line">session.add(user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件，将配置文件拷贝出来用vim修改</span></span><br><span class="line">sudo docker cp a3a3dc6b79fe:/usr/<span class="built_in">local</span>/airflow/airflow.cfg .</span><br><span class="line">vim airflow.cfg . <span class="comment"># 修改</span></span><br><span class="line">sudo docker cp airflow.cfg  dc8b159da311:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 py 文件拷贝到容器</span></span><br><span class="line">sudo docker cp set_password.py  1291e03f85fc:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f85fc bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码</span></span><br><span class="line">python set_password.py <span class="comment"># 提示缺少包 flask_bcrypt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 flask_bcrypt 包</span></span><br><span class="line">pip intall flask_bcrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码, 重启</span></span><br><span class="line">python set_password.py</span><br><span class="line">docker container restart 1291e03f85fc</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"><span class="comment"># list dags</span></span><br><span class="line"></span><br><span class="line">airflow list_dags</span><br><span class="line"></span><br><span class="line">Filling up the DagBag from /home/repl/workspace/dags , 加粗部分为 dags 所在文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置文件</span></span><br><span class="line">cat ~/airflow/airflow.cfg</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line"><span class="comment"># 容器启动失败查看日志</span></span><br><span class="line">sudo docker logs <span class="variable">$&#123;container_id&#125;</span></span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://notbe.cn/2019/05/12/1557726443776.html">airflow 使用心得，从环境到部署上线</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个 Python 编写的调度工具，在此记录它的部署过程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="docker" scheme="https://scottzhang.pro/tags/docker/"/>
    
    <category term="airflow" scheme="https://scottzhang.pro/tags/airflow/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-模版模式</title>
    <link href="https://scottzhang.pro/article/ebf9c4b3.html"/>
    <id>https://scottzhang.pro/article/ebf9c4b3.html</id>
    <published>2021-11-21T07:51:22.000Z</published>
    <updated>2021-11-28T13:50:07.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><p>模版模式有助于去除重复代码，并满足了”DRY-不要重复自己“原则。</p><p>平时遇到数据处理的需求，我们需要执行一些常见的任务，如：</p><ol type="1"><li>去数据库取数，并将某些结果打印至控制台</li><li>去数据库取数，简单处理后，将结果保存到 csv 文件</li></ol><p>在这两个步骤中，有些子步骤是一样的，比如连接数据库，发出查询请求，执行 query 语句等。</p><p>可以将这部分功能集成到基类中，而其他特殊的功能可以放到子类中。</p><p>我们举例来说明，首先准备一个数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;CREATE TABLE sales&quot;</span></span><br><span class="line">    <span class="string">&quot;(&quot;</span></span><br><span class="line">    <span class="string">&quot;salespersion txt,&quot;</span></span><br><span class="line">    <span class="string">&quot;amt currency,&quot;</span></span><br><span class="line">    <span class="string">&quot;year integer,&quot;</span></span><br><span class="line">    <span class="string">&quot;model text,&quot;</span></span><br><span class="line">    <span class="string">&quot;new boolen&quot;</span></span><br><span class="line">    <span class="string">&quot;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入一些假数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete all rows from db before any new rows insert into table</span></span><br><span class="line">conn.execute(<span class="string">&quot;delete from sales&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert rows</span></span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Scott&#x27;, 1400, 2007, &#x27;Toyota&#x27;, &#x27;false&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Desmond&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Burney&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Austin&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cursor = conn.execute(<span class="string">&quot;select * from sales&quot;</span>)</span><br><span class="line">cursor.fetchall()</span><br></pre></td></tr></table></figure><p>查询结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&#x27;Scott&#x27;</span>, 1400, 2007, <span class="string">&#x27;Toyota&#x27;</span>, <span class="string">&#x27;false&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Desmond&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Burney&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Austin&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>现在我们设计一个 query 的模版类，想想它需要有哪些功能？</p><p>一个可能的基类是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_format</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;暴露给外部调用的方法，用来保证每个方法按照顺序执行。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.connect()</span><br><span class="line">        self.construct_query()</span><br><span class="line">        self.do_query()</span><br><span class="line">        self.format_results()</span><br><span class="line">        self.output_results()</span><br></pre></td></tr></table></figure><p>基类定义了我们需要有哪些功能，现在根据我们的需求，将其中一些可以共用的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个类提供了连接数据库、执行 query，格式化结果的功能</span></span><br><span class="line"><span class="string">       而对于构造 query、导出结果的功能，则抽象成接口交给子类去实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.conn.execute(self.query)  <span class="comment"># query 待 construct_query 实现</span></span><br><span class="line">        self.result = result.fetchall()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> self.result:</span><br><span class="line">            row = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> row]</span><br><span class="line">            output.append(row)</span><br><span class="line">        self.formated_result = <span class="string">&#x27;\n&#x27;</span>.join(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>现在实现我们自己的需求就很容易了，因为我们只需要将精力放在构造 query 和 输出结果这两个方法上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewVehiclesQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.query = <span class="string">&quot;select * from sales where new = &#x27;true&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.format_result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.do_query = <span class="string">&quot;select * from sales&quot;</span>  <span class="comment"># do what you want to do</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        file_name = <span class="string">&quot;output_file.csv&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span> (file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.formated_result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-单例模式及其实现原理</title>
    <link href="https://scottzhang.pro/article/18dbdeeb.html"/>
    <id>https://scottzhang.pro/article/18dbdeeb.html</id>
    <published>2021-11-18T13:25:00.000Z</published>
    <updated>2021-11-28T13:50:00.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="面向对象">面向对象</h1><h2 id="方法是怎么工作的">方法是怎么工作的？</h2><p>方法是绑定在类中的函数。你可以像下面这样声明一个 pizza 类以及它的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接访问类的 get_size 方法，会告诉你这个方法未绑定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 中不会提示</span></span><br><span class="line">Pizza.get_size</span><br><span class="line">&lt;unbound method Pizza.get_size&gt;</span><br></pre></td></tr></table></figure><p>我们无法调用这个方法，因为它没有绑定给任何 Pizza 的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 会直接报错</span></span><br><span class="line">Pizza.get_size()</span><br><span class="line">TypeError: unbound method get_size() must be called <span class="keyword">with</span> Pizza instance <span class="keyword">as</span> first argument (got nothing instead)</span><br></pre></td></tr></table></figure><p>它提示你第一个参数必须是 Pizza 的实例，那我们将它的 Pizza 的实例传进去看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 方法，同时传入实例，正常</span></span><br><span class="line">Pizza.get_size(Pizza(<span class="number">42</span>))</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>成功了! 不过这样使用也太麻烦了，好在 Python 会帮我们自动实现这些繁琐的工作。它会自动将 Pizza 中所有的方法绑定给任何 Pizza 的实例，当我们定义类方法的时候，其中写的 self 就等于类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = Pizza(<span class="number">42</span>).get_size</span><br><span class="line">m()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>如果你想知道方法被绑定给了那个对象，可以通过 <code>m.__self__</code> 来查看方法被绑定到了哪个对象。</p><h2 id="静态方法">静态方法</h2><p>静态方法不需要提供 self 或 cls 等参数，因为声明为静态方法后，它不会绑定给任何实例或者类, 这减少了类实例创建时候的开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mix_ingredients</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mix_ingredients(self.cheese, self.vegetables)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到两个实例的方法是不想等的，而静态方法的对于实例和类都是相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pizza().cook <span class="keyword">is</span> Pizza().cook</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza.mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza().mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="类方法">类方法</h2><p>类方法的概念和实例方法类似，不同的是它会被绑定给类本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    radius = <span class="number">42</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">cls</span>):</span>  <span class="comment"># cls 为类</span></span><br><span class="line">        <span class="keyword">return</span> cls.radius</span><br></pre></td></tr></table></figure><p>对于类方法来说，不管你通过类还是类的实例调用，它引用的也都是同一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pizza.get_radius</span><br><span class="line">&lt;bound method <span class="built_in">type</span>.get_radius of &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">type</span>.<span class="title">get_radius</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span> == <span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span>()</span></span><br><span class="line"><span class="class">42</span></span><br></pre></td></tr></table></figure><p>什么时候使用类方法呢？</p><p>第一种情况是工厂模式中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ingredients</span>):</span></span><br><span class="line">        self.ingredients = ingredients</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_fridge</span>(<span class="params">cls, fridge</span>):</span></span><br><span class="line">        <span class="comment"># 会返回一个新的类的实例，这允许你在类的实例被初始化之前做一些事情，</span></span><br><span class="line">        <span class="comment"># 它的初始化参数来自于fridge 的两个方法 get_cheese() + get_vegetables()</span></span><br><span class="line">        <span class="keyword">return</span> cls(fridge.get_cheese() + fridge.get_vegetables())</span><br></pre></td></tr></table></figure><p>这样写的好处是，你可以通过 <code>Pizza.from_fridge(...)</code> 的方式生成实例。</p><p>第二种情况是调用静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius, height</span>):</span></span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.height = height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span>(<span class="params">radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> math.pi * (radius ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_volume</span>(<span class="params">cls, height, radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> height * cls.compute_area(radius)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_volume</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.compute_volume(self.height, self.radius)</span><br></pre></td></tr></table></figure><p>这里的 cls 可以写成 Pizza, 但通过 cls 的方式避免将 Pizza 类写死在类中。</p><h2 id="抽象方法">抽象方法</h2><p>抽象方法（Abstract methods）是定义在基类中的，未实现的方法，它有点类似于 java 中的接口。它规定了一种方法的形式，任何继承基类的子类都必须实现此方法才可以工作。</p><p>一个简单的抽象方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>根据这个定义，任何继承了 Pizza 类的子类，都必须实现并重写 get_redius 方法，如果你忘记实现，实例调用 get_radius 就会出错。</p><p>如果你想要让这种错误发生的更早一点，比如发生在实例刚创建的时候，那么可以设置 Pizza 的 metaclass 为 abc 模块中的 ABCMeta。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="string">&quot;&quot;&quot;Method that should do something.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这里继承自 BasePizza 的类中，必须实现 get_radius 方法。BasePizza 对实现的细节并不关心，可以是类方法，实例方法，或者是静态方法。同样它也不关心返回的结果。</p><blockquote><p>参考: <a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">The definitive guide on how to use static, class or abstract methods in Python.</a></p></blockquote><h2 id="super-类">super 类</h2><p>是的，这标题没有错！super 是一个类，实例化之后得到的是一个代理的对象，而不是得到了父类，我们使用这个代理对象来调用父类或者兄弟类的方法。</p><p>但是当继承的父类比较多时，去哪个父类中调用方法就是个问题。对于子类的实例来说，可以通过 <code>obj.__mro__</code> 或者是 <code>cls.mro()</code> 访问父类的列表，python 通过它用管理类的继承顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问一个实例的 MRO 列表</span></span><br><span class="line"><span class="built_in">type</span>(B()).__mro__</span><br><span class="line">(__main__.B, __main__.A, <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>如果你提供一个 MRO 列表以及一个 MRO 中的类 C 给 super()，它将返回一个从 MRO 列表中 C 之后的类中查找到的方法的对象。</p><p>假设有个MRO列表为 [A, B, C, D, E, object]，执行 super(C, A).foo() 它只会从 C 之后查找，即: 只会在 D 或 E 或 object 中查找 foo 方法。</p><p>super() 它有几种使用方法：</p><ul><li>super() -&gt; same as super(<strong>class</strong>, <first argument>)</li><li>super(type) -&gt; unbound super object</li><li>super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</li><li>super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</li></ul><p>举个 super(type, obj) 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Base&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 super 的 func</span></span><br><span class="line"><span class="built_in">super</span>(A, C()).func()  <span class="comment"># 输出 &#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么是 B 呢？首先看一下 MRO 列表，Python 会根据第二个参数来计算 MRO，也就是这里提供的 C() 产生的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C.mro()</span><br><span class="line">[__main__.C, __main__.A, __main__.B, __main__.Base, <span class="built_in">object</span>]</span><br></pre></td></tr></table></figure><p>super 会计算出来的 mro 列表中，跳过参数A，从后面开始找父类的 func 方法，所以这里会执行 B 的 func。</p><p>然后再来说说 super(type, obj) 和 super(type, type2)的区别，他们的区别是第二个参数，super的第二个参数传递的是类，得到的是函数，super的第二个参数传递的是对象，得到的是绑定方法。</p><blockquote><p>理解绑定方法，有兴趣的再可以深入了解<a href="(https://docs.python.org/zh-cn/3.7/howto/descriptor.html)">描述器</a>的介绍。</p></blockquote><h1 id="单例模式">单例模式</h1><p>掌握了面向对象的知识和 super 的使用，就可以介绍单例模式了。单例模式是一种确保一个类只有一个实例会被创建出来的模式。</p><p>在其他语言中，单例通过构造函数私有化实现，Python 中没有私有构造函数，但可以通过类方法 <code>__new__</code> 实现。</p><p>我们知道 <code>__init__</code> 函数，但 <code>__init__</code> 是对创建好的实例初始化，而 <code>__new__</code> 才创建实例。</p><p>摘录网上一段关于这两个方法的解释：</p><ul><li>new (cls[, ...]) 是在一个对象实例化的时候所调用的第一个方法，在调用 init 初始化前，先调用new 。</li><li>new 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给 init 。</li><li>new 对当前类进行了实例化，并将实例返回，传给 init 的self。但是，执行了new ，并不一定会进入 init ，只有new 返回了，当前类cls的实例，当前类的 init 才会进入。</li><li>若new 没有正确返回当前类cls的实例，那 init 是不会被调用的，即使是父类的实例也不行，将没有 init 被调用。</li><li>new 方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径。</li></ul><blockquote><p>为 markdown 渲染方便，这里的 new 即 <code>__new__</code>, init 即 <code>__init__</code></p></blockquote><p>来看一个实现了这两个方法的类的调用顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Scott&quot;</span>, <span class="number">25</span>)</span><br><span class="line">__new__</span><br><span class="line">__init__</span><br></pre></td></tr></table></figure><p>可以看到先调用了 <code>__new__</code>, 才是 <code>__init__</code>，利用 new 的特性，我们可以用它来实现单例模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span>:</span></span><br><span class="line">    _singleton = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># super(OnlyOne, cls) 即上面的 super(type, type2) 模式</span></span><br><span class="line">        <span class="comment"># 这里相当于根据 cls 找 MRO 列表中，OnlyOne后的父类</span></span><br><span class="line">        <span class="comment"># 使用它的 __new__ 方法创建一个 cls（即本类）的实例</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._singleton:</span><br><span class="line">            cls._singleton = <span class="built_in">super</span>(</span><br><span class="line">                OnlyOne, cls</span><br><span class="line">            ).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._singleton</span><br></pre></td></tr></table></figure><p>我们首先检查这个单件的实例是否被创建出来，如果没有，我们用 super 函数来创建它。因此，每当我们调用 OnlyOne 的时候，总是可以得到完全相同的实例。</p><p>单例模式还有其他的实现，比如装饰器、MetaClass，感兴趣的可以看<a href="https://zhuanlan.zhihu.com/p/37534850">这篇</a>文章。</p><p>单例的这种思想，可以用在模块中。比如对于我们前面状态模式中的例子，状态模式中对于不同的状态，我们都有对应的类会初始化作为对状态的记录（如 First tag, Open tag）。</p><p>其实我们可以将状态设置为变量，这就避免了每次都初始化状态类产生一个新的实例，同时在每一个状态类内部，不再对解析器做引用，具体的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildNode</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remaining_str, parser</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        parser.state = child_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">child_node = ChildNode()</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>单例模式设计的内容还是挺多的，如装饰器、静态方法、类方法、继承、多态、MRO、装饰器、super 方法等。为了理解单例模式，我也是花了不少时间复习这块的内容，希望整理的这些笔记可以帮到你，如果要彻底理解这些内容，重要的还是要多去练习、多动手写代码。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/37534850">Python单例模式 Singleton 的N种实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/261579683">python魔法方法，详解 new 和 init 方法</a></li><li><a href="https://www.cnblogs.com/maple-shaw/p/9288018.html">你会使用super()吗？你确定你了解它吗？</a></li><li><a href="https://docs.python.org/zh-cn/3.7/howto/descriptor.html">实现描述器</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="OOP" scheme="https://scottzhang.pro/tags/OOP/"/>
    
    <category term="singleton" scheme="https://scottzhang.pro/tags/singleton/"/>
    
    <category term="super" scheme="https://scottzhang.pro/tags/super/"/>
    
    <category term="staticmethod" scheme="https://scottzhang.pro/tags/staticmethod/"/>
    
    <category term="classmethod" scheme="https://scottzhang.pro/tags/classmethod/"/>
    
    <category term="Abstract methods" scheme="https://scottzhang.pro/tags/Abstract-methods/"/>
    
    <category term="abc" scheme="https://scottzhang.pro/tags/abc/"/>
    
    <category term="MRO" scheme="https://scottzhang.pro/tags/MRO/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-策略与状态模式</title>
    <link href="https://scottzhang.pro/article/8a706eb8.html"/>
    <id>https://scottzhang.pro/article/8a706eb8.html</id>
    <published>2021-11-16T13:32:21.000Z</published>
    <updated>2021-11-28T13:49:55.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="策略模式">策略模式</h1><p>策略模式是一种面向对象编程中的抽象模式。针对同样的问题，它实现了不同的解决方案，你的代码可以在运行的时候自由选择最恰当的方案。</p><p>策略模式的一个应用是排序，比如你要实现一个排序算法，它可以自动选择排序方法来对输入的数组进行排序，排序的方法是自动选择的，而结果是不变的。</p><p>还有一个例子是设置电脑的墙纸，当你设置墙纸的时候，你的电脑会自动帮你设置很多事情：</p><ol type="1"><li>根据屏幕的分辨率，自动将图片缩放到合适的大小</li><li>自动处理图片与系统组件之间的缩放、虚化关系</li><li>图片与背景色的结合</li></ol><p>你可以定义不同的对象，它们接受的 input 是一样的（目标图片，屏幕分辨率），不管怎样，这些对象都都能达到设置屏幕壁纸的目的。</p><p>有人说我通过 if 判断也可以达到同样的目的，但是这意味着你需要将你的代码放到一个巨大的方法中，随着新的策略的增加，你的函数将变得非常笨重。</p><p>这里略过策略模式的实例。</p><h1 id="状态模式">状态模式</h1><p>状态模式的目的是实现“状态切换”，对象的状态可以被外面知道，并且可能会被一些活动改变。来一个例子，需求是要对一个 <a href="https://www.w3.org/XML/">xml 文件</a>进行解析，一个简单的 xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>welcome to scott&#x27;s blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想把这样的文件解析出来，结果是我可以通过 node.attr 的方式访问 xml 文件的内容。比如 xml_file.body 作为一个节点。该节点有一个属性叫子节点，我可以通过 xml_file.body.children 的方式拿到，对于 title 中的内容，我已通过 xml_file.body.title.text 的方式拿到。</p><p>首先需要一个节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点类，记录节点的名字，文本，节点之间有上下级关系，所以它</span></span><br><span class="line"><span class="string">       还需要一个指向父节点的指针。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tagname, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.parent=parent</span><br><span class="line">        self.tagname = tagname</span><br><span class="line">        <span class="comment"># text 和 children 都由其他组件操作</span></span><br><span class="line">        self.children = []</span><br><span class="line">        self.text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.text:</span><br><span class="line">            <span class="keyword">return</span> self.tagname + <span class="string">&#x27;:&#x27;</span> + self.text</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.tagname</span><br></pre></td></tr></table></figure><p>有了节点后，我们还需要一个解析器，解析器会一层一层的解析字符串，我们可以定义解析器有几种状态，即处于：</p><ul><li>开始节点</li><li>子节点</li><li>结束节点</li></ul><p>如何根据解析器的状态判断是否还可以深入一步呢？可以这么定义：</p><ul><li>开始节点</li><li>子节点</li><li>打开的节点</li><li>结束节点</li><li>文本节点（最底层无子节点的节点）</li></ul><p>来看代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parser 是一个解析器。它会负责去切换状态，下图的状态之间会互相转换。</span></span><br><span class="line"><span class="string">       第一个状态是 First Tag，它永远将切换至子节点，再由子节点来决定切换到其他哪个状态。</span></span><br><span class="line"><span class="string">       每一个状态都会用自己的方法处理收到的剩余字符，然后将状态再设置为 Children Node，告诉解析器来处理剩下的部分。</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">        |                     .-------------.                      |</span></span><br><span class="line"><span class="string">        |                    (   First Tag   )                     |</span></span><br><span class="line"><span class="string">        |                     `-------------&#x27;                      |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                     .------v------.                      |</span></span><br><span class="line"><span class="string">        |         +---------&gt;( Children Node )&lt;----------+         |</span></span><br><span class="line"><span class="string">        |         |           `-------------&#x27;            |         |</span></span><br><span class="line"><span class="string">        |         |                  ^                   |         |</span></span><br><span class="line"><span class="string">        |         v                  v                   v         |</span></span><br><span class="line"><span class="string">        |  .-------------.    .-------------.     .-------------.  |</span></span><br><span class="line"><span class="string">        | (   Open tag    )  (  Closed tag   )   (     Text      ) |</span></span><br><span class="line"><span class="string">        |  `-------------&#x27;    `-------------&#x27;     `-------------&#x27;  |</span></span><br><span class="line"><span class="string">        |                                                          |</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parse_str</span>):</span></span><br><span class="line">        self.parse_str = parse_str</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.current_node = <span class="literal">None</span></span><br><span class="line">        self.state = FirstTag()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str</span>):</span></span><br><span class="line">        remainning = self.state.process(remain_str, self)</span><br><span class="line">        <span class="keyword">if</span> remainning:</span><br><span class="line">            self.process(remainning)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.process(self.parse_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理剩余的字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str (string): 剩余需要解析的字符</span></span><br><span class="line"><span class="string">            parser (Parser): parser 即上面定义的的 Parser，它会被闯进来修改它的属性，如current_node, root, state</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 剩余需要解析的字符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line"></span><br><span class="line">        root = Node(tag_name)</span><br><span class="line">        parser.root = parser.current_node = root</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;同样只需要一个 process 方法来处理字符串。</span></span><br><span class="line"><span class="string">           作为 ChildrenNode，它需要根据字符来判断需要使用什么样的类状态器，</span></span><br><span class="line"><span class="string">           类状态器的 process 方法将会完成对剩余字符的处理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str ([type]): [description]</span></span><br><span class="line"><span class="string">            parser ([type]): [description]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        striped = remain_str.strip()</span><br><span class="line">        <span class="keyword">if</span> striped.startswith(<span class="string">&#x27;&lt;&#x27;</span>):</span><br><span class="line">            parser.state = OpenTag()</span><br><span class="line">        <span class="keyword">elif</span> striped.startswith(<span class="string">&#x27;&gt;&#x27;</span>):</span><br><span class="line">            parser.state = CloseTag()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parser.state = TextNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line">        <span class="comment"># parser.current_node 未被更改还是上一层节点，将其设为父节点</span></span><br><span class="line">        node = Node(tag_name, parser.current_node)</span><br><span class="line">        parser.current_node.children.append(node)</span><br><span class="line">        parser.current_node = node</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        <span class="comment"># assert 断言中</span></span><br><span class="line">        <span class="comment"># 第一个确保 &lt; 后是/，如 &lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 第二个确保以同一个tag名开始结束，如 &lt;h1&gt;Hi&lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 以及因当前是结束tag，重置parser当前节点为其父节点</span></span><br><span class="line">        <span class="keyword">assert</span> remain_str[i_start_tag+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        tagname = remain_str[i_end_tag+<span class="number">2</span>:i_end_tag]</span><br><span class="line">        <span class="keyword">assert</span> tagname == parser.current_node.tagname</span><br><span class="line">        parser.current_node = parser.current_node.parent</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:].strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">         i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">         text = remain_str[:i_start_tag]</span><br><span class="line">         parser.current_node.text = text</span><br><span class="line">         parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> remain_str[i_start_tag:]</span><br></pre></td></tr></table></figure><p>启动代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.xml&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        p = Parser(file.read())</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">        nodes = [p.root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            nodes = node.children + nodes</span><br></pre></td></tr></table></figure><p>将会产生下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">title:welcome to scott&#x27;s blog</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
