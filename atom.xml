<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2022-05-17T01:40:59.584Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法题: 两数之和与三数之和</title>
    <link href="https://scottzhang.pro/article/347c867a.html"/>
    <id>https://scottzhang.pro/article/347c867a.html</id>
    <published>2022-05-16T14:51:09.000Z</published>
    <updated>2022-05-17T01:40:59.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/">📌</a> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p></blockquote><span id="more"></span><h3 id="两数之和">两数之和</h3><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>():</span></span><br><span class="line">    hashtable = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">            <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">        hashtable[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="三数之和">三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><a href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">算法流程</a>：</p><ol type="1"><li>特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。</li><li>对数组进行排序。</li><li>遍历排序后数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 若 nums[i] &gt; 0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</span><br><span class="line">- 对于重复元素：跳过，避免出现重复解</span><br><span class="line">- 令左指针 L=i+1，右指针 R=n−1，当 L&lt;R 时，执行循环：</span><br><span class="line">    - 当 nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</span><br><span class="line">    - 若和大于 0，说明 nums[R] 太大，R 左移</span><br><span class="line">    - 若和小于 0，说明 nums[L] 太小，L 右移</span><br></pre></td></tr></table></figure><p>简单演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-1, 0, 1, 2, -1, -4]</span><br><span class="line">[ I, L, 1, 2, -1,  R]</span><br><span class="line">[ I, 0, L, 2, -1,  R]</span><br><span class="line">[ I, 0, L, 2,  R, -4]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># null, 长度 &lt; 3, 返回 []</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> nums <span class="keyword">or</span> n &lt; <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 排序方便操作</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 连续两个重复值，前面已经尝试过所有组合，所以跳过    </span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># L 从 i+1 开始，R 从数组长度 -1 开始</span></span><br><span class="line">        L = i+<span class="number">1</span></span><br><span class="line">        R = n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(L &lt; R):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[L]+nums[R] == <span class="number">0</span>):</span><br><span class="line">                res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                <span class="keyword">while</span>(L &lt; R <span class="keyword">and</span> nums[L] == nums[L+<span class="number">1</span>]):</span><br><span class="line">                    L = L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span>(L &lt; R <span class="keyword">and</span> nums[R] == nums[R-<span class="number">1</span>]):</span><br><span class="line">                    R = R-<span class="number">1</span></span><br><span class="line">                L = L+<span class="number">1</span></span><br><span class="line">                R = R-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span>(nums[i]+nums[L]+nums[R] &gt; <span class="number">0</span>):</span><br><span class="line">                R = R-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = L+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">threeSum(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle/&quot;&gt;📌&lt;/a&gt; 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 字母异位词分组</title>
    <link href="https://scottzhang.pro/article/2239a89.html"/>
    <id>https://scottzhang.pro/article/2239a89.html</id>
    <published>2022-05-16T14:50:37.000Z</published>
    <updated>2022-05-17T01:36:29.592Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/group-anagrams/">📌</a> 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。Leetcode</p></blockquote><span id="more"></span><h3 id="思考">思考</h3><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>使用题目"有效的字母异位词"思路判断异位词。</p><p>对数组中的每一个元素进行组合执行上面的判断， 需要将所有的异位词放到一个数组，所以需要构建另外一个数组。</p><p>如果找到了一个新的形式，需要将新的放到这个数组，比对的对象可以是第一个，因为所有异位词之间应该都是相等的关系， 那么可以使用第一个遇到的词语作为键和值，后续找到的新的放到值中。</p><h3 id="解法">解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">strs: <span class="built_in">list</span></span>):</span></span><br><span class="line">    angram_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">            is_angram = isAnagramCounter(strs[i], strs[j])</span><br><span class="line">            <span class="keyword">if</span> is_angram:</span><br><span class="line">                <span class="keyword">if</span> strs[i] <span class="keyword">in</span> angram_dict:</span><br><span class="line">                    angram_dict[strs[i]].append(strs[j])</span><br><span class="line">                <span class="keyword">elif</span> strs[i] <span class="keyword">in</span> angram_dict.values():</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    angram_dict[strs[i]] = []</span><br><span class="line">                    angram_dict[strs[i]].append(strs[j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> angram_dict</span><br><span class="line"></span><br><span class="line">groupAnagrams(strs)</span><br></pre></td></tr></table></figure><p>上面的双重循环增加了很多复杂度，可以直接借鉴排序的优秀解法，其中 tuple(sorted(w)) 也可以换成 ''.join(sorted(w))。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记住 d.get(key, []) + [w]</span></span><br><span class="line">strs = [<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>,<span class="string">&quot;tan&quot;</span>,<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;bat&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">strs</span>):</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">sorted</span>(strs):</span><br><span class="line">        key = <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(w))</span><br><span class="line">        d[key] = d.get(key, []) + [w]</span><br><span class="line">    <span class="keyword">return</span> d.values()</span><br><span class="line"></span><br><span class="line">groupAnagrams(strs)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/group-anagrams/&quot;&gt;📌&lt;/a&gt; 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。Leetcode&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字典" scheme="https://scottzhang.pro/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 有效的字母异位词</title>
    <link href="https://scottzhang.pro/article/f2f7dffe.html"/>
    <id>https://scottzhang.pro/article/f2f7dffe.html</id>
    <published>2022-05-16T14:50:24.000Z</published>
    <updated>2022-05-17T01:36:39.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/valid-anagram/">📌</a> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p></blockquote><span id="more"></span><p>直接排序，异位词的顺序不同出现的次数一样，所以使用 sort 方法排序后的值应该相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagramSort</span>(<span class="params">s, t</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    s_sorted = <span class="built_in">sorted</span>(s)</span><br><span class="line">    t_sorted = <span class="built_in">sorted</span>(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s_sorted == t_sorted:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">isAnagramSort(a, b)</span><br></pre></td></tr></table></figure><p>使用 collection 中的 Counter。</p><p>Counter 支持比较运算符 ==, !=, &lt;, &lt;=, &gt;, &gt;=.</p><p>需要注意对于个数为 0的，不算入比较的范围，如 Counter(a=1) == Counter(a=1, b=0) 返回 true.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagramCounter</span>(<span class="params">s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">return</span> collections.Counter(s) == collections.Counter(t)</span><br></pre></td></tr></table></figure><p>链接：</p><ul><li><a href="https://leetcode.com/problems/valid-anagram/">英文站</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-anagram/&quot;&gt;📌&lt;/a&gt; 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="collections" scheme="https://scottzhang.pro/tags/collections/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 用队列实现栈</title>
    <link href="https://scottzhang.pro/article/5a9968.html"/>
    <id>https://scottzhang.pro/article/5a9968.html</id>
    <published>2022-05-16T14:45:32.000Z</published>
    <updated>2022-05-17T01:37:20.384Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">📌</a> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）</p></blockquote><span id="more"></span><p>实现 MyStack 类：</p><ul><li>void push(int x) 将元素 x 压入栈顶。</li><li>int pop() 移除并返回栈顶元素。</li><li>int top() 返回栈顶元素。</li><li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。  </li></ul><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue1 = []</span><br><span class="line">        self.queue2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.queue1.append(x)</span><br><span class="line">        self.queue2 = <span class="built_in">list</span>(<span class="built_in">reversed</span>(self.queue1))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue2.pop()</span><br><span class="line">        <span class="keyword">del</span> self.queue1[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue1) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mystack = MyStack()</span><br><span class="line">mystack.push(<span class="number">1</span>)</span><br><span class="line">mystack.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">mystack.queue2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-stack-using-queues/&quot;&gt;📌&lt;/a&gt; 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://scottzhang.pro/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 最小栈问题</title>
    <link href="https://scottzhang.pro/article/302a7493.html"/>
    <id>https://scottzhang.pro/article/302a7493.html</id>
    <published>2022-05-16T14:45:17.000Z</published>
    <updated>2022-05-17T01:36:36.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/min-stack/">📌</a> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p></blockquote><span id="more"></span><p>实现 MinStack 类:</p><ul><li>MinStack() 初始化堆栈对象。</li><li>void push(int val) 将元素val推入堆栈。</li><li>void pop() 删除堆栈顶部的元素。</li><li>int top() 获取堆栈顶部的元素。</li><li>int getMin() 获取堆栈中的最小元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack2Arr</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;内部使用了两个栈（一个辅助栈）&quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/min-stack/&quot;&gt;📌&lt;/a&gt; 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 有效的括号</title>
    <link href="https://scottzhang.pro/article/6d4e3bea.html"/>
    <id>https://scottzhang.pro/article/6d4e3bea.html</id>
    <published>2022-05-16T14:45:03.000Z</published>
    <updated>2022-05-17T01:36:42.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/valid-parentheses/">📌</a> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p></blockquote><span id="more"></span><p>注意：有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。</p><p>左括号必须以正确的顺序闭合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;注意理解栈的原理&quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="built_in">dict</span> = &#123;<span class="string">&quot;]&quot;</span>:<span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>:<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;)&quot;</span>:<span class="string">&quot;(&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># 查 value，如果出现左括号，将其放到栈中</span></span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> <span class="built_in">dict</span>.values():</span><br><span class="line">            stack.append(char)</span><br><span class="line">        <span class="comment"># 如果是出现了右括号、若栈是空的或者</span></span><br><span class="line">        <span class="comment"># 根据右边括号找到对应的左括号不等于栈顶元素，返回 False</span></span><br><span class="line">        <span class="keyword">elif</span> char <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">            <span class="keyword">if</span> stack == [] <span class="keyword">or</span> <span class="built_in">dict</span>[char] != stack.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 其他情况，返回 False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> stack == []</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/valid-parentheses/&quot;&gt;📌&lt;/a&gt; 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 判断环形链表</title>
    <link href="https://scottzhang.pro/article/50c0087b.html"/>
    <id>https://scottzhang.pro/article/50c0087b.html</id>
    <published>2022-05-16T14:40:24.000Z</published>
    <updated>2022-05-17T01:36:24.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/">📌</a> 给你一个链表的头节点 head ，判断链表中是否有环。</p></blockquote><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_cycle_set</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用集合或者哈希表，记录访问过的节点，若再次出现则有环</span></span><br><span class="line"><span class="string">       1. 时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</span></span><br><span class="line"><span class="string">       2. 空间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seen.add(head)</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_cycle_fast_slow_pointer</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用两个指针，一快一慢遍历链表，如果链表存在环，则最终快指针肯定会与慢指针相遇</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果头节点为空或者头结点没有下一个结点，则不存在环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义两个快慢指针遍历，这里快指针比慢指针先出发</span></span><br><span class="line">    <span class="comment"># 不是同一个位置出发，这么写的原因是 while 的条件需要一开始</span></span><br><span class="line">    <span class="comment"># 处于不满足的情况</span></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        <span class="comment"># 如果 fast 为空或没有下一个结点，说明遍历到了链表尾部</span></span><br><span class="line">        <span class="comment"># 说明不存在环，有环的话会循环到前面的结点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动快慢指针</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># while 后的条件为 True，即 slow == fast, 说明存在环</span></span><br><span class="line">    <span class="comment"># 此时 slow 指向的结点 == fast 指向的结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>链表的访问是从第一个结点开始的，不要用数组的思维去理解链表</p><p>在链表操作中，通常会创建一个伪结点，又称 dummy 结点，使用 dummy 结点的好处是 1. 在链表初始化的时候，没有合适的结点可以使用，用一个伪结点开始初始化比较方便，但需要注意在返回的时候需要返回 dummy.next. 2. 可以使用 <code>while node</code> 或者是 <code>if node</code> ，来判断某个结点是否有 next</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle/&quot;&gt;📌&lt;/a&gt; 给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="链表" scheme="https://scottzhang.pro/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 合并 K 个排序链表</title>
    <link href="https://scottzhang.pro/article/6b8b3431.html"/>
    <id>https://scottzhang.pro/article/6b8b3431.html</id>
    <published>2022-05-16T14:38:39.000Z</published>
    <updated>2022-05-17T01:36:26.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">📌</a> 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><span id="more"></span><h3 id="合并-k-个排序链表">合并 K 个排序链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</span><br><span class="line">输出：[1, 1, 2, 3, 4, 4, 5, 6]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;顺序合并，效率不是很高&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">        d = c = ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                c.<span class="built_in">next</span>, l1 = l1, l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c.<span class="built_in">next</span>, l2 = l2, l2.<span class="built_in">next</span></span><br><span class="line">            c = c.<span class="built_in">next</span></span><br><span class="line">        c.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> d.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        ans = merge(ans, i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">mergeKLists([l1, l2])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    p = dummy</span><br><span class="line">    head = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">        <span class="keyword">if</span> lists[i]:</span><br><span class="line">            heapq.heappush(head, (lists[i].val, i))</span><br><span class="line">            lists[i] = lists[i].<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        val, idx = heapq.heappop(head)</span><br><span class="line">        p.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> lists[idx]:</span><br><span class="line">            heapq.heappush(head, (lists[idx].val, idx))</span><br><span class="line">            lists[idx] = lists[idx].<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-k-sorted-lists/&quot;&gt;📌&lt;/a&gt; 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="链表" scheme="https://scottzhang.pro/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 无重复字符串的最长子串</title>
    <link href="https://scottzhang.pro/article/aaafc94b.html"/>
    <id>https://scottzhang.pro/article/aaafc94b.html</id>
    <published>2022-05-16T14:24:34.000Z</published>
    <updated>2022-05-17T01:36:33.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">📌</a> 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。</p></blockquote><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    output = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        If s[r] not in seen, we can keep increasing the window size by moving right pointer</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s[r] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            output = <span class="built_in">max</span>(output, r-l+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># There are two cases if s[r] in seen:</span></span><br><span class="line">        <span class="comment"># case1: s[r] is inside the current window, we need to change the window by moving left pointer to seen[s[r]] + 1.</span></span><br><span class="line">        <span class="comment"># case2: s[r] is not inside the current window, we can keep increase the window</span></span><br><span class="line">            <span class="keyword">if</span> seen[s[r]] &lt; l:</span><br><span class="line">                output = <span class="built_in">max</span>(output,r-l+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = seen[s[r]] + <span class="number">1</span></span><br><span class="line">        seen[s[r]] = r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lengthOfLongestSubstring(<span class="string">&quot;pwwkew&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-substring-without-repeating-characters/&quot;&gt;📌&lt;/a&gt; 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 盛水最多的容器</title>
    <link href="https://scottzhang.pro/article/45859c42.html"/>
    <id>https://scottzhang.pro/article/45859c42.html</id>
    <published>2022-05-16T14:20:11.000Z</published>
    <updated>2022-05-17T01:37:08.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">📌</a> 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p></blockquote><span id="more"></span><p>说明：你不能倾斜容器。</p><p>双指针往中间靠拢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_area_towards_center</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数组：一开始就将 left bar 和 right bar 设置到最左和最右</span></span><br><span class="line"><span class="string">    慢慢收敛，因为宽度已是最大，只需要控制高度即可</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        area = <span class="built_in">min</span>(arr[l], arr[r]) * (r - l)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, area)</span><br><span class="line">        <span class="keyword">if</span> arr[l] &lt;= arr[r]:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">max_area_towards_center([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>使用 for 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_area_2_loop</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数组：枚举所有元素，双重 for 循环，找出 area 最大的</span></span><br><span class="line"><span class="string">    缺点，时间复杂度比较高</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    area_max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            area = (j-i) * <span class="built_in">min</span>(arr[i], arr[j])</span><br><span class="line">            area_max = <span class="built_in">max</span>(area_max, area)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area_max</span><br><span class="line"></span><br><span class="line">max_area_2_loop([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><ul><li>🇺🇸 <a href="https://leetcode.com/problems/container-with-most-water/">英文站</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;📌&lt;/a&gt; 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法题：移动0</title>
    <link href="https://scottzhang.pro/article/22174669.html"/>
    <id>https://scottzhang.pro/article/22174669.html</id>
    <published>2022-05-16T14:17:58.000Z</published>
    <updated>2022-05-17T01:37:15.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/move-zeroes/">📌</a> 给定一个数组，将所有其中的 0，移动到末尾。Leetcode</p></blockquote><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">my_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_zero</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;数组：利用快慢指针交换值.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    zero_idx = <span class="number">0</span>  <span class="comment"># 慢指针，其数值表示0所在的位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 要做的操作与慢指针移动的条件</span></span><br><span class="line">        <span class="comment"># 若不满足慢指针移动条件，慢指针停留不动，快指针继续移动</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] != <span class="number">0</span>:</span><br><span class="line">            arr[i], arr[zero_idx] = arr[zero_idx], arr[i]</span><br><span class="line">            zero_idx += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(f&quot;&#123;arr&#125;, i:&#123;i&#125;, zero_idx:&#123;zero_idx&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">move_zero(my_arr)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/move-zeroes/&quot;&gt;📌&lt;/a&gt; 给定一个数组，将所有其中的 0，移动到末尾。Leetcode&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程与生成器</title>
    <link href="https://scottzhang.pro/article/d7273f24.html"/>
    <id>https://scottzhang.pro/article/d7273f24.html</id>
    <published>2022-05-14T04:41:02.000Z</published>
    <updated>2022-05-15T13:50:32.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的出现，就是为了解决回调编写难的问题。</p></blockquote><span id="more"></span><h1 id="协程">协程</h1><p>比如，回调模式编码复杂度高、同步编程的并发性不高，多线程编程需要线程间同步，有 Lock 的限制。</p><p>那么能不能采用同步的方式去编写异步的代码呢？</p><p>一个办法是使用单线程去切换任务，这样就不需要操作系统切换线程，也不需要锁，而且实现了并发性很高（但需要程序员自己去调度任务）类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_part1</span>(<span class="params">arg</span>):</span></span><br><span class="line">    <span class="comment"># job B 为 IO 操作，会阻塞</span></span><br><span class="line">    <span class="comment"># 我们希望在执行到 A 的时候，可以跳出去</span></span><br><span class="line">    <span class="comment"># 继续执行耗费 CPU 的部分</span></span><br><span class="line">    a = do_job_A(arg)</span><br><span class="line">    b = do_job_B(a)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_all_job</span>():</span></span><br><span class="line">    p1 = do_part1(<span class="number">1</span>)</span><br><span class="line">    result = do_part2(p1)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>说白了，我们需要一个这样的函数，即它可以暂停，并且在适当的时候恢复。</p><h1 id="生成器进阶">生成器进阶</h1><h2 id="send">send</h2><p>生成器不只是可以产出值，还可以接收值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    addr = <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">addr = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="comment"># send 的值，将函数赋值给内部的 addr</span></span><br><span class="line">after_send = g.send(<span class="string">&quot;apple.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里第一次需要调用 next 方法，否则会报 TypeError, 如果不调用 next，也可以在开始的时候 send 一个 None.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    addr = <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">g.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># send 的值，将函数赋值给内部的 addr</span></span><br><span class="line">after_send = g.send(<span class="string">&quot;apple.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是因为在调用 send 发送非 None 值之前，我们必须启动一次生成器。</p><p>有两种方式：</p><ol type="1"><li>使用 next</li><li>或调用生成器对象的 send 方法传入 None 值</li></ol><p>另外生成器，还有一个 close 方法，可以将生成器关闭。</p><p>如果一个生成器会 yield 三次，如果在第一次的时候 close 了，那么在第二次的时候调用 next 就会报 GeneratorExit 错误。</p><h2 id="throw">throw</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="comment"># 为什么不是 try microsoft</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Pass Test Error&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;scottzhang.pro&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">g.throw(Exception, <span class="string">&quot;TestError&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure><h2 id="yield-from">yield from</h2><blockquote><p>Python 3.3 新语法。</p></blockquote><p>yield from 可以理解为 yiled 的简化，比如下面这两种写法差不多是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> v1 <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">for</span> v2 <span class="keyword">in</span> v1:</span><br><span class="line">            <span class="keyword">yield</span> v2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> v1 <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> v1</span><br></pre></td></tr></table></figure><p>yield from 还有另外一个功能，先看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_gen</span>(<span class="params">gen</span>):</span></span><br><span class="line">    <span class="comment"># gen 是一个可迭代对象</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> gen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    g = my_gen()</span><br><span class="line">    g.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这里有几个概念需要区分清楚：</p><ul><li>main 叫做调用者</li><li>my_gen 叫做委托生成器</li><li>gen 叫做子生成器</li></ul><p><code>yield from</code> 的另外一个特性就是能在调用者和子生成器之间建立一个通道，而且是双向的。</p><p>一个基于上面的模式编程的例子，要求是统计一个字典中值的个数， 并将值重新赋值为(num, [values]) 的形式，即值变为个数与值的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果字典</span></span><br><span class="line">final_result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sales_sum</span>(<span class="params">pro_name</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(pro_name+<span class="string">&quot;销量: &quot;</span>, x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">        nums.append(x)</span><br><span class="line">    <span class="keyword">return</span> total, nums</span><br><span class="line"></span><br><span class="line"><span class="comment"># 委托生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middle</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        final_result[key] = <span class="keyword">yield</span> <span class="keyword">from</span> sales_sum(key)</span><br><span class="line">        <span class="built_in">print</span>(key + <span class="string">&quot;销量统计完成！！.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 产品销量字典</span></span><br><span class="line">    data_sets = &#123;</span><br><span class="line">        <span class="string">&quot;产品A&quot;</span>: [<span class="number">1200</span>, <span class="number">1500</span>, <span class="number">3000</span>],</span><br><span class="line">        <span class="string">&quot;产品B&quot;</span>: [<span class="number">28</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">108</span> ],</span><br><span class="line">        <span class="string">&quot;产品C&quot;</span>: [<span class="number">280</span>,<span class="number">560</span>,<span class="number">778</span>,<span class="number">70</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, data_set <span class="keyword">in</span> data_sets.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start key:&quot;</span>, key)</span><br><span class="line">        m = middle(key)</span><br><span class="line">        m.send(<span class="literal">None</span>) <span class="comment"># 预激 middle 协程</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> data_set:</span><br><span class="line">            m.send(value)   <span class="comment"># 给协程传递每一组的值</span></span><br><span class="line">        m.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;final_result:&quot;</span>, final_result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>可能你会有疑问为什么这里不把子生成器和委托生成器合二为一，这样直接使用 yield 也可以实现。</p><p>但这样你就得在生成器快结束的时候，自己处理生成器对象的异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">my_gen.send(last_value)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        my_gen.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        result = e.value</span><br></pre></td></tr></table></figure><p>而 yield from 会帮我们自动处理这些逻辑，但还不止这些。</p><p>我们来看下 yield from 背后源码的原理, 看源码之前，我们先认识下所用到的变量。</p><blockquote><p>PEP380</p></blockquote><ul><li>_i：子生成器，同时也是一个迭代器</li><li>_y：子生成器生产的值</li><li>_r：yield from 表达式最终的值</li><li>_s：调用方通过send()发送的值</li><li>_e：异常对象</li></ul><p>摘录一段简单的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_i = <span class="built_in">iter</span>(EXPR)      <span class="comment"># EXPR是一个可迭代对象，_i其实是子生成器；</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = <span class="built_in">next</span>(_i)   <span class="comment"># 预激子生成器，把产出的第一个值存在_y中；</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value   <span class="comment"># 如果抛出了`StopIteration`异常，那么就将异常对象的`value`属性保存到_r，这是最简单的情况的返回值；</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:    <span class="comment"># 尝试执行这个循环，委托生成器会阻塞；</span></span><br><span class="line">        _s = <span class="keyword">yield</span> _y   <span class="comment"># 生产子生成器的值，等待调用方`send()`值，发送过来的值将保存在_s中；</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _y = _i.send(_s)    <span class="comment"># 转发_s，并且尝试向下执行；</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">            _r = _e.value       <span class="comment"># 如果子生成器抛出异常，那么就获取异常对象的`value`属性存到_r，退出循环，恢复委托生成器的运行；</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">RESULT = _r     <span class="comment"># _r就是整个yield from表达式返回的值。</span></span><br></pre></td></tr></table></figure><p>此外，yield from 还需要处理这些逻辑：</p><ol type="1"><li>子生成器可能只是一个迭代器，并不是一个作为协程的生成器，所以它不支持.throw()和.close()方法；</li><li>如果子生成器支持.throw()和.close()方法，但是在子生成器内部，这两个方法都会抛出异常；</li><li>调用方让子生成器自己抛出异常</li><li>当调用方使用next()或者.send(None)时，都要在子生成器上调用next()函数，当调用方使用.send()发送非 None 值时，才调用子生成器的.send()方法；</li></ol><p>总结一下：</p><p>总结一下关键点：</p><ol type="1"><li>子生成器生产的值，都是直接传给调用方的；调用方通过.send()发送的值都是直接传递给子生成器的；如果发送的是 None，会调用子生成器的__next__()方法，如果不是 None，会调用子生成器的.send()方法；</li><li>子生成器退出的时候，最后的return EXPR，会触发一个StopIteration(EXPR)异常；</li><li>yield from表达式的值，是子生成器终止时，传递给StopIteration异常的第一个参数；</li><li>如果调用的时候出现StopIteration异常，委托生成器会恢复运行，同时其他的异常会向上 "冒泡"；</li><li>传入委托生成器的异常里，除了GeneratorExit之外，其他的所有异常全部传递给子生成器的.throw()方法；如果调用.throw()的时候出现了StopIteration异常，那么就恢复委托生成器的运行，其他的异常全部向上 "冒泡"；</li><li>如果在委托生成器上调用.close()或传入GeneratorExit异常，会调用子生成器的.close()方法，没有的话就不调用。如果在调用.close()的时候抛出了异常，那么就向上 "冒泡"，否则的话委托生成器会抛出GeneratorExit异常。</li></ol><h1 id="async-和-await">async 和 await</h1><p>Python 3.5+ 后，引入了 async 和 await 两个关键字，定义了原生的协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Fake Result&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="comment"># 将任务交给子协程完成</span></span><br><span class="line">    <span class="comment"># await 后面跟的是 collections.Awaittable 对象</span></span><br><span class="line">    <span class="comment"># 也可以实现 __await__ 魔法方法来支持</span></span><br><span class="line">    <span class="comment"># await 可以理解为 yield from</span></span><br><span class="line">    result = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    coro = download_url(<span class="string">&quot;www.scottzhang.pro&quot;</span>)</span><br><span class="line">    coro.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>注意生成器是不可以直接传给 await，下面的代码会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Fake Result&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    result = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    coro = download_url(<span class="string">&quot;www.scottzhang.pro&quot;</span>)</span><br><span class="line">    coro.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>解决办法是，加一个装饰器, 这个装饰器会将这个函数实现 <code>__await__</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="meta">@types.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Fake Result&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;协程的出现，就是为了解决回调编写难的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="协程" scheme="https://scottzhang.pro/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="生成器" scheme="https://scottzhang.pro/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程和异步IO</title>
    <link href="https://scottzhang.pro/article/4bf14380.html"/>
    <id>https://scottzhang.pro/article/4bf14380.html</id>
    <published>2022-05-11T03:40:41.000Z</published>
    <updated>2022-05-14T04:42:10.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍了一些异步IO的基本概念与 Select 即回调函数的使用。</p></blockquote><span id="more"></span><h1 id="一些基本概念">一些基本概念</h1><p>在学习协程之前，建议先复习一下 socket 编程和多线程的知识。</p><p><strong>并发与并行</strong></p><p>并发：一个时间段、有几个程序在同一个 CPU 上运行，任意时刻只有一个程序在CPU上运行。</p><p>并行：任意时刻，有多个程序运行在多个 CPU 上。</p><p><strong>同步和异步</strong></p><blockquote><p>是一种消息通信机制，把操作看成消息在不同线程、协程中发送，然后得到 Future进行后续操作。</p></blockquote><p>同步：代码调用IO操作时，必须等待IO操作完成菜返回的调用方式。</p><p>异步：代码调用IO操作时，不必等操作完成就返回的调用方式。</p><p><strong>阻塞和非阻塞</strong></p><blockquote><p>是一种函数调用的机制。</p></blockquote><p>阻塞：调用函数是当前线程被挂起。</p><p>非阻塞：调用函数时，当前线程不会被挂起，而是立即返回。</p><h1 id="什么是-c10k-问题">什么是 C10K 问题？</h1><p><a href="https://en.wikipedia.org/wiki/C10k_problem">C10K</a>，一个1999 年提出来的技术挑战，即我们如何在1颗 1GHz CPU，2G 内存，1gbps 网络环境下，让单台服务器同时为1万个客户端提供FTP服务。</p><h1 id="io-多路复用">IO 多路复用</h1><p>Unix 下的五种 I/O 模型:</p><ul><li>阻塞 I/O</li><li>非阻塞 I/O</li><li>多路复用 I/O</li><li>信号驱动是 I/O</li><li>异步I/O (POSIX 的 aio_系列函数)</li></ul><p>以 socket 中的连接建立为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 阻塞 I/O</span></span><br><span class="line"><span class="comment"># 基础的用的最多的，socket.connect 连接成功后再返回，这时候产生阻塞</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((host, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---  非阻塞 I/O</span></span><br><span class="line"><span class="comment"># 发出 socket.connect 后马上返回（不阻塞，但没有结果）</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.setblocking(<span class="literal">False</span>)</span><br><span class="line">client.connect((host, <span class="number">80</span>))</span><br><span class="line"><span class="comment"># 随后不停询问服务端连接是否，成功后才可以发送消息</span></span><br><span class="line"><span class="comment"># 不过此时，也可以直接就开始干别的事情</span></span><br><span class="line"><span class="keyword">while</span> (client connected):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">client.send(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---多路复用 I/O</span></span><br><span class="line"><span class="comment"># 调用操作系统的 select 方法，操作系统会告诉我们哪些 socket 的端口</span></span><br><span class="line"><span class="comment"># 和文件句柄已经准备好了，它支持监听多个文件和 socket（select 本质上也是阻塞方法)</span></span><br><span class="line"><span class="comment"># 比如我们可以监听100个端口，只要其中某个端口可用，我们就可以立即处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---信号驱动式 I/O</span></span><br><span class="line"><span class="comment"># 应用较少，暂时不做介绍</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---异步 I/O</span></span><br><span class="line"><span class="comment"># aio_read 真正的异步</span></span><br></pre></td></tr></table></figure><p>select,poll,epoll 都是 I/0 多路复用的机制。I/0 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><p>但select,poll, epoll 本质上都是同步 I/0，因为他们都需要在读写事件就绪后自己负责 进行读写，也就是说这个读写过程是阻塞的，而异步V/0则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。</p><h2 id="select">Select</h2><p>select 函数监视的文件描述符分3类，分别是 writefds、readfds, 和 exceptfds。</p><p>调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指指定等待时间，如果立即返回设为null即可），函数返回。</p><p>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p><p>select的一个缺点在于，单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><h2 id="poll">Poll</h2><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。</p><p>polfd结构包含了要监视的event和发生的event，不再使用select "参数-值" 传递的方式。</p><p>同时，pollfd并没有最大数量限制（ 但是数量过大后性能也是会下降）。和select西数一样，pol返回后需要轮询polfd来获取就绪的描述符。从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取 已经就绪的socket。</p><p>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态 ，因此随着监视的描述符数量的增长，其效率也会线性下降</p><h2 id="epoll">Epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和pol的增强版本。</p><p>相对于select和poll来说，epol更加灵活，没有描述符限制。epoll使用-一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><p>epoll 实现使用了红黑树。</p><h2 id="对比">对比</h2><p>在并发高的情况下，连接活跃度不是很高，epoll 比 selelct 好；</p><p>并发不高，连接很活跃的时候，select 比 epoll 好；</p><h1 id="实例非阻塞io">实例：非阻塞I/O</h1><p>先看一段使用非阻塞IO完成 socket 请求与接受的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用非阻塞io完成http请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立socket连接</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((host, <span class="number">80</span>)) <span class="comment">#阻塞不会消耗cpu</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不停的询问连接是否建立好， 需要while循环不停的去检查状态</span></span><br><span class="line">    <span class="comment"># 做计算任务或者再次发起其他的连接请求</span></span><br><span class="line"></span><br><span class="line">    send_to = <span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(path, host).encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client.send(send_to)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    data = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    data = data.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    html_data = data.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    get_url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实例select-回调">实例：Select 回调</h1><p>下面这个是使用 Select 的版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需处理系统兼容性问题</span></span><br><span class="line"><span class="comment"># 如 Windows 和 Linux 不一样, 推荐使用 selectors</span></span><br><span class="line"><span class="comment"># import select</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()</span><br><span class="line"><span class="comment"># 使用select完成http请求</span></span><br><span class="line"><span class="comment"># 一个线程发出url请求后即可不管，操作系统 select</span></span><br><span class="line"><span class="comment"># 会自动使用可用的 socket 处理，对比多线程中一个线程对应一个 url</span></span><br><span class="line"><span class="comment"># 省去了线程切换的开销，以及其占用的内存</span></span><br><span class="line">urls = []</span><br><span class="line">stop = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        selector.unregister(key.fd)</span><br><span class="line">        self.client.send(<span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(self.path, self.host).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        selector.register(self.client.fileno(), EVENT_READ, self.readable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readable</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        d = self.client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            self.data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selector.unregister(key.fd)</span><br><span class="line">            data = self.data.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">            html_data = data.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(html_data)</span><br><span class="line">            self.client.close()</span><br><span class="line">            urls.remove(self.spider_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> urls:</span><br><span class="line">                <span class="keyword">global</span> stop</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.spider_url = url</span><br><span class="line">        url = urlparse(url)</span><br><span class="line">        self.host = url.netloc</span><br><span class="line">        self.path = url.path</span><br><span class="line">        self.data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            self.path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立socket连接</span></span><br><span class="line">        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.client.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.client.connect((self.host, <span class="number">80</span>))  <span class="comment"># 阻塞不会消耗cpu</span></span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#注册</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    <span class="comment">#事件循环，不停的请求socket的状态并调用对应的回调函数</span></span><br><span class="line">    <span class="comment"># 1. select本身是不支持register模式</span></span><br><span class="line">    <span class="comment"># 2. socket状态变化以后的回调是由程序员完成的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop:</span><br><span class="line">        ready = selector.select()</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> ready:</span><br><span class="line">            call_back = key.data</span><br><span class="line">            call_back(key)</span><br><span class="line">    <span class="comment"># 回调+事件循环+select(poll\epoll)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    fetcher = Fetcher()</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">&quot;http://shop.projectsedu.com/goods/&#123;&#125;/&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">        urls.append(url)</span><br><span class="line">        fetcher = Fetcher()</span><br><span class="line">        fetcher.get_url(url)</span><br><span class="line">    loop()</span><br><span class="line">    <span class="built_in">print</span>(time.time()-start_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="回调的问题">回调的问题</h1><p>使用回调虽然可以带来效率上的提升，但是也会有一些问题，包括：</p><ul><li>回调函数执行不正常怎么办？</li><li>回调函数里还要嵌套回调怎么办？嵌套多层怎么办？</li><li>多层嵌套中，某个环节出错了怎么办？</li><li>有个数据，需要每个回调函数都处理怎么办？</li><li>怎么使用当前函数中的局部变量？</li></ul><p>归纳来看，可以说回调的问题在于：</p><ol type="1"><li>代码可读性变差</li><li>共享状态的管理困难</li><li>处理异常比较麻烦</li></ol><p>要处理这个问题，这时候就轮到协程出场了。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍了一些异步IO的基本概念与 Select 即回调函数的使用。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="socket" scheme="https://scottzhang.pro/tags/socket/"/>
    
    <category term="select" scheme="https://scottzhang.pro/tags/select/"/>
    
    <category term="poll" scheme="https://scottzhang.pro/tags/poll/"/>
    
    <category term="epoll" scheme="https://scottzhang.pro/tags/epoll/"/>
    
    <category term="回调函数" scheme="https://scottzhang.pro/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 多进程</title>
    <link href="https://scottzhang.pro/article/4300f84b.html"/>
    <id>https://scottzhang.pro/article/4300f84b.html</id>
    <published>2022-05-11T03:23:35.000Z</published>
    <updated>2022-05-11T03:25:47.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python 多进程编程参考，适合 CPU 密集型操作。</p></blockquote><span id="more"></span><h1 id="多进程">多进程</h1><p>在 Python 中，对于IO密集型操作，可以考虑多线程。而 CPU 密集型操作则应考虑多进程。</p><p>在 Linux 中, <code>os.fork()</code> 子进程会将父进程中所有数据拷贝过来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi, This is Scott!&quot;</span>)</span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位于子进程: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;父进程为: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位于父进程: <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里的运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hi, This is Scott!</span><br><span class="line">位于父进程: 3021</span><br><span class="line">Hi, This is Scott!</span><br><span class="line">位于子进程: 3021</span><br><span class="line">父进程为: 3020</span><br></pre></td></tr></table></figure><h1 id="multiprocessing">Multiprocessing</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do something in sub_progress&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    progress = multiprocessing.Process(</span><br><span class="line">        target=do_something,</span><br><span class="line">        args=(<span class="number">2</span>,)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;progress pid: <span class="subst">&#123;progress.pid&#125;</span>&quot;</span>)</span><br><span class="line">    progress.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;progress pid: <span class="subst">&#123;progress.pid&#125;</span>&quot;</span>)</span><br><span class="line">    progress.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;main progress finished&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">progress pid: None</span><br><span class="line">progress pid: 3391</span><br><span class="line">do something in sub_progress</span><br><span class="line">main progress finished</span><br></pre></td></tr></table></figure><p>当然也可以使用继承的方式，重写内部的 run 方法，这部分和多线程中的代码类似。</p><h1 id="进程池">进程池</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do something in sub_progress&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># using a pool to manage process</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    result = pool.apply_async(do_something, args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># waiting all tasks finished</span></span><br><span class="line">    <span class="comment"># must close a pool before join it, for new task added to pool</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="built_in">print</span>(result.get())</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ python multiprocessing_test.py</span><br><span class="line">do something in sub_progress</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>pool 中还有 <code>imap</code> 方法，类似线程中 <code>excuter.map</code> 方法，result 为每个函数的返回值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入顺序</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> pool.imap(do_something, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;do something in <span class="subst">&#123;result&#125;</span>s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成顺序</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> pool.imap_unordered(do_something, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;do something in <span class="subst">&#123;result&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ python multiprocessing_test.py</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 1s</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 3s</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 5s</span><br></pre></td></tr></table></figure><h1 id="进程间通信">进程间通信</h1><p>多进程中，使用全局变量是无法共享数据的，因为进程间的数据是互相隔离的。</p><h2 id="使用-queue">使用 Queue</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="comment"># 下面的 queue 在多进程中无法使用</span></span><br><span class="line"><span class="comment"># from queue import Queue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line"></span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用进程池">使用进程池</h2><p>Pool 中的进程间通信，需要使用 manager 中的 queue.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># pool 中的 queue 需要使用 manager 中的</span></span><br><span class="line">    queue = Manager().Queue(<span class="number">10</span>)</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pool.apply_async(producer, args=(queue,))</span><br><span class="line">    pool.apply_async(consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>至此我们这里出现了三个 queue，注意区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line">queue = Manager().Queue</span><br></pre></td></tr></table></figure><h2 id="使用管道">使用管道</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe, Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&#x27;scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># pipe 只能适用于两个进程, 但更高效，相比 queue 它没那么多锁</span></span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line"></span><br><span class="line">    my_producer = Process(target=producer, args=(send_pipe,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用共享内存">使用共享内存</h2><p>Manager 中有一些支持共享内存的数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&#x27;scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    share_var = Manager().<span class="built_in">dict</span></span><br><span class="line">    share_var = Manager().Array</span><br><span class="line">    share_var = Manager().<span class="built_in">list</span></span><br><span class="line">    <span class="comment"># and more</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Python 多进程编程参考，适合 CPU 密集型操作。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Python 多进程" scheme="https://scottzhang.pro/tags/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="Multiprocessing" scheme="https://scottzhang.pro/tags/Multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>Python 多线程</title>
    <link href="https://scottzhang.pro/article/55e6fd87.html"/>
    <id>https://scottzhang.pro/article/55e6fd87.html</id>
    <published>2022-05-11T03:09:56.000Z</published>
    <updated>2022-05-11T03:23:08.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python 多线程编程参考。</p></blockquote><span id="more"></span><h1 id="关于线程">关于线程</h1><p>线程是操作系统的最小调度单位，属于进程。如果将操作系统比较工厂，那么进程就属于车间，而线程就是具体的工人。</p><h1 id="使用-tread-类">使用 Tread 类</h1><p>Python 中线程的模块是 treading, 我们先看一个简单的例子：</p><p>先导入包，定义好我们需要的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟爬取网页内容的操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get detail started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get detail end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟获取网页地址的操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get url started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get url end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>进行我们第一个测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义两个线程</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程可以并发，所以线程开始执行后无需等待执行结果即可继续执行打印时间的代码</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><p>查看执行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get detail started</span><br><span class="line">get url started</span><br><span class="line"><span class="number">0.0020024776458740234</span></span><br><span class="line">get detail end</span><br><span class="line">get url end</span><br></pre></td></tr></table></figure><p>设置守护线程可以让主线程结束后将子线程都 kill 掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义两个线程</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置守护线程</span></span><br><span class="line">    <span class="comment"># 主进程执行完毕后，子线程都 kill 掉，若其中只有某个</span></span><br><span class="line">    <span class="comment"># 子线程设置了守护线程，则等待另外一个</span></span><br><span class="line">    thread1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    thread2.setDaemon(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程可以并发，所以线程开始执行后无需等待执行结果即可继续执行打印时间的代码</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><p>主线程执行完毕后，其它子线程也将结束（在 jupyter 中不一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get detail started</span><br><span class="line">get url started</span><br><span class="line">0.0010001659393310547</span><br></pre></td></tr></table></figure><p>同时线程还有一个 join 方法，可以造成阻塞并等待前面的线程结束之后才运行后面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义两个线程</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程可以并发，所以线程开始执行后无需等待执行结果即可继续执行打印时间的代码</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 阻塞，等所有子线程运行完成才继续</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><h1 id="继承-tread-类">继承 Tread 类</h1><p>我们也可以继承 treading.Tread 类实现多线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailHtml</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟爬取网页内容的操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get detail started&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get detail end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailURL</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟获取网页地址的操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get url started&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get url end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread1 = GetDetailHtml()</span><br><span class="line">    thread2 = GetDetailURL()</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><h1 id="线程间通信">线程间通信</h1><p>前面提供了两个函数，一个是负责去抓 url，一个是去爬取 url 的内容，那么对于抓到的 url，你需要有一种方式传给爬取内容的函数，这就是线程之间需要通信的例子。</p><p>线程中通信有几种方案：</p><ul><li>使用全局变量</li><li>使用 Python 中的队列，即 queue</li></ul><h1 id="线程同步">线程同步</h1><p>在之前关于 GIL 的文章中，有一个多线程加减的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure><p>当我们查看上面代码的字节码的时候，可以看到大概的步骤如下：</p><ol type="1"><li>加载 total 到内存</li><li>加载 1</li><li>进行加法操作</li><li>赋值给 total （多线程状态下，赋值会出错）</li></ol><p>上述代码，每次的结果都不一样，就是因为在上面4个步骤的任意一个步骤中，GIL 都有可能被释放，然后加载的变量被其他的线程修改了。</p><p>这里就引出我们的线程的同步机制，即我们设置一种方法，让某一段代码执行完毕之后，才能切换到别的线程执行，这就保证了在修改数据的时候，不会出错。</p><h2 id="锁-lock">锁 Lock</h2><p>同步机制可以使用锁来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total is: <span class="subst">&#123;total&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># Total is: 0，可以看到结果正确了</span></span><br></pre></td></tr></table></figure><p>但是使用锁，也优缺点，第一个是性能上的损失，另外是容易引起死锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 没有 release 却重新申请导致死锁</span></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 竞争死锁</span></span><br><span class="line"><span class="comment"># A 任务需要 a，b，B 任务需要 b，a</span></span><br><span class="line"><span class="comment"># 那么 A 和 B 互相持有 a，b 容易导致死锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 子函数死锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">lock</span>):</span></span><br><span class="line">    lock.acquire()</span><br><span class="line"></span><br><span class="line">lock.acquire()</span><br><span class="line">do_something(lock)</span><br></pre></td></tr></table></figure><p>针对第三种情况，Python 有一种 RLock（可以重复申请的锁）, 可以让你连续申请锁，但是注意，申请和释放的次数要一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> RLock</span><br><span class="line"></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="comment"># pass</span></span><br><span class="line">lock.release()</span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><h2 id="条件变量-condition">条件变量 Condition</h2><p>假设有一个需求是，需要设计一个对话系统，让两个人可以互相对话，即他们说话的顺序需要是交互的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Condition</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># notify 和 wait，必须在 with 语句中</span></span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>, 1&quot;</span>) <span class="comment"># A先处理自己的逻辑</span></span><br><span class="line">            self.cond.notify()       <span class="comment"># 通知调用 wait 的方法启动</span></span><br><span class="line">            self.cond.wait()         <span class="comment"># 等待某个变量的通知</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>, 3&quot;</span>)</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># notify 和 wait，必须在 with 语句中</span></span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            self.cond.wait()        <span class="comment"># B顺序在后，所以先等待</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 2&quot;</span>) <span class="comment"># B再处理自己的逻辑</span></span><br><span class="line">            self.cond.notify()      <span class="comment"># 再通知 A</span></span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 4&quot;</span>)</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cond = Condition()</span><br><span class="line"></span><br><span class="line">    a = A(cond)</span><br><span class="line">    b = B(cond)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动顺序很重要，在这里如果 a 启动，那么 a 首先处理自己的代码</span></span><br><span class="line">    <span class="comment"># 随后发送 notify，但这个时候会出问题，因为 b 还没有启动起来</span></span><br><span class="line">    <span class="comment"># 所有正确的方式是先让 b 起来等待，再启动 a</span></span><br><span class="line">    b.start()</span><br><span class="line">    a.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么notify 和 wait，必须在 with 语句中呢？condition 内部有两把锁</p><ul><li>第一底层锁，控制 condition 的进入，即通过 with 或者 cond.acquire()。在这里 B 通过 with 语句进入 condition 内部后，它调用了 wait 方法，wait 内部首先会将底层锁释放，这样 a 才可以通过 wiht 语句进入 condition。</li><li>随后，在 wait 方法内，它还会申请一把新的锁放入condition的等待队列（双端队列）中，等待 notify 方法的唤醒</li></ul><p>了解了这个原理，上面的问题就很简单了，如果不先通过 with 语句，我们是无法进入到 condition 内部的。</p><p>Condition 也有类似锁的申请、释放的模式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.cond.acquire()</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">self.cond.release()</span><br></pre></td></tr></table></figure><h2 id="信号量-semaphore">信号量 Semaphore</h2><p>Semaphore 是用于控制进入数量的锁。</p><p>比如在文件的操作中，需要控制读写线程的数量。在爬虫的实现中，需要限制请求并发数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> c</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlSpider</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;HTML 爬取模拟器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        threading (Thread): 继承自线程类，每个 URL 有一个线程处理</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url, sem</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.url&#125;</span> finished.&quot;</span>)</span><br><span class="line">        <span class="comment"># 处理完成后，释放该锁</span></span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlMaker</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sem</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这里有 100 URL 需要处理，但是同时并发这么多请求会报错</span></span><br><span class="line">        <span class="comment"># 可以通过 semaphore 限制并发的数量来控制</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            <span class="comment"># 一把 sem 锁，最多进入10个线程</span></span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_sider = HtmlSpider(<span class="string">f&quot;http:/scottzhang.pro/<span class="subst">&#123;i&#125;</span>&quot;</span>, self.sem)</span><br><span class="line">            html_sider.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sem = threading.Semaphore(<span class="number">10</span>)  <span class="comment"># 控制并发数量为 10 个</span></span><br><span class="line">    url_maker = UrlMaker(sem)</span><br><span class="line">    url_maker.start()</span><br></pre></td></tr></table></figure><p>信号量内部实际上是使用 condition 实现的，而 condition 则是使用 queue 实现的。</p><h1 id="threadpoolexecutor-线程池">ThreadPoolExecutor 线程池</h1><h2 id="使用">使用</h2><p>线程池也可以实现 semaphore 的功能，即控制线程的数量。</p><p>但是线程池可以控制的东西更多，比如它可以获得某个线程的状态与返回值。</p><p>当一个线程完成的时候，主线程可以立即知道。</p><p>其次，futures 可以让多线程和多进程编码接口一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_function</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟某个函数的执行&quot;&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">&quot;Thread %s: starting&quot;</span>, name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    logging.info(<span class="string">&quot;Thread %s: finishing&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_thread_1</span>():</span></span><br><span class="line">    logging.info(<span class="string">&quot;# Start thread with method 1&quot;</span>)</span><br><span class="line">    executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">    task1 = executor.submit(thread_function, (<span class="string">&#x27;A thread&#x27;</span>))</span><br><span class="line">    task2 = executor.submit(thread_function, (<span class="string">&#x27;B thread&#x27;</span>))</span><br><span class="line">    task3 = executor.submit(thread_function, (<span class="string">&#x27;C thread&#x27;</span>))</span><br><span class="line">    <span class="comment"># 查看是否成功，返回结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task 1 status: <span class="subst">&#123;task1.done()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 取消某个任务(还未执行)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Cancel task 3: <span class="subst">&#123;task3.cancel()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_thread_2</span>(<span class="params">names</span>):</span></span><br><span class="line">    logging.info(<span class="string">&quot;# Start thread with method 2&quot;</span>)</span><br><span class="line">    executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    all_tasks = [</span><br><span class="line">        executor.submit(thread_function, (x)) <span class="keyword">for</span> x <span class="keyword">in</span> names</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 这里会直接进入到 as_completed 逻辑，并不会阻塞</span></span><br><span class="line">    <span class="comment"># as_completed 会将已经完成的 task yield</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_tasks):</span><br><span class="line">        data = future.result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_thread_3</span>(<span class="params">names</span>):</span></span><br><span class="line">    logging.info(<span class="string">&quot;# Start thread with method 3&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        data = executor.<span class="built_in">map</span>(thread_function, names)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">format</span> = <span class="string">&quot;%(asctime)s: %(message)s&quot;</span></span><br><span class="line">    logging.basicConfig(<span class="built_in">format</span>=<span class="built_in">format</span>, level=logging.INFO,</span><br><span class="line">                        datefmt=<span class="string">&quot;%H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">    names = [<span class="string">&#x27;A thread&#x27;</span>, <span class="string">&#x27;B thread&#x27;</span>, <span class="string">&#x27;C thread&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    start_thread_1()</span><br><span class="line">    start_thread_2(names)</span><br><span class="line">    start_thread_3(names)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">15:36:09: # Start thread with method 1</span><br><span class="line">15:36:09: Thread A thread: starting</span><br><span class="line">15:36:09: Thread B thread: starting</span><br><span class="line">Task 1 status: False</span><br><span class="line">Cancel task 3: True</span><br><span class="line">15:36:09: # Start thread with method 2</span><br><span class="line">15:36:09: Thread A thread: starting</span><br><span class="line">15:36:09: Thread B thread: starting</span><br><span class="line">15:36:09: Thread C thread: starting</span><br><span class="line">15:36:11: Thread B thread: finishing</span><br><span class="line">15:36:11: Thread A thread: finishing</span><br><span class="line">15:36:11: Thread C thread: finishing</span><br><span class="line">15:36:11: Thread A thread: finishing</span><br><span class="line">15:36:11: # Start thread with method 3</span><br><span class="line">15:36:11: Thread A thread: starting</span><br><span class="line">15:36:11: Thread B thread: starting</span><br><span class="line">15:36:11: Thread B thread: finishing</span><br><span class="line">15:36:13: Thread B thread: finishing</span><br><span class="line">15:36:13: Thread C thread: starting</span><br><span class="line">15:36:13: Thread A thread: finishing</span><br><span class="line">15:36:15: Thread C thread: finishing</span><br></pre></td></tr></table></figure><p>另外 <code>concurrent.futures</code> 中还有 wait 方法，可以用来阻塞。比如你想指定某个或者某些任务完成才继续:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> wait, FIRST_COMPLETED</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">all_tasks = [executor.submit(thread_function, (x)) <span class="keyword">for</span> x <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">wait(all_task)  <span class="comment"># 等所有 task 结束才完成</span></span><br><span class="line">wait(all_task, return_when=FIRST_COMPLETED)</span><br></pre></td></tr></table></figure><h2 id="理解-future-类">理解 Future 类</h2><p>当我们调用时:</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>task1 <span class="op">=</span> executor.submit(thread_function, (<span class="st">&#39;A thread&#39;</span>))</span></code></pre></div><p>task1 是一个 Future 类的实例，这个实例贯穿我们整个多线程的体系中。</p><p>因为 Python 为了提供系统的一致性，将多线程、多进程以及协程都采用了一样的设计模式。</p><p>仔细想一下，我们的 <code>thread_function</code> 函数并没有去访问任何 Future 实例，为什么它却可以拿到 函数的执行状态呢？</p><p>我们看一下 submit 的源码：</p><figure><img src="https://s2.loli.net/2022/05/10/kptihyjHsd4m9lO.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>其中 f 为 future 类实例；w 为 workitem 实例；workitem 负责了将 future 实例和我们的函数，以及其参数做绑定。</p><p>并将 w 放到队列中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Python 多线程编程参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="GIL" scheme="https://scottzhang.pro/tags/GIL/"/>
    
    <category term="线程" scheme="https://scottzhang.pro/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Thread" scheme="https://scottzhang.pro/tags/Thread/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://scottzhang.pro/tags/ThreadPoolExecutor/"/>
    
    <category term="Python Future" scheme="https://scottzhang.pro/tags/Python-Future/"/>
    
  </entry>
  
  <entry>
    <title>Spark-浅析API 与工具集P1</title>
    <link href="https://scottzhang.pro/article/28c39ad6.html"/>
    <id>https://scottzhang.pro/article/28c39ad6.html</id>
    <published>2022-03-21T13:20:08.000Z</published>
    <updated>2022-03-21T13:21:17.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spark 概述、浅析、工具集与结构化API。</p></blockquote><span id="more"></span><h2 id="spark-指南">Spark 指南</h2><h2 id="大数据与-spark-概述">大数据与 Spark 概述</h2><p><img src="https://s2.loli.net/2022/03/21/FrOiSsICP6Lhz51.png" /></p><h2 id="spark-浅析">Spark 浅析</h2><figure><img src="https://s2.loli.net/2022/03/21/eO2kihfLurdR96C.png" alt="spark浅析1, 基本架构、多语言、API 以及 SparkSession" /><figcaption aria-hidden="true">spark浅析1, 基本架构、多语言、API 以及 SparkSession</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/21/u2j5WVkyzgBhxdY.png" alt="spark 的主要架构" /><figcaption aria-hidden="true">spark 的主要架构</figcaption></figure><p>多语言支持中通过 spark 会话提交任务给执行器，具体如下图所示：</p><figure><img src="https://s2.loli.net/2022/03/21/AjqW67HLPRhaCTD.png" alt="多语言 API.png" /><figcaption aria-hidden="true">多语言 API.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/21/QmZVLvBwWj9xGFe.png" alt="spark浅析2,数据分区、转换操作、惰性评估、动作操作与用户接口" /><figcaption aria-hidden="true">spark浅析2,数据分区、转换操作、惰性评估、动作操作与用户接口</figcaption></figure><h2 id="spark-工具集介绍">Spark 工具集介绍</h2><figure><img src="https://s2.loli.net/2022/03/21/8lsOzB4ejMPy1X7.png" alt="Spark 工具集.png" /><figcaption aria-hidden="true">Spark 工具集.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/21/rojM52HmCB1wRge.png" alt="spark 工具集架构" /><figcaption aria-hidden="true">spark 工具集架构</figcaption></figure><h2 id="结构化-api">结构化 API</h2><figure><img src="https://s2.loli.net/2022/03/21/uvgWDohx7JceLrQ.png" alt="结构化 API" /><figcaption aria-hidden="true">结构化 API</figcaption></figure><p>结构化API指以下三种核心分布式集合类型的API： - Dataset类型。 - DataFrame类型。 - SQL表和视图。</p><p>结构化API是在编写大部分数据处理程序时会用到的基础抽象概念。</p><h3 id="结构化api的执行步骤">结构化API的执行步骤</h3><ul><li>编写DataFrame / Dataset / SQL代码。</li><li>如果代码能有效执行， Spark将其转换为一个逻辑执行计划（Logical Plan）。</li><li>Spark将此逻辑执行计划转化为一个物理执行计划（Physical Plan）， 检查可行的 优化策略，并在此过程中检查优化。</li><li>Spark在集群上执行该物理执行计划（RDD操作）。</li></ul><figure><img src="https://s2.loli.net/2022/03/21/GltsvRengH6C9QZ.png" alt="Catalyst优化器.png" /><figcaption aria-hidden="true">Catalyst优化器.png</figcaption></figure><blockquote><p>通过控制台提交给Spark，或者以一个Spark作业的形式提交。然后代码将交由Catalyst优化器决定如何执行， 并指定一个执行计划。 最后代码被运行， 得到的结果返回给用户。图4-1展示了整个过程。</p></blockquote><h3 id="逻辑计划">逻辑计划</h3><p><img src="https://s2.loli.net/2022/03/21/YEerSUfdGn7RLbx.png" /></p><blockquote><p>Spark使用catalog（所有表和DataFrame信息的存储库）在分析器中 解析列和表格。 如果目录中不存在所需的表或列名称， 分析器可能会拒绝该未解析的 逻辑计划。</p></blockquote><h3 id="物理计划">物理计划</h3><p><img src="https://s2.loli.net/2022/03/21/wlUpdFQYTNZ85oa.png" /></p><blockquote><p>在成功创建优化的逻辑计划后， Spark开始执行物理计划流程。物理规划产生一系列的RDD和转换操作。 这就是Spark被称为编译器的原因， 因为它 将对DataFrame、Dataset和SQL中的查询来作为你编译一系列RDD的转换操作。</p></blockquote><h3 id="执行">执行</h3><p>在选择一个物理计划时， Spark将所有代码运行在Spark的底层编程接口RDD上（第Ⅲ 部分将会介绍）。 Spark在运行时执行进一步优化， 生成可以在执行期间优化任务或 阶段的本地Java字节码，最终将结果返回给用户。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Spark 概述、浅析、工具集与结构化API。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Spark 权威指南" scheme="https://scottzhang.pro/categories/Spark-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="Spark" scheme="https://scottzhang.pro/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Linux 是如何工作的-管理设备</title>
    <link href="https://scottzhang.pro/article/d7967d77.html"/>
    <id>https://scottzhang.pro/article/d7967d77.html</id>
    <published>2022-03-20T15:11:55.000Z</published>
    <updated>2022-03-20T15:13:42.225Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Linux 的设备文件系统、系统设备路径与设备名、udev, SCSI 等内容。</p></blockquote><span id="more"></span><p>Linux 设备</p><h2 id="设备文件系统device-files">设备文件系统（Device files）</h2><p>操作系统负责帮我们管理设备，将其抽象成类似文件的形式放在磁盘上，所以当往设备中输出内容，就像我们往一个文件中写内容一样，这些设备文件存放于 <code>/dev</code> 中, 执行 <code>ls /dev</code> 可以看到这些设备。</p><p>Linux启动的时候，会动态的在/dev目录下创建好各种设备的设备文件节点（也就是说，系统启动后/dev目录下就有了各种设备的设备文件，直接就可使用了）。</p><p>除此之外，他还可以在设备卸载后自动的删除/dev下对应的设备文件节点（这对于一些热插拔设备很有用，插上的时候自动创建，拔掉的时候又自动删除）。</p><p>在我们编写设备驱动的时候，不必再去为设备指定主设备号，在设备注册时用0来动态的获取可用的主设备号，然后在驱动中来实现创建和销毁设备文件（一般在驱动模块加载和卸载函数中来实现）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">brw-rw----   1 root disk 8, 1 Sep  6 08:37 sda1</span><br><span class="line">crw-rw-rw-   1 root root 1, 3 Sep  6 08:37 null</span><br><span class="line">prw-r--r--   1 root root    0 Mar  3 19:17 fdata</span><br><span class="line">srw-rw-rw-   1 root root    0 Dec 18 07:43 log</span><br></pre></td></tr></table></figure><p>第一个字母，<code>b, c, p, s</code> 分别代表 block, character, pipe, and socket。</p><p>block 设备：Programs access data from a block device in fixed chunks，block device’s total size is fixed and easy to index, processes have quick random access to any block in the device with the help of the kernel.</p><p>character 设备：work with data streams，only character, don’t have a size. Like printer; kernel cannot back up and reexamine the data stream after it has passed data to a device or process.</p><p>Pipe device: like character device, work with IO process instead of kernel.</p><p>Socket device: special-purpose interfaces that are frequently used for interprocess communication. They’re often found outside of the /dev directory.</p><h2 id="系统设备路径">系统设备路径</h2><p>/dev 下面的名字所能告诉你的信息很有限，而且内核根据设备被发现的顺序来给设备命名，所以一旦计算机重启，这些设备的名字有可能会不一样。</p><p>Linux 根据设备的属性，提供了一个统一的视图来访问所有的设备，即： <code>/sys/devices</code>。</p><p>/dev 下的文件让用户进程可以与设备交互。/sys/devices 用来查看和管理设备。</p><p>sys 目录下还有一些分类，比如 <code>/sys/block</code> 下面都是块设备。</p><p>在 /dev 目录下，找到设备的路径上有点不容易，不过可以通过 <code>udevadm</code> 命令查看，我们将会在之后介绍更多关于这个命令的知识。</p><h2 id="dd-和-设备">dd 和 设备</h2><p><code>dd</code> 程序在与块设备与字符设备时非常方便，但它也是一个非常强大的命令，需要特别小心的使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从块数据中复制固定大小的数据</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=new_file bs=1024 count=1</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>if, 输入文件，默认是标准输入</li><li>of, 输出文件，默认是标准输出</li><li>bs, 块大小，可以使用 b 或者 k</li><li>count=num，块的个数，当使用大文件或者文件流，需要用 count 或下面的 skip 来控制大小</li><li>skip=num, 另外一个控制大小的选项</li></ul><h2 id="设备名">设备名</h2><h3 id="找到设备名">找到设备名</h3><p>找到设备名有时候很麻烦，这里提供了集中方式：</p><ol type="1"><li>使用 <code>udevadm</code></li><li>检查 /sys 目录</li><li>通过 <code>journalctl -k</code> 命令打印系统内核的消息、日志，猜测设备名</li><li>对于存储设备，可以通过 mount 命令查看</li><li>通过 <code>cat /proc/devices</code> 命令查看块设备和字符设备的驱动。</li></ol><p>其中只有第一种方式是最可靠的，建议主要还是用第一种方式，如果你的系统中实在是没有 <code>udevadm</code> 可以使用，可以再参考其他的方式。</p><p>下面的内容会例举出 Linux 中最常见的一些设备，以及它们的命名。</p><h3 id="存储设备-devsd">存储设备 /dev/sd*</h3><p>存储设备的命名一般以 sd 开头，即 SCSI disk 的简写, SCSI 的意思是：Small Computer System Interface。SCSI 是最早被开发用来在存储设备和外围设备之间进行通讯。</p><p><code>lsscsi</code> 命令可以用来检查设备中的存储设备，它的输出如下：</p><p><img src="https://s2.loli.net/2022/03/13/5Iuy2Kewt6jAJqX.png" /></p><p>其中 1 表示设备在系统中的位置；2 表示设备描述； 3 表示去哪里找到这个设备；</p><h3 id="虚拟存储-devxvd-devvd">虚拟存储 /dev/xvd*, /dev/vd*</h3><p>有的磁盘设备是为了虚拟机优化而存在的，例如 AWS 实例，Virtual-Box.</p><h3 id="non-volatile-memory-devices-devnvme">Non-Volatile Memory Devices: /dev/nvme*</h3><p>有一些系统现在使用 Non-Volatile memory，即 NVMe 接口与某些类型的固态存储通信。</p><p>可以用 <code>nvme list</code> 命令列出这些设备。</p><h3 id="device-mapper-devdm--devmapper">Device Mapper: /dev/dm-*, /dev/mapper/*</h3><p>Device Mapper 并不是一个文件系统（File System），而是 Linux 内核映射块设备的一种技术框架。提供的一种从逻辑设备（虚拟设备）到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。</p><p>使用了这种映射的名字一般以 <code>/dev/dm-</code> 或者 <code>/dev/mapper</code> 命名。</p><h3 id="cd-和-dvd-devsr">CD 和 DVD: /dev/sr*</h3><p>一般命名为 /dev/sr0, /dev/sr1，只读。如果是可以写的，可能会命名为：/dev/sg0.</p><h3 id="pata-hard-disks-devhd">PATA Hard Disks: /dev/hd*</h3><p>Older type of storage bus. <code>/dev/hda, /dev/hdb, /dev/hdc, and /dev/hdd</code> , 如果你发现你的 SATA 驱动被识别成上面的格式，则代表它工作在钱荣模式下，这会影响性能，你可以查看 BIOS 设置是否正确。</p><h3 id="终端devtty-devpts-and-devtty">终端：/dev/tty*, /dev/pts/*, and /dev/tty</h3><p>终端是一种设备，它在用户进程和 I/O 设备间传输字符。而且大部分终端属于伪设备，它不是一个真的硬件。</p><p>两个常见的终端设备是 /dev/tty1（第一个虚拟控制台）和 /dev/pts/0（第一个伪终端设备）。 /dev/pts 目录本身就是一个专用的文件系统。</p><p>显示模式和虚拟终端：</p><p>Linux 主要有两种显示模式，文本和图形。</p><p>Linux 系统传统上是在文本模式下启动的，现在分发的大部分的系统则会隐藏文本模式。</p><p>这里的控制台或终端都是计算机产生早期的遗留下来的概念。为了充分使用计算机提供的计算资源，早期很多计算机会连接若干终端控制台，这些终端控制台从硬件上构造很简单，只包括键盘和显示器，不执行计算的任务，只简单的把用户的输入发送到主计算机去处理，然后再把计算结果返回给用户。</p><h3 id="串行端口-devttys-devttyusb-devttyacm">串行端口: /dev/ttyS*, /dev/ttyUSB*, /dev/ttyACM*</h3><p>串行接口（Serial port），主要用于串行式逐位数据传输。按电气标准及协议来分包括RS-232-C、RS-422、RS485、USB等。 RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接外挂程式、电缆或协议。USB是近几年发展起来的新型接口标准，主要应用于高速数据传输领域。</p><p>可以使用 screen 来连接 usb 串口设备。</p><blockquote><p>参考<a href="https://cloud.tencent.com/developer/news/304629">命令行界面、终端、Shell、TTY 的区别</a></p></blockquote><h3 id="并行端口devlp0-and-devlp1">并行端口：/dev/lp0 and /dev/lp1</h3><p>计算机上数据以并行方式传递的端口，也就是说至少应该有两条连接线用于传递数据。 与只使用一根线传递数据（这里没有包括用于接地、控制等的连接线）的串行端口相比，并口在相同的数据传送速率下，并口可以更快地传输数据。所以在21世纪之前，在需要较大传输速度的地方，例如打印机，并口得到广泛使用。但是随着速度迅速提高，并且上导线之间数据同步成为一个很难处理的难题，导致并口在速度竞赛中逐渐被淘汰。USB等改进的串口逐渐代替了并口。</p><h3 id="音频设备devsnd-devdsp-devaudio-and-more">音频设备：/dev/snd/*, /dev/dsp, /dev/audio, and More</h3><p>Linux 有两种音频设备，ALSA 和 OSS。分别代表了 Advanced Linux Sound Architecture 和 Open Sound System.</p><p>The ALSA devices are in the /dev/snd directory, but it’s difficult to work with them directly. Linux systems that use ALSA support OSS backward-compatible devices if the OSS kernel support is currently loaded.</p><h3 id="创建设备文件">创建设备文件</h3><p>在绝大多数情况下，你不需要自己创建设备文件，它们会被 devtmpfs 和 udev 自动创建。但我们至少可以学习一下如何做。</p><p><code>mknod</code> 命令可以用来创建一个设备。你必须知道设备的名字，以及它的主要、次要版本号，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b 8 1, 指定了 block 设备，major 版本为8，minor 版本为1</span></span><br><span class="line">mknod /dev/dda1 b 8 1</span><br></pre></td></tr></table></figure><p>对于linux 来说管理如此多的设备以及版本是非常复杂的，特别是当linux系统在升级的时候，后来出现了 devfs，一个内核空间中的 /dev 的实现，它包括了所有现在内核支持的设备，可以指定设备号、所有者、用户空间等信息，devfs 运行在内核环境中，并有不少缺点：可能出现主/辅设备号不够，命名不灵活，不能指定设备名称等问题。</p><p>所以后人又开发了 udev 和 devtmpfs.</p><h2 id="udev">udev</h2><p>关于 udev 的相关介绍，可以参考这篇文章: <a href="https://www.pianshen.com/article/5062954066/">Linux 文件系统与设备文件系统 （一）—— udev 设备文件系统</a></p><h3 id="devtmpfs">devtmpfs</h3><p>The devtmpfs filesystem was developed in response to the problem of device availability during boot.</p><h3 id="udevd-操作和配置">udevd 操作和配置</h3><p>在 GNU/Linux 系统中，虽然设备的底层支持是在内核层面处理的，但是，它们相关的事件管理是在用户空间中通过 udev 来管理的。确切地说是由 udevd 守护进程来完成的。</p><p>Udevd 守护进程所作的操作如下：</p><ol type="1"><li>内核通过内部的网络连接向 udevd 发送一个名为 uevent 的通知事件</li><li>udevd 从 uevent 中加载所有的属性</li><li>udevd 从 rule 中提取、过滤或者是更新相关内容</li></ol><p>可以使用 <code>udevadm monitor --property</code> 得到一个 uevent 的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ACTION=change</span><br><span class="line">DEVNAME=sde</span><br><span class="line">DEVPATH=/devices/pci0000:00/0000:00:1a.0/usb1/1-1/1-1.2/1-1.2:1.0/host4/</span><br><span class="line">target4:0:0/4:0:0:3/block/sde</span><br><span class="line">DEVTYPE=disk</span><br><span class="line">DISK_MEDIA_CHANGE=1</span><br><span class="line">MAJOR=8</span><br><span class="line">MINOR=64</span><br><span class="line">SEQNUM=2752</span><br><span class="line">SUBSYSTEM=block</span><br><span class="line">UDEV_LOG=3</span><br></pre></td></tr></table></figure><p>udev 规则是定义在一个以 .rules 为扩展名的文件中。那些文件主要放在两个位置：/usr/lib/udev/rules.d，这个目录用于存放系统安装的规则；/etc/udev/rules.d/ 这个目录是保留给自定义规则的。</p><p>定义那些规则的文件的命名惯例是使用一个数字作为前缀（比如，50-udev-default.rules），并且以它们在目录中的词汇顺序进行处理的。在 /etc/udev/rules.d 中安装的文件，会覆盖安装在系统默认路径中的同名文件。</p><p>下面是 udevd 规则的行为逻辑：</p><ol type="1"><li>udevd reads rules from start to finish of a rules file.</li><li>After reading a rule and possibly executing its action, udevd continues reading the current rules file for more applicable rules.</li><li>There are directives (such as GOTO) to skip over parts of rules files if necessary. These are usually placed at the top of a rules file to skip over the entire file if it’s irrelevant to a particular device that udevd is configuring.</li></ol><p>我们来看一下一个 /dev/sda 下面的符号链接，它被定义在 <code>lib/udev/rules.d/60-persistent-storage.rules</code> 当中，这个文件中有几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ATA</span><br><span class="line">KERNEL==&quot;sd*[!0-9]|sr*&quot;, ENV&#123;ID_SERIAL&#125;!=&quot;?*&quot;, SUBSYSTEMS==&quot;scsi&quot;, ATTRS&#123;vendor&#125;==&quot;ATA&quot;, IMPORT&#123;program&#125;=&quot;ata_id --export $devnode&quot;</span><br><span class="line"></span><br><span class="line"># ATAPI devices (SPC-3 or later)</span><br><span class="line">KERNEL==&quot;sd*[!0-9]|sr*&quot;, ENV&#123;ID_SERIAL&#125;!=&quot;?*&quot;, SUBSYSTEMS==&quot;scsi&quot;, ATTRS&#123;type&#125;==&quot;5&quot;,ATTRS&#123;scsi_level&#125;==&quot;[6-9]*&quot;, IMPORT&#123;program&#125;=&quot;ata_id --export $devnode&quot;</span><br></pre></td></tr></table></figure><p>通过内核的 SCSI 子系统，这些规则会与 AKA 硬盘以及 optical media 设备匹配，一般是通过文本的模式来匹配，比如 <code>"sd*[!0-9]|sr*"</code>.</p><blockquote><p>ATA 是一个广为使用的 IDE 和 EIDE设备相关的标准，意思是高级技术附件规格。ATA的硬盘分为 PATA 和 SATA，其中 P 代表的是并行、S代表的串行。目前 SATA 使用广泛，它的速度比 PATA 快太多，而且体积小、散热也更好。</p></blockquote><p>更多关于编写 udev 的规则，可参考这篇文章:&gt; <a href="https://linux.cn/article-9365-1.html">在 Linux 中如何编写基本的 udev 规则</a></p><h3 id="udev管理工具udevadm">udev管理工具：udevadm</h3><p>Udevadm 程序是 udev 的一个管理工具。你可以重新加载 udev 的规则，触发事件，最重要的一个特性是，你可以查找和探索系统的设备，或者是监控内核发出的 uevents 事件。</p><p>我们首先来看看怎么使用 udevadm 检查系统设备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info --query=all --name=/dev/sda </span><br></pre></td></tr></table></figure><p>下面是这条命令在我电脑上的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@scott-pc:/mnt/c/Users/Scott# udevadm info --query=all --name=/dev/sda</span><br><span class="line">P: /devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:0/block/sda</span><br><span class="line">N: sda</span><br><span class="line">L: 0</span><br><span class="line">E: DEVPATH=/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:0/block/sda</span><br><span class="line">E: DEVNAME=/dev/sda</span><br><span class="line">E: DEVTYPE=disk</span><br><span class="line">E: MAJOR=8</span><br><span class="line">E: MINOR=0</span><br><span class="line">E: SUBSYSTEM=block</span><br></pre></td></tr></table></figure><p>其中每一行代表了一个设备的属性，在上面的例子中：</p><ul><li>P: 最开始的那行，是 sysfs 设备路径</li><li>N: 设备节点，也就是给 /dev 下面文件的名字</li><li>S: 表明了设备节点的符号链接</li><li>E： 从 udevd 规则中找到的附加的信息</li></ul><h3 id="使用-udevadm-监控设备">使用 udevadm 监控设备</h3><p>你可以使用 <code>udevadm monitor</code> 来监控电脑上的设备，下面是它的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">KERNEL[658299.569485] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2 (usb)</span><br><span class="line">KERNEL[658299.569667] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0 (usb)</span><br><span class="line">KERNEL[658299.570614] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/host15 </span><br><span class="line">(scsi)</span><br><span class="line">KERNEL[658299.570645] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/ </span><br><span class="line">host15/scsi_host/host15 (scsi_host)</span><br><span class="line">UDEV [658299.622579] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2 (usb)</span><br><span class="line">UDEV [658299.623014] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0 (usb)</span><br><span class="line">UDEV [658299.623673] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/host15 </span><br><span class="line">(scsi)</span><br><span class="line">UDEV [658299.623690] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/</span><br><span class="line">host15/scsi_host/host15 (scsi_host)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><p>这里有重复的输出，因为默认会输出来自内核的消息，以及 udevd 处理的消息，可以指定 --kernel 选项只查看内核的消息，--udev 查看 udevd处理的消息，以及--property 则可以让你查看整个 uevent, 包括属性。</p><p>你也可以通过 subsystem 来 filter 这些消息,比如你只想要看到 SCSI 子系统的 kernel 的消息，可执行下面的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ udevadm monitor --kernel --subsystem-match=scsi</span><br></pre></td></tr></table></figure><p>关于更多 Udevadm 的使用，可以查看 udevadm(8) 的操作手册。udev 本身还有很多其他的知识，例如有一个守护进程叫做 udisksd, 它会监听事件，当有新的磁盘接入的时候，会自动向进程发送消息。</p><h2 id="深入理解scsi-和-linux-内核">深入理解：SCSI 和 Linux 内核</h2><p>这一小节我们会探讨 Linux 内核对于 SCSI 的支持，以增加对 Linux 内核架构的理解。如果是为了学习如何使用磁盘，你无需学习本小节中的内容。</p><p>我们先讲一个小背景，传统的SCSi硬件配置是一个主机适配器通过 SCSI总线连接了一系列的设备，如下图所示:</p><p><img src="https://s2.loli.net/2022/03/17/hYZJzEHWNAUKQXp.png" /></p><p>其中的电脑通过 SCSI Host Adapter 来与其他的 Disk 通信，每一个 Disk 都有唯一的 ID，对于每一个单独的 Disk，他们之间可以通过 SCSI 命令进行点对点的通信。</p><p>新版本的 SCSI，也就是 Serial Attached SCSI （SAS）提供了更好的性能，但在大部分机器上，也许找不到任何真正意义上的 SCSI 设备。</p><p>SATA 磁盘在你的系统上，也已 SCSI 设备的形式出现，但是它们还是有一点不同的，因为它们中大部分都是通过 libata 库 中的翻译层通信。</p><p>这些说明了什么呢？假设我们查看系统上的设备，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lsscsi</span><br><span class="line">[0:0:0:0]   disk    ATA       WDC WD3200AAJS-2  01.0  /dev/sda</span><br><span class="line">[1:0:0:0]   cd/dvd  Slimtype  DVD A DS8A5SH     XA15  /dev/sr0</span><br><span class="line">[2:0:0:0]   disk    USB2.0    CardReader CF     0100  /dev/sdb</span><br><span class="line">[2:0:0:1]   disk    USB2.0    CardReader SM XD  0100  /dev/sdc</span><br><span class="line">[2:0:0:2]   disk    USB2.0    CardReader MS     0100  /dev/sdd</span><br><span class="line">[2:0:0:3]   disk    USB2.0    CardReader SD     0100  /dev/sde</span><br><span class="line">[3:0:0:0]   disk    FLASH     Drive UT_USB20    0.00  /dev/sdf</span><br></pre></td></tr></table></figure><p>先看方括号中的内容，从左至右分别是 SCSI 适配器号，SCSI 总线号，设备的 SCSI ID，以及 LUN（Logical Unit Number）逻辑快号。</p><p>上面的例子中，可以看到有四个适配器(scsi0-3)，每一个都有一个总线（号码都从0开始），每一个总线上，也只有一个设备。USB 读卡器在 2:0:0 上有四个逻辑单元，通过LUN 编号可以很容易看出这一点，即内核给每个逻辑单元都分配了一个 device file.</p><p>Figure 3-2 是内核中的驱动与接口的结构：</p><figure><img src="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png" alt="Figure 3-2" /><figcaption aria-hidden="true">Figure 3-2</figcaption></figure><ul><li>图中上面的层负责处理设备集的操作，比如 sd(SCSI Disk) 在这层；它知道如何翻译来自内核块设备接口的命令，将它变成磁盘特定的、SCSI 协议的指令</li><li>中间层，连接顶层和底层，传输 SCSI 消息，track 所有的SCSI总线，以及插入到系统上的设备</li><li>执行特定的硬件操作。</li></ul><blockquote><p>The top and bottom layers contain many different drivers, but it’s important to remember that, for any given device file on your system, the kernel (nearly always) uses one top-layer driver and one lower-layer driver. For the disk at /dev/sda in our example, the kernel uses the sd top-layer driver and the ATA bridge lower-layer driver.</p></blockquote><h3 id="usb-存储-and-scsi">USB 存储 and SCSI</h3><p>为了使 SCSI 子系统与常见的 USB 存储硬件通信，如图 3-2 所示，内核需要的不仅仅是一个较低层的 SCSI 驱动程序。 以 /dev/sdf 为代表的 USB 闪存驱动器可以理解 SCSI 命令，但要真正与驱动器通信，内核需要知道如何通过 USB 系统进行通信。</p><p>从抽象结构上来看，USB 和 SCSI 很像，它们都有 device classes, buses, host controller。 所以 Linux 在内核中一个 USB Subsystem.</p><p>就像 SCSI 子系统在其组件之间传递 SCSI 命令一样，USB 子系统在其组件之间传递 USB 消息。 甚至还有一个类似于 lsscsi 的 lsusb 命令。</p><p>这里有趣的在于，USB 子系统在一头使用的是 USB 命令，而另外一头则使用的是 SCSI 命令。</p><p>在结构上，USB 子系统和 SCSI 子系统是分开的，因为两个子系统不应该共享同一个驱动，为了让它们可以通信，在 SCSI 子系统中，还有一个 lower-layer 的 SCSI bridge.</p><h3 id="scsi-和-ata">SCSI 和 ATA</h3><p>SATA 硬盘和其他的CD/DVD设备都使用了 SATA 接口。为了连接内核中 SATA 专用的驱动与 SCSI 子系统，内核利用了一个 bridge driver, 内核使用了一个桥接驱动程序，就像 USB 驱动器一样，但具有不同的机制和额外的复杂性。 光驱使用 ATAPI，一种以 ATA 协议编码的 SCSI 命令版本。 但是，硬盘不使用 ATAPI，也不编码任何 SCSI 命令！</p><p>Linux 内核使用名为 libata 的库的一部分来协调 SATA（和 ATA）驱动器与 SCSI 子系统。</p><h3 id="通用-scsi-设备">通用 SCSI 设备</h3><p>当用户空间进程与 SCSI 子系统通信时，它通常通过块设备层和/或位于 SCSI 设备类驱动程序（如 sd 或 sr）之上的另一个其他内核服务来进行。 换句话说，大多数用户进程从不需要知道关于 SCSI 设备或其命令的任何信息。</p><p>但是，用户进程可以绕过设备类驱动程序,直接向设备提供 SCSI 协议命令。 例如可以在 lsscsi 命令后添加 -g 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lsscsi -g</span><br><span class="line">[0:0:0:0]   disk    ATA       WDC WD3200AAJS-2  01.0  /dev/sda 1/dev/sg0</span><br><span class="line">[1:0:0:0]   cd/dvd  Slimtype  DVD A DS8A5SH     XA15  /dev/sr0   /dev/sg1</span><br><span class="line">[2:0:0:0]   disk    USB2.0    CardReader CF     0100  /dev/sdb   /dev/sg2</span><br><span class="line">[2:0:0:1]   disk    USB2.0    CardReader SM XD  0100  /dev/sdc   /dev/sg3</span><br><span class="line">[2:0:0:2]   disk    USB2.0    CardReader MS     0100  /dev/sdd   /dev/sg4</span><br><span class="line">[2:0:0:3]   disk    USB2.0    CardReader SD     0100  /dev/sde   /dev/sg5</span><br><span class="line">[3:0:0:0]   disk    FLASH     Drive UT_USB20    0.00  /dev/sdf   /dev/sg6</span><br></pre></td></tr></table></figure><p>为什么要使用通用设备？ 答案与内核中代码的复杂性有关。 随着任务变得越来越复杂，最好将它们排除在内核之外。 考虑 CD/DVD 写入和读取。 读取光盘是一个相当简单的操作，并且有一个专门的内核驱动程序。</p><p>然而，写入光盘比读取要困难得多，并且没有关键的系统服务依赖于写入的动作。 没有理由用这个活动来增加内核空间。 因此，要在 Linux 中写入光盘，您需要运行一个与通用 SCSI 设备（例如 /dev/sg1）对话的用户空间程序。 这个程序可能比内核驱动程序效率低一点，但它更容易构建和维护。</p><h3 id="单个设备的多种访问方法">单个设备的多种访问方法</h3><p>图 3-3 显示了 Linux SCSI 子系统从用户空间访问光驱的两个方法（sr 和 sg）（省略了 SCSI 底层以下的任何驱动程序）。</p><p>进程 A 使用 sr 驱动程序从驱动器读取，进程 B 使用 sg 驱动程序写入驱动器。 但是，像这样的进程通常不会同时运行以访问同一设备。</p><figure><img src="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png" alt="3-3" /><figcaption aria-hidden="true">3-3</figcaption></figure><p>在图 3-3 中，进程 A 从块设备中读取数据。 但是用户进程真的以这种方式读取数据吗？ 通常，答案是否定的。这种访问不是直接的，因为在块设备之上还有更多的层，甚至更多的硬盘访问点，我们将在下一章中学习。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Linux 的设备文件系统、系统设备路径与设备名、udev, SCSI 等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="How Linux Works" scheme="https://scottzhang.pro/categories/How-Linux-Works/"/>
    
    
    <category term="Linux" scheme="https://scottzhang.pro/tags/Linux/"/>
    
    <category term="Operating System" scheme="https://scottzhang.pro/tags/Operating-System/"/>
    
    <category term="udev" scheme="https://scottzhang.pro/tags/udev/"/>
    
    <category term="SCSI" scheme="https://scottzhang.pro/tags/SCSI/"/>
    
  </entry>
  
  <entry>
    <title>设计数据密集型应用-数据系统 P2</title>
    <link href="https://scottzhang.pro/article/ec2d337d.html"/>
    <id>https://scottzhang.pro/article/ec2d337d.html</id>
    <published>2022-03-20T15:07:08.000Z</published>
    <updated>2022-03-20T15:10:33.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「设计数据密集型应用」书中第三、四章内容的思维导图。包括：存储与检索、编码数据等内容。</p></blockquote><span id="more"></span><h1 id="存储与检索">3. 存储与检索</h1><h2 id="驱动数据库的数据结构">驱动数据库的数据结构</h2><figure><img src="https://s2.loli.net/2022/03/19/e2KTmgGZcw9th57.png" alt="驱动数据库的数据结构" /><figcaption aria-hidden="true">驱动数据库的数据结构</figcaption></figure><h3 id="散列索引">散列索引</h3><figure><img src="https://s2.loli.net/2022/03/19/k1KDrNagqEcGRtl.png" alt="以类 CSV 格式存储键值对的日志，并使用内存散列映射进行索引" /><figcaption aria-hidden="true">以类 CSV 格式存储键值对的日志，并使用内存散列映射进行索引</figcaption></figure><h3 id="sstable">SSTable</h3><figure><img src="https://s2.loli.net/2022/03/19/EVPSAbnZQypHuks.png" alt="驱动数据库的数据结构" /><figcaption aria-hidden="true">驱动数据库的数据结构</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/19/R9mu5kEyvLtP3d2.png" alt="键值更新日志压缩" /><figcaption aria-hidden="true">键值更新日志压缩</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/19/LZ4NIC9WTB2t3bJ.png" alt="同时执行压缩和分段合并" /><figcaption aria-hidden="true">同时执行压缩和分段合并</figcaption></figure><p>SSTable 的优势</p><ol type="1"><li>即使文件大于可用内存，合并段的操作仍然是简单而高效的。</li><li>为了在文件中找到一个特定的键，你不再需要在内存中保存所有键的索引。</li><li>由于读取请求无论如何都需要扫描所请求范围内的多个键值对，因此可以将这些记录分组为块（block），并在将其写入硬盘之前对其进行压缩</li></ol><h2 id="事务处理还是存储分析">3.2 事务处理还是存储分析</h2><figure><img src="https://s2.loli.net/2022/03/19/m6WxNfZC5PpsOhk.png" alt="事务处理分析" /><figcaption aria-hidden="true">事务处理分析</figcaption></figure><h3 id="olap-vs-oltp">OLAP vs OLTP</h3><table><thead><tr class="header"><th>属性</th><th>事务处理系统 OLTP</th><th>分析系统 OLAP</th></tr></thead><tbody><tr class="odd"><td>主要读取模式</td><td>查询少量记录，按键读取</td><td>在大批量记录上聚合</td></tr><tr class="even"><td>主要写入模式</td><td>随机访问，写入要求低延时</td><td>批量导入（ETL）或者事件流</td></tr><tr class="odd"><td>主要用户</td><td>终端用户，通过 Web 应用</td><td>内部数据分析师，用于决策支持</td></tr><tr class="even"><td>处理的数据</td><td>数据的最新状态（当前时间点）</td><td>随时间推移的历史事件</td></tr><tr class="odd"><td>数据集尺寸</td><td>GB ~ TB</td><td>TB ~ PB</td></tr></tbody></table><h3 id="数据仓库">数据仓库</h3><p>OLTP 系统往往对业务运作至关重要，因而通常会要求 高可用 与 低延迟。所以 DBA 会密切关注他们的 OLTP 数据库，他们通常不愿意让业务分析人员在 OLTP 数据库上运行临时的分析查询，因为这些查询通常开销巨大，会扫描大部分数据集，这会损害同时在执行的事务的性能。</p><p>从 OLTP 数据库中提取数据（使用定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中。将数据存入仓库的过程称为 “抽取 - 转换 - 加载（ETL）”。</p><figure><img src="https://s2.loli.net/2022/03/19/1q2SbhHmzZoeA3i.png" alt="事务处理分析-数据仓库" /><figcaption aria-hidden="true">事务处理分析-数据仓库</figcaption></figure><h3 id="列式存储">列式存储</h3><figure><img src="https://s2.loli.net/2022/03/19/29WjEJDOoRHq5lp.png" alt="列式存储" /><figcaption aria-hidden="true">列式存储</figcaption></figure><h1 id="编码与演化">4. 编码与演化</h1><h2 id="编码数据的格式">编码数据的格式</h2><figure><img src="https://s2.loli.net/2022/03/20/OMzifUsVo5aNhdj.png" alt="编码与演化-格式1" /><figcaption aria-hidden="true">编码与演化-格式1</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/20/WHOUvbmGMj4wnks.png" alt="编码与演化-格式2" /><figcaption aria-hidden="true">编码与演化-格式2</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/20/Wmj9cRuQgToqLyz.png" alt="编码与演化-模式" /><figcaption aria-hidden="true">编码与演化-模式</figcaption></figure><h2 id="数据流的类型">数据流的类型</h2><figure><img src="https://s2.loli.net/2022/03/20/cpGuNimlo9SZ6zK.png" alt="数据流" /><figcaption aria-hidden="true">数据流</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;「设计数据密集型应用」书中第三、四章内容的思维导图。包括：存储与检索、编码数据等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计数据密集型应用" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="database" scheme="https://scottzhang.pro/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>设计数据密集型应用-数据系统 P1</title>
    <link href="https://scottzhang.pro/article/752462c7.html"/>
    <id>https://scottzhang.pro/article/752462c7.html</id>
    <published>2022-03-18T13:44:15.000Z</published>
    <updated>2022-03-18T13:47:06.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「设计数据密集型应用」书中第一二章内容的思维导图。包括：第一章关于可靠性、可伸缩性、可维护性以及第二章介绍的数据模型与查询语言。</p></blockquote><span id="more"></span><p>设计数据密集型应用-数据系统</p><h1 id="可靠性可伸缩性可维护性">1. 可靠性、可伸缩性、可维护性</h1><h2 id="可靠性">1.1 可靠性</h2><figure><img src="https://s2.loli.net/2022/03/18/oMFv6ndUyYaERgm.png" alt="1-1" /><figcaption aria-hidden="true">1-1</figcaption></figure><h2 id="可伸缩性">1.2 可伸缩性</h2><figure><img src="https://s2.loli.net/2022/03/18/MZfmFU98SGbJHe2.png" alt="1-2" /><figcaption aria-hidden="true">1-2</figcaption></figure><h2 id="可维护性">1.3 可维护性</h2><figure><img src="https://s2.loli.net/2022/03/18/SO3gwFKtd8U7iaL.png" alt="1-3" /><figcaption aria-hidden="true">1-3</figcaption></figure><h1 id="数据模型与查询语言">2. 数据模型与查询语言</h1><h2 id="关系模型与文档模型">2.1 关系模型与文档模型</h2><figure><img src="https://s2.loli.net/2022/03/18/an5Gom1VSOcqBp6.png" alt="关系模型与文档模型2-1.png" /><figcaption aria-hidden="true">关系模型与文档模型2-1.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/18/rS9UTdP7OC1YJqv.png" alt="关系模型与文档模型2-2.png" /><figcaption aria-hidden="true">关系模型与文档模型2-2.png</figcaption></figure><h2 id="数据查询语言">2.2 数据查询语言</h2><figure><img src="https://s2.loli.net/2022/03/18/Gf6BhxwE3jTVDcr.png" alt="数据查询语言2-3.png" /><figcaption aria-hidden="true">数据查询语言2-3.png</figcaption></figure><h2 id="图数据模型">2.3 图数据模型</h2><figure><img src="https://s2.loli.net/2022/03/18/7rQefncS3tWBLd6.png" alt="图数据示例2-3-1.png" /><figcaption aria-hidden="true">图数据示例2-3-1.png</figcaption></figure><p>一个图数据模型示例。可以从社交网络或系谱数据库中获得：它显示了两个人，来自爱达荷州的 Lucy 和来自法国 Beaune 的 Alain。他们已婚，住在伦敦。</p><figure><img src="https://s2.loli.net/2022/03/18/uFSEp4mULksXdYo.png" alt="图数据模型2-3-2.png" /><figcaption aria-hidden="true">图数据模型2-3-2.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/18/ajBF7HSo9ZT8AOR.png" alt="图数据模型2-3-3.png" /><figcaption aria-hidden="true">图数据模型2-3-3.png</figcaption></figure><p>在历史上，数据最开始被表示为一棵大树（层次数据模型），但是这不利于表示多对多的关系，所以发明了关系模型来解决这个问题。最近，开发人员发现一些应用程序也不适合采用关系模型。新的非关系型 “NoSQL” 数据存储在两个主要方向上存在分歧：</p><p>文档数据库 的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。 图形数据库 用于相反的场景：任意事物都可能与任何事物相关联。 这三种模型（文档，关系和图形）在今天都被广泛使用，并且在各自的领域都发挥很好。一个模型可以用另一个模型来模拟 — 例如，图数据可以在关系数据库中表示 — 但结果往往是糟糕的。这就是为什么我们有着针对不同目的的不同系统，而不是一个单一的万能解决方案。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;「设计数据密集型应用」书中第一二章内容的思维导图。包括：第一章关于可靠性、可伸缩性、可维护性以及第二章介绍的数据模型与查询语言。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计数据密集型应用" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="database" scheme="https://scottzhang.pro/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Linux-基本命令与目录结构</title>
    <link href="https://scottzhang.pro/article/fa8d7a03.html"/>
    <id>https://scottzhang.pro/article/fa8d7a03.html</id>
    <published>2022-03-02T07:06:53.000Z</published>
    <updated>2022-03-02T07:19:54.660Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章涵盖了Linux中关于基本命令、环境变量、特殊符号、Shell 编辑工具、帮助文档查询、标准输入输出、符号链接、解压缩、超级用户以及目录的结构介绍等内容。</p></blockquote><span id="more"></span><h2 id="关于-unix-和-linux">关于 Unix 和 Linux</h2><p>Linux is a Unix flavor at heart. You’ll see the word Unix in this chapter more than Linux because you can take what you learn straight over to BSD and other Unix-flavored systems.</p><h2 id="bourne-shell-binsh">Bourne Shell: /bin/sh</h2><p>A shell is a program that runs commands.</p><p>现在有很多的 Shell，但大部分的都是起源于 Bourne shell (/bin/sh)，这是贝尔实验室早期开发给 Unix 用的。</p><p>Linux 也有一个优化过的 Shell 叫 <code>bash</code>，全称是 bourne again shell.</p><h2 id="基本命令">基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">cp</span><br><span class="line">mv</span><br><span class="line">rm</span><br><span class="line">touch</span><br><span class="line">mkdir</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">grep</span><br><span class="line">less</span><br><span class="line">more</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">diff 对比两个文件不同</span><br><span class="line">file 查看一个文件的格式</span><br><span class="line">find</span><br><span class="line">head</span><br><span class="line">tail</span><br><span class="line">sort</span><br><span class="line">passwd 改密码</span><br></pre></td></tr></table></figure><h2 id="环境和-shell-变量">环境和 Shell 变量</h2><p>Shell 环境下可以保存一些变量:</p><p><img src="https://s2.loli.net/2022/03/01/U13k84fPnlTDwYp.png" /></p><p>如果希望当 shell 启动的时候就将一些变量存起来，则可通过环境变量。</p><p>The main difference between environment and shell variables is that the operating system passes all of your shell’s environment variables to programs that the shell runs, whereas shell variables cannot be accessed in the commands that you run.</p><h2 id="命令地址">命令地址</h2><p><code>Path</code> 是一个特殊的环境变量，我们输入的指令 shell 会去这些路径中寻找程序，例如这是我的电脑上 <code>Path</code> 的值：</p><p><img src="https://s2.loli.net/2022/03/01/6Z1ztSubRsA3vlP.png" /></p><p>这个地址中的可以编辑，添加。</p><h2 id="特殊符号">特殊符号</h2><table><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 66%" /></colgroup><thead><tr class="header"><th>符号</th><th>符号名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>*</td><td>star, asterisk</td><td>Regular expression, glob character</td></tr><tr class="even"><td>.</td><td>dot</td><td>Current directory, file/hostname delimiter</td></tr><tr class="odd"><td>!</td><td>bang</td><td>Negation, command history</td></tr><tr class="even"><td>|</td><td>pipe</td><td>Command pipes</td></tr><tr class="odd"><td>/</td><td>(forward) slash</td><td>Directory delimiter, search command</td></tr><tr class="even"><td>\</td><td>backslash</td><td>Literals, macros (never directories)</td></tr><tr class="odd"><td>$</td><td>dollar</td><td>Variables, end of line</td></tr><tr class="even"><td>'</td><td>tick, (single) quote</td><td>Literal strings</td></tr><tr class="odd"><td>`</td><td>backtick, backquote</td><td>Command substitution</td></tr><tr class="even"><td>"</td><td>double quote</td><td>Semi-literal strings</td></tr><tr class="odd"><td>^</td><td>caret</td><td>Negation, beginning of line</td></tr><tr class="even"><td>~</td><td>tilde, squiggle</td><td>Negation, directory shortcut</td></tr><tr class="odd"><td>#</td><td>hash, sharp, pound</td><td>Comments, preprocessor, substitutions</td></tr><tr class="even"><td>[ ]</td><td>(square) brackets</td><td>Ranges</td></tr><tr class="odd"><td>{ }</td><td>braces, (curly) brackets</td><td>Statement blocks, ranges</td></tr><tr class="even"><td>_</td><td>underscore, under</td><td>Cheap substitute for a space used when spaces aren’t wanted or allowed, or when autocomplete algorithms get confused</td></tr></tbody></table><h2 id="shell-中编辑">Shell 中编辑</h2><table><thead><tr class="header"><th>快捷键</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CTRL-B</td><td>Move the cursor left</td></tr><tr class="even"><td>CTRL-F</td><td>Move the cursor right</td></tr><tr class="odd"><td>CTRL-P</td><td>View the previous command (or move the cursor up)</td></tr><tr class="even"><td>CTRL-N</td><td>View the next command (or move the cursor down)</td></tr><tr class="odd"><td>CTRL-A</td><td>Move the cursor to the beginning of the line</td></tr><tr class="even"><td>CTRL-E</td><td>Move the cursor to the end of the line</td></tr><tr class="odd"><td>CTRL-W</td><td>Erase the preceding word</td></tr><tr class="even"><td>CTRL-U</td><td>Erase from cursor to beginning of line</td></tr><tr class="odd"><td>CTRL-K</td><td>Erase from cursor to end of line</td></tr><tr class="even"><td>CTRL-Y</td><td>Paste erased text (for example, from CTRL-U)</td></tr></tbody></table><h2 id="查询帮助文档">查询帮助文档</h2><p><code>man ls</code> 查询 ls 的帮助；<code>man -k kerword</code> 查询有 keyword 关键字的帮助，结果你会发现有些数字，这些数字是告诉你这个命令在哪个分类下出现，数字对应的分类信息如下</p><table><thead><tr class="header"><th>Section</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>1</td><td>User commands</td></tr><tr class="even"><td>2</td><td>Kernel system calls</td></tr><tr class="odd"><td>3</td><td>Higher-level Unix programming library documentation</td></tr><tr class="even"><td>4</td><td>Device interface and driver information</td></tr><tr class="odd"><td>5</td><td>File descriptions (system configuration files)</td></tr><tr class="even"><td>6</td><td>Games</td></tr><tr class="odd"><td>7</td><td>File formats, conventions, and encodings (ASCII, suffixes, and so on)</td></tr><tr class="even"><td>8</td><td>System commands and servers</td></tr></tbody></table><h2 id="标准输入输出和错误">标准输入输出和错误</h2><ul><li><code>command &gt; file</code> # 命令的输出存到 file</li><li><code>command &gt;&gt; file</code> # 命令的输出追加到 file</li><li><code>command1 | command2</code> # 命令1 的输出作为命令2 的输入</li><li><code>head &lt; /proc/cpuinfo#</code> 文件内容到输出</li></ul><p>如果执行一个命令会报错，但希望将报错的内容单独保存到其他文件中，可使用下图的命令，The number <code>2</code> specifies the stream ID that the shell modifies. Stream ID 1 is standard output (the default), and 2 is standard error. <code>&gt;&amp;</code> notation will send both standard output and standard error to the file named f</p><p><img src="https://s2.loli.net/2022/03/01/utf8BAJgk43Fnbz.png" /></p><h2 id="管理进程">管理进程</h2><h3 id="列出进程">列出进程</h3><p>在系统中，每个进程都有一个 PID 作为标识进程的唯一 ID，在 Linux 可以使用 <code>ps</code> 命令直接查看所有进程的情况:</p><p><img src="https://s2.loli.net/2022/03/02/X3bOYeqWzfl9Ex4.png" /></p><ul><li>PID, The process ID.</li><li>TTY, The terminal device where the process is running. More about this later.</li><li>STAT, what the process is doing and where its memory resides. For example, S means sleeping and R means running. (See the ps(1) manual page for a description of all the symbols.)</li><li>TIME, the total amount of time that the process has spent running instructions on the processor. Remember that because processes don’t run constantly, this is different from the time since the process started (or “wall-clock time”).</li><li>COMMAND, This one might seem obvious as the command used to run the program, but be aware that a process can change this field from its original value. Furthermore, the shell can perform glob expansion, and this field will reflect the expanded command instead of what you enter at the prompt.</li></ul><blockquote><p>Mac 下没有 STAT 这列</p></blockquote><p>Ps 还有一些选项可以指定，方便我们定义输出：</p><ul><li><code>ps x</code> Show all of your running processes.</li><li><code>ps ax</code> Show all processes on the system, not just the ones you own.</li><li><code>ps u</code> Include more detailed information on processes.</li><li><code>ps w</code> Show full command names, not just what fits on one line.</li></ul><h3 id="杀死进程">杀死进程</h3><p>杀死一个进程使用 kill 指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill pid, 让内核向进程发送一个 TERM 信号（默认），停止该进程</span><br><span class="line">kill -STOP pid, 发送 STOP 信号， 冻结该进程，冻结的进程还会存在于内存</span><br><span class="line">kill -CONT pid, 恢复一个冻结的进程</span><br></pre></td></tr></table></figure><p>发送上面的指令可能你还会看到进程存在，因为操作系统会给进程机会去处理现场，进程也可能直接忽略你发送的信号，这时候你可以强制杀死一个进程，不给其任何机会</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -KILL pid</span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><h3 id="作业管理">作业管理</h3><p>作业管理，allows you to suspend and switch between programs you’re using。</p><p>For example, you can send a TSTP signal with CTRL-Z and then start the process again by entering fg (bring to foreground) or bg (move to background; see the next section).</p><p>可使用 <code>jobs</code> 查看是否有什么作业正在运行。</p><p>用 <code>screen</code> 或者 <code>tmux</code> 来管理作业是一个更好的选择。</p><h3 id="进程放到后台使用">进程放到后台使用</h3><p>如果你有一个解压大量文件的需求，当你运行的时候，只有当全部任务结束你才会看到输出，这时候你也没办法做什么，但你可以将这个任务放到后台去做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip file.gz &amp;</span><br></pre></td></tr></table></figure><p>这会给你一个 PID 告诉你正在处理这个任务的进程。</p><p>如果这个后台运行的进程需要标准输入，那么它会进入冻结状态，可以使用 <code>fg</code> 将其带入前台，如果这个后台进程报错了，那你会收到报错的信息（即便你当时正在忙别的事情😂），如果不想被打扰，最好将其错误信息重定向到其他地方（前面介绍过）.</p><h2 id="文件模式和权限">文件模式和权限</h2><p>所有 Unix 文件都有一组权限来决定你是否可以读或者写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 juser somegroup 7041  Mar 26 19:34  endnotes.html</span><br></pre></td></tr></table></figure><p>最开始的 <code>-rw-r--r--</code> 表明了该文件的权限，其含义如下:</p><p><img src="https://s2.loli.net/2022/03/02/GIVpzYK9hBNSUxC.png" /></p><p>第一个 - 往后开始，三个一组为权限组，其中各个字母的意思如下：</p><ul><li>r means that the file is readable.</li><li>w means that the file is writable.</li><li>x means that the file is executable (you can run it as a program).</li><li>- means “nothing” (more specifically, the permission for that slot in the set has not been granted).</li><li>有些会是s，用来表示用户执行这个程序时，将以这个程序所有者的身份执行，可以直接设置s权限，而无需先有x，但是有可能未生效（将以大S表示）</li><li>Mac OS X文件系统还有一个的附加属性@.</li></ul><h2 id="权限修改">权限修改</h2><p>使用 <code>chmod</code> 来修改权限，如对 group 和 others 增加写权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod g+r file</span><br><span class="line">chmod o+r file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者通过一条命令</span></span><br><span class="line">chmod go+r file</span><br></pre></td></tr></table></figure><p>你可能会看到通过数字来指定权限的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sets all permission bits at once</span></span><br><span class="line">chmod 644 file</span><br></pre></td></tr></table></figure><p>无需记住所有数字的意思，常用的权限可以参考下表：</p><table style="width:100%;"><colgroup><col style="width: 14%" /><col style="width: 57%" /><col style="width: 28%" /></colgroup><thead><tr class="header"><th>Mode</th><th>Meaning</th><th>Used for</th></tr></thead><tbody><tr class="odd"><td>644</td><td>user: read/write; group, other: read</td><td>files</td></tr><tr class="even"><td>600</td><td>user: read/write; group, other: none</td><td>files</td></tr><tr class="odd"><td>755</td><td>user: read/write/execute; group, other: read/execute</td><td>directories, programs</td></tr><tr class="even"><td>700</td><td>user: read/write/execute; group, other: none</td><td>directories, programs</td></tr><tr class="odd"><td>711</td><td>user: read/write/execute; group, other: execute</td><td>directories</td></tr></tbody></table><p>关于目录的权限：</p><ul><li>You can list the contents of a directory if it’s readable, but you can only access a file in a directory if the directory is executable.</li><li>You need both in most cases;</li></ul><p><code>unmask</code> 命令:</p><ul><li>ou can specify a set of default permissions with the umask shell command, which applies a predefined set of permissions to any new file you create.</li><li>use umask 022 if you want everyone to be able to see all of the files and directories that you create, and use umask 077 if you don’t.</li></ul><h2 id="符号链接">符号链接</h2><p>symbolic link is a file that points to another file or a directory, effectively creating an alias (like a shortcut in Windows). Symbolic links offer quick access to obscure directory paths.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 ruser users  11 Feb 27 13:52  somedir -&gt; /home/origdir</span><br></pre></td></tr></table></figure><p>若符号链接代表的文件不存在，则依赖该文件的命令会出错，除了 <code>ls file</code>。</p><p>通过符号链接，你无法知道指向的文件或者文件夹的特征，你必须访问该路径去看了才知道，而且一个符号链接可以指向另外一个符号链接，这种被称为 chained symbolic links.</p><p>创建一个符号链接可以通过下面的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -s 指定为软链接，若没有则是硬链接</span><br><span class="line">ln -s target linkname</span><br></pre></td></tr></table></figure><blockquote><p>注意不要将 target 和 linkname 搞反了，否则会发生的事情就是：creates a link named target inside linkname, and the link will point to itself unless linkname is a full path.</p></blockquote><p>符号链接可能还有一个问题是，你以为你编辑的是一个文件（可以编辑），但其实它是一个符号链接。</p><p>符号链接本质上是创建一个新的文件，这个文件保存的是目标文件的地址，而硬链接则是指向文件系统中底层的数据。</p><ul><li>当对一个文件创建了硬链接，如果对硬链接修改，那么原始文件也会被修改</li><li>当原始文件被删除，访问硬链接还可以看到原始文件内容，因为底层的文件数据存在硬链接这个引用，并未被真的删除；访问软链接则会提示原始文件已经不见。</li><li>原始文件被删除后，当向硬链接追加内容，硬链接文件内容会有原始内容和新内容；软连接则会创建一个新文件，并将新内容写入。</li></ul><h2 id="解压缩">解压缩</h2><ul><li><code>gzip</code>, The program gzip (GNU Zip) is one of the current standard Unix compression programs. 但无法压缩多个文件.</li><li><code>tar</code>, 可压缩多个文件，细节如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 压缩</span><br><span class="line"># c, create mode</span><br><span class="line"># v, 显示输入，两个v则显示更多细节</span><br><span class="line"># f, 指定要压缩的文件</span><br><span class="line">tar cvf archive.tar file1 file2 ...</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar xvf archive.tar</span><br><span class="line"># x, 解压模式</span><br></pre></td></tr></table></figure><p>在解压一个文件之前，先查看压缩文件内有哪些东西是有必要的，可以通过 <code>t</code> 模式来实现。</p><p>解压时的权限控制： consider using the p option to preserve permissions. Use this in extract mode to override your umask and get the exact permissions specified in the archive.</p><p>压缩文件有时候会有多重压缩的情况，比如你可能看到一个这样的文件: <code>file.tar.gz</code>，解压这种文件需要从右往左使用对应工具解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunzip file.tar.gz</span><br><span class="line">tar xvf file.tar</span><br></pre></td></tr></table></figure><p>但分别解压是比较慢的，需要两次磁盘读写和io时间，可以利用管道来处理:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat file.tar.gz | tar xvf -</span><br></pre></td></tr></table></figure><p><code>zcat</code> 相当于 <code>gunzip -dc</code>, 其中 d 的意思是解压，c 的意思是将结果放到标准输出。</p><p><code>zcat</code> 使用非常频繁, 所以 tar 将其放在内置参数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar ztvf file.tar.gz</span><br></pre></td></tr></table></figure><p>其他的解压工具还有 <code>xz</code> 和 <code>bzip2</code>.</p><h2 id="linux-目录结构">Linux 目录结构</h2><p>目录结构一般如下图所示：</p><p><img src="https://s2.loli.net/2022/03/02/vRuS1hNDzWUI2Hl.png" /></p><hr /><p><strong>一般的目录文件夹介绍：</strong></p><ul><li>/bin Contains ready-to-run programs (also known as executables), including most of the basic Unix commands such as ls and cp. Most of the programs in /bin are in binary format, having been created by a C compiler, but some are shell scripts in modern systems.</li><li>/dev Contains device files. You’ll learn more about these in Chapter 3.</li><li>/etc This core system configuration directory (pronounced EHT-see) contains the user password, boot, device, networking, and other setup files.</li><li>/home Holds home (personal) directories for regular users. Most Unix installations conform to this standard.</li><li>/lib An abbreviation for library, this directory holds library files containing code that executables can use. There are two types of libraries: static and shared. The /lib directory should contain only shared libraries, but other lib directories, such as /usr/lib, contain both varieties as well as other auxiliary files. (We’ll discuss shared libraries in more detail in Chapter 15.)</li><li>/proc Provides system statistics through a browsable directory-and-file interface. Much of the /proc subdirectory structure on Linux is unique, but many other Unix variants have similar features. The /proc directory contains information about currently running processes as well as some kernel parameters.</li><li>/run Contains runtime data specific to the system, including certain process IDs, socket files, status records, and, in many cases, system logging. This is a relatively recent addition to the root directory; in older systems, you can find it in /var/run. On newer systems, /var/run is a symbolic link to /run.</li><li>/sys This directory is similar to /proc in that it provides a device and system interface. You’ll read more about /sys in Chapter 3.</li><li>/sbin The place for system executables. Programs in /sbin directories relate to system management, so regular users usually do not have /sbin components in their command paths. Many of the utilities found here don’t work if not run as root.</li><li>/tmp A storage area for smaller, temporary files that you don’t care much about. Any user may read to and write from /tmp, but the user may not have permission to access another user’s files there. Many programs use this directory as a workspace. If something is extremely important, don’t put it in /tmp because most distributions clear /tmp when the machine boots and some even remove its old files periodically. Also, don’t let /tmp fill up with garbage because its space is usually shared with something critical (the rest of /, for example).</li><li>/usr Although pronounced “user,” this subdirectory has no user files. Instead, it contains a large directory hierarchy, including the bulk of the Linux system. Many of the directory names in /usr are the same as those in the root directory (like /usr/bin and /usr/lib), and they hold the same type of files. (The reason that the root directory does not contain the complete system is primarily historic—in the past, it was to keep space requirements low for the root.)</li><li>/var The variable subdirectory, where programs record information that can change over the course of time. System logging, user tracking, caches, and other files that system programs create and manage are here. (You’ll notice a /var/tmp directory here, but the system doesn’t wipe it on boot.)</li></ul><p><strong>其他 root 目录下的子文件夹：</strong></p><ul><li>/boot Contains kernel boot loader files. These files pertain only to the very first stage of the Linux startup procedure, so you won’t find information about how Linux starts up its services in this directory. See Chapter 5 for more about this.</li><li>/media A base attachment point for removable media such as flash drives that is found in many distributions.</li><li>/opt This may contain additional third-party software. Many systems don’t use /opt.</li></ul><p><strong>其他用户目录下存在的子文件夹：</strong></p><ul><li>/include Holds header files used by the C compiler.</li><li>/local Is where administrators can install their own software. Its structure should look like that of / and /usr.</li><li>/man Contains manual pages.</li><li>/share Contains files that should work on other kinds of Unix machines with no loss of functionality. These are usually auxiliary data files that programs and libraries read as necessary. In the past, networks of machines would share this directory from a file server, but today a share directory used in this manner is rare because there are no realistic space restraints for these kinds of files on contemporary systems. Instead, on Linux distributions, you’ll find /man, /info, and many other subdirectories here because it is an easily understood convention.</li></ul><p><strong>内核路径</strong></p><p>在 Linux 中，内核一般放在 /vmlinuz or /boot/vmlinuz，在系统启动的时候，boot loader 会启动内核。关于 boot loader 会在之后的文章中介绍。</p><h2 id="以超级用户执行命令">以超级用户执行命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vipw</span><br></pre></td></tr></table></figure><p>可通过 <code>/etc/sudoers</code> 文件配置谁可以使用 sudo 命令执行，是否需要密码等。</p><p>下面的配置表明，user1 和 user2 可以直接使用 sudo 命令，而不需要输入密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># defines an ADMINS user alias with the two users</span><br><span class="line">User_Alias ADMINS = user1, user2</span><br><span class="line"></span><br><span class="line"># users in the ADMINS alias can use sudo to execute commands as root</span><br><span class="line"># The second ALL means “any command.” The first ALL means “any host.” </span><br><span class="line">ADMINS ALL = NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line"># superuser may also use sudo to run any command on any host.</span><br><span class="line"># extra (ALL) means that the superuser may also run commands as any other user.</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"># 上面的这句，可以扩展为</span><br><span class="line">ADMINS ALL = (ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>visudo</code> 命令来编辑上面这个文件，它会检查你的语法。</p></blockquote><p>要查看 sudo 命令的历史记录，可使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl SYSLOG_IDENTIFIER=sudo</span><br></pre></td></tr></table></figure><p>来启用，对于老一点的系统，可能需要在 <code>/var/log</code> 查看, 比如 <code>/var/log/auth.log.</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章涵盖了Linux中关于基本命令、环境变量、特殊符号、Shell 编辑工具、帮助文档查询、标准输入输出、符号链接、解压缩、超级用户以及目录的结构介绍等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="How Linux Works" scheme="https://scottzhang.pro/categories/How-Linux-Works/"/>
    
    
    <category term="Linux" scheme="https://scottzhang.pro/tags/Linux/"/>
    
    <category term="Operating-System" scheme="https://scottzhang.pro/tags/Operating-System/"/>
    
  </entry>
  
</feed>
