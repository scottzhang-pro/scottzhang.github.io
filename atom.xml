<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="http://wittyfans.com/atom.xml" rel="self"/>
  
  <link href="http://wittyfans.com/"/>
  <updated>2021-11-19T14:12:08.908Z</updated>
  <id>http://wittyfans.com/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python设计模式-单例模式及其实现原理</title>
    <link href="http://wittyfans.com/article/18dbdeeb.html"/>
    <id>http://wittyfans.com/article/18dbdeeb.html</id>
    <published>2021-11-18T13:25:00.000Z</published>
    <updated>2021-11-19T14:12:08.908Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。</p></blockquote><span id="more"></span><h1 id="面向对象">面向对象</h1><h2 id="方法是怎么工作的">方法是怎么工作的？</h2><p>方法是绑定在类中的函数。你可以像下面这样声明一个 pizza 类以及它的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接访问类的 get_size 方法，会告诉你这个方法未绑定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 中不会提示</span></span><br><span class="line">Pizza.get_size</span><br><span class="line">&lt;unbound method Pizza.get_size&gt;</span><br></pre></td></tr></table></figure><p>我们无法调用这个方法，因为它没有绑定给任何 Pizza 的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 会直接报错</span></span><br><span class="line">Pizza.get_size()</span><br><span class="line">TypeError: unbound method get_size() must be called <span class="keyword">with</span> Pizza instance <span class="keyword">as</span> first argument (got nothing instead)</span><br></pre></td></tr></table></figure><p>它提示你第一个参数必须是 Pizza 的实例，那我们将它的 Pizza 的实例传进去看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 方法，同时传入实例，正常</span></span><br><span class="line">Pizza.get_size(Pizza(<span class="number">42</span>))</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>成功了! 不过这样使用也太麻烦了，好在 Python 会帮我们自动实现这些繁琐的工作。它会自动将 Pizza 中所有的方法绑定给任何 Pizza 的实例，当我们定义类方法的时候，其中写的 self 就等于类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = Pizza(<span class="number">42</span>).get_size</span><br><span class="line">m()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>如果你想知道方法被绑定给了那个对象，可以通过 <code>m.__self__</code> 来查看方法被绑定到了哪个对象。</p><h2 id="静态方法">静态方法</h2><p>静态方法不需要提供 self 或 cls 等参数，因为声明为静态方法后，它不会绑定给任何实例或者类, 这减少了类实例创建时候的开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mix_ingredients</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mix_ingredients(self.cheese, self.vegetables)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到两个实例的方法是不想等的，而静态方法的对于实例和类都是相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pizza().cook <span class="keyword">is</span> Pizza().cook</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza.mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza().mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="类方法">类方法</h2><p>类方法的概念和实例方法类似，不同的是它会被绑定给类本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    radius = <span class="number">42</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">cls</span>):</span>  <span class="comment"># cls 为类</span></span><br><span class="line">        <span class="keyword">return</span> cls.radius</span><br></pre></td></tr></table></figure><p>对于类方法来说，不管你通过类还是类的实例调用，它引用的也都是同一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pizza.get_radius</span><br><span class="line">&lt;bound method <span class="built_in">type</span>.get_radius of &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">type</span>.<span class="title">get_radius</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span> == <span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span>()</span></span><br><span class="line"><span class="class">42</span></span><br></pre></td></tr></table></figure><p>什么时候使用类方法呢？</p><p>第一种情况是工厂模式中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ingredients</span>):</span></span><br><span class="line">        self.ingredients = ingredients</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_fridge</span>(<span class="params">cls, fridge</span>):</span></span><br><span class="line">        <span class="comment"># 会返回一个新的类的实例，这允许你在类的实例被初始化之前做一些事情，</span></span><br><span class="line">        <span class="comment"># 它的初始化参数来自于fridge 的两个方法 get_cheese() + get_vegetables()</span></span><br><span class="line">        <span class="keyword">return</span> cls(fridge.get_cheese() + fridge.get_vegetables())</span><br></pre></td></tr></table></figure><p>这样写的好处是，你可以通过 <code>Pizza.from_fridge(...)</code> 的方式生成实例。</p><p>第二种情况是调用静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius, height</span>):</span></span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.height = height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span>(<span class="params">radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> math.pi * (radius ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_volume</span>(<span class="params">cls, height, radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> height * cls.compute_area(radius)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_volume</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.compute_volume(self.height, self.radius)</span><br></pre></td></tr></table></figure><p>这里的 cls 可以写成 Pizza, 但通过 cls 的方式避免将 Pizza 类写死在类中。</p><h2 id="抽象方法">抽象方法</h2><p>抽象方法（Abstract methods）是定义在基类中的，未实现的方法，它有点类似于 java 中的接口。它规定了一种方法的形式，任何继承基类的子类都必须实现此方法才可以工作。</p><p>一个简单的抽象方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>根据这个定义，任何继承了 Pizza 类的子类，都必须实现并重写 get_redius 方法，如果你忘记实现，实例调用 get_radius 就会出错。</p><p>如果你想要让这种错误发生的更早一点，比如发生在实例刚创建的时候，那么可以设置 Pizza 的 metaclass 为 abc 模块中的 ABCMeta。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="string">&quot;&quot;&quot;Method that should do something.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这里继承自 BasePizza 的类中，必须实现 get_radius 方法。BasePizza 对实现的细节并不关心，可以是类方法，实例方法，或者是静态方法。同样它也不关心返回的结果。</p><blockquote><p>参考: <a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">The definitive guide on how to use static, class or abstract methods in Python.</a></p></blockquote><h2 id="super-类">super 类</h2><p>是的，这标题没有错！super 是一个类，实例化之后得到的是一个代理的对象，而不是得到了父类，我们使用这个代理对象来调用父类或者兄弟类的方法。</p><p>但是当继承的父类比较多时，去哪个父类中调用方法就是个问题。对于子类的实例来说，可以通过 <code>obj.__mro__</code> 或者是 <code>cls.mro()</code> 访问父类的列表，python 通过它用管理类的继承顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问一个实例的 MRO 列表</span></span><br><span class="line"><span class="built_in">type</span>(B()).__mro__</span><br><span class="line">(__main__.B, __main__.A, <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>如果你提供一个 MRO 列表以及一个 MRO 中的类 C 给 super()，它将返回一个从 MRO 列表中 C 之后的类中查找到的方法的对象。</p><p>假设有个MRO列表为 [A, B, C, D, E, object]，执行 super(C, A).foo() 它只会从 C 之后查找，即: 只会在 D 或 E 或 object 中查找 foo 方法。</p><p>super() 它有几种使用方法：</p><ul><li>super() -&gt; same as super(<strong>class</strong>, <first argument>)</li><li>super(type) -&gt; unbound super object</li><li>super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</li><li>super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</li></ul><p>举个 super(type, obj) 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Base&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 super 的 func</span></span><br><span class="line"><span class="built_in">super</span>(A, C()).func()  <span class="comment"># 输出 &#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么是 B 呢？首先看一下 MRO 列表，Python 会根据第二个参数来计算 MRO，也就是这里提供的 C() 产生的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C.mro()</span><br><span class="line">[__main__.C, __main__.A, __main__.B, __main__.Base, <span class="built_in">object</span>]</span><br></pre></td></tr></table></figure><p>super 会计算出来的 mro 列表中，跳过参数A，从后面开始找父类的 func 方法，所以这里会执行 B 的 func。</p><p>然后再来说说 super(type, obj) 和 super(type, type2)的区别，他们的区别是第二个参数，super的第二个参数传递的是类，得到的是函数，super的第二个参数传递的是对象，得到的是绑定方法。</p><blockquote><p>理解绑定方法，有兴趣的再可以深入了解<a href="(https://docs.python.org/zh-cn/3.7/howto/descriptor.html)">描述器</a>的介绍。</p></blockquote><h1 id="单例模式">单例模式</h1><p>掌握了面向对象的知识和 super 的使用，就可以介绍单例模式了。单例模式是一种确保一个类只有一个实例会被创建出来的模式。</p><p>在其他语言中，单例通过构造函数私有化实现，Python 中没有私有构造函数，但可以通过类方法 <code>__new__</code> 实现。</p><p>我们知道 <code>__init__</code> 函数，但 <code>__init__</code> 是对创建好的实例初始化，而 <code>__new__</code> 才创建实例。</p><p>摘录网上一段关于这两个方法的解释：</p><ul><li>new (cls[, ...]) 是在一个对象实例化的时候所调用的第一个方法，在调用 init 初始化前，先调用new 。</li><li>new 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给 init 。</li><li>new 对当前类进行了实例化，并将实例返回，传给 init 的self。但是，执行了new ，并不一定会进入 init ，只有new 返回了，当前类cls的实例，当前类的 init 才会进入。</li><li>若new 没有正确返回当前类cls的实例，那 init 是不会被调用的，即使是父类的实例也不行，将没有 init 被调用。</li><li>new 方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径。</li></ul><blockquote><p>为 markdown 渲染方便，这里的 new 即 <code>__new__</code>, init 即 <code>__init__</code></p></blockquote><p>来看一个实现了这两个方法的类的调用顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Scott&quot;</span>, <span class="number">25</span>)</span><br><span class="line">__new__</span><br><span class="line">__init__</span><br></pre></td></tr></table></figure><p>可以看到先调用了 <code>__new__</code>, 才是 <code>__init__</code>，利用 new 的特性，我们可以用它来实现单例模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span>:</span></span><br><span class="line">    _singleton = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># super(OnlyOne, cls) 即上面的 super(type, type2) 模式</span></span><br><span class="line">        <span class="comment"># 这里相当于根据 cls 找 MRO 列表中，OnlyOne后的父类</span></span><br><span class="line">        <span class="comment"># 使用它的 __new__ 方法创建一个 cls（即本类）的实例</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._singleton:</span><br><span class="line">            cls._singleton = <span class="built_in">super</span>(</span><br><span class="line">                OnlyOne, cls</span><br><span class="line">            ).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._singleton</span><br></pre></td></tr></table></figure><p>我们首先检查这个单件的实例是否被创建出来，如果没有，我们用 super 函数来创建它。因此，每当我们调用 OnlyOne 的时候，总是可以得到完全相同的实例。</p><p>单例模式还有其他的实现，比如装饰器、MetaClass，感兴趣的可以看<a href="https://zhuanlan.zhihu.com/p/37534850">这篇</a>文章。</p><p>单例的这种思想，可以用在模块中。比如对于我们前面状态模式中的例子，状态模式中对于不同的状态，我们都有对应的类会初始化作为对状态的记录（如 First tag, Open tag）。</p><p>其实我们可以将状态设置为变量，这就避免了每次都初始化状态类产生一个新的实例，同时在每一个状态类内部，不再对解析器做引用，具体的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildNode</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remaining_str, parser</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        parser.state = child_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">child_node = ChildNode()</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>单例模式设计的内容还是挺多的，如装饰器、静态方法、类方法、继承、多态、MRO、装饰器、super 方法等。为了理解单例模式，我也是花了不少时间复习这块的内容，希望整理的这些笔记可以帮到你，如果要彻底理解这些内容，重要的还是要多去练习、多动手写代码。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/37534850">Python单例模式 Singleton 的N种实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/261579683">python魔法方法，详解 new 和 init 方法</a></li><li><a href="https://www.cnblogs.com/maple-shaw/p/9288018.html">你会使用super()吗？你确定你了解它吗？</a></li><li><a href="https://docs.python.org/zh-cn/3.7/howto/descriptor.html">实现描述器</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
    <category term="design pattern" scheme="http://wittyfans.com/tags/design-pattern/"/>
    
    <category term="OOP" scheme="http://wittyfans.com/tags/OOP/"/>
    
    <category term="singleton" scheme="http://wittyfans.com/tags/singleton/"/>
    
    <category term="super" scheme="http://wittyfans.com/tags/super/"/>
    
    <category term="staticmethod" scheme="http://wittyfans.com/tags/staticmethod/"/>
    
    <category term="classmethod" scheme="http://wittyfans.com/tags/classmethod/"/>
    
    <category term="Abstract methods" scheme="http://wittyfans.com/tags/Abstract-methods/"/>
    
    <category term="abc" scheme="http://wittyfans.com/tags/abc/"/>
    
    <category term="MRO" scheme="http://wittyfans.com/tags/MRO/"/>
    
  </entry>
  
  <entry>
    <title>Python设计模式-策略与状态模式</title>
    <link href="http://wittyfans.com/article/8a706eb8.html"/>
    <id>http://wittyfans.com/article/8a706eb8.html</id>
    <published>2021-11-16T13:32:21.000Z</published>
    <updated>2021-11-19T14:12:08.908Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。</p></blockquote><span id="more"></span><h1 id="策略模式">策略模式</h1><p>策略模式是一种面向对象编程中的抽象模式。针对同样的问题，它实现了不同的解决方案，你的代码可以在运行的时候自由选择最恰当的方案。</p><p>策略模式的一个应用是排序，比如你要实现一个排序算法，它可以自动选择排序方法来对输入的数组进行排序，排序的方法是自动选择的，而结果是不变的。</p><p>还有一个例子是设置电脑的墙纸，当你设置墙纸的时候，你的电脑会自动帮你设置很多事情：</p><ol type="1"><li>根据屏幕的分辨率，自动将图片缩放到合适的大小</li><li>自动处理图片与系统组件之间的缩放、虚化关系</li><li>图片与背景色的结合</li></ol><p>你可以定义不同的对象，它们接受的 input 是一样的（目标图片，屏幕分辨率），不管怎样，这些对象都都能达到设置屏幕壁纸的目的。</p><p>有人说我通过 if 判断也可以达到同样的目的，但是这意味着你需要将你的代码放到一个巨大的方法中，随着新的策略的增加，你的函数将变得非常笨重。</p><p>这里略过策略模式的实例。</p><h1 id="状态模式">状态模式</h1><p>状态模式的目的是实现“状态切换”，对象的状态可以被外面知道，并且可能会被一些活动改变。来一个例子，需求是要对一个 <a href="https://www.w3.org/XML/">xml 文件</a>进行解析，一个简单的 xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>welcome to scott&#x27;s blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想把这样的文件解析出来，结果是我可以通过 node.attr 的方式访问 xml 文件的内容。比如 xml_file.body 作为一个节点。该节点有一个属性叫子节点，我可以通过 xml_file.body.children 的方式拿到，对于 title 中的内容，我已通过 xml_file.body.title.text 的方式拿到。</p><p>首先需要一个节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点类，记录节点的名字，文本，节点之间有上下级关系，所以它</span></span><br><span class="line"><span class="string">       还需要一个指向父节点的指针。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tagname, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.parent=parent</span><br><span class="line">        self.tagname = tagname</span><br><span class="line">        <span class="comment"># text 和 children 都由其他组件操作</span></span><br><span class="line">        self.children = []</span><br><span class="line">        self.text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.text:</span><br><span class="line">            <span class="keyword">return</span> self.tagname + <span class="string">&#x27;:&#x27;</span> + self.text</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.tagname</span><br></pre></td></tr></table></figure><p>有了节点后，我们还需要一个解析器，解析器会一层一层的解析字符串，我们可以定义解析器有几种状态，即处于：</p><ul><li>开始节点</li><li>子节点</li><li>结束节点</li></ul><p>如何根据解析器的状态判断是否还可以深入一步呢？可以这么定义：</p><ul><li>开始节点</li><li>子节点</li><li>打开的节点</li><li>结束节点</li><li>文本节点（最底层无子节点的节点）</li></ul><p>来看代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parser 是一个解析器。它会负责去切换状态，下图的状态之间会互相转换。</span></span><br><span class="line"><span class="string">       第一个状态是 First Tag，它永远将切换至子节点，再由子节点来决定切换到其他哪个状态。</span></span><br><span class="line"><span class="string">       每一个状态都会用自己的方法处理收到的剩余字符，然后将状态再设置为 Children Node，告诉解析器来处理剩下的部分。</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">        |                     .-------------.                      |</span></span><br><span class="line"><span class="string">        |                    (   First Tag   )                     |</span></span><br><span class="line"><span class="string">        |                     `-------------&#x27;                      |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                     .------v------.                      |</span></span><br><span class="line"><span class="string">        |         +---------&gt;( Children Node )&lt;----------+         |</span></span><br><span class="line"><span class="string">        |         |           `-------------&#x27;            |         |</span></span><br><span class="line"><span class="string">        |         |                  ^                   |         |</span></span><br><span class="line"><span class="string">        |         v                  v                   v         |</span></span><br><span class="line"><span class="string">        |  .-------------.    .-------------.     .-------------.  |</span></span><br><span class="line"><span class="string">        | (   Open tag    )  (  Closed tag   )   (     Text      ) |</span></span><br><span class="line"><span class="string">        |  `-------------&#x27;    `-------------&#x27;     `-------------&#x27;  |</span></span><br><span class="line"><span class="string">        |                                                          |</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parse_str</span>):</span></span><br><span class="line">        self.parse_str = parse_str</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.current_node = <span class="literal">None</span></span><br><span class="line">        self.state = FirstTag()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str</span>):</span></span><br><span class="line">        remainning = self.state.process(remain_str, self)</span><br><span class="line">        <span class="keyword">if</span> remainning:</span><br><span class="line">            self.process(remainning)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.process(self.parse_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理剩余的字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str (string): 剩余需要解析的字符</span></span><br><span class="line"><span class="string">            parser (Parser): parser 即上面定义的的 Parser，它会被闯进来修改它的属性，如current_node, root, state</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 剩余需要解析的字符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line"></span><br><span class="line">        root = Node(tag_name)</span><br><span class="line">        parser.root = parser.current_node = root</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;同样只需要一个 process 方法来处理字符串。</span></span><br><span class="line"><span class="string">           作为 ChildrenNode，它需要根据字符来判断需要使用什么样的类状态器，</span></span><br><span class="line"><span class="string">           类状态器的 process 方法将会完成对剩余字符的处理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str ([type]): [description]</span></span><br><span class="line"><span class="string">            parser ([type]): [description]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        striped = remain_str.strip()</span><br><span class="line">        <span class="keyword">if</span> striped.startswith(<span class="string">&#x27;&lt;&#x27;</span>):</span><br><span class="line">            parser.state = OpenTag()</span><br><span class="line">        <span class="keyword">elif</span> striped.startswith(<span class="string">&#x27;&gt;&#x27;</span>):</span><br><span class="line">            parser.state = CloseTag()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parser.state = TextNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line">        <span class="comment"># parser.current_node 未被更改还是上一层节点，将其设为父节点</span></span><br><span class="line">        node = Node(tag_name, parser.current_node)</span><br><span class="line">        parser.current_node.children.append(node)</span><br><span class="line">        parser.current_node = node</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        <span class="comment"># assert 断言中</span></span><br><span class="line">        <span class="comment"># 第一个确保 &lt; 后是/，如 &lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 第二个确保以同一个tag名开始结束，如 &lt;h1&gt;Hi&lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 以及因当前是结束tag，重置parser当前节点为其父节点</span></span><br><span class="line">        <span class="keyword">assert</span> remain_str[i_start_tag+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        tagname = remain_str[i_end_tag+<span class="number">2</span>:i_end_tag]</span><br><span class="line">        <span class="keyword">assert</span> tagname == parser.current_node.tagname</span><br><span class="line">        parser.current_node = parser.current_node.parent</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:].strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">         i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">         text = remain_str[:i_start_tag]</span><br><span class="line">         parser.current_node.text = text</span><br><span class="line">         parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> remain_str[i_start_tag:]</span><br></pre></td></tr></table></figure><p>启动代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.xml&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        p = Parser(file.read())</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">        nodes = [p.root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            nodes = node.children + nodes</span><br></pre></td></tr></table></figure><p>将会产生下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">title:welcome to scott&#x27;s blog</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Python设计模式-装饰器与观察者模式</title>
    <link href="http://wittyfans.com/article/140cd416.html"/>
    <id>http://wittyfans.com/article/140cd416.html</id>
    <published>2021-11-15T12:50:18.000Z</published>
    <updated>2021-11-19T14:12:08.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。</p></blockquote><span id="more"></span><h1 id="装饰器模式">装饰器模式</h1><p>装饰器可以将一个提供核心功能的对象，和其他可以改变这个功能的对象“包裹”在一起使用。</p><p>它主要有两种用途：</p><ul><li>增强一个组件给另一个组件发送数据时的<strong>响应能力</strong></li><li>支持<strong>多种可选的行为</strong>（适当的代替多重继承）</li></ul><h2 id="装饰器">装饰器</h2><p>如果你不知道什么是装饰器，可以看下这篇 <a href="https://medium.com/citycoddee/python%E9%80%B2%E9%9A%8E%E6%8A%80%E5%B7%A7-3-%E7%A5%9E%E5%A5%87%E5%8F%88%E7%BE%8E%E5%A5%BD%E7%9A%84-decorator-%E5%97%B7%E5%97%9A-6559edc87bc0">文章</a>，其中有一段代码可以让你很容易理解它的原理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span>(<span class="params">a_func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之前做一些无聊的工作&quot;</span>)</span><br><span class="line"></span><br><span class="line">        a_func()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之后做一些无聊的工作&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;就是你! 来包装我吧!&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是一个需要被包装的家伙&quot;</span></span><br><span class="line">          <span class="string">&quot;快来拯救我！&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br></pre></td></tr></table></figure><h2 id="网络编程装饰器实例">网络编程装饰器实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法，即不管你传进来的啥东西，只要有 send 和 close</span></span><br><span class="line"><span class="string">       方法即可。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个常量数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP，另外还有 UDP（这属于计算机网络的知识）</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(client)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br></pre></td></tr></table></figure><p>上面的 respond 方法只关注接受的对象有没有 send, close 方法。</p><p>我们甚至可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法可以继续工作。</p><p>让我们来实现一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</p><p>下面的例子是一个网络编程实例的实现，它有一个服务端和客户端，服务端会一直处于待命状态，只要有客户端连接，服务端就会做出回应.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogSocket</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上面的 respond 方法只关注接受的对象有没有 send, close 方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    我们可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法就还是可以继续工作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    所以，我们可以写一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    下面举一个例子是在 send，close 调用的时候执行答应。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sending <span class="subst">&#123;data&#125;</span> to <span class="subst">&#123;self.socket.getpeername()[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        self.socket.send(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(LogSocket(client))  <span class="comment"># client 被包装（装饰），或者说被替换了</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用装饰器的好处是，你可以灵活的切换，比如你可以另外写一个装饰器，用于对发送的数据压缩。 然后你就可以实现类似这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GzipSocket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        buf = BytesIO(data)</span><br><span class="line">        zipfile = gzip.GzipFile(fileobj=buf, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        zipfile.write(data)</span><br><span class="line">        zipfile.close()</span><br><span class="line"></span><br><span class="line">        self.socket.send(buf.getvalues())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">client, addr = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> log_send:</span><br><span class="line">    client = LogSocket(client)</span><br><span class="line"><span class="keyword">if</span> gzip_send:</span><br><span class="line">    client = GzipSocket(client)</span><br></pre></td></tr></table></figure><h2 id="自定义打印的实例">自定义打印的实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_calls</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个新的函数，替换原来传入的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用：&#123;0&#125;, 携带参数 &#123;1&#125;, &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__, args, kwargs</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        return_value = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函数 &#123;&#125; 用时 &#123;&#125; &quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__,</span><br><span class="line">            time.time() - now</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> return_value</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用方法实现的装饰器的使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test = log_calls(test)</span><br><span class="line">result = test(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 特殊的方法使用装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@log_calls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用：<span class="built_in">test</span>, 携带参数 (2, 3), &#123;&#125;</span><br><span class="line">函数 <span class="built_in">test</span> 用时 2.002716064453125e-05</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="装饰器技巧">装饰器技巧</h2><p>想象一下，如果你需要给一个类中的所有方法添加一个装饰器，你会怎么办？也许你不会有这样的需求，但有时候，你可能需要对某几个函数添加装饰器，但你又不想在原来的类旁边添加任何代码。</p><p>这可以通过 metaclass 来实现，或者通过循环类的方法使用 setattr 方法修改，有兴趣的可以研究一下。</p><p>这里放一个 StackOverflow 上的 <a href="https://stackoverflow.com/questions/3467526/attaching-a-decorator-to-all-functions-within-a-class">讨论</a>。</p><h1 id="观察者模式">观察者模式</h1><p>观察者模式适用于<strong>状态监测</strong>和<strong>事件处理</strong>。</p><p>它有一个核心对象，以及观察者。核心对象由一组未知，并可能正在扩展的 “观察者” 对象来监控。一旦核心对象的值发生了变化，便会通过 update 方法告诉每一个观察者。观察者收到更新后，可能会做不一样的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inventory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.observers = []</span><br><span class="line">        self._product = <span class="literal">None</span></span><br><span class="line">        self._quantity = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._product</span><br><span class="line"></span><br><span class="line"><span class="meta">    @product.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._product = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._quantity</span><br><span class="line"></span><br><span class="line"><span class="meta">    @quantity.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._quantity = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_observers</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            <span class="comment"># 调用 observer 对象，为了让一个对象可以被调用，它需要实现</span></span><br><span class="line">            <span class="comment"># __call__ 方法</span></span><br><span class="line">            observer()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleObserver</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inventory</span>):</span></span><br><span class="line">        self.inventory = inventory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwds</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;观察者模式可以用于备份数据至不同的地方，比如文件、数据库或互联网应用。</span></span><br><span class="line"><span class="string">           它将正在被观察的代码，和执行的代码分离。</span></span><br><span class="line"><span class="string">           如果不使用这种模式，则必须在每个属性中处理可能出现的情况，这意味着任务代码和</span></span><br><span class="line"><span class="string">           被观察的对象耦合在一起，维护起来会很麻烦。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.inventory.product)</span><br><span class="line">        <span class="built_in">print</span>(self.inventory.quantity)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">invt = Inventory()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以很容易的添加观察者</span></span><br><span class="line">console_1 = ConsoleObserver(invt)</span><br><span class="line">console_2 = ConsoleObserver(invt)</span><br><span class="line"></span><br><span class="line">invt.attach(console_1)</span><br><span class="line">invt.attach(console_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到每次对 product 或者 quantity 的修改</span></span><br><span class="line"><span class="comment"># 都会产生两次打印，这是因为两个观察者都做出了响应</span></span><br><span class="line">invt.product = <span class="string">&#x27;元气森林&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">invt.quantity = <span class="number">100</span>,<span class="number">000</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
    <category term="design pattern" scheme="http://wittyfans.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级导入技巧</title>
    <link href="http://wittyfans.com/article/935fa388.html"/>
    <id>http://wittyfans.com/article/935fa388.html</id>
    <published>2021-09-21T15:33:14.000Z</published>
    <updated>2021-11-19T14:12:08.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章深入研究了 <code>import</code> 命令以及它的工作原理。</p></blockquote><span id="more"></span><h1 id="基本导入命令">基本导入命令</h1><p>在 <a href="https://wittyfans.com/article/c8bc6f6.html">Python-模块与包</a> 一文中，我们看到过 <code>import</code> 命令，它可以用来导入包和模块。</p><p><code>import</code> 命令有几种形式:</p><ul><li><code>import math</code></li><li><code>from math import pi</code></li><li><code>import math as m</code></li></ul><p>对于 <code>import</code> 命令，它不关心 <code>import</code> 的是一个包还是一个模块，因为语法是一样的，只是包在构建的时候有些不同。</p><blockquote><p>一个没有 <code>__init__.py</code> 文件的目录，也会被当做一个包，只是不是普通的包，有时候称其为命名空间包 (namespace packages)。</p></blockquote><p>通常情况下，在一个普通的包中，子模块和子包默认不会导入，除非你在 <code>__init__.py</code> 中有 <code>import</code> 子包和子模块。</p><p>举一例，有个叫 world 包的包，其目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">world/</span><br><span class="line">│</span><br><span class="line">├── africa/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── zimbabwe.py</span><br><span class="line">│</span><br><span class="line">├── europe/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── greece.py</span><br><span class="line">│   ├── norway.py</span><br><span class="line">│   └── spain.py</span><br><span class="line">│</span><br><span class="line">└── __init__.py</span><br></pre></td></tr></table></figure><p>如果你要使用 world 包，若其中没有 <code>__init__.py</code> 是不会包括子包的。</p><p>导入一个包会加载包的内容，并创建命名空间，命名空间是一个字典，你可以通过 <code>__dict__</code> 属性访问到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.__dict__[<span class="string">&quot;pi&quot;</span>]</span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>同样的，全局变量也是一个命名空间，可以通过 <code>globals()</code> 访问。</p><h1 id="常见导入问题">常见导入问题</h1><p>假设你现在有一个包，它的目录结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── files.py</span><br><span class="line">└── structure.py</span><br></pre></td></tr></table></figure><p><code>structure.py</code> 中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># structure.py</span></span><br><span class="line"><span class="keyword">import</span> files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>运行 <code>python structure.py .</code> 后的输出: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python structure.py .</span><br><span class="line">Create file: /home/gahjelle/structure/001/structure.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/files.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/__pycache__/files.cpython-38.pyc</span><br></pre></td></tr></table></figure></p><p>当你在 <code>structure.py</code> 需要用到 files 时，如果这两个文件在同一目录，这样是没有问题的。</p><p>现在为了满足 Pyinstaller guide 而创建了一个程序入口，你的目录结构变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── structure/</span><br><span class="line">│   ├── files.py</span><br><span class="line">│   └── structure.py</span><br><span class="line">│</span><br><span class="line">└── cli.py</span><br></pre></td></tr></table></figure><p>在 <code>cli.py</code> 中，你导入了 structure 中的 main 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> structure.structure <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>此时，如果你在 <code>cli.py</code> 所在目录执行 <code>python cli.py structure</code>，则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;cli.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from structure.structure import main</span><br><span class="line">  File &quot;/home/gahjelle/structure/structure/structure.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    import files</span><br><span class="line">ModuleNotFoundError: No module named &#x27;files&#x27;</span><br></pre></td></tr></table></figure><p>因为 <code>import files</code> 基于当前目录去寻找 files，而当执行目录变化以后，肯定就找不到了。</p><p>一种解决办法是，在引用文件中，找到引用文件的父目录，并将其加入到 <code>sys.path</code> 中（即 implicit relative imports，隐式相对导入）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local imports</span></span><br><span class="line"> sys.path.insert(<span class="number">0</span>, <span class="built_in">str</span>(pathlib.Path(__file__).parent))</span><br><span class="line"> <span class="keyword">import</span> files</span><br></pre></td></tr></table></figure><p>你可能会像在 <code>structure.py</code> 中，使用相对路径导入 <code>files</code>，如：<code>from . import files</code></p><p>但这样也是不行的，因为<a href="https://www.python.org/dev/peps/pep-0328/#relative-imports-and-name">相对导入在脚本中的解析方式与导入模块中的解析方式不同</a>。</p><p>一个更好的方式是使用 <code>pip</code>, 你自己创建一个包，使用起来就好像其他的包一样。</p><h1 id="何不创建自己的包">何不创建自己的包？</h1><p>当你通过 pip 安装一个包的时候，它可以在任何地方使用，事实上你也可以做到，首先在你的包文件夹旁边新建两个文件：</p><ul><li><code>setup.cfg</code></li><li><code>setup.py</code></li></ul><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># setup.cfg</span><br><span class="line"></span><br><span class="line">[metadata]</span><br><span class="line">name = local_structure</span><br><span class="line">version = 0.1.0</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line">packages = structure</span><br><span class="line"></span><br><span class="line"># setup.py</span><br><span class="line"></span><br><span class="line">import setuptools</span><br><span class="line"></span><br><span class="line">setuptools.setup()</span><br></pre></td></tr></table></figure><p>name 和 version，随意。名字的话建议打上标识，比如 local 或者你的用户名，这样可以方便的找出你自己的包。</p><p>准备好了之后，就可以创建你自己的包了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -e .</span><br></pre></td></tr></table></figure><p><code>-e</code> 的意思是 <code>editable</code>， 这个非常重要，因为这可以让你更改你的源代码，而不用重新安装你的包。</p><p>这条命令会将你的包安装到系统，你可以在任何地方使用你的包，只需执行 <code>from structure import files</code>。不用担心相对路径，绝对路径等问题。</p><blockquote><p>简单的包可以这样直接建立，但如果比较复杂的包则最好附上更多详细的信息，可参考 [<a href="https://realpython.com/pypi-publish-python-package/">How to Publish an Open-Source Python Package to PyPI</a>.</p></blockquote><h1 id="介绍命名空间包">介绍命名空间包</h1><p>命名空间包可以允许不存在 <code>__init__.py</code> 文件，特别的，它还允许文件分布在不同的文件夹。当你的文件夹中有 py 文件，但是没有 <code>__init__.py</code> 文件，命名空间包会被自动创建。</p><p>为了更理解命名空间包，我们直接实现它。</p><p>考虑一个需求，要将歌曲的信息序列化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>song = Song(song_id=<span class="string">&quot;1&quot;</span>, title=<span class="string">&quot;The Same River&quot;</span>, artist=<span class="string">&quot;Riverside&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>song.serialize()</span><br><span class="line"><span class="string">&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;title&quot;: &quot;The Same River&quot;, &quot;artist&quot;: &quot;Riverside&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在已经有第三方社区为你实现了一部分工作。</p><p>对于 <code>song.serialize()</code>，它接收一个序列化对象，这个序列化对象有基于 json 实现的，有基于 xml 实现的，可能内部实现代码不一样，但暴露的方法名一样，你可以在 <code>song.serialize()</code> 中自动处理。</p><p>这两个序列化对象，分别放在不同文件实现，文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">third_party/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    ├── json.py</span><br><span class="line">    └── xml.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前看起来不错，这时候你可能想再加一个自己的 yaml 的序列化方法，同样的创建目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    └── yaml.py</span><br></pre></td></tr></table></figure><p>这里虽然代码在不同的目录，但是对于 <code>serializers</code> 来说，在这2个目录里，都有着共同的命名空间。</p><p>所以你可以直接这样导入全部的序列化对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">&quot;third_party&quot;</span>, <span class="string">&quot;local&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> serializers <span class="keyword">import</span> json, xml, yaml</span><br></pre></td></tr></table></figure><p>再举一例：</p><p>假设你有Python代码的两个不同的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo-package/</span><br><span class="line">    spam/</span><br><span class="line">        blah.py</span><br><span class="line"></span><br><span class="line">bar-package/</span><br><span class="line">    spam/</span><br><span class="line">        grok.py</span><br></pre></td></tr></table></figure><p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有 <code>__init__.py</code> 文件。</p><p>让我们看看，如果将 <code>foo-package</code> 和 <code>bar-package</code> 都加到python 模块路径并尝试导入会发生什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.extend([&#x27;foo-package&#x27;, &#x27;bar-package&#x27;])</span><br><span class="line">&gt;&gt;&gt; import spam.blah</span><br><span class="line">&gt;&gt;&gt; import spam.grok</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>两个不同的包目录被合并到一起，你可以导入 <code>spam.blah</code> 和<code>spam.grok</code>，并且它们能够工作。</p><p>在这里工作的机制被称为“包命名空间”的一个特征。</p><p>从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p><h1 id="导入包的风格规范">导入包的风格规范</h1><p>导入包不可以太随意，建议将标准包、第三方包、用户自定义包区分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Standard library imports</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Third party imports</span></span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader imports</span></span><br><span class="line"><span class="keyword">from</span> reader <span class="keyword">import</span> URL</span><br></pre></td></tr></table></figure><h1 id="如何导入数据资源">如何导入数据资源？</h1><p>有时候你的包需要依赖一些数据，如果你想要将这些数据也一起打包分发给你的用户，可能会有一些问题：</p><ul><li>数据文件的路径不确定，这取决于用户的配置，包如何分发的，以及安装在哪里</li><li>你的数据文件可能在压缩文件或者 <code>.egg</code> 文件中无法直接使用</li></ul><p>历史上有过一些对数据资源的解决方案，包括 <a href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html"><code>setuptools.pkg_resources</code></a>，不过现在在 python3.7 中，有了官方的标准库来解决这个问题，那就是 <code>importlib.resources</code>，对于之前的版本，则需要使用 <code>importlib_resources</code></p><blockquote><p>命名空间包不支持 importlib.resources</p></blockquote><p>假设你有一个数据文件是关于书籍的，你的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">books/</span><br><span class="line">│</span><br><span class="line">├── __init__.py  # 空文件，构造包所用</span><br><span class="line">├── alice_in_wonderland.png</span><br><span class="line">└── alice_in_wonderland.txt</span><br></pre></td></tr></table></figure><p>如果需要这两个文件，只需要按如下代码操作即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="comment"># 文本文件, books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_text(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.txt&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    alice = fid.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制文件，books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_binary(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.png&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    cover = fid.read()</span><br></pre></td></tr></table></figure><p>如果是较老的版本，可以在 import 的时候换成支持的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><p>再来一个例子，你现在需要将你的程序添加一个 logo，你的包目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello_gui/</span><br><span class="line">│</span><br><span class="line">├── gui_resources/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── hand.png</span><br><span class="line">│   └── logo.png</span><br><span class="line">│</span><br><span class="line">└── __main__.py</span><br></pre></td></tr></table></figure><p>下面的代码显示了你应该如何引用你的 logo 文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">with</span> resources.path(<span class="string">&quot;hello_gui.gui_resources&quot;</span>, <span class="string">&quot;logo.png&quot;</span>) <span class="keyword">as</span> path:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># or do you work</span></span><br></pre></td></tr></table></figure><h1 id="使用动态导入">使用动态导入</h1><p>Python 是一门动态语言（尽管这有时候也算是缺点），这意味着你可以在 python 程序运行的时候，增加类的属性，修改函数的定义、模块的 docstring，甚至你可以修改 <code>print()</code> 函数让它什么都不输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello dynamic world!&quot;</span>)</span><br><span class="line">Hello dynamic world!</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Redefine the built-in print()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> = <span class="keyword">lambda</span> *args, **kwargs: <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hush, everybody!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Nothing is printed</span></span><br></pre></td></tr></table></figure><p>所以你也可以动态的导入一个包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docreader.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">module_name = <span class="built_in">input</span>(<span class="string">&quot;Name of module? &quot;</span>)</span><br><span class="line">module = importlib.import_module(module_name)</span><br><span class="line"><span class="built_in">print</span>(module.__doc__)</span><br></pre></td></tr></table></figure><h1 id="深入python-的导入系统">深入Python 的导入系统</h1><p>当你执行导入操作时候，背后主要发生了三件事：</p><ol type="1"><li>搜索</li><li>加载</li><li>绑定到命名空间</li></ol><p><code>import</code> 命令执行的时候，这三步会自动完成，而<code>importlib</code> 只会完成前两步。</p><p>有一点需要注意的是，即便你只导入了某个包中的一个属性，整个模块也会被导入，只是其余的部分没有绑定到当前命名空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[<span class="string">&quot;math&quot;</span>].cos(pi)</span><br><span class="line">-<span class="number">1.0</span></span><br></pre></td></tr></table></figure><p><code>sys.modules</code> 相当于系统对导入模块的缓存。当 python 在执行导入的时候，会先去缓存中查找，如果存在了，则不会执行导入。</p><h2 id="只导入一次">只导入一次</h2><p>你的包中有一些方法，它依赖一些数据，这些数据需要从磁盘或者网络读取，你的类在初始化的时候，可能会刷新这些数据，但如果每次初始化就刷新数据，会导致大量时间花在磁盘或网络IO上，可以设计一个单例模式来解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Population</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Prepare to read the population file&quot;&quot;&quot;</span></span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line">        self.variant = <span class="string">&quot;Medium&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment"># 创建只读属性的装饰器，名字不变，调用无需加括号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Read data from disk&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._data:  <span class="comment"># 已存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件，保存到 self._data</span></span><br><span class="line">        <span class="keyword">with</span> resources.open_text(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, <span class="string">&quot;WPP2019_TotalPopulationBySex.csv&quot;</span></span><br><span class="line">        ) <span class="keyword">as</span> fid:</span><br><span class="line">            <span class="comment"># Read data, filter the correct variant</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>property</code> 参考 <a href="https://www.tianqiweiqi.com/python-property.html">Python内置属性函数@property详解</a></p></blockquote><h2 id="刷新要导入的包">刷新要导入的包</h2><p>当模块属性或者方法有更新，可以使用 <code>importlib</code> 重载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importlib.reload(module_name)</span><br></pre></td></tr></table></figure><h2 id="理解导入顺序">理解导入顺序</h2><p>如果你的模块名字和标准库中的一样，系统会优先使用标准库的。</p><p><code>import</code> 执行时有几步：</p><ol type="1"><li>检查模块缓存，<code>sys.modules</code></li><li>通过查找器查找模块</li><li>通过加载器加载模块</li></ol><p>你可以继承 python 的查找器实现你自己的 finder，甚至是自己的 loader，当然可能目前没有必要。</p><p>这里想说明的是，导入操作是有顺序的，在执行查找操作时， <code>sys.meta_path</code> 会控制哪个查找器会被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">FrozenImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib_external</span>.<span class="title">PathFinder</span>&#x27;&gt;]</span></span><br></pre></td></tr></table></figure><p>这里可以看到，内置的模块先于自定义的被加载。</p><p>如果你把当前环境下所有查找器移除，python 就无法查找任何包了，但 python 仍然可以导入一些包，因为有些包已经位于缓冲中了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;math&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib  <span class="comment"># Autoimported at start-up, still in the module cache</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib</span><br><span class="line">&lt;module <span class="string">&#x27;importlib&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;.../python/lib/python3.8/importlib/__init__.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>咱们自定义一下系统的查找器，让它在查找的时候打印，这样我们就知道了当我导入一个包，有哪些包导入了。</p><p>对于查找器，有一个要求就是它必须要实现 <code>.find_spec()</code> 这个类方法，这个方法会尝试去查找模块，如果它不知道怎么查，它应该返回 None，如果知道，则返回 <code>nodule spec</code>, 如果模块无法找到，则发起 <code>ModuleNotFoundError</code> 错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debug_importer.py</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DebugFinder</span>:</span></span><br><span class="line"><span class="meta">     @classmethod  </span><span class="comment"># 类方法，无需示例即可使用</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">f&quot;Importing <span class="subst">&#123;name!r&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">sys.meta_path.insert(<span class="number">0</span>, DebugFinder)</span><br></pre></td></tr></table></figure><p>上面的查找器打印后，返回 None, 表示它不知道怎么查，随后会交给其他查找器查。</p><p>你可以按需要自定义 <code>sys.meta_path</code> 的加载顺序。</p><p>将这个自定义查找器，放在 <code>sys.meta_path</code> 第一位，每次执行 <code>import</code> 你就可以看到所有被导入的模块。</p><p>通过这种自定义查找的方法，我们甚至可以写一个自动安装包的查找器，把它插到 <code>sys.meta_path</code> 末尾，因为如果在末尾的位置被执行，这意味着前面的查找器都没有找到你想要的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip_importer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipFinder</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Module <span class="subst">&#123;name!r&#125;</span> not installed.  Attempting to pip install&quot;</span>)</span><br><span class="line">        cmd = <span class="string">f&quot;<span class="subst">&#123;sys.executable&#125;</span> -m pip install <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subprocess.run(cmd.split(), check=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> util.find_spec(name)</span><br><span class="line"></span><br><span class="line">sys.meta_path.append(PipFinder)</span><br></pre></td></tr></table></figure><blockquote><p>只是随便一说，不要放到自己项目中用！可能会带来灾难性后果</p></blockquote><h2 id="例子-数据文件导入">例子: 数据文件导入</h2><p>这个例子灵感的来源是 Aleksey Bilogur, 他有一篇文章(<a href="https://blog.quiltdata.com/import-almost-anything-in-python-an-intro-to-module-loaders-and-finders-f5e7b15cda47">Import Almost Anything in Python: An Intro to Module Loaders and Finders</a>)，介绍了模块的加载器和查找器。</p><p>你可能实现过自定义的加载器加载数据文件，但能不能利用加载器和查找器直接 <code>import</code> csv 文件呢？就好像下面这个代码一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv_importer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> employees</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.name  <span class="comment"># 直接访问列名</span></span><br><span class="line">(<span class="string">&#x27;John Smith&#x27;</span>, <span class="string">&#x27;Erica Meyers&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> employees.data:  <span class="comment"># 直接访问数据</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row[<span class="string">&quot;department&quot;</span>])</span><br><span class="line">...</span><br><span class="line">Accounting</span><br><span class="line">IT</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.__file__  <span class="comment"># 访问文件名</span></span><br><span class="line"><span class="string">&#x27;employees.csv&#x27;</span></span><br></pre></td></tr></table></figure><p>其实是可以的，我们可以将路径传给查找器处理路径的问题，然后通过加载器读取数据文件，最终实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> ModuleSpec</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CsvImporter</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, csv_path</span>):</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod  </span><span class="comment"># 类方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 处理路径</span></span><br><span class="line">    <span class="comment"># 其他操作</span></span><br><span class="line"><span class="keyword">return</span> ModuleSpec(name, cls(csv_path))  <span class="comment"># 此处 cls() 构造一个类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_module</span>(<span class="params">self, module</span>):</span></span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line"><span class="comment"># 绑定到模块中</span></span><br><span class="line">module.__dict__.update(fields)</span><br><span class="line">        module.__dict__[<span class="string">&quot;data&quot;</span>] = data</span><br><span class="line">        module.__dict__[<span class="string">&quot;fieldnames&quot;</span>] = fieldnames</span><br><span class="line">        module.__file__ = <span class="built_in">str</span>(self.csv_path)</span><br></pre></td></tr></table></figure><h1 id="其他导入技巧">其他导入技巧</h1><h2 id="导入特定版本">导入特定版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><h2 id="有条件导入你喜欢的包">有条件导入你喜欢的包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> ujson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line">   </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> quicktions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br></pre></td></tr></table></figure><h2 id="处理包的缺失">处理包的缺失</h2><p>你可能有一些比较酷的想法，比如利用 <a href="https://pypi.org/project/colorama/">Colorama</a> 这个包来给你的输出增加一些颜色，但是这个包并不是一个必要的，如果用户电脑上有这个包，那可以，要是没有你希望也可以正常使用你的程序。</p><p>你可以参考 <a href="https://realpython.com/python-testing/">testing</a> 中对于 <a href="https://realpython.com/python-mock-library/">mocks</a> 的使用实现这个想法。</p><h2 id="将脚本导入为模块">将脚本导入为模块</h2><p>脚本和模块的区别在于，脚本主要是去 do_something, 而模块则提供函数以供使用。他们都存在于 python 文件中，就 Python 而言，其实它们并没有什么区别。</p><blockquote><p>有时候你的模块可能比较复杂，有脚本也有模块，这时候可以考虑<a href="https://realpython.com/python-refactoring/">refactor</a>你的模块。</p></blockquote><p>但你也可以让你的模块提供两者的功能，既有函数，也可以直接执行，相信你看到过这种 python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="从-zip-文件启动脚本">从 ZIP 文件启动脚本</h2><p>新建一个 <code>__main__.py</code> 文件，打包成压缩包，你便可以直接通过 <code>python zip_file_name.zip</code> 这种形式运行。</p><p>你可以将你自己的包也按照这种方式处理，但 python 有提供了一个工具 <a href="https://docs.python.org/library/zipapp.html"><code>zipapp</code></a>，它可以帮你处理这些事情。</p><p>你只需要在你的包目录执行 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m zipapp population_quiz -m population_quiz:main</span><br></pre></td></tr></table></figure><p>它会做两件事，一是为你的程序添加入口，二是打包你的程序。</p><p>这里的 <code>__main__.py</code> 会自动生成，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> population_quiz</span><br><span class="line">population_quiz.main()</span><br></pre></td></tr></table></figure><p>上面的命令执行后，会产生 <code>.pyz</code> 的打包文件，在 windows 上应该可以直接执行，因为 <code>.pyz</code> 文件应该自动关联了运行程序，而在 Linux 或者 Mac 上，可以通过 -p 指定运行环境:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m zipapp population_quiz -m population_quiz:main \</span><br><span class="line">&gt;   -p <span class="string">&quot;/usr/bin/env python&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意在 zip 文件中，如果处理数据文件，open 方法会无法使用</p></blockquote><h2 id="处理循环导入">处理循环导入</h2><p>循环导入就是你中有我我中有你，比如</p><p><img src="https://i.loli.net/2021/09/21/V4rsyDKYe312CT7.png" /></p><p>这种情况本会发生无限递归循环，但是因为我们的老朋友模块缓存所以避免了惨剧的发生。</p><p>但是在下面这种情况，则会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yin.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yin&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yang</span><br><span class="line">number = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yang.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># yang.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yang&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yin</span><br><span class="line">number = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;yin and yang combined is <span class="subst">&#123;combine()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yang&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行 <code>import yin</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yin <span class="comment">#导入 yin 的时候，yin 中的 number 没有还没有定义</span></span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">  File <span class="string">&quot;.../yang.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> combine</span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line">AttributeError: module <span class="string">&#x27;yin&#x27;</span> has no attribute <span class="string">&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure><p>执行 <code>import yang</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yang  <span class="comment">#yang 调用 combine() 的时候，yin 已经初始化完成</span></span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Goodbye <span class="keyword">from</span> yin</span><br><span class="line">yin <span class="keyword">and</span> yang combined <span class="keyword">is</span> <span class="number">66</span></span><br><span class="line">Goodbye <span class="keyword">from</span> yang</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢？其实你的模块如果有存在互相引用，这意味着你的模块设计的不好，你需要想想怎么去组织你的代码。</p><h2 id="优化你的导入速度">优化你的导入速度</h2><p>你可能有些包导入的速度很慢，你想了解具体是在哪里速度变慢，自从 Python3.7 你可以有一个非常简单的办法了解你导入包的速度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python -X importtime -c <span class="string">&quot;import datetime&quot;</span></span><br><span class="line">import time: self [us] | cumulative | imported package</span><br><span class="line">...</span><br><span class="line">import time:        87 |         87 |   time</span><br><span class="line">import time:       180 |        180 |   math</span><br><span class="line">import time:       234 |        234 |   _datetime</span><br><span class="line">import time:       820 |       1320 | datetime</span><br></pre></td></tr></table></figure><p>cumulative 列按包显示了导入的累计时间（以微秒为单位）。</p><h1 id="总结">总结</h1><p>这篇文章主要介绍了：</p><ul><li>命名空间包</li><li>导入资源和数据文件</li><li>使用动态导入</li><li>扩展 Python 的导入机制</li><li>处理不同版本的包</li></ul><p>这里还有一些优秀的参考信息：</p><ul><li><a href="https://docs.python.org/reference/import.html">The import system</a></li><li><a href="https://docs.python.org/library/importlib.html">The <code>importlib</code> package</a></li><li><a href="https://www.python.org/dev/peps/pep-0420/">PEP 420: Implicit namespace packages</a></li><li><a href="https://docs.python.org/library/modules.html">Importing modules</a></li></ul><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-import/#basic-python-import">Python import: Advanced Techniques and Tips</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p05_separate_directories_import_by_namespace.html">利用命名空间导入目录分散的代码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章深入研究了 &lt;code&gt;import&lt;/code&gt; 命令以及它的工作原理。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-模块与包</title>
    <link href="http://wittyfans.com/article/c8bc6f6.html"/>
    <id>http://wittyfans.com/article/c8bc6f6.html</id>
    <published>2021-09-18T09:59:07.000Z</published>
    <updated>2021-11-19T14:12:08.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章会介绍 Python 中的模块和包。</p></blockquote><span id="more"></span><h1 id="python---模块与包">Python - 模块与包</h1><p>引申出模块化编程的概念，即将代码分解成小模块，各自解决不同的问题，这样使得代码更简单 (<strong>Simplicity</strong>)，容易维护 (<strong>Maintainability</strong>)，也更容易分享、重用代码 (<strong>Reusability</strong>)。</p><p>Python 中的模块主要有三种：</p><ol type="1"><li>用Python写的模块</li><li>用C 写的模块</li><li>内置的模块如 <code>itertools</code> 模块</li></ol><p>这篇文章只关注 Python 写的模块。</p><h1 id="模块的搜索路径">模块的搜索路径</h1><p>假设你写了个模块 <code>mod.py</code> , 怎么使用呢？</p><p>如果你当前工作目录在合适的位置，你可以执行 <code>import mod</code>, 然后你便可以引用其中的对象，那什么叫合适的位置？</p><ol type="1"><li>与 <code>mod.py</code> 同一位置</li><li>你的模块位置被包含在 <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> 中</li><li>模块位置在安装 Python 时标准链接库目录是定义过</li><li>你创建了一个 <code>.pth</code> 文件告诉 Python 去哪里找，此模块位于其中</li></ol><p>上面四种情况，只有 <code>PYTHONPATH</code> 环境变量和路径文件可以被用户配置。</p><p>Python 会自动去寻找这些地方是否有你需要的包，你可以通过 <code>sys.path</code> 查看它的搜索顺序。</p><p>所以还有一种方法导入包，即将你的包地址放入 <code>sys.path</code>，它是一个列表，所以你可以执行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">r&#x27;C:\Users\john&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> mod</span><br></pre></td></tr></table></figure><p>当模块被导入后，你也可以通过 <code>mod.__file__</code> 查看包的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Users\\john\\mod.py&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Python36\\lib\\re.py&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="导入模块">导入模块</h1><p>模块的存在是为了被导入 <code>import</code> 以使用, 就像钢琴的存在是被人演奏以产生音乐。</p><h2 id="import-module_name">import module_name</h2><p><code>import</code> 上面已有例子，需注意 <code>import</code> 不能让你直接使用所有模块内的内容。模块有其私有符号表 (<strong>private symbol table</strong>), 模块以此来确定各自之间的边界。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zoo</span><br><span class="line"><span class="built_in">print</span>(zoo.dog)  <span class="comment"># yes</span></span><br><span class="line"><span class="built_in">print</span>(dog)  <span class="comment"># no, dog 位于 zoo 中</span></span><br></pre></td></tr></table></figure><h2 id="from-module_name-import-name">from module_name import name</h2><p>另一种导入模块的方式是直接导入模块内的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module_name&gt; <span class="keyword">import</span> &lt;name(s)&gt;</span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> dog, pig  <span class="comment"># 只需要特定对象</span></span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> *  <span class="comment"># 需要所有对象</span></span><br></pre></td></tr></table></figure><p>需要小心 <code>from &lt;module_name&gt; import *</code> 这种方式，除非你很清楚自己在做什么。</p><h2 id="from-module_name-import-name-as-alt_name">from module_name import name as alt_name</h2><p>这种方式和上面的一样，只是多了 <code>as</code> 关键字以定义别名。</p><h2 id="导入提示">导入提示</h2><p>导入模块的语句通常写在文件首部，但也可以写在函数中，不过 Python3 不允许在函数中 <code>import *</code>。</p><p>防止模块导入失败，可以使用 <code>try...except...</code> 语句捕捉 <code>ImportError</code>错误。</p><p><code>dir()</code> 函数可以返回当前命名空间中所有的变量。</p><p>导入模块的时候，模块的代码将会执行，如果希望模块内的某些代码只是在你需要的时候才调用执行，可以加入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__name__ == <span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line"><span class="keyword">pass</span>  <span class="comment"># do you work</span></span><br></pre></td></tr></table></figure><p>导入模块的操作只会执行一次，考虑以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.a</span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br></pre></td></tr></table></figure><p>发现第二次和第三次导入并未输出，如果想要每次导入操作都重新导入，可利用 <code>importlib</code> 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib.reload(mod)</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">&lt;module <span class="string">&#x27;mod&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\Users\\john\\Documents\\Python\\doc\\mod.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>模块可以被当作脚本执行，只需要在模块所在文件夹增加一个 <code>__main__.py</code> 文件。</p><h1 id="python-包">Python 包</h1><p>包是一组或多组模块，包可以让你通过包的名字简单的访问其下面的各种模块。</p><p>下面是一个包的结构，其中有两个模块。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br></pre></td></tr></table></figure> 这时候如果你在 <code>pkg</code> 上级目录执行 <code>import pkg</code> 该包里将不会包括任何东西，无法引用 mod1 也无法引用 mod2 中的内容。</p><h2 id="init__.py"><code>__init__.py</code></h2><p>如果在 pkg 目录下新增 <code>__init__.py</code> 文件，则可以引用 <code>__init__</code>中的的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br><span class="line">__init__.py</span><br></pre></td></tr></table></figure><p>在内部 mod1 模块中，你也可以访问<code>__init__</code> 中的对象。</p><p>如果想在外部通过 <code>import pkg</code> 的方式，通过 <code>pkg</code> 访问 <code>mod1</code> 或 <code>mod2</code> 中的对象，则需要在 <code>__init__</code> 中导入 <code>mod1</code> 和 <code>mod2</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In __init__.py</span></span><br><span class="line"><span class="keyword">import</span> pkg.mod1, pkg.mod2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 Mod1 和 Mod2</span></span><br><span class="line"><span class="keyword">import</span> pkg</span><br><span class="line"></span><br><span class="line">pkg.mod1.foo()</span><br><span class="line"></span><br><span class="line">pkg.mod2.bar()</span><br></pre></td></tr></table></figure><blockquote><p>在 Python3.3 之后，<a href="https://www.python.org/dev/peps/pep-0420/">Implicit Namespace Packages</a> 发布了，定义包也可以不新建 <code>__init__</code> 了。</p></blockquote><h2 id="all__"><code>__all__</code></h2><p>你肯定写过 <code>from &lt;package_name&gt; import *</code> 这样的代码，其中 * 代表的是 import 什么？</p><p>如果在包的 <code>__init__.py</code> 中定义 <code>__all__</code> 来进行控制。</p><p><em><strong>pkg/__init__.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [</span><br><span class="line">        <span class="string">&#x27;mod1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod4&#x27;</span></span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>则所有其中的内容都会在写 <code>from pkg import *</code> 的时候，自动导入。</p><p>在模块中定义 <code>__all__</code> 亦是。</p><p><em><strong>pkg/mod1.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"><span class="comment"># 当使用 `from pkg.mod1 import *` 的时候，只有 foo 会被导入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod1] foo()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>区别是：</p><ul><li>对于一个包，如果<code>__all__</code> 没有定义，<code>import *</code> 不会导入任何对象</li><li>对于一个模块，如果<code>__all__</code> 没有定义，<code>import *</code> 默认导入所有对象</li></ul><h1 id="python-子包">Python 子包</h1><p>包中可以放子包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg1</span><br><span class="line">    │      mod1.py</span><br><span class="line">    │      mod2.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg2</span><br><span class="line">    │      mod3.py</span><br><span class="line">    │      mod4.py</span><br></pre></td></tr></table></figure><p>使用方式则需要一层一层使用 <code>.</code> 语法下钻:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg.sub_pkg1.mod1</span><br><span class="line">pkg.sub_pkg1.mod1.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1 <span class="keyword">import</span> mod2</span><br><span class="line">mod2.bar()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod3 <span class="keyword">import</span> baz</span><br><span class="line">baz()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod4 <span class="keyword">import</span> qux <span class="keyword">as</span> grault</span><br><span class="line">grault()</span><br></pre></td></tr></table></figure><p>如果是兄弟模块之间要导入模块怎么办？有两种方式：</p><p>全路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>相对路径: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> sub_pkg1</span><br><span class="line"><span class="built_in">print</span>(sub_pkg1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-modules-packages/">Real Python - Python Modules and Packages – An Introduction</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章会介绍 Python 中的模块和包。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 与 Go 开发环境配置</title>
    <link href="http://wittyfans.com/article/dfea7f59.html"/>
    <id>http://wittyfans.com/article/dfea7f59.html</id>
    <published>2021-09-14T04:50:03.000Z</published>
    <updated>2021-11-19T14:12:08.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。</p></blockquote><span id="more"></span><h1 id="centos-7-开发环境配置">CentOS 7 开发环境配置</h1><h2 id="git">Git</h2><blockquote><p>略过。</p></blockquote><h2 id="docker">Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 docker 进程</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 docker 阿里云镜像，容器镜像服务</span></span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://8szzfxmd.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 docker-compose</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html">如何检查进程？</a></p></blockquote><h2 id="mysql">Mysql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 mysql</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 mysql</span></span><br><span class="line">docker run -p 3306:3306 --name mymysql -v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d -V <span class="variable">$PWD</span>/logs:logs -v <span class="variable">$PWD</span>/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234@Abc -d mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 docker 的容器</span></span><br><span class="line">docker ps -a (ps: Process Status, from linux)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 mysql 容器并启动 bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -it a7a8e9df1270 /bin/bash</span><br><span class="line">myql -uroot -pyoupassword</span><br></pre></td></tr></table></figure><h2 id="python">Python</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anaconda in centos7</span></span><br><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh</span><br><span class="line">bash naconda3-5.3.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://linuxize.com/post/how-to-install-anaconda-on-centos-7/">Install &amp; uninstall Anaconda on centos7</a></p></blockquote><h2 id="go">Go</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go 环境变量</span></span><br><span class="line">go env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 go module</span></span><br><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello golang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行运行 </span></span><br><span class="line"><span class="keyword">go</span> run .\hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译文件, c/c++ -&gt; .so .lib .dll; java -&gt; .class; go -&gt; windows exe</span></span><br><span class="line"><span class="keyword">go</span> build .\hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
  </entry>
  
  <entry>
    <title>数据仓库-维度建模</title>
    <link href="http://wittyfans.com/article/c721127b.html"/>
    <id>http://wittyfans.com/article/c721127b.html</id>
    <published>2021-09-14T03:39:28.000Z</published>
    <updated>2021-11-19T14:12:08.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据仓库、商业智能初步，常用维度建模架构对比。</p></blockquote><span id="more"></span><h1 id="业务管理的问题">业务管理的问题</h1><p>信息系统存在的目的是解决业务的问题，对于数据仓库 Data WareHouse 和商业智能 Business Intelligence 来说，下面这些问题已经存在了几十年了：</p><ul><li>收集了很多数据却无法访问</li><li>需要对数据做切片、切块</li><li>分析师、业务人员需要方便的获取数据</li><li>怎么展示最重要的事情</li><li>花费大量时间在研究数字的正确性，而不是业务决策</li><li>希望使用信息做更多基于事实的决策</li></ul><p>这些问题对应了数据仓库与商业智能的目标，解决这些业务问题，信息系统必须做到：</p><ul><li>方便的存取信息</li><li>一致性的形式展示信息</li><li>能够适应变化</li><li>及时的展示信息</li><li>保护信息财富</li><li>成为提高决策制定能力的权威</li><li>业务群体的认可</li></ul><p>作为一个 DW/BI 管理者，你的责任则更具体：</p><ol type="1"><li>理解业务用户</li><li>对业务用户发布高质量、相关的、可访问的信息和分析</li><li>维护 DW/BI 环境</li></ol><h1 id="维度建模">维度建模</h1><blockquote><p>爱因斯坦曾说: <strong>凡事应该尽量简单，直到不能再简单为止</strong>。</p></blockquote><p>维度建模是展示分析数据的首选技术，它的优势在于能以商业用户可理解的方式发布数据并提供了高效的查询性能。它最初是用来简化数据库的，在维度建模中最开始使用的数据模型通常越简单越好，复杂的开始会导致最终的模型也很复杂。</p><p>维度模型通常建立在关系型数据库上，但这不意味着维度模型必须满足关系型数据库的要求，比如第三范式（3NF）。</p><p>3NF 是为了减少数据冗余，它会将数据划分成不同的实体，每个实体构成一个关系表。</p><p>但 3NF 不适用于 BI，主要是其模式太复杂，3NF 主要应用在操作性过程中，而不是 BI 查询，维度建模可以解决模式过分复杂的问题。</p><p>维度建模在不同的数据库系统中有不同的叫法：</p><ul><li>关系数据库 -&gt; 星型模式</li><li>多维数据库 -&gt; 联机分析处理</li></ul><h2 id="事实表与维度表">事实表与维度表</h2><p>在维度建模中，存在两类表：</p><ul><li>事实表（数量，销售额，需注意可加性和不可加性，比如账户结余不可加）</li><li>维度表（谁、什么、哪里、何时、如何、为什么）</li></ul><p>事实表中一条记录所表达的业务细节程度被称为<strong>粒度</strong>。通常粒度可以通过两种方式来表述：一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。</p><p>事实表的粒度有三类：事务周期快照累快照，个。 事实表通常只有很少的列和很多行，是一种<strong>“瘦高”</strong>型的表。事实表定义为以下三种类型之一：</p><ul><li>事务事实表:记录有关特定事件的事实（例如，销售事件，保存在原子的粒度，也称为原子事实表）</li><li>周期快照事实表记录给定时间点的事实（例如，月末的帐户详细信息）</li><li>累积快照事实表记录了给定时间点的汇总事实（例如，某产品的当月迄今总销售额）</li></ul><p>作为度量业务过程的事实，一般为整型或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完全不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚集。</p><p>一般事实表具有两个或更多外键与维度表关联，比如事实表中的产品键始终与产品维度中的特定产品键匹配。如果事实表中所有键与维度表中的都匹配，则满足了 <code>参照完整性</code>, 可以通过维度表使用连接操作访问事实表。</p><figure><img src="https://i.loli.net/2021/09/14/1GKmvWe2dBNwols.jpg" alt="事实表与维度表" /><figcaption aria-hidden="true">事实表与维度表</figcaption></figure><p>事实表通常包含外键集合的主键，具有组合键的表即事实表，事实表通常具有多对多的关系。</p><p>维度是维度建模的基础和灵魂。在维度建模中，将度量称为<strong>事实</strong>，将环境描述为<strong>维度</strong>，维度是用于分析事实所需要的多样环境。</p><p>维度表通常有很多列、属性，维度表倾向于包含少量的行，一般用维度表来作为查询的约束、分组。</p><p>多数情况下，数据仓库的好坏直接取决于维度属性的设置，也决定了 DW/BI 的分析能力，强大的维度属性等于健壮的分片、分块分析能力。</p><p>对维度表的设计重点关注简单性和可访问性，可以不满足第三范式。</p><h1 id="kimball-的-dwbi-架构">Kimball 的 DW/BI 架构</h1><figure><img src="https://i.loli.net/2021/09/14/9LHTwZXSxevy48a.png" alt="Kimball 架构" /><figcaption aria-hidden="true">Kimball 架构</figcaption></figure><h2 id="操作型源系统">操作型源系统</h2><p>该系统面对很多用户，并发事务很多。多是插入、更新操作。对数据的插入，更新性能要求更高，因此数据多是规范化的，规范化是指冗余度比较少。</p><h2 id="etl-系统">ETL 系统</h2><p>处理操作型源系统与DW/BI 之间，该系统对数据的处理分为三个部分：</p><ol type="1"><li>获取 Extract，从操作型系统导入到 DW/BI</li><li>转换 Transformation，清洗，合并，复制等</li><li>加载 Load，构建和加载数据到<code>展现区域</code>的目标维度模型</li></ol><p>展现区域用于组织、存储，用户也可以在这里制作报表，查询，这是用户主要关注的区域，关于展现区，该书作者有两点建议：</p><ol type="1"><li>数据应该以维度模型来展现（星型或OLAP多维数据库）</li><li>必须包含到最详细的原子数据级别</li></ol><h2 id="bi-应用">BI 应用</h2><p>这是最后一个主要的部件，BI 突出的是支持商业决策的能力，它可以很简单，也可以很复杂。</p><h1 id="其他-dwbi-架构">其他 DW/BI 架构</h1><p>第一种是独立数据集市，特点是以部门为架构组织，只考虑本部门的需要与业务规则，但不同部门之间的数据访问与标准各异，很多数值无法匹配。</p><p>这种架构代表了一种 DW/BI 架构，但其实属于没有结构，容易造成混乱。虽然可以低成本实现快速开发，但会存在分析数据冗余的问题，不是长远之计。</p><figure><img src="https://i.loli.net/2021/09/14/XUFEgK8xyf6VS4L.jpg" alt="简化的独立数据集市" /><figcaption aria-hidden="true">简化的独立数据集市</figcaption></figure><p>第二种是辐射状企业信息工厂(Corporate Information Factory) Inmon 架构，它的数据从操作型数据库获取，经过 ETL 会保存在满足第三范式的数据库中，称为 EDW (Enterprise Data Warehouse).</p><p>EDW 中的数据都是规范化的，原子级别的，相当于有一个中间过程协调与集成数据，缺点是它的下游数据组织形式以部门为单位，且包含的是聚集数据，非原子级别的数据，而对业务用户暴露原子级别的数据是有必要的，<strong>聚集数据比原子数据提供了更好的性能，但不能取代细节数据</strong>。</p><figure><img src="https://i.loli.net/2021/09/14/bNcup7VxdTjy1If.jpg" alt="CIF" /><figcaption aria-hidden="true">CIF</figcaption></figure><p>最后还有一种混合了 CIF 与 Kimball 模式的架构，有人说这是最好的架构因为混合了前面的两种架构，但是这也意味着更多的开销与时间，无论是开发还是运行期间，因为数据需要更多次的移动，细节数据冗余存储。</p><p>如果你已经建立了第三范式的 EDW，但无法让用户更灵活的实现报表与分析，可以采用这种模式。</p><h1 id="维度建模的误解">维度建模的误解</h1><p>维度模型被广泛使用，但也还存在很多误解，如：</p><ul><li>它仅包含汇总数据</li><li>它是部门级的，不是企业级的</li><li>它不可扩展</li><li>它仅用于预测</li><li>它不能被集成</li></ul><p>实际上，维度模型可以存储大量历史数据，按照业务过程组织即可满足企业级的要求，事实表非常容易扩展，数据库提供商也在不断优化维度模型的可扩展性和性能。</p><p>维度模型对业务的适应性也很强，业务需求可能是经常变化的，但维度模型具有对称性，只要以最细粒度级别构建事实表，加上维度结构非常灵活，可以很好的满足业务需要。</p><blockquote><p>细节就是上帝。—— 建筑师 Mies van der Rohe</p></blockquote><h1 id="参考">参考</h1><ul><li><a href="https://jiamaoxiang.top/2020/07/11/数仓-大数据时代-维度建模过时了吗/">数仓-大数据时代-维度建模过时了吗?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据仓库、商业智能初步，常用维度建模架构对比。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="data" scheme="http://wittyfans.com/categories/data/"/>
    
    
    <category term="data warehouse" scheme="http://wittyfans.com/tags/data-warehouse/"/>
    
    <category term="data base" scheme="http://wittyfans.com/tags/data-base/"/>
    
  </entry>
  
  <entry>
    <title>B 树索引与位图索引简述</title>
    <link href="http://wittyfans.com/article/a8fa00e8.html"/>
    <id>http://wittyfans.com/article/a8fa00e8.html</id>
    <published>2021-09-09T13:04:16.000Z</published>
    <updated>2021-11-19T14:12:08.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。</p></blockquote><span id="more"></span><p>在 Oracle 中， 可以使用 <code>CREATE INDEX</code> 创建索引，索引的类型有以下几种：</p><ul><li><p>Normal indexes (Oracle Database 默认使用的 B-tree 索引)</p></li><li><p>Bitmap indexes (用一个bit位来标记某个元素 rowid 对应的Value)</p></li></ul><blockquote><p>Refer <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5010.htm">Oracle 官方文档</a></p></blockquote><h1 id="b-tree">B-tree</h1><p>B-tree 的出现主要是为了提高访问磁盘的速度。那为什么使用 B-tree 实现而不是其他的数据结构呢？</p><p>对于二叉搜索树，红黑树，avl 树来说，每一个节点只能存储一个 key，如果你需要存储大量的 key，使用这些数据结构就会让树变得很高，但 B-tree 在一个节点内就可以存储多个 key，且可以拥有多个子节点，这就可以降低树的高度，提高磁盘访问速度。</p><p>那一个节点内可以存储多少个 key，可以拥有多少个子节点呢？</p><p>假设用 k (取值范围M-M/2)表示，则 B-tree 中的每个节点可以有 k-1 个 key，以及 k 个子树。</p><p>所谓 M 阶（m-way）B树，其中 M 就是表示 B-tree 中每个节点最多可以有几个子树。</p><h1 id="b-tree-1">B+ tree</h1><p>B+ tree 是 B-tree 的升级版，一棵 B+ 树需要满足以下条件:</p><ol type="1"><li>节点的子树数和关键字(Key)数相同（B 树是关键字数比子树数少一）</li><li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li><li>叶子节点包含了全部数据，同时符合左小右大的顺序</li></ol><p>B+ 树数据都在叶子节点，并使用一个链表将它们排列起来，这样在查询时效率更快。</p><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。</p><h1 id="bitmap-索引">Bitmap 索引</h1><p>我们知道计算机所有信息最终都是通过“位bit”来运算的，二进制位运算在计算机中非常高效。而位图索引也是用0或1来处理索引进程，故得名位图索引。 位图索引主要针对大量相同值的列而创建的，索引块的一个索引行中存储键值、起止RowId及此键值的位图，根据位图信息可以得知每一条记录的ROWID。它为列的每个键值建立位图，位图中的每一位可能对应多个列，位图中位的值为1表示此行的值为对应的键值。</p><p>特点：</p><ul><li>可以存储null值；</li><li>不适合键值较多的列（重复数据较少的列）,适合只有几个固定值的列；如性别、婚姻状况、行政区等等</li><li>相对于B*Tree索引,占用的空间非常小,创建和使用非常快；</li><li>适合静态数据，而不适合索引频繁更新的列；</li><li>使用count、and、or或in查询时,直接用索引的位图进行或运算,快速得出结果行数据。</li></ul><h1 id="参考">参考</h1><ul><li><a href="https://juejin.cn/post/6844903613915987975">理解 B 树、B+ 树特点及使用场景</a></li><li><a href="https://www.programiz.com/dsa/b-tree">B-tree 介绍与代码实现</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-tree 动态交互图</a></li><li><a href="https://bbs.huaweicloud.com/blogs/114861">Oracle 索引概述</a></li><li><a href="http://tech.jasonsoso.com/2015/01/B-tree-indexes-and-bitmap-indexes/">B 树索引与位图索引简述</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="data structure" scheme="http://wittyfans.com/tags/data-structure/"/>
    
    <category term="database" scheme="http://wittyfans.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>数据分析在做什么</title>
    <link href="http://wittyfans.com/article/a31aaf3c.html"/>
    <id>http://wittyfans.com/article/a31aaf3c.html</id>
    <published>2021-09-06T15:42:25.000Z</published>
    <updated>2021-11-19T14:12:08.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据分析即做比较。</p></blockquote><span id="more"></span><h1 id="数据分析在做什么">数据分析在做什么？</h1><p>数据分析本质上做对比，所以首先考虑的问题是和谁比，怎么比，比什么。 其次，分析对应的是分解问题，分析拆解后的复杂事物，得到拆解元素之间的联系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据分析 -&gt; 拆分、分解问题 -&gt; 比较</span><br></pre></td></tr></table></figure><p>数据的字段 (Field) 有各种类型，如：</p><ol type="1"><li>定类尺度（性别）</li><li>定序尺度（成绩优良中下）</li><li>定距尺度（30比20高10）</li><li>定比尺度（项目数，每月工时）</li></ol><p>同样，对于数据的属性也有好几种，如离散属性以及连续属性。离散属性中有频率与频数。连续属性则有：</p><ol type="1"><li>平均值</li><li>中位数、分位数</li><li>众数</li><li>方差、标准差、自由度</li><li>偏态系数</li><li>峰态系数</li></ol><h1 id="怎么比">怎么比</h1><p>首先来看怎么比的问题，简单的多少、长短也是比较，对于数据分析我们有如下几种常用的类型。</p><ol type="1"><li>假设检验，一致还是不一致</li><li>多维分析与钻取分析（Drill Down，Roll up）</li><li>交叉分析与透视表</li><li>秩次比较</li><li>相关分析</li><li>回归探索</li><li>自由分组与归类</li></ol><blockquote><p>这里说的是什么暂时不理解没关系，之后会单独拿出来讲。</p></blockquote><h2 id="一致还是不一致">一致还是不一致</h2><p>我们可以通过假设检验来回答一致还是不一致的问题，先解释假设检验中的两个单词: <code>H0</code> 和 <code>H1</code>。</p><ul><li><code>H0</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差是由自然误差引起的</li><li><code>H1</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差存在本质上的差别</li></ul><p>拒绝<code>H0</code> 的成立，就可以对数据的比较做出结论推断，通常需要确定最大概率，用 <span class="math inline">\(\alpha\)</span> 表示，常见的情况下取 0.05 或 0.01， 如果原假设发生的概率小于 <span class="math inline">\(\alpha\)</span> 则可以拒绝 <code>H0</code>。 为了拒绝原假设，需要进行检验，即检验统计量，检验统计量的方法有很多种，在不同的场景下对应着不同的检验方法，常见的检验方法及应用场景有：</p><ul><li>Z 检验， 样本均值是否与正态分布总体一致？</li><li>T 检验，样本平均数与整体平均数</li><li>F 检验，多组样本间的一致性比较</li><li>卡方检验， 两个分部是否一致的差异</li><li>秩和检验， 摆脱对总体分布的依赖，秩理解为名次</li><li>A/B Test，新功能衡量部分用户的表现，上不上？</li><li>低功效实验，P值</li></ul><p>需注意不同的检验方法的要求与统计量的计算方式不同，需要根据实际情况选择。</p><p>假设检验的结果也有可能是错的，主要有两类错误：</p><ul><li>第一类错误，是真实情况为 <em><code>H0</code></em> 成立，但判断结论为拒绝 <em><code>H0</code></em>， 也就是把真的当成了假的</li><li>第二类错误，是真实情况为 <em><code>H0</code></em> 不成立，但判断结果接受 <em><code>H0</code></em>，也就是把假的当成了真的</li></ul><p>在饱和的情况下，这两类的错误属于此消彼长的关系，当降低第一类错误发生概率时，第二类错误发生的概率会增加，反之亦然。</p><h2 id="假设检验公式">假设检验公式</h2><ul><li>Z检验, <span class="math inline">\(Z = \frac{(\bar{x}-\mu_0)}{s}\)</span> = <span class="math inline">\(\frac{(sample average-mean)}{standard\ deviation}\)</span></li></ul><h2 id="多维分析与钻取分析">多维分析与钻取分析</h2><p>多维分析的问题类似，调查北京有多少厨师？你需要列举所有可能的与厨师数量的属性，比如餐馆的数量、门店类型、分布规律等。</p><p>钻取分析的例子，假设某月，可乐的销量突然上涨，你想知道具体是在什么地区上涨（Contributing)。</p><p>多维分析是从多个角度、多个维度分析。钻取分析则是从维度变化的角度考虑，扩大或者缩小分析粒度。</p><p>多维分析可以在不同对象的相同维度下进行比较，也可以在相同对象的不同维度下，甚至是不同对象的不同维度，只要有业务支持。具体的方法可以比数值、也可以比占比。其精髓在于尽可能的罗列所有维度。</p><p>钻取分析需要注意其陷阱，因为<strong>下钻的层次越深，复合特征的样本越来越少，越少的样本代表着越高的风险，也会导致越不可靠的结论。</strong></p><p>其次钻取的顺序也需要注意，比如调查离职员工的规律，为什么先从部门开始钻取，而不是其他？这里需要有个标准，一般来说<strong>区分程度最大的下钻方式应该排在最前面</strong>，如何衡量这个区分度呢？这就属于决策树中的内容了。</p><p>另外一个钻取的陷阱是<a href="https://wiki.mbalib.com/wiki/辛普森悖论">辛普森悖论</a>， 这里不做多介绍，感兴趣的可以打开链接了解。</p><h2 id="交叉分析与透视表">交叉分析与透视表</h2><p>这部分如果会使用 Excel 的 Pivot Table，或者 Pandas 里的 <code>groupby</code>， <code>pivot</code> 或 <code>pivot_table</code> 方法就懂了，在此不做解释。</p><h2 id="秩次比较">秩次比较</h2><blockquote><p>未完待续...</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据分析即做比较。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="data analysis" scheme="http://wittyfans.com/categories/data-analysis/"/>
    
    
  </entry>
  
  <entry>
    <title>统计基础概念</title>
    <link href="http://wittyfans.com/article/4187072417.html"/>
    <id>http://wittyfans.com/article/4187072417.html</id>
    <published>2021-08-15T15:03:54.000Z</published>
    <updated>2021-11-19T14:12:08.913Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概率与统计的基础概念。</p></blockquote><span id="more"></span><h1 id="统计">统计</h1><p>数据类型： - 离散类型，只能是某些既定的值 - 连续类型，可以是一个范围里任何的值</p><p>离散数据是数出来的，连续数据是测量出来的。对于离散概率分布，我们关心的是取得一个特定数值的概率。例如抛硬币正面向上的概率为:p(x=正面)=1/2</p><p>而对于连续概率分布来说，我们无法给出每一个数值的概率，因为我们不可能列举每一个精确数值。</p><h2 id="histograms直方图">1. Histograms（直方图）</h2><p>定义：是一种对数据分布情况的图形表示，横轴是统计样本，纵轴是统计样本某个属性的度量。</p><p>我们测试人的身高，把这些数据放到数轴上，并分段，把数据这个段（bins）的数据从下往上堆，就得到了直方图。</p><p>有了这个图，我们就可以预测未来的到某个身高值的概率。</p><p>比如，你敢打赌下一个测量的人，有很大的几率处在直方图靠近中间的位置。</p><p>如果你想要用一个图，来近似表示你的数据，或未来预测的测量值，就可以使用直方图。</p><p>直方图中的bins的选择，很重要，太小或太大都不行，不要仅仅依靠程序的默认值。</p><h2 id="statistical-distribution概率分布">2. Statistical distribution（概率分布）</h2><p>现在你拿到了直方图，你的bins可能需要调整一下，你从1调整为0.5，这样让你的图像更直观，同时，也让你对数据的预测更准确。</p><p>你会发现，你的数据量越多，和你的bins越小，都可以提高你对数据预测的准确率。</p><p>你可以用一条曲线来表示分布，他比直方图更准确，因为直方图总会有在某个区间的值比较少或没有的情况，而曲线是连续的，且很方便计算。</p><p>另外，当你没有足够的资源和钱做足够的测试，你其实可以用既有的数据算出这跟我曲线。曲线图和分布图都是描述分布的一种方式。</p><h2 id="normal-distribution正态分布">3. Normal Distribution（正态分布）</h2><p>我们看过身高的数据，会发现它是左右对称的，事实上人类身高是一种正态分布。</p><p>刚出生的小孩和成年人的分布不一样，成年人高矮的区间比较大，而刚出生的小孩身高区间都在一个比较小的范围。</p><p>这个分布的宽度（即身高的区间）由数据的标准差决定。</p><p>知道这个标准差很重要，如在小孩的分布中，图像标准差为0.6，成人的为4.</p><p>我们可以知道 95% 的数据会落在（平均值 +- 2* 标准差），自然界的很多事物都遵循正态分布，这是因为什么呢？这就是中心极限定理</p><h2 id="population-parameters总体参数">4. Population Parameters（总体参数）</h2><p>我们选择测量一些基因数据，得到了一个直方图，通过直方图计算概率。</p><p><img src="https://i.loli.net/2020/03/28/lbg2cPIiaHqfGBD.png" /></p><p>这个分布的 mean=20, std=10。</p><p>同样的，我们也可以根据曲线图来计算概率。</p><p><img src="https://i.loli.net/2020/03/28/FgTQjHkDPYcIoUs.png" /></p><p>因为上述的直方图和曲线图，表示了所有的基因数据分布，在统计上会叫它为population，而mean和std，叫做 population mean 和 population std.</p><p>分布有很多种，有： - 指数分布，指数分布的参数是rate,即population rate. - Gamma 分布, 参数是 shape 和 rate</p><p>知道 population 参数的原因是，你的分布可以重复计算. 如果你有机器学习基础，你可以把 population参数看作是 training dataset, 曲线则是我们想要根据我们的方法作出的预测。</p><p>事实上，你测量的数据得到的population参数，每次都是不一样的，那怎么估计真实的参数呢？事实上，当你做的测量越多，你得到的参数，就越接近真实的参数。</p><p>统计的一个目的就是，根据你现有测量的数据，你对这个真实的参数，有多大的信心估计正确了。</p><p>特别的，我们一般用 p-value 和 置信区间来描述这种信心。</p><p>数据也多，你的信心就越大，</p><h3 id="bootstrap-refresher">bootstrap refresher</h3><p>我们测量12只母老鼠的体重，并计算这组老鼠体重的的平均值，这个平均值只是这12只老鼠的，而利用sample，我们可以利用手中已有的值，去估计所有老鼠体重的平均值。</p><p>怎么做的，用 sampling with replacement，即有放回的抽样，抽12次之后，计算平均值。</p><p>重复上面的步骤很多次，对这些平均值再取平均，即得到了你想要的值。</p><p>再来说置信区间，我们一般说95%的置信区间，意思就是，那个包含了上述95%的平均值的范围。</p><p>如果你拿母老鼠和公老鼠的数据对比，分别看他们95%的平均值的范围，如果彼此没有重合，那就可以说他们是不一样的，两组值的mean是统计显著的，而如果有重合的部分，就需要做t-test了。</p><h2 id="meanvariancestd">5. Mean，Variance，STD</h2><p>我们以上面的基因例子为例，对240万个基因值计算平均值，即得到了平均值，注意，这是对所有的值计算平均值，所以不是population mean，而是 真正的mean。</p><p>注意区分：</p><ul><li>sample mean，estimated mean（x-bar）</li><li>population mean（mu）</li></ul><p>总结：</p><p>如果你有所有的值，那直接除以数量，就得到了平均值（mu） 如果你没有所有值，可以利用（x-bar）估计population mean，x-bar是你既有的值算出来的平均值。</p><p>population variance，用你的data减去population mean（mu），平方后再除以样本数。</p><p>population std则是对population variance开根号。</p><p>然而，更多的情况是，你不可能直接算出来population mean，std，variance这些值，因为你只有有限的样本。</p><p>所以你得用x-bar代替mu，并将n-1代替n作为样本空间，计算variance，以及std。</p><p>因为我们算的是sample mean，而不是population mean，所以n需要减1。</p><p>为什么呢？请看下图</p><p><img src="https://i.loli.net/2020/03/29/Dch4BEqaHNTnJ7b.png" /></p><p><img src="https://i.loli.net/2020/03/29/ElgYG5SktiePJZu.jpg" /></p><p>因为数据与sample mean之间的差值，要小于数据与population mean之间的差值。</p><h2 id="what-is-a-statistical-model">6. What is a statistical model?</h2><p>model，即模型。比如根据老鼠体重，预测体长，这就是一个 model.</p><p>在这个语境下，model是一种关系。</p><p>体重越大，体长越长。</p><p>有时候model中，x和y的关系，并不是一条直线。</p><p>model 可以很简单，也可以很复杂。</p><h2 id="sampling-a-distribution">7. Sampling A Distribution</h2><p>对一个分布进行抽样，假设你现在有一个随机的分布，我们可以从中抽样，来计算这个分布的mean值（x-bar）</p><p>你可以抽样很多次，于是你会得到一个mean值的分布，这个分布图像的mean，随着抽样的个数（sample size）的增加，抽样分布的mean，会趋向于真正的mean，即（population mean），抽样分布的图像，会接近正态分布，符合中心极限定理的定义。</p><p>这里的n增加，我们的图像的std会变小，即图像变得更窄，但更高。</p><h2 id="python-实践">Python 实践</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="population-parametersactual">Population parameters(actual)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 Numpy 自带包计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Population Mean: &#123;&#125; \nPopulation Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.mean(arr),np.var(arr)))</span><br></pre></td></tr></table></figure><pre><code>Population Mean: 50.29 Population Variance:687.2659000000001</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mean</span></span><br><span class="line">population_mean = np.mean(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># variance</span></span><br><span class="line">value_squares = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">    value = num - population_mean</span><br><span class="line">    value_square = np.square(value)</span><br><span class="line">    value_squares.append(value_square)</span><br><span class="line">    </span><br><span class="line">variance = np.<span class="built_in">sum</span>(value_squares) / <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Population Mean: &#123;&#125; \nPopulation Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(population_mean,variance))</span><br></pre></td></tr></table></figure><pre><code>Population Mean: 50.29 Population Variance:687.2659000000001</code></pre><h3 id="samples-parametersestimate">Samples parameters(estimate)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sampling</span></span><br><span class="line">sample = np.random.choice(arr,size=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample mean, x-bar</span></span><br><span class="line">sample_x_bar = np.mean(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample variance with numpy</span></span><br><span class="line">sample_var = np.var(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample variance by hand, n as denominator</span></span><br><span class="line">absolute_values = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sample:</span><br><span class="line">    absolute_value = i - np.mean(sample)</span><br><span class="line">    absolute_value_square = np.square(absolute_value)</span><br><span class="line">    absolute_values.append(absolute_value_square)</span><br><span class="line"></span><br><span class="line">biased_variance = np.<span class="built_in">sum</span>(absolute_values)/<span class="built_in">len</span>(sample)</span><br><span class="line">unbiased_variance = np.<span class="built_in">sum</span>(absolute_values)/<span class="built_in">len</span>(sample) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Mean:&#123;&#125;\nSample Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(sample_x_bar,sample_var))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Variance Biased:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(biased_variance))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Variance Unbiased:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(unbiased_variance))</span><br></pre></td></tr></table></figure><pre><code>Sample Mean:50.54Sample Variance:726.8484Sample Variance Biased:726.8484Sample Variance Unbiased:725.8484</code></pre><h3 id="sampling-distribution">Sampling Distribution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x_bars = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># sampling</span></span><br><span class="line">    sample = np.random.choice(arr,size=<span class="number">100</span>)</span><br><span class="line">    <span class="comment"># sample mean, x-bar</span></span><br><span class="line">    sample_x_bar = np.mean(sample)</span><br><span class="line">    x_bars.append(sample_x_bar)</span><br><span class="line"></span><br><span class="line">plt.hist(x_bars)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/30/FCkgKPpLjIShmrH.png" /></p><h1 id="p-values">8. P-values</h1><p>对于两个药物的测试结果如下，我们完全可以观察出，A药物明显有效果，而B无效，且无法断定说，这两者的表现，只是一种随机现象。</p><figure><img src="https://i.loli.net/2020/03/29/Ez6BOw4moXCx7gM.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这时候就可以请p value发挥作用了。</p><figure><img src="https://i.loli.net/2020/03/29/lItcEZOfhXn8Vju.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/03/29/QbJnsG5hw7TdLUp.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="calculate-p-values">Calculate P-values</h2><p>P-values有两种，One-Sided 和 Two-Sided。</p><p>我们一般谈后面那种，并避免使用第一种。</p><p>你扔了两次硬币，都是国徽面朝上，你觉得这个硬币应该是不正常的，你搞到了一个神奇硬币！</p><p>你想知道，这真的是一个神奇硬币吗？</p><p>于是你想验证，你假设，这个这个硬币和别的硬币没什么区别（Null Hypothesis）。</p><p>如果你接下，推翻了这个假设，即，这个硬币和别的是有区别的，那么你拿到的，就是神奇硬币了。</p><p>为了验证这个假设，我们来计算抛两次硬币的概率, 使用树形图来看，很明显，两枚硬币都是国徽面的概率是25%。</p><figure><img src="https://i.loli.net/2020/04/05/syJ5TqSHGOrA4pf.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在，我们再来算，我们得到两个人像面的p value,p-value 由 3 部分组成：</p><ol type="1"><li>The probability random chance would result in the observation，在这里就是一个正常硬币，扔两次得到两次人像的概率，即0.25。</li><li>The probability of observing something else that is equally rare, 这里是两个人像或是两个国徽，也是0.25.</li><li>The probability of observing something rarer or more extreme. 这里是0，因为没有其他的结果比两个人像、两个国徽的概率更低。</li></ol><p>​</p><p>现在，p-value 就是 0.25 + 0.25 + 0 = 0.5. 注意我们计算 p-value 的目的是测试假设：</p><p>我的硬币和其他硬币是一样的。</p><p>通常来说，当 p-value 小于0.05 的时候，我们会拒绝这个假设，但是现在的概率是0.5,所以这个假设是真的，也就是你拿到的，不是神奇硬币啦。</p><blockquote><p>注意， 得到两个人像面概率为0.25与得到两个人像面得p-value为0.25，这两者不一样。</p></blockquote><p>为什么我们需要关心上面得条件2和3呢？</p><p>举个例子，当你送一朵花给你得意中人，你说：这是这个品种的花中最特别的。于是你得到了它的芳心。</p><p>但当她收到了10朵花，你说：这朵花和其余9朵花一样都很特殊。那这朵花，她也许就觉得不特别了，这是2的情况，所以我们把2的概率加进来。</p><p>也有可能是这样，你跟她说：还有很多的花，比现在这朵更稀有。她也会觉得这朵花不特别，这是3的情况。</p><p>现在我们知道扔2次，得到2个人像面的情况，如果扔5次得到4次人像呢？我们计算 p-value 看看(我们不关心顺序)：</p><figure><img src="https://i.loli.net/2020/04/05/Ve46vSliGoZ7Uth.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/Ve46vSliGoZ7Uth.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/U5dWXOKJkA1Hshq.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>我们需要p-value小于0.05就可以拒绝这个假设了，但目前来看，好像还是无法拒绝:</p><figure><img src="https://i.loli.net/2020/04/05/jK7meLAH9l1WEZU.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>对于连续的数据计算p-value，我们一般通过概率分布来计算，考虑一个身高的例子：</p><figure><img src="https://i.loli.net/2020/04/05/dvnTr6PucGeQFUm.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/ReZDQBT7lgu92H5.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/NegynLJ7pU3xTKB.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="covariance-and-correlation">9. Covariance and Correlation</h1><p>Covariance 一般可以分为三类，斜率为正的图像，斜率为负的图像，平行于x或y轴的图像。</p><p>即 positive trends, negative trends, no trends.</p><p>但 covariance 只能告诉你，数据是positive还是 negative 的trend，无法告诉你这个图像的slope，是陡峭还是平缓。</p><p>它也无法告诉你各个点与图像之间的距离。</p><p>如果所有的图像的 x或者y 值，是一样的，则 covariance 为0.</p><p>如果我们根据x和x本身来算 Covariance, 同时对比 2*x与 2*x 本身的图像，会发现两者的图像是一致的:</p><figure><img src="https://i.loli.net/2020/04/07/1FbmP3zsrGCL8fg.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>总的来说，Covariance 是根据各个点与平均值之间的距离来算的，这意味着它会受到点与均值之间距离的影响，也会受到坐标轴的影响。解决这个问题，引入下一个概念，即 Correlation。</p><h1 id="r-squared">10. R-squared</h1><p>我们已经知道 Correlation 的概念。为什么需要 <span class="math inline">\(R^{2}\)</span> 的概念，某些时候，它更容易解释，如 0.7 是 0.5 的两倍不容易理解，而0.7方是0.5方的两倍却很简单。</p><p>另外看一个老鼠的例子：</p><figure><img src="https://i.loli.net/2020/04/16/YrKQpu8G6xnB9mj.png" alt="老鼠的例子" /><figcaption aria-hidden="true">老鼠的例子</figcaption></figure><p>我们分别计算各点对于平均值（黑线）的方差，以及平均值对于fit的蓝线的方差，然后计算<span class="math inline">\(R^{2}\)</span>。</p><p>公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var(mean) - var(blue line) / var(mean)</span><br></pre></td></tr></table></figure><p>结果是 81%, 这意味着蓝线比平均值小了81%的方差。</p><p>对于两个变量之间的关系来说，<span class="math inline">\(R^{2}\)</span> 越高，说明拟合程度越好。</p><p>需要<a href="https://www.zhihu.com/question/32021302">区别</a>: <span class="math inline">\(R^{2}\)</span> 和相关系数的关系。</p><h1 id="central-limit-theorem">11. Central Limit Theorem</h1><p>中心极限定理，如果我们对0-1之间的数据抽样20个，计算mean，得出一个结果，然后绘制在另一个<strong>直方图</strong>上，如此反复几百遍后，我们得到的mean将会是一个正态分布的图。</p><p>这个原理，对于任何分布的图都适用。</p><p>摘录几则关于中心极限定理的话：</p><blockquote><p>摘录来自: “赤裸裸的统计学。” Apple Books.</p></blockquote><ul><li>“中心极限定理是许多统计活动的“动力源泉”，这些活动存在着一个共同的特点，那就是使用样本对一个更大的数量对象进行推理”</li><li>“个大型样本的正确抽样与其所代表的群体存在相似关系。当然，每个样本之间肯定会存在差异（比如前往马拉松起点的这么多辆客车，每辆客车乘客的组成都不可能完全相同），但是任一样本与整体之间存在巨大差异的概率是较低的”</li><li>“如果我们掌握了某个正确抽取的样本的具体信息（平均数和标准差），就能对其所代表的群体做出令人惊讶的精确推理”</li><li>“如果我们掌握了某个样本的数据，以及某个群体的数据，就能推理出该样本是否就是该群体的样本之一”</li><li>“通过中心极限定理，我们就能计算出某个样本（客车上的肥胖乘客）属于某个群体（马拉松比赛选手）的概率是多少，如果概率非常低，那么我们就能自信满满地说该样本不属于该群体”</li><li>“如果我们已知两个样本的基本特性，就能推理出这两个样本是否取自同一个群体。”</li></ul><p>那么，中心极限定理的实际意义是什么呢？</p><ol type="1"><li>计算置信区间</li><li>t-test，即两个sample的mean是否不同</li><li>ANAVO,即三个sample或以上的mean是否不同</li></ol><p><em>通常来说，为了中心极限定理的有效性，sample size必须要至少大于30.</em></p><h1 id="standard-deviation-vs-standard-error">12. Standard Deviation vs Standard Error</h1><ul><li>“标准差（Standard Deviation）是用来衡量群体中所有个体的离散性”，如心脏研究中所有参与者的体重分布”</li><li>“标准误差（Standard Error）衡量的仅仅是样本平均值的离散性。如果我们反复从弗雷明汉心脏研究数据库中抽取100名参与者作为样本，并计算其平均值，那么这些样本平均值的分布会是怎样一种情况？”</li></ul><p>另外：</p><p><strong>“标准误差就是所有样本平均值的标准差！”</strong></p><p>“如果标准误差差很大，就意味着样本平均值在群体平均值周围分布得极为分散；如果标准误差差很小，就意味着样本平均值之间的聚集程度很高。”</p><p>关于这两者，还有一些图像上的规律：</p><ul><li>“样本数量越多，其平均值就越不容易偏离整体平均值。图像也就越集中，因为大型样本受极端异常值的影响相对较小”</li><li>“数据分布越分散，那么其样本平均值的聚集程度就越低。”</li></ul><p>其次，需要注意的是：</p><p><strong>“如果标准差本身的数值很大，那么标准误差的数值也不会小。取自一个高度离散群体的大规模样本，其离散程度也会很高；与之对应，如果是一个高度聚集的群体，其样本围绕平均值的聚集程度也会很高。”</strong></p><p>由于样本的平均值是正态分布的，即中心极限定理的内容，我们有以下的规律：</p><p>“差不多有68%的样本平均值会在群体平均值一个标准误差的范围之内，有95%的样本平均值会在群体平均值的两个标准误差的范围之内，有99.7%的样本平均值会在群体平均值3个标准误差的范围之内。”</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概率与统计的基础概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="math" scheme="http://wittyfans.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法参考</title>
    <link href="http://wittyfans.com/article/1895500896.html"/>
    <id>http://wittyfans.com/article/1895500896.html</id>
    <published>2021-08-15T14:40:06.000Z</published>
    <updated>2021-11-19T14:12:08.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统的复习一下数据结构与算法的知识，包括 Python 实现的代码模板。</p></blockquote><span id="more"></span><blockquote><p>Update: 2021-8-22, 更新链表 python 实现</p></blockquote><h1 id="数组链表跳表">数组、链表、跳表</h1><h2 id="数组">数组</h2><p>申请数组，计算机在内存中给你开辟一段 <strong>连续</strong> 的地址。如果直接访问数组中的某个元素，不管是前后，时间复杂度是一样的 O(1).</p><p>问题：</p><ul><li>在中间位置插入元素，后面的元素都要移动，导致插入操作的时间复杂度不再是常数级的了，而是 O(n)，在最坏的情况下</li><li>删除的时候，也一样，时间复杂度和插入一样</li></ul><h3 id="java-数组实现">Java 数组实现</h3><p>操作</p><ol type="1"><li>判断数组的 Size 是否够</li><li>如果够，插入元素</li><li>如果不够，申请一个新的数组，size是当前的2倍，并将原来的数组拷贝到新的数组</li><li>将后面的元素往后挪</li></ol><p>可见数组的操作中，存在大量的元素拷贝。</p><h2 id="链表">链表</h2><p>在修改，添加，删除等操作频繁的情况下，数组并不好用，这时候推荐使用链表。链表的每一个元素都有 <code>value</code> 和 <code>next</code>，其中 <code>next</code> 指向下一个元素。这个元素一般使用 <code>class</code> 来定义，叫 <code>node</code>。</p><p>如果只有一个指针叫单链表，如果有两个双向的，叫双链表，头指针叫 <code>head</code>，尾指针叫 <code>tail</code>，如果 <code>head</code> 连接了 <code>tail</code>，叫<code>循环链表</code>。</p><p>Python 实现单链表，来自<a href="https://zhuanlan.zhihu.com/p/60057180">知乎</a>，该文章还有关于双链表，循环列表的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表的结点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># next是下一个节点的标识</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始指针指向head</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 指针指向None 表示到达尾部</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针下移</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">items</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取head指针</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="comment"># 循环遍历</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 返回生成器</span></span><br><span class="line">            <span class="keyword">yield</span> cur.item</span><br><span class="line">            <span class="comment"># 指针下移</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;向链表头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 新结点指针指向原头部结点</span></span><br><span class="line">        node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="comment"># 头部结点指针修改为新结点</span></span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 先判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 空链表，_head 指向新结点</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不是空链表，则找到尾部，将尾部next结点指向新结点</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置插入元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 指定位置在第一个元素之前，在头部插入</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="comment"># 指定位置超过尾部，在尾部插入</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; (self.length() - <span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 创建元素结点</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="comment"># 循环到需要插入的位置</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除节点&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 找到指定元素</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 如果第一个就是删除的节点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                    <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 继续按链表后移节点</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self.items()</span><br></pre></td></tr></table></figure><h3 id="链表复杂度">链表复杂度</h3><p>操作</p><ol type="1"><li>将插入位置前的元素的next指向新节点，新节点的指向后节点，操作两次，常数级别，O(1)</li><li>与插入类似</li></ol><p>优点：</p><ul><li>不用群移，不需要复制元素</li><li>移动，修改的效率很高</li></ul><p>缺点</p><ul><li>访问中间节点，必须一步一步往后挪，所以复杂度为O(n)</li></ul><h2 id="跳表">跳表</h2><figure><img src="https://i.loli.net/2021/03/07/5ryvJGuCsPS4cpN.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>弥补链表的设计缺陷而设计，为了加速链表访问的速度，在节点之间搭建快速路（索引）。</li><li>索引越多，速度越快，但是也没有降到O(1)，而是 O(logn)</li><li>现实中，因为索引经常操作，维护成本较高</li><li>空间复杂度为 O(n)，但肯定还是比链表高</li></ul><h1 id="栈队列">栈、队列</h1><ul><li><p>栈相当于一个瓶子，先放进去的后面才能拿出来。</p></li><li><p>队列相当于一个管子，先放进去的先出来。</p></li></ul><p>这两个，复杂度添加删除都是 O(1)，查询则是 O(n)，因为它们内部元素是无序的，查任何元素都需要遍历整个数据结构。</p><p>实战中，其实纯粹的栈、队列用的很少，更多的用的是双端队列(Double-End queue)，一个栈和队列的结合体，它两边都可以 push，pop，复杂度和正常的栈、队列都一样。</p><figure><img src="https://i.loli.net/2021/08/12/JUxhPSH6LqB74CO.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>栈的一些操作，可以直接通过 python 中的列表实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="built_in">list</span>.append() == push</span><br><span class="line"><span class="built_in">list</span>.pop() == pop</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] == peek</span><br></pre></td></tr></table></figure><h2 id="优先队列">优先队列</h2><p>也就是元素是有优先级的，它的插入是 O(1), 取出操作 O(logN), 因为需要按照元素的优先级取出。底层的实现方式较为多样和负责，有 heap, bst, treap.</p><h1 id="哈希表映射集合">哈希表、映射、集合</h1><p>哈希表也叫散列表，现实中用的比较多，类似字典的key value对，但它是通过哈希函数建立一个映射关系，key 相当于关键码值，value 也就是存放数据的地方叫哈希表。</p><p>现实中一般应用在电话号码，用户信息表，缓存，键值对存储（Redis）。</p><p>哈希函数有很多种，选的好可以让生成的地址比较分散，不会重复，这里重复的意思就是，比如我字符 scott 生成的地址是 9，然后 zhang 生成的也是9，这就重复了，这叫哈希碰撞。</p><p>但发生了碰撞怎么办呢？可以在相同得位置，拉出一个链表出来，把信息存在这个链表上，如果哈希函数选的不好，链表很长，复杂度会变成O(n)，而没有链表得情况下是 O(1)。</p><figure><img src="https://i.loli.net/2021/08/12/6bKBh2UTQecgLqX.png" alt="发生哈希碰撞后的哈希表" /><figcaption aria-hidden="true">发生哈希碰撞后的哈希表</figcaption></figure><figure><img src="https://i.loli.net/2021/08/12/YyGFwVB43sMe9Tj.png" alt="哈希表的复杂度" /><figcaption aria-hidden="true">哈希表的复杂度</figcaption></figure><p>哈希表在 python 中有两种，Dictionary 和 Set，在 Java 中，可能只是一个接口，比如 Set 的实现有很多种，有基于红黑树的，基于二叉树的等等。</p><h1 id="树二叉树二叉搜索树">树、二叉树、二叉搜索树</h1><blockquote><p>2 维数据结构。</p></blockquote><h2 id="树">树</h2><p>树的示意图</p><figure><img src="https://i.loli.net/2021/08/13/6bpLCrNwEKTWOvy.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>为什么会出现树呢？工程实践就是二维的,树和链表没有本质上的区别，只是从1维到了二维。。树的遍历怎么办？对于一维数组，你可以直接循环遍历，而对于树，则有好几种方式：</p><ol type="1"><li>前序 (Pre-order)：根，左边，右边</li><li>中序 (In-order)：左边，根，右边</li><li>后序 (Post-order)：左边，右边，根</li></ol><p>树的循环，效率是比较麻烦的，反倒是写递归比较简单，树的各种操作，不要害怕递归。</p><h2 id="二叉树">二叉树</h2><p>二叉树，也就是儿子节点只有两个</p><figure><img src="https://i.loli.net/2021/08/13/jGRmsLDIFeryCP9.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="二叉搜索树">二叉搜索树</h2><p>如果树要查找元素，就必须要遍历，如果树里的元素没有顺序，那和列表什么的没区别。于是为了方便搜索，我们对树进行了排序，定义了二叉搜索树，它的特点是<strong>一颗空树</strong>或者<strong>具有以下性质的二叉树</strong>：</p><ol type="1"><li>左子树上所有节点的值均小于根节点的值；</li><li>右子树上所有节点的值均大于它的根节点的值；</li><li>以此类推：左右子树也分别为二叉查找树（重复性）</li></ol><p>中序遍历：升序排列</p><p>排序后的树，查询和操作都是 logn 的复杂度，相当于是加速了，因为它在查询的时候，会将当前节点与查询的节点做比较，每次可以筛掉一般的值，所以变成logn，虽然不是 O(1)，但logn 还是比 n 是不知道快多少了。</p><p>看树的查询动画，see also <a href="https://visualgo.net/en">Visualgo</a>.</p><p>二叉搜索树遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        self.preorder(root.left)</span><br><span class="line">        self.preorder(self.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        self.inorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.postorder(root.left)</span><br><span class="line">        self.postorder(root.right)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br></pre></td></tr></table></figure><h2 id="图">图</h2><p>图又是什么呢？图就是上面的节点中，子节点又连接到兄弟节点甚至是父节点去了。</p><blockquote><p>Linked List 是特殊化的 Tree，Tree是特殊化的 Graph.</p></blockquote><h1 id="递归">递归</h1><p>递归本质上类似与循环，即通过循环调用自己，以前使用的汇编语言，那时候没有循环嵌套这么一说，更多的时候就是你之前的指令写在上面地方，就不断的调用，从汇编的角度看，其实汇编的代码里，循环和递归差不多。</p><p>递归的特点，类似于盗梦空间。</p><ul><li>向下进入梦境，向上回到原来那层，只能一层一层进入或者退出。</li><li>每一层的环境和周围的人都是一份拷贝</li><li>通过声音返回上一层（return）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n*Factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure><img src="https://i.loli.net/2021/08/13/7mQvWfEewTYuPjA.png" alt="执行逻辑" /><figcaption aria-hidden="true">执行逻辑</figcaption></figure><p>递归代码模板：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span>(<span class="params">level, param1, param2, ...</span>):</span></span><br><span class="line"><span class="comment"># recursion terminator 终结条件</span></span><br><span class="line"><span class="keyword">if</span> level &gt; max_level:</span><br><span class="line">process_result</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># process logic in current level 处理当前层的逻辑</span></span><br><span class="line">    process(level, data...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># drill down 下探到下一层，带上参数</span></span><br><span class="line">    self.recursion(level+<span class="number">1</span>, p1, ...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse the current level states if needed 如果需要递归完了清理当前层</span></span><br></pre></td></tr></table></figure><p>思维要点：</p><ul><li>不要人肉递归</li><li>找到最近，最简的方法，拆解成可重复解决的问题（最近重复子问题）</li><li>数学归纳法的思维</li></ul><h1 id="分治回溯">分治、回溯</h1><blockquote><p>递归里面的细分类</p></blockquote><p>碰到一个题目，我们要去找重复性，重复性有两种：</p><ul><li>最近重复性 -&gt; 分支、回溯，递归</li><li>最优重复性 -&gt; 动态规划</li></ul><h2 id="分治">分治</h2><p>大问题都是子问题、复杂问题构成的，解决问题本质上就是找重复性，分解问题，组合子问题的结果。</p><figure><img src="https://i.loli.net/2021/08/13/UJNRMharPXo53V8.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>分治的代码模板:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_conquer</span>(<span class="params">problem, param1, param2, ...</span>):</span></span><br><span class="line">    <span class="comment"># recursion terminator</span></span><br><span class="line">    <span class="keyword">if</span> problem <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   <span class="comment"># prepare data</span></span><br><span class="line">    data = prepare_data(problem)</span><br><span class="line">    subproblems = split_problem(problem, data)</span><br><span class="line">    <span class="comment"># conquer subproblems</span></span><br><span class="line">    subresult1 = self.divide_conquer(subproblems[<span class="number">0</span>], p1, ...)</span><br><span class="line">    subresult2 = self.divide_conquer(subproblems[<span class="number">1</span>], p1, ...)</span><br><span class="line">    subresult3 = self.divide_conquer(subproblems[<span class="number">2</span>], p1, ...)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># process and generate the final result</span></span><br><span class="line">    result = process_result(subresult1, subresult2, subresult3)</span><br><span class="line">    <span class="comment"># revert the current level states</span></span><br></pre></td></tr></table></figure><h2 id="回溯">回溯</h2><p>采用试错的思想，分步解决一个问题，如果分布方案不解决问题，会取消上一步或几步的计算，再通过其他可能的分步方案寻找答案。</p><p>简单来说就是，每一层我都有不同的办法，一个一个试。</p><h1 id="深度优先广度优先搜索">深度优先、广度优先搜索</h1><h2 id="深度优先">深度优先</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>深度优先就是先往最深处的节点走，发现没有子节点了，返回到有子节点的节点，继续往下面走。</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">self, tree</span>):</span></span><br><span class="line"><span class="keyword">if</span> tree.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">visited, stack = [], [tree.root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)</span><br><span class="line">        stack.push(nodes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, visited</span>):</span></span><br><span class="line"><span class="comment"># terminator</span></span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment"># already visited</span></span><br><span class="line">visited.add(node)</span><br><span class="line"><span class="comment"># process current node here</span></span><br><span class="line"><span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">dfs(next_node, visited)</span><br></pre></td></tr></table></figure><h2 id="广度优先">广度优先</h2><p>广度优先遍历，类似与一个水滴滴到根节点，然后像水波一样一层一层扩散下去，这种思想在算最短路径的时候，比深度优先效率高。遍历的方式使用队列实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)</span><br><span class="line">        queue.push(nodes)</span><br><span class="line">     <span class="comment"># othres processing work</span></span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>这里的算法为了方便理解，举个例子，就好像要访问公司的人员信息，首先先看老总的信息，老总看完了，放到 visited 数组，然后看他有没有其他下属，有的话全部取出来放到队列（先进先出）</p><h1 id="贪心算法">贪心算法</h1><p>贪心算法在每一步选择中，都采取当前状态下最好或最优的选择，从而导致结果是最好的或最优的算法。（有一定的局限性，因为当下最优不一定全局最优）</p><p>动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心法主要解决一些最优化问题，图中的最小生成树，求哈夫曼编码等。</p><p>一旦一个问题可以通过贪心算法解决，那么贪心法一般是解决这个问题的最好办法。</p><p>适用于贪心的情况，即<code>问题可以分解成子问题，子问题的最优解可以递推到最终问题的最优解</code></p><h1 id="二分查找">二分查找</h1><p>一定记住二分查找的前提（肌肉记忆）:</p><ol type="1"><li>目标函数单调性（单调递增或递减），才可以通过特征排除掉前半部分或后半部分</li><li>存在上下界（bounded），没有上下界，空间可能无限大</li><li>能够通过索引访问（index acccessible)，如果是单链表，即使有序，也比较难</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设数组是有序的</span></span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = (left + right) /<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target!</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><ul><li>Dynamic Programming（一种解决问题的办法）, 本质就是将复杂问题，分解成小问题，可以理解为动态的递推，每一步保存最优解，淘汰掉那些不怎么好的，然后最终求得总体的最优解。</li><li>直接递归的复杂度是指数级的，如果淘汰掉一些解，可以变成 n 平方</li></ul><h1 id="字典树">字典树</h1><h2 id="字典树的数据结构">字典树的数据结构</h2><p>之前我们的树，内部就是值本身，而是把字符串拆成单个得字幕存储。</p><figure><img src="https://i.loli.net/2021/08/14/zYdmwyHZCFXQovM.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>节点本身不存完整单词</li><li>根节点到某一结点，连起来即为单词</li><li>每个不同的边都是不一样的字符</li></ul><p>这种结构中，节点还可以存储其他信息，比如这个节点所得到的单词出现的频次。这种结构的核心思想是空间换时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end_of_word = <span class="string">&quot;#&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            node = node.setdefault(char, &#123;&#125;)</span><br><span class="line">        node[self.end_of_word] = self.end_of_word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">           node = node[char]</span><br><span class="line">        <span class="keyword">return</span> self.end_of_word <span class="keyword">in</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[char]</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><p>属于一种比较跳跃式的数据结构，如果你会就很简单，如果不会就很难，它使用情景主要是在组团、配对问题。</p><p>这两个个体是不是在一个集合之中。</p><h3 id="基本操作">基本操作</h3><ul><li><p>makeSets(s): 新建并查集，其中包括s个单元素集合。</p></li><li><p>unionSet(x, y): 集合合并，要求不相交才合并</p></li><li><p>find(x): 判断 x 所在集合的代表</p></li></ul><p>每个元素都有一个 parent 数组指向自己，表示自己是自己的集合。</p><h3 id="合并">合并</h3><figure><img src="https://i.loli.net/2021/08/14/rE8CmX27OjkgKcl.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="路径优化">路径优化</h3><figure><img src="https://i.loli.net/2021/08/14/aXNWL3ogTiyGZ7w.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="实现">实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">p</span>):</span></span><br><span class="line">    p = []i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, i, j</span>):</span></span><br><span class="line">    p1 = self.parent(p, i)</span><br><span class="line">    p2 = self.parent(p, j)</span><br><span class="line">    p[p1] = p2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span>(<span class="params">self, p, i</span>):</span></span><br><span class="line">    root = i</span><br><span class="line">    <span class="keyword">while</span> p[root] != root:</span><br><span class="line">        root = p[root]</span><br><span class="line">    <span class="keyword">while</span> p[i] != i:</span><br><span class="line">        x = i</span><br><span class="line">        i = p[i]</span><br><span class="line">        p[x] = root</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="高级搜索">高级搜索</h1><h2 id="剪枝">剪枝</h2><p>说高级搜索前，什么是初级搜索呢？</p><ol type="1"><li><p>朴素搜索</p></li><li><p>优化方式：不重复、剪枝，剪枝就是在搜索的时候去掉重复，或者剪去是一些没必要的访问</p></li><li><p>搜索方向</p><ol type="1"><li><p>DFS，深度优先，没有优先级，傻搜</p></li><li><p>BFS，广度优先</p></li></ol></li></ol><p>搜索的话可以通过双向搜索，启发式搜索来优化。</p><figure><img src="https://i.loli.net/2021/08/14/tUCHVGfwRDlAZIo.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="双向bfs">双向BFS</h2><p>问题：找出A到L的最短路径</p><figure><img src="https://i.loli.net/2021/08/14/24WjlLP5qa7dDKS.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这种需求，我们一般使用广度优先算法，而双向 BFS 的意思是，从两边一起进行广度优先算法的遍历，两边一起逼近中间，这样就可以提高效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image.png](https://i.loli.net/2021/08/14/J3fKMgXRkuynHOd.png)</span><br></pre></td></tr></table></figure><h2 id="启发式搜索-heuristic-search-a">启发式搜索 Heuristic Search (A*)</h2><p>只能搜索，根据某项条件，我们去优化条件，也可以理解为思考型搜索，本质上是用优先级。</p><p>这里就要用到优先队列了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AstarSearch</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line">    pq = collections.priority_queue() <span class="comment"># 优先级，估价函数</span></span><br><span class="line">    pq.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        node = pq.pop()  <span class="comment"># 能更智能一点吗？</span></span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)  <span class="comment"># 正常的BFS代码</span></span><br><span class="line"></span><br><span class="line">        unvisited=[node <span class="keyword">for</span> node <span class="keyword">in</span> nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">        pq.push(unvisited)</span><br></pre></td></tr></table></figure><p>这里怎么来定优先级呢？这就需要你按照对题目的理解把估价函数写出来。</p><h1 id="avl和红黑树">AVL和红黑树</h1><blockquote><p>二三树，B树，B+树，B-树。</p></blockquote><p>如何保持一棵树的平衡？</p><h2 id="avl">AVL</h2><ol type="1"><li>Balance Factor，因为二叉树的查找只与高度有关，平衡因子是它的左子树的高度减去右子树的高度（有时候相反）,balance factor = {-1, 0, 1}</li><li>通过旋转操作来进行平衡（四种）</li></ol><p>那么如何判断高度呢?</p><figure><img src="https://i.loli.net/2021/08/14/4GL5jIuWhpclkzS.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>通过高度的值不超过1，不小于-1来判断一棵树是否需要调整，即旋转，旋转的方式有：</p><ol type="1"><li>左旋</li><li>右选</li><li>左右旋</li><li>右左旋</li></ol><p>缺点：需要额外的信息存储，且调整次数频繁。</p><h2 id="红黑树">红黑树</h2><p>也是一种<code>近似平衡</code>的二叉搜索树，它能确保任何一个节点的左右子树高度差小于两倍，具体来说：</p><ul><li>每个节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>每个叶节点（NIL节点，空节点）是黑色的。</li><li>不能有相邻接的两个红色节点</li><li>从任何一个节点到每个叶子的所有路径都包含相同数目的黑色节点</li></ul><p>这些性质就让红黑树的时间复杂度可以保持在 logn 的水平，不会退化，需要调整的时间也是相对比较折中。</p><p>下面是 AVL 与 红黑树的对比：</p><figure><img src="https://i.loli.net/2021/08/15/8JMDFWkV2CG9dxc.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>如果读操作非常多写操作少就用 AVL，它插入、删除需要的操作比较多。</li><li>插入操作也很多，或者操作、查询需求差不多，就用红黑树</li></ul><h1 id="位运算">位运算</h1><p>位运算简单说就是进制转换，比如十进制转二进制，在进制表示中，<code>4(d)</code> 中的 d 表示的是十进制，<code>0100</code> 中零开头表示2进制。</p><p>具体转换的算法可以参考<a href="https://zh.wikihow.com/%E4%BB%8E%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6">这里</a>。</p><h2 id="位运算符">位运算符</h2><table><thead><tr class="header"><th style="text-align: center;">含义</th><th style="text-align: center;">运算符</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">左移</td><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;">0011 =&gt; 0110</td></tr><tr class="even"><td style="text-align: center;">右移</td><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;">0110 =&gt; 0011</td></tr><tr class="odd"><td style="text-align: center;">按位或，有1则1</td><td style="text-align: center;">|</td><td style="text-align: center;">0011 | 1011 =&gt; 1011</td></tr><tr class="even"><td style="text-align: center;">按位与，有0则0</td><td style="text-align: center;">&amp;</td><td style="text-align: center;">0011 &amp; 1011 =&gt; 0011</td></tr><tr class="odd"><td style="text-align: center;">按位取反，0变1，1变0</td><td style="text-align: center;">~</td><td style="text-align: center;">0011 =&gt; 1100</td></tr><tr class="even"><td style="text-align: center;">按位异或，相同0不同1</td><td style="text-align: center;">^</td><td style="text-align: center;">0011 ^ 1011 =&gt; 1000</td></tr></tbody></table><h2 id="异或特点">异或特点</h2><p>异或操作的一些特点：</p><ul><li><code>x^0 = x</code>, 只要 <code>x</code> 和 <code>0</code> 相同的就为 <code>0</code>，不同的为 <code>1</code>，所以这里 <code>x^0</code> 就等于 <code>x</code></li><li><code>x^1s = ~x</code>, <code>1s</code> 指的是全1，也就是等于0取反 <code>~</code></li><li><code>x^(~x)=1s</code>, 取反后，所有位置都不一样，所有都不同，都是1，1s</li><li><code>x^x=0</code>, 异或相同为0，所有都是0</li><li><code>c=a^b</code> ,<code>a^c=b</code> 则 <code>b^c=a</code>, 交换两数</li><li><code>a^b^c = a^(b^c) = (a^b)^c</code>, associative</li></ul><h2 id="指定位置的位运算">指定位置的位运算</h2><figure><img src="https://i.loli.net/2021/08/15/Us8dBF7LNfHVIbh.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="实战运算要点">实战运算要点</h2><figure><img src="https://i.loli.net/2021/08/15/yvDgQ5d7JhCejr1.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="布隆过滤器lru-cache">布隆过滤器，LRU Cache</h1><h2 id="布隆过滤器">布隆过滤器</h2><p>在说布隆过滤器之前，回顾一下哈希表，前面说过哈希表在哈希操作的时候，有可能会得到一样的地址（整数），这时候会采用拉链的办法，也就是在同样的地址上叠罗汉。</p><p>在哈希表的应用中，我们发现，有时候我们并不需要去存储元素的信息本身，而是只需要知道某个信息在我们的表中有没有。</p><p>如果我们只是需要知道某个信息在表里有没有，这时候 Bloom filter 就设计出来了。</p><h3 id="布隆过滤器具-vs-哈希表">布隆过滤器具 vs 哈希表</h3><ul><li>空间效率和查询时间都远远超过一般算法</li><li>缺点是有一定的误识别率和删除困难</li></ul><h3 id="布隆过滤器具原理">布隆过滤器具原理</h3><figure><img src="https://i.loli.net/2021/08/15/zMKNUgRTZF73ht4.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在有 xyz 三个元素需要存储，布隆过滤器会对每一个元素执行哈希，得到一组值，然后再将这组值插入到下面的框框中，y 和 z 也是同理，这样下次查询的时候，只需要查看这些对应的位置是否为1就好了，而且查询的时候，我只需要判断任意一个元素是0，那么就可以判断这个元素是不在这个表中的。</p><p>但是这种查法可能会有问题，比如下面的这个B：</p><figure><img src="https://i.loli.net/2021/08/15/Hw9t4BfN3cp2OWe.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>对于一个元素，布隆过滤器可以确定一个元素不存在，但只可以说某个元素有可能存在。</p><p>布隆过滤器一般放在数据库的外层当作缓存使用。</p><h3 id="布隆过滤器具案例">布隆过滤器具案例</h3><ol type="1"><li>比特币网络</li><li>分布式系统（Map-Reduce）- Hadooop，search engine</li><li>Redis 缓存</li><li>垃圾邮件、评论等的过滤</li></ol><h3 id="布隆过滤器具-python实现">布隆过滤器具 Python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bfrom bitarray <span class="keyword">import</span> bitarray</span><br><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size, hash_num</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.hash_num = hash_num</span><br><span class="line">        self.bit_array = bitarray(size)</span><br><span class="line">        self.bit_array.setall(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_num):</span><br><span class="line">            result = mmh3.<span class="built_in">hash</span>(s, seed) % self.size</span><br><span class="line">            self.bit_array[result] = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookup</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_num):</span><br><span class="line">            result = mmh3.<span class="built_in">hash</span>(s, seed) % self.size</span><br><span class="line">            <span class="keyword">if</span> self.bit_array[result] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Nope&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Probably&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bf = BloomFilter(500000, 7)</span><br><span class="line">bf.add(&quot;scott&quot;)</span><br><span class="line">bf.lookup(&quot;scott&quot;)</span><br><span class="line">&#x27;Probably&#x27;</span><br><span class="line"></span><br><span class="line">bf.lookup(&quot;zhang&quot;)</span><br><span class="line">&#x27;Nope&#x27;</span><br></pre></td></tr></table></figure><h2 id="lru-cache-缓存">LRU Cache 缓存</h2><blockquote><p>Least Rencent Used,</p></blockquote><ul><li>两个要素：大小、替换策略</li><li>使用 Hash Table + Double LinkedList 实现</li><li>O(1) 查询，O(1) 更新、更新</li></ul><h3 id="工作示例">工作示例</h3><figure><img src="https://i.loli.net/2021/08/15/noydHrUWJNVbB3F.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="排序算法">排序算法</h1><blockquote><p>To be continued.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;系统的复习一下数据结构与算法的知识，包括 Python 实现的代码模板。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Data Structure" scheme="http://wittyfans.com/categories/Data-Structure/"/>
    
    
    <category term="算法" scheme="http://wittyfans.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://wittyfans.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>cx_Oracle 在 Linux 上的安装与配置</title>
    <link href="http://wittyfans.com/article/3551438313.html"/>
    <id>http://wittyfans.com/article/3551438313.html</id>
    <published>2021-03-04T14:23:56.000Z</published>
    <updated>2021-11-19T14:12:08.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>cx_Oracle 是一个Python扩展模块，用来支持访问Oracle数据库，在 python 下，即便你使用其它的数据库 <a href="http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html">ORM 映射框架</a>, 也需要配置 cx_Oracle, 这篇文章介绍了如何配置 cx_Oracle 以便让你可以访问 Oracle 数据库。</p></blockquote><span id="more"></span><h1 id="cx_oracle">cx_Oracle</h1><p>下面这种图介绍了 cx_Oracle 在与 Oracle 数据库交互中起的作用。</p><p><img src="https://cx-oracle.readthedocs.io/en/latest/_images/cx_Oracle_arch.png" /></p><p>安装 cx_Oracle 本身很简单:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install cx_Oracle --upgrade</span><br></pre></td></tr></table></figure><p>但是我们还需要安装 Oracle 客户端的库, 可以选择 Oracle Instant Client 或者 Oracle Database Express Edition (“XE”), 后者需要你本地安装了 oracle 数据库， 我们选择 Instant Client, Instant Client 提供了两种版本，<code>zip</code> 和 <code>rpm</code> 版本，<code>zip</code> 版本解压到本地电脑即可开始配置，<code>rpm</code> 则是提供给 Linux 使用的，要详细了解 <code>rpm</code> ，这里可以推荐一篇 <a href="https://developer.ibm.com/zh/articles/l-lo-rpm-build-package/">IBM 的文章</a>。</p><p>安装 Instant Client 的步骤：</p><ol type="1"><li>前往 Oracle Instant Client <a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html">下载页面</a> 下载<strong>正确的版本</strong>，一定要参考服务端的 Oracle 版本，因为客户端的高版本并不支持连接低版本的服务端，例如我第一次使用客户端 21 版本连接服务端 11 的版本就报错: <code>ORA-28547</code></li></ol><p>下图说明了 Oracle 客户端与服务端的兼容关系:</p><figure><img src="https://i.loli.net/2021/03/04/RQmyUibWJtaSulD.png" alt="IMG_4465.PNG" /><figcaption aria-hidden="true">IMG_4465.PNG</figcaption></figure><ol start="2" type="1"><li>在 Linux 上，使用 <code>unzip</code> 命令解压到你需要的文件夹</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/oracle</span><br><span class="line">cd /opt/oracle</span><br><span class="line">unzip instantclient-basic-linux.x64-你下载的版本.zip</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>安装 libaio, libaio是Linux下的一个异步非阻塞接口，它提供了以异步非阻塞方式来读写文件的方式，读写效率比较高。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libaio</span><br><span class="line"># 有的 linux 叫做libaio1</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>如果你不担心影响其它的程序，可以永久的将 Instant Client 添加到<a href="https://www.zhihu.com/question/20484931">动态库链接</a>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo /opt/oracle/instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>如果你使用 <code>tnsnames.ora</code>, <code>sqlnet.ora</code> 或 <code>oraaccess.xml</code> 则需要更改 cx_Oracle 初始化配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import cx_Oracle</span><br><span class="line">cx_Oracle.init_oracle_client(config_dir=&quot;/home/your_username/oracle/your_config_dir&quot;)</span><br></pre></td></tr></table></figure><p>或者设置环境变量 <code>TNS_ADMIN</code>, 并将相关文件放至 <code>network/admin</code> 子文件夹。</p><p>通过 RPMs 安装的方式类似，在此不再赘述。</p><h1 id="docker-file">Docker file</h1><p>下面是一个 Flask 应用配置 Oracle 的部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7.3</span><br><span class="line"># Set up Oracle</span><br><span class="line">WORKDIR    /opt/oracle</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y libaio1 wget unzip \</span><br><span class="line">    &amp;&amp; cp /app/query_eda_tool/oracle_configs/instantclient-basic-linux.x64-12.2.0.1.0.zip . \</span><br><span class="line">    &amp;&amp; unzip instantclient-basic-linux.x64-12.2.0.1.0.zip \</span><br><span class="line">    &amp;&amp; rm -f instantclient-basic-linux.x64-12.2.0.1.0.zip \</span><br><span class="line">    &amp;&amp; cd /opt/oracle/instantclient* \</span><br><span class="line">    &amp;&amp; rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \</span><br><span class="line">    &amp;&amp; echo /opt/oracle/instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf \</span><br><span class="line">    &amp;&amp; ldconfig \</span><br><span class="line">    &amp;&amp; mkdir -p /opt/oracle/instantclient_12_2/network/admin \</span><br><span class="line">    &amp;&amp; cp /app/query_eda_tool/oracle_configs/tnsnames.ora /opt/oracle/instantclient_12_2/network/admin/ \</span><br><span class="line">    &amp;&amp; cp /app/query_eda_tool/oracle_configs/sqlnet.ora /opt/oracle/instantclient_12_2/network/admin/</span><br></pre></td></tr></table></figure><blockquote><p>注：我的项目文件中已经从官网下载好 <code>instantclient-basic-linux.x64-12.2.0.1.0.zip</code> 文件。</p></blockquote><h1 id="参考">参考</h1><ul><li><a href="https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html">cx_Oracle 8 Installation</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;cx_Oracle 是一个Python扩展模块，用来支持访问Oracle数据库，在 python 下，即便你使用其它的数据库 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html&quot;&gt;ORM 映射框架&lt;/a&gt;, 也需要配置 cx_Oracle, 这篇文章介绍了如何配置 cx_Oracle 以便让你可以访问 Oracle 数据库。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="Oracle" scheme="http://wittyfans.com/tags/Oracle/"/>
    
    <category term="cx_Oracle" scheme="http://wittyfans.com/tags/cx-Oracle/"/>
    
    <category term="Python" scheme="http://wittyfans.com/tags/Python/"/>
    
    <category term="Database" scheme="http://wittyfans.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Spark 笔记</title>
    <link href="http://wittyfans.com/article/3170800033.html"/>
    <id>http://wittyfans.com/article/3170800033.html</id>
    <published>2021-03-02T13:27:00.000Z</published>
    <updated>2021-11-19T14:12:08.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A platform for cluster computing.</p></blockquote><span id="more"></span><p>Spark lets you spread data and computations over <em>clusters</em> with multiple <em>nodes</em> (think of each node as a separate computer). Spark is a platform for cluster computing. Spark lets you spread data and computations over <em>clusters</em> with multiple <em>nodes</em> (think of each node as a separate computer). Splitting up your data makes it easier to work with very large datasets because each node only works with a small amount of data.</p><p>As each node works on its own subset of the total data, it also carries out a part of the total calculations required, so that both data processing and computation are performed <em>in parallel</em> over the nodes in the cluster. It is a fact that parallel computation can make certain types of programming tasks much faster.</p><h1 id="连接集群">连接集群</h1><p>The first step in using Spark is connecting to a cluster.</p><p>In practice, the cluster will be hosted on a remote machine that's connected to all other nodes. There will be one computer, called the <em>master</em> that manages splitting up the data and the computations. The master is connected to the rest of the computers in the cluster, which are called <em>worker</em>. The master sends the workers data and calculations to run, and they send their results back to the master.</p><p>Creating the connection is as simple as creating an instance of the <code>SparkContext</code> class. The class constructor takes a few optional arguments that allow you to specify the attributes of the cluster you're connecting to.</p><p>An object holding all these attributes can be created with the <code>SparkConf()</code> constructor. Take a look at the <a href="http://spark.apache.org/docs/2.1.0/api/python/pyspark.html">documentation</a> for all the details!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">SparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 sc 对象</span></span><br><span class="line"><span class="built_in">print</span>(sc)</span><br><span class="line">&lt;SparkContext master=local[*] appName=pyspark-shell&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line"><span class="built_in">print</span>(sc.version)</span><br></pre></td></tr></table></figure><h1 id="spark-中的数据">Spark 中的数据</h1><p>Spark's core data structure is the Resilient Distributed Dataset (RDD). This is a low level object that lets Spark work its magic by splitting data across multiple nodes in the cluster. However, RDDs are hard to work with directly</p><p>The Spark DataFrame was designed to behave a lot like a SQL table (a table with variables in the columns and observations in the rows). Not only are they easier to understand, DataFrames are also more optimized for complicated operations than RDDs.</p><p>When you start modifying and combining columns and rows of data, there are many ways to arrive at the same result, but some often take much longer than others. When using RDDs, it's up to the data scientist to figure out the right way to optimize the query, but the DataFrame implementation has much of this optimization built in!</p><p>To start working with Spark DataFrames, you first have to create a <code>SparkSession</code> object from your <code>SparkContext</code>. You can think of the <code>SparkContext</code> as your connection to the cluster and the <code>SparkSession</code> as your interface with that connection.</p><p>we will have a <code>SparkSession</code> called <code>spark</code> .</p><p>Creating multiple <code>SparkSession</code>s and <code>SparkContext</code>s can cause issues, so it's best practice to use the <code>SparkSession.builder.getOrCreate()</code> method. This returns an existing <code>SparkSession</code> if there's already one in the environment, or creates a new one if necessary!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import SparkSession from pyspark.sql</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create my_spark</span></span><br><span class="line">my_spark = SparkSession.builder.getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print my_spark</span></span><br><span class="line"><span class="built_in">print</span>(my_spark)</span><br></pre></td></tr></table></figure><p>Once you've created a <code>SparkSession</code>, you can start poking around to see what data is in your cluster!</p><p>Your <code>SparkSession</code> has an attribute called <code>catalog</code> which lists all the data inside the cluster. This attribute has a few methods for extracting different pieces of information.</p><p>One of the most useful is the <code>.listTables()</code> method, which returns the names of all the tables in your cluster as a list.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Print the tables in the catalog</span></span><br><span class="line"><span class="built_in">print</span>(spark.catalog.listTables())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running a query on this table</span></span><br><span class="line">query = <span class="string">&quot;FROM flights SELECT * LIMIT 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the first 10 rows of flights</span></span><br><span class="line">flights10 = spark.sql(query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the results</span></span><br><span class="line">flights10.show()</span><br></pre></td></tr></table></figure><h2 id="读取-spark-数据到-pandas">读取 Spark 数据到 Pandas</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Don&#x27;t change this query</span></span><br><span class="line">query = <span class="string">&quot;SELECT origin, dest, COUNT(*) as N FROM flights GROUP BY origin, dest&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the query</span></span><br><span class="line">flight_counts = spark.sql(query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the results to a pandas DataFrame</span></span><br><span class="line">pd_counts = flight_counts.toPandas()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of pd_counts</span></span><br><span class="line"><span class="built_in">print</span>(pd_counts.head())</span><br></pre></td></tr></table></figure><h2 id="pandas-data-frame-写入到-spark">Pandas Data Frame 写入到 Spark</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create pd_temp</span></span><br><span class="line">pd_temp = pd.DataFrame(np.random.random(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create spark_temp from pd_temp</span></span><br><span class="line">spark_temp = spark.createDataFrame(pd_temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Examine the tables in the catalog</span></span><br><span class="line"><span class="built_in">print</span>(spark.catalog.listTables())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add spark_temp to the catalog</span></span><br><span class="line">spark_temp.createOrReplaceTempView(<span class="string">&quot;temp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Examine the tables in the catalog again</span></span><br><span class="line"><span class="built_in">print</span>(spark.catalog.listTables())</span><br></pre></td></tr></table></figure><p>The <code>.createDataFrame()</code> method takes a <code>pandas</code> DataFrame and returns a Spark DataFrame.</p><p>The output of this method is stored locally, not in the <code>SparkSession</code> catalog. This means that you can use all the Spark DataFrame methods on it, but you can't access the data in other contexts.</p><p>For example, a SQL query (using the <code>.sql()</code> method) that references your DataFrame will throw an error. To access the data in this way, you have to save it as a <em>temporary table</em>.</p><p>You can do this using the <code>.createTempView()</code> Spark DataFrame method, which takes as its only argument the name of the temporary table you'd like to register. This method registers the DataFrame as a table in the catalog, but as this table is temporary, it can only be accessed from the specific <code>SparkSession</code> used to create the Spark DataFrame.</p><p>There is also the method <code>.createOrReplaceTempView()</code>. This safely creates a new temporary table if nothing was there before, or updates an existing table if one was already defined. You'll use this method to avoid running into problems with duplicate tables.</p><p>Check out the diagram to see all the different ways your Spark data structures interact with each other.</p><figure><img src="https://i.loli.net/2021/03/01/OsewxPRf3JFbGd4.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="spark-读取文本文件">Spark 读取文本文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Don&#x27;t change this file path</span></span><br><span class="line">file_path = <span class="string">&quot;/usr/local/share/datasets/airports.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the airports data</span></span><br><span class="line">airports = spark.read.csv(file_path,header=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the data</span></span><br><span class="line">airports.show()</span><br></pre></td></tr></table></figure><h1 id="操作数据">操作数据</h1><p>In Spark you can do this using the <code>.withColumn()</code> method, which takes two arguments. First, a string with the name of your new column, and second the new column itself.</p><p>The new column must be an object of class <code>Column</code>. Creating one of these is as easy as extracting a column from your DataFrame using <code>df.colName</code>.</p><p>Updating a Spark DataFrame is somewhat different than working in <code>pandas</code> because the Spark DataFrame is <em>immutable</em>. This means that it can't be changed, and so columns can't be updated in place.</p><p>Thus, all these methods return a new DataFrame. To overwrite the original DataFrame you must reassign the returned DataFrame using the method like so:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.withColumn(<span class="string">&quot;newCol&quot;</span>, df.oldCol + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>The above code creates a DataFrame with the same columns as <code>df</code> plus a new column, <code>newCol</code>, where every entry is equal to the corresponding entry from <code>oldCol</code>, plus one.</p><p>To overwrite an existing column, just pass the name of the column as the first argument!</p><h2 id="filter-data">Filter Data</h2><p>The <code>.filter()</code> method takes either an expression that would follow the <code>WHERE</code> clause of a SQL expression as a string, or a Spark Column of boolean (<code>True</code>/<code>False</code>) values.</p><p>For example, the following two expressions will produce the same output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flights.<span class="built_in">filter</span>(<span class="string">&quot;air_time &gt; 120&quot;</span>).show()</span><br><span class="line">flights.<span class="built_in">filter</span>(flights.air_time &gt; <span class="number">120</span>).show()</span><br></pre></td></tr></table></figure><h2 id="select-data">Select Data</h2><p>The Spark variant of SQL's <code>SELECT</code> is the <code>.select()</code> method. This method takes multiple arguments - one for each column you want to select. These arguments can either be the column name as a string (one for each column) or a column object (using the <code>df.colName</code> syntax). When you pass a column object, you can perform operations like addition or subtraction on the column to change the data contained in it, much like inside <code>.withColumn()</code>.</p><p>The difference between <code>.select()</code> and <code>.withColumn()</code> methods is that <code>.select()</code> returns only the columns you specify, while <code>.withColumn()</code> returns all the columns of the DataFrame in addition to the one you defined. It's often a good idea to drop columns you don't need at the beginning of an operation so that you're not dragging around extra data as you're wrangling. In this case, you would use <code>.select()</code> and not <code>.withColumn()</code>.</p><p>Similar to SQL, you can also use the <code>.select()</code> method to perform column-wise operations. When you're selecting a column using the <code>df.colName</code> notation, you can perform any column operation and the <code>.select()</code> method will return the transformed column. For example,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flights.select(flights.air_time/<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>returns a column of flight durations in hours instead of minutes. You can also use the <code>.alias()</code> method to rename a column you're selecting. So if you wanted to <code>.select()</code> the column <code>duration_hrs</code> (which isn't in your DataFrame) you could do</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flights.select((flights.air_time/<span class="number">60</span>).alias(<span class="string">&quot;duration_hrs&quot;</span>))</span><br></pre></td></tr></table></figure><p>with the SQL <code>as</code> keyword being equivalent to the <code>.alias()</code> method. To select multiple columns, you can pass multiple strings.</p><h2 id="aggregating">Aggregating</h2><p>All of the common aggregation methods, like <code>.min()</code>, <code>.max()</code>, and <code>.count()</code> are <code>GroupedData</code> methods. These are created by calling the <code>.groupBy()</code> DataFrame method. You'll learn exactly what that means in a few exercises. For now, all you have to do to use these functions is call that method on your DataFrame. For example, to find the minimum value of a column, <code>col</code>, in a DataFrame, <code>df</code>, you could do</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupBy().<span class="built_in">min</span>(<span class="string">&quot;col&quot;</span>).show()</span><br></pre></td></tr></table></figure><p>This creates a <code>GroupedData</code> object (so you can use the <code>.min()</code> method), then finds the minimum value in <code>col</code>, and returns it as a DataFrame.</p><h3 id="grouping-and-aggregating-i">Grouping and Aggregating I</h3><p>Part of what makes aggregating so powerful is the addition of groups. PySpark has a whole class devoted to grouped data frames: <code>pyspark.sql.GroupedData</code>, which you saw in the last two exercises.</p><p>You've learned how to create a grouped DataFrame by calling the <code>.groupBy()</code> method on a DataFrame with no arguments.</p><p>Now you'll see that when you pass the name of one or more columns in your DataFrame to the <code>.groupBy()</code> method, the aggregation methods behave like when you use a <code>GROUP BY</code> statement in a SQL query!</p><h3 id="grouping-and-aggregating-ii">Grouping and Aggregating II</h3><p>In addition to the <code>GroupedData</code> methods you've already seen, there is also the <code>.agg()</code> method. This method lets you pass an aggregate column expression that uses any of the aggregate functions from the <code>pyspark.sql.functions</code> submodule.</p><p>This submodule contains many useful functions for computing things like standard deviations. All the aggregation functions in this submodule take the name of a column in a <code>GroupedData</code> table.</p><h2 id="joining">Joining</h2><p>Another very common data operation is the <em>join</em>. Joins are a whole topic unto themselves, so in this course we'll just look at simple joins. If you'd like to learn more about joins, you can take a look <a href="https://www.datacamp.com/courses/merging-dataframes-with-pandas">here</a>.</p><p>A join will combine two different tables along a column that they share. This column is called the <em>key</em>. Examples of keys here include the <code>tailnum</code> and <code>carrier</code> columns from the <code>flights</code> table.</p><p>For example, suppose that you want to know more information about the plane that flew a flight than just the tail number. This information isn't in the <code>flights</code> table because the same plane flies many different flights over the course of two years, so including this information in every row would result in a lot of duplication. To avoid this, you'd have a second table that has only one row for each plane and whose columns list all the information about the plane, including its tail number. You could call this table <code>planes</code></p><p>When you join the <code>flights</code> table to this table of airplane information, you're adding all the columns from the <code>planes</code> table to the <code>flights</code> table. To fill these columns with information, you'll look at the tail number from the <code>flights</code> table and find the matching one in the <code>planes</code> table, and then use that row to fill out all the new columns.</p><h3 id="joining-ii">Joining II</h3><p>In PySpark, joins are performed using the DataFrame method <code>.join()</code>. This method takes three arguments. The first is the second DataFrame that you want to join with the first one. The second argument, <code>on</code>, is the name of the key column(s) as a string. The names of the key column(s) must be the same in each table. The third argument, <code>how</code>, specifies the kind of join to perform. In this course we'll always use the value <code>how="leftouter"</code>.</p><h1 id="machine-learning-pipelines">Machine learning pipelines</h1><p>In the next two chapters you'll step through every stage of the machine learning pipeline, from data intake to model evaluation. Let's get to it!</p><p>At the core of the <code>pyspark.ml</code> module are the <code>Transformer</code> and <code>Estimator</code> classes. Almost every other class in the module behaves similarly to these two basic classes.</p><p><code>Transformer</code> classes have a <code>.transform()</code> method that takes a DataFrame and returns a new DataFrame; usually the original one with a new column appended. For example, you might use the class <code>Bucketizer</code> to create discrete bins from a continuous feature or the class <code>PCA</code> to reduce the dimensionality of your dataset using principal component analysis.</p><p><code>Estimator</code> classes all implement a <code>.fit()</code> method. These methods also take a DataFrame, but instead of returning another DataFrame they return a model object. This can be something like a <code>StringIndexerModel</code> for including categorical data saved as strings in your models, or a <code>RandomForestModel</code> that uses the random forest algorithm for classification or regression.</p><h2 id="join-the-dataframes">Join the DataFrames</h2><p>In the next two chapters you'll be working to build a model that predicts whether or not a flight will be delayed based on the flights data we've been working with. This model will also include information about the plane that flew the route, so the first step is to join the two tables: <code>flights</code> and <code>planes</code>!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rename year column</span></span><br><span class="line">planes = planes.withColumnRenamed(<span class="string">&#x27;year&#x27;</span>,<span class="string">&#x27;plane_year&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Join the DataFrames</span></span><br><span class="line">model_data = flights.join(planes, on=<span class="string">&#x27;tailnum&#x27;</span>, how=<span class="string">&quot;leftouter&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="data-types">Data types</h2><p>Good work! Before you get started modeling, <strong>it's important to know that Spark only handles numeric data</strong>. That means all of the columns in your DataFrame must be either integers or decimals (called 'doubles' in Spark).</p><p>When we imported our data, we let Spark guess what kind of information each column held. Unfortunately, Spark doesn't always guess right and you can see that some of the columns in our DataFrame are strings containing numbers as opposed to actual numeric values.</p><p>To remedy this, you can use the <code>.cast()</code> method in combination with the <code>.withColumn()</code> method. It's important to note that <code>.cast()</code> works on columns, while <code>.withColumn()</code> works on DataFrames.</p><p>The only argument you need to pass to <code>.cast()</code> is the kind of value you want to create, in string form. For example, to create integers, you'll pass the argument <code>"integer"</code> and for decimal numbers you'll use <code>"double"</code>.</p><p>You can put this call to <code>.cast()</code> inside a call to <code>.withColumn()</code> to overwrite the already existing column, just like you did in the previous chapter!</p><h3 id="string-to-integer">String to integer</h3><p>Now you'll use the <code>.cast()</code> method you learned in the previous exercise to convert all the appropriate columns from your DataFrame <code>model_data</code> to integers!</p><p>To convert the type of a column using the <code>.cast()</code> method, you can write code like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cast the columns to integers</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;arr_delay&quot;</span>, model_data.arr_delay.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;air_time&quot;</span>, model_data.air_time.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;month&quot;</span>, model_data.month.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;plane_year&quot;</span>, model_data.plane_year.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the column plane_age</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;plane_age&quot;</span>, model_data.year - model_data.plane_year)</span><br></pre></td></tr></table></figure><h3 id="making-a-boolean">Making a Boolean</h3><p>Consider that you're modeling a yes or no question: is the flight late? However, your data contains the arrival delay in minutes for each flight. Thus, you'll need to create a boolean column which indicates whether the flight was late or not!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create is_late</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;is_late&quot;</span>, model_data.arr_delay &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert to an integer</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;label&quot;</span>, model_data.is_late.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove missing values</span></span><br><span class="line">model_data = model_data.<span class="built_in">filter</span>(<span class="string">&quot;arr_delay is not NULL and dep_delay is not NULL and air_time is not NULL and plane_year is not NULL&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="strings-and-factors">Strings and factors</h3><p>As you know, Spark requires numeric data for modeling. So far this hasn't been an issue; even boolean columns can easily be converted to integers without any trouble. But you'll also be using the airline and the plane's destination as features in your model. These are coded as strings and there isn't any obvious way to convert them to a numeric data type.</p><p>Fortunately, PySpark has functions for handling this built into the <code>pyspark.ml.features</code> submodule. You can create what are called 'one-hot vectors' to represent the carrier and the destination of each flight. A <em>one-hot vector</em> is a way of representing a categorical feature where every observation has a vector in which all elements are zero except for at most one element, which has a value of one (1).</p><p>Each element in the vector corresponds to a level of the feature, so it's possible to tell what the right level is by seeing which element of the vector is equal to one (1).</p><p>The first step to encoding your categorical feature is to create a <code>StringIndexer</code>. Members of this class are <code>Estimator</code>s that take a DataFrame with a column of strings and map each unique string to a number. Then, the <code>Estimator</code> returns a <code>Transformer</code> that takes a DataFrame, attaches the mapping to it as metadata, and returns a new DataFrame with a numeric column corresponding to the string column.</p><p>The second step is to encode this numeric column as a one-hot vector using a <code>OneHotEncoder</code>. This works exactly the same way as the <code>StringIndexer</code> by creating an <code>Estimator</code> and then a <code>Transformer</code>. The end result is a column that encodes your categorical feature as a vector that's suitable for machine learning routines!</p><p>This may seem complicated, but don't worry! All you have to remember is that you need to create a <code>StringIndexer</code> and a <code>OneHotEncoder</code>, and the <code>Pipeline</code> will take care of the rest.</p><h3 id="carrier-destination">Carrier &amp; Destination</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a StringIndexer</span></span><br><span class="line">carr_indexer = StringIndexer(inputCol=<span class="string">&quot;carrier&quot;</span>,outputCol=<span class="string">&quot;carrier_index&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a OneHotEncoder</span></span><br><span class="line">carr_encoder = OneHotEncoder(inputCol=<span class="string">&quot;carrier_index&quot;</span>,outputCol=<span class="string">&quot;carrier_fact&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a StringIndexer</span></span><br><span class="line">dest_indexer = StringIndexer(inputCol=<span class="string">&#x27;dest&#x27;</span>,outputCol=<span class="string">&#x27;dest_index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a OneHotEncoder</span></span><br><span class="line">dest_encoder = OneHotEncoder(inputCol=<span class="string">&#x27;dest_index&#x27;</span>,outputCol=<span class="string">&#x27;dest_fact&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="assemble-a-vector">Assemble a vector</h3><p>The last step in the <code>Pipeline</code> is to combine all of the columns containing our features into a single column. This has to be done before modeling can take place because every Spark modeling routine expects the data to be in this form. You can do this by storing each of the values from a column as an entry in a vector. Then, from the model's point of view, every observation is a vector that contains all of the information about it and a label that tells the modeler what value that observation corresponds to.</p><p>Because of this, the <code>pyspark.ml.feature</code> submodule contains a class called <code>VectorAssembler</code>. This <code>Transformer</code> takes all of the columns you specify and combines them into a new vector column.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a VectorAssembler</span></span><br><span class="line">vec_assembler = VectorAssembler(inputCols=[<span class="string">&quot;month&quot;</span>, <span class="string">&quot;air_time&quot;</span>, <span class="string">&quot;carrier_fact&quot;</span>, <span class="string">&quot;dest_fact&quot;</span>, <span class="string">&quot;plane_age&quot;</span>], outputCol=<span class="string">&quot;features&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="create-the-pipeline">Create the pipeline</h3><p>ou're finally ready to create a <code>Pipeline</code>!</p><p><code>Pipeline</code> is a class in the <code>pyspark.ml</code> module that combines all the <code>Estimators</code> and <code>Transformers</code> that you've already created. This lets you reuse the same modeling process over and over again by wrapping it up in one simple object. Neat, right?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import Pipeline</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the pipeline</span></span><br><span class="line">flights_pipe = Pipeline(stages=[dest_indexer, dest_encoder, carr_indexer, carr_encoder, vec_assembler])</span><br></pre></td></tr></table></figure><h3 id="test-and-train">Test and Train</h3><p>After you've cleaned your data and gotten it ready for modeling, one of the most important steps is to split the data into a <em>test set</em> and a <em>train set</em>. After that, don't touch your test data until you think you have a good model! As you're building models and forming hypotheses, you can test them on your training data to get an idea of their performance.</p><p>Once you've got your favorite model, you can see how well it predicts the new data in your test set. This never-before-seen data will give you a much more realistic idea of your model's performance in the real world when you're trying to predict or classify new data.</p><p>In Spark it's important to make sure you split the data <strong>after</strong> all the transformations. This is because operations like <code>StringIndexer</code> don't always produce the same index even when given the same list of strings.</p><h3 id="transform-the-data">Transform the data</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fit and transform the data</span></span><br><span class="line">piped_data = flights_pipe.fit(model_data).transform(model_data)</span><br></pre></td></tr></table></figure><h3 id="split-the-data">Split the data</h3><p>Now that you've done all your manipulations, the last step before modeling is to split the data!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Split the data into training and test sets</span></span><br><span class="line">training, test = piped_data.randomSplit([<span class="number">.6</span>, <span class="number">.4</span>])</span><br></pre></td></tr></table></figure><h1 id="model-tuning-and-selection">Model tuning and selection</h1><h2 id="what-is-logistic-regression">What is logistic regression?</h2><p>The model you'll be fitting in this chapter is called a <em>logistic regression</em>. This model is very similar to a linear regression, but instead of predicting a numeric variable, it predicts the probability (between 0 and 1) of an event.</p><p>To use this as a classification algorithm, all you have to do is assign a cutoff point to these probabilities. If the predicted probability is above the cutoff point, you classify that observation as a 'yes' (in this case, the flight being late), if it's below, you classify it as a 'no'!</p><p>You'll tune this model by testing different values for several <em>hyperparameters</em>. A <em>hyperparameter</em> is just a value in the model that's not estimated from the data, but rather is supplied by the user to maximize performance. For this course it's not necessary to understand the mathematics behind all of these values - what's important is that you'll try out a few different choices and pick the best one.</p><h3 id="建立模型">建立模型</h3><p>The <code>Estimator</code> you'll be using is a <code>LogisticRegression</code> from the <code>pyspark.ml.classification</code> submodule.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import LogisticRegression</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.classification <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a LogisticRegression Estimator</span></span><br><span class="line">lr = LogisticRegression()</span><br></pre></td></tr></table></figure><h3 id="cross-validation">Cross validation</h3><p>In the next few exercises you'll be tuning your logistic regression model using a procedure called <em>k-fold cross validation</em>. This is a method of estimating the model's performance on unseen data (like your <code>test</code> DataFrame).</p><p>It works by splitting the training data into a few different partitions. The exact number is up to you, but in this course you'll be using PySpark's default value of three. Once the data is split up, one of the partitions is set aside, and the model is fit to the others. Then the error is measured against the held out partition. This is repeated for each of the partitions, so that every block of data is held out and used as a test set exactly once. Then the error on each of the partitions is averaged. This is called the <em>cross validation error</em> of the model, and is a good estimate of the actual error on the held out data.</p><p>You'll be using cross validation to choose the hyperparameters by creating a grid of the possible pairs of values for the two hyperparameters, <code>elasticNetParam</code> and <code>regParam</code>, and using the cross validation error to compare all the different models so you can choose the best one!</p><h3 id="create-the-evaluator">Create the evaluator</h3><p>The first thing you need when doing cross validation for model selection is a way to compare different models. Luckily, the <code>pyspark.ml.evaluation</code> submodule has classes for evaluating different kinds of models. Your model is a binary classification model, so you'll be using the <code>BinaryClassificationEvaluator</code> from the <code>pyspark.ml.evaluation</code> module.</p><p>This evaluator calculates the area under the ROC. This is a metric that combines the two kinds of errors a binary classifier can make (false positives and false negatives) into a simple number. You'll learn more about this towards the end of the chapter!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the evaluation submodule</span></span><br><span class="line"><span class="keyword">import</span> pyspark.ml.evaluation <span class="keyword">as</span> evals</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a BinaryClassificationEvaluator</span></span><br><span class="line">evaluator = evals.BinaryClassificationEvaluator(metricName=<span class="string">&quot;areaUnderROC&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="make-a-grid">Make a grid</h3><p>Next, you need to create a grid of values to search over when looking for the optimal hyperparameters. The submodule <code>pyspark.ml.tuning</code> includes a class called <code>ParamGridBuilder</code> that does just that (maybe you're starting to notice a pattern here; PySpark has a submodule for just about everything!).</p><p>You'll need to use the <code>.addGrid()</code> and <code>.build()</code> methods to create a grid that you can use for cross validation. The <code>.addGrid()</code> method takes a model parameter (an attribute of the model <code>Estimator</code>, <code>lr</code>, that you created a few exercises ago) and a list of values that you want to try. The <code>.build()</code> method takes no arguments, it just returns the grid that you'll use later.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the tuning submodule</span></span><br><span class="line"><span class="keyword">import</span> pyspark.ml.tuning <span class="keyword">as</span> tune</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the parameter grid</span></span><br><span class="line">grid = tune.ParamGridBuilder()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the hyperparameter</span></span><br><span class="line">grid = grid.addGrid(lr.regParam, np.arange(<span class="number">0</span>, <span class="number">.1</span>, <span class="number">.01</span>))</span><br><span class="line">grid = grid.addGrid(lr.elasticNetParam, [<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build the grid</span></span><br><span class="line">grid = grid.build()</span><br></pre></td></tr></table></figure><h3 id="make-the-validator">Make the validator</h3><p>The submodule <code>pyspark.ml.tuning</code> also has a class called <code>CrossValidator</code> for performing cross validation. This <code>Estimator</code> takes the modeler you want to fit, the grid of hyperparameters you created, and the evaluator you want to use to compare your models.</p><p>The submodule <code>pyspark.ml.tune</code> has already been imported as <code>tune</code>. You'll create the <code>CrossValidator</code> by passing it the logistic regression <code>Estimator</code> <code>lr</code>, the parameter <code>grid</code>, and the <code>evaluator</code> you created in the previous exercises.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create the CrossValidator</span></span><br><span class="line">cv = tune.CrossValidator(estimator=lr,</span><br><span class="line">               estimatorParamMaps=grid,</span><br><span class="line">               evaluator=evaluator</span><br><span class="line">               )</span><br></pre></td></tr></table></figure><h3 id="fit-the-models">Fit the model(s)</h3><p>You're finally ready to fit the models and select the best one!</p><p>Unfortunately, cross validation is a very computationally intensive procedure. Fitting all the models would take too long on DataCamp.</p><p>To do this locally you would use the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fit cross validation models</span></span><br><span class="line">models = cv.fit(training)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract the best model</span></span><br><span class="line">best_lr = models.bestModel</span><br></pre></td></tr></table></figure><p>Remember, the training data is called <code>training</code> and you're using <code>lr</code> to fit a logistic regression model. Cross validation selected the parameter values <code>regParam=0</code> and <code>elasticNetParam=0</code> as being the best. These are the default values, so you don't need to do anything else with <code>lr</code> before fitting the model.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Call lr.fit()</span></span><br><span class="line">best_lr = lr.fit(training)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print best_lr</span></span><br><span class="line"><span class="built_in">print</span>(best_lr)</span><br></pre></td></tr></table></figure><h2 id="evaluate-the-model">Evaluate the model</h2><p>For this course we'll be using a common metric for binary classification algorithms call the <em>AUC</em>, or area under the curve. In this case, the curve is the ROC, or receiver operating curve. The details of what these things actually measure isn't important for this course. All you need to know is that for our purposes, the closer the AUC is to one (1), the better the model is!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use the model to predict the test set</span></span><br><span class="line">test_results = best_lr.transform(test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate the predictions</span></span><br><span class="line"><span class="built_in">print</span>(evaluator.evaluate(test_results))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;A platform for cluster computing.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="spark" scheme="http://wittyfans.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Bash for Data Manipulation</title>
    <link href="http://wittyfans.com/article/2196900071.html"/>
    <id>http://wittyfans.com/article/2196900071.html</id>
    <published>2021-02-25T15:20:39.000Z</published>
    <updated>2021-11-19T14:12:08.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Do complex things with just a few keystrokes!</p></blockquote><span id="more"></span><p>Bash is a Unix shell and command language, it survived and thrived for almost 50 years because it lets people do complex things with just a few keystrokes. Sometimes called "the universal glue of programming," it helps users combine existing programs in new ways, automate repetitive tasks, and run programs on clusters and clouds that may be halfway around the world.</p><h1 id="basic">Basic</h1><blockquote><p>How to move around in the shell, and how to create, modify, and delete files and folders.</p></blockquote><ul><li><code>pwd</code> print working directory</li><li><code>ls</code>: listing files or directories</li><li><code>cd</code>: change directory</li><li><code>cp</code>: copy</li><li><code>mv</code>: move or rename</li><li><code>rm</code>: remove</li><li><code>$1</code> or <code>$2</code> in bash script file, receive ARGV in bash scripts. <code>$@</code> , <code>$*</code> means get ARGV list, <code>$#</code> means get ARGV length.</li></ul><h1 id="find-files">Find files</h1><h2 id="by-name">by name</h2><ul><li>find ., list all file and folder below current</li><li>find folder</li><li>find . -type d, find all foldre, no file</li><li>find . -type f, find all file , no foldre</li><li>find . -type f -name "test.txt", name as text txt file</li><li>find . -type f -name "text*", name as txt all file</li><li>find . -type f -iname "text*", 不区分大小写</li><li>find . -type f -name "*.py"</li></ul><h2 id="by-time">by time</h2><ul><li>find . -type f -mmin -10,过去十分钟修改过的文件</li><li>find . -type f -mmin +10</li><li>find . -type f -mmin +1 -mmin -5</li><li>find . -type f -mtime -20</li></ul><p>amin,atime: access min and access day; cmin,ctime: change min and change day; mmin,mtime: modify;</p><h2 id="by-size">by size</h2><ul><li>find . -size +5m, k,g is work too</li><li>ls -lah ./folders, info about sub folder and files,including size</li><li>find . -empty</li></ul><h2 id="by-permission">by permission</h2><ul><li>find. -perm 777, read, write, and excute</li><li>find folder -exec chown coreschafer:www-data {} +</li><li>find folder, will return all folder, -exec will run the command in that results, {} palceholder, + end of the command.</li><li>find folder -type f -exec chmod 664 {} +</li><li>find folder -perm 664</li><li>find . -type f -name "*.jpg"</li><li>find . -type f -name "*.jpg" -maxdepth 1, searched 1 level down</li><li>find . -type f -name "*.jpg" -maxdepth 1 -exec rm {} +, delete serched files</li></ul><h1 id="grep">Grep</h1><h2 id="grep-single-file">Grep single file</h2><blockquote><p>searched text</p></blockquote><ul><li>grep "text_you_want_search" filename.txt</li><li>grep -w "text_you_want_search" filename.txt, have to match all words</li><li>grep -wi "text_you_want_search" filename.txt, igore the lowcase and uppearcse.</li><li>grep -win "text_you_want_search" filename.txt, get info about the line number</li><li>grep -win -B 4 "text_you_want_search" filename.txt, return the context about the searched words, 4 line, behind</li><li>grep -win -A 4 "text_you_want_search" filename.txt, return the context about the searched words, 4 line, ahead</li><li>grep -win -C 4 "text_you_want_search" filename.txt, return the context about the searched words, 4 line, two line before and two behind.</li></ul><h2 id="grep-multi-file">Grep multi file</h2><ul><li>grep -win "text_" ./*, all file</li><li>grep -win "text_" ./*.txt, txt file</li><li>grep -winr "text" ./ , search all subdir</li><li>grep -wirl "text" ./ , no need match info, just file list</li><li>grep -wirc "text" ./ , show matched number in eatch file</li></ul><h2 id="grep-command-history">Grep command history</h2><ul><li>history | grep "git commit"</li><li>history | grep "git commit" | grep "dotfile"</li></ul><h2 id="grep-rgx">Grep rgx</h2><ul><li>grep -P "--" file.txt, work well in linux, mac need to config, I configed</li></ul><h1 id="curl">cURL</h1><h2 id="requests">Requests</h2><ul><li>curl url</li><li>curl http://localhost:5000</li><li>curl http:www.wittyfans.com/json_file</li><li>curl -i http:www.wittyfans.com/json_file, details info about the get</li><li>curl http:www.wittyfans.com/method</li><li>curl -d "first=name&amp;last=lastname" http:www.wittyfans.com/method, d for data, Post request</li><li>curl -X PUT -d "first=name&amp;last=lastname" http:www.wittyfans.com/method, d for data, Pust request</li><li>curl -X DELETE http:www.wittyfans.com/method, delete request</li></ul><h2 id="verify">Verify</h2><p>Could not verify your access ?</p><p><code>curl -u username:password http://wittyfans.com, Auth</code></p><h2 id="download">Download</h2><ul><li>curl http://wittyfans.com/folder, return binary file , error</li><li>curl -o filename.jpg http://wittyfans.com/folder , sucess</li><li>curl -o file_name.json http:/.api.wittyfans.com , Saving large json file</li></ul><h1 id="rsync">rsync</h1><h2 id="install">Install</h2><p>aviable in Mac, debian-based linux need to install</p><ul><li>apt-get install rsync</li><li>yum install rsync</li></ul><h2 id="use">Use</h2><ul><li>rsync folder1/* backup/ , sync fils to backup folder,will skping the subfolder's file, but affected subfolder</li><li>rsync -r folder1/* backup/ , including subfolder's file</li><li>rsync -r folder1 backup/, sync folder, not content in it</li></ul><h2 id="check-chage-before-run">Check chage before run</h2><ul><li>rsync -a --dry-run folder1/* backup/, check before the command run, now view showed</li><li>rsync -av --dry-run folder1/* backup/, auto view</li></ul><h2 id="source_folder-has-new-file">Source_folder has new file</h2><ul><li>rsync -av --delete --dry-run original/ backup/, check, be careful !</li></ul><h2 id="do-it-in-local-and-host">Do it in local and host</h2><ul><li>rsync -zaP -p local_folder username@ip:~/public/, z for compress, a for all, P for tarnsfer in internet</li><li>rsync 0zaP username@ip:~/public/file ~/Downloads/, revers</li></ul><h1 id="manipulating-data">Manipulating data</h1><blockquote><p>How to work with the data in those files</p></blockquote><p><code>cat</code>: view a files contents, meaning concatenate</p><p><code>less</code> &amp; <code>more</code>: view contents piece by piece, <code>more</code> is superseded by <code>less</code> now, In <code>less</code>:</p><ul><li><code>:n</code>, Move to next file</li><li><code>:p</code>, Go back to previous file</li><li><code>:q</code>, quit</li></ul><p><code>head</code>: look at the start of a text file, <code>head -3</code>, only display the first three lines</p><p><code>tail</code>: look at the end of a text file, <code>tail -n +7</code>, display content from line 7 to end</p><p><code>ls</code> : list everything below a directory, <code>ls -R -F</code>, <code>-R</code> recursive <code>-F</code>prints a <code>/</code> after the name of every directory and a <code>*</code> after the name of every runnable program.</p><p><code>man</code>: manual, automatically invokes <code>less</code></p><p><code>cut -f 2-5,8 -d values.csv</code>: select columns 2 through 5 and columns 8, using comma as the separator. <code>-d</code> means delimiter, <code>-f</code> meaning fields to specify columns</p><p><code>!command</code>: re-run the most recent use of that command matched</p><p><code>grep bicuspid seasonal/winter.csv</code>: prints lines from winter.csv that contain "bicuspid"</p><p><code>cat two_cities.txt | egrep 'Sydney Carton|Charles Darnay' | wc -l</code> : Count the number of lines in the book that contain <em>either</em> the character 'Sydney Carton' or 'Charles Darnay'.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c: <span class="built_in">print</span> a count of matching lines rather than the lines themselves</span><br><span class="line">-h: <span class="keyword">do</span> not <span class="built_in">print</span> the names of files when searching multiple files</span><br><span class="line">-i: ignore <span class="keyword">case</span> (e.g., treat <span class="string">&quot;Regression&quot;</span> and <span class="string">&quot;regression&quot;</span> as matches)</span><br><span class="line">-l: <span class="built_in">print</span> the names of files that contain matches, not the matches</span><br><span class="line">-n: <span class="built_in">print</span> line numbers <span class="keyword">for</span> matching lines</span><br><span class="line">-v: invert the match, i.e., only show lines that don<span class="string">&#x27;t match</span></span><br><span class="line"><span class="string">egrep: grep -E</span></span><br></pre></td></tr></table></figure><h2 id="combining-tools">Combining tools</h2><blockquote><p>How to use this power to select the data you want, and introduce commands for sorting values and removing duplicates.</p></blockquote><p><code>head -n 5 seasonal/summer.csv &gt; top.csv</code>: get first 5 rows content of summer.csv, write to top.csv</p><p><code>cut -d , -f 2 seasonal/summer.csv | grep -v Tooth</code>, select all of the tooth names from column 2 of the comma delimited file.</p><p><code>wc</code>, word count, count a date from a file. <code>grep 2017-07 seasonal/spring.csv | wc -l</code></p><p><code>head -n 3 seasonal/s*</code>, show all s* files first 3 rows.</p><ul><li><code>*</code>, all</li><li><code>?</code>, single word</li><li><code>[...]</code> matches any one of the characters inside the square brackets, <code>201[78].txt</code> matches <code>2017.txt</code> or <code>2018.txt</code>, but not <code>2016.txt</code></li><li><code>&#123;...&#125;</code> matches any of the comma-separated patterns inside the curly brackets, so <code>&#123;*.txt, *.csv&#125;</code> matches any file whose name ends with <code>.txt</code> or <code>.csv</code>, but not files whose names end with <code>.pdf</code>.</li></ul><p><code>sort</code>, <code>-n</code>: sort numerically, <code>-r</code>: reverse, <code>-b</code>: ignore leading blanks, <code>-f</code>: be case-insensitive</p><p><code>uniq</code>, remove <strong>adjacent</strong> duplicated lines .</p><p><code>wc -l seasonal/*.csv</code>, Print line numbers for each file in folder seasonal</p><p><code>wc -l seasonal/*.csv | grep -v 'total' | sort -n | head -n 1</code>, remove rows with word 'total' and select first row.</p><h2 id="batch-processing">Batch processing</h2><blockquote><p>How to make your own pipelines do that. Along the way, you will see how the shell uses variables to store information.</p></blockquote><p><code>set</code>: check <strong>environment variables</strong></p><p><code>echo</code>: print</p><ul><li><code>$User</code>, user name</li><li><code>$OSTYPE</code> name of the kind of operating system you are using</li></ul><p><code>training=seasonal/summer.csv</code> then <code>echo $training</code>, define a variable and print it.</p><p><strong>For loop:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example 1</span></span><br><span class="line"><span class="keyword">for</span> filetype <span class="keyword">in</span> gif jpg png; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$filetype</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># Example 2</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> seasonal/*.csv; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$filename</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># Example 3</span></span><br><span class="line">datasets=seasonal/*.csv</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> <span class="variable">$datasets</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$filename</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># Example 4</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> seasonal/*.csv; <span class="keyword">do</span> head -n 2 <span class="variable">$file</span> | tail -n 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>Do not using space in file name, it will causing issue in bash.</p></blockquote><h2 id="creating-new-tools">Creating new tools</h2><blockquote><p>How to go one step further and create new commands of your own.</p></blockquote><p><strong>Edit file using <code>nano</code>:</strong></p><p><code>nano filename.txt</code>, edit a file</p><ul><li><code>Ctrl</code> + <code>K</code>: delete a line.</li><li><code>Ctrl</code> + <code>U</code>: un-delete a line.</li><li><code>Ctrl</code> + <code>O</code>: save the file ('O' stands for 'output'). <em>You will also need to press Enter to confirm the filename!</em></li><li><code>Ctrl</code> + <code>X</code>: exit the editor.</li></ul><p><code>grep -h -v Tooth spring.csv summer.csv &gt; temp.csv</code>, <code>-h</code> stop it from printing filenames, <code>-v</code> printing all rows exclude Tooth</p><p><code>history | tail -n 3</code>, Show most recent 3 commands</p><p><code>$@</code>, pass filenames to scripts. <code>tail -q -n +2 $@ | wc -l</code></p><h2 id="downloading-data">Downloading data</h2><blockquote><p>how to download data files from web servers via the command line</p></blockquote><p><code>curl</code>, Client for URLs. <code>man curl</code> , check curl installation.</p><ul><li><code>curl -O url</code> save the file with it's original name</li><li><code>curl -o newname.txt url</code> new file name</li><li>Download all 100 data file, <code>curl -O https://s3.amazonaws.com/datafile[001-100].txt</code></li></ul><p><code>Wget</code>, World Wide Web and get. better than curl when downloading multiple files recursively. <code>which wget</code>, check <code>wget</code> installation.</p><p><code>wget -c -b https://wittyfans.com/201812SpotifyData.zip</code></p><ul><li><code>-c</code>, resume broken download</li><li><code>-b</code>, go to background</li><li><code>wget --wait=1 -i url_list.txt</code>, # Create a mandatory 1 second pause between downloading all files in url_list.txt</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use curl, download and rename a single file from URL</span></span><br><span class="line">curl -O Spotify201812.zip -L https://assets.datacamp.com/production/repositories/4180/datasets/eb1d6a36fa3039e4e00064797e1a1600d267b135/201812SpotifyData.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unzip, delete, then re-name to Spotify201812.csv</span></span><br><span class="line">unzip Spotify201812.zip &amp;&amp; rm Spotify201812.zip</span><br><span class="line">mv 201812SpotifyData.csv Spotify201812.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># View url_list.txt to verify content</span></span><br><span class="line">cat url_list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Wget, limit the download rate to 2500 KB/s, download all files in url_list.txt</span></span><br><span class="line">wget --limit-rate=2500k -i url_list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Take a look at all files downloaded</span></span><br><span class="line">ls</span><br></pre></td></tr></table></figure><h2 id="csv-kit">CSV Kit</h2><blockquote><p>Using <code>csvkit</code> to convert, preview, filter and manipulate files to prepare our data for further analyses.</p></blockquote><p><code>pip install csvk</code> for install, <a href="https://csvkit.readthedocs.io/en/latest/tutorial.html">Doc</a></p><h3 id="in2csv">in2csv</h3><ul><li><code>in2csv -h</code>, converting files to csv.</li><li><code>in2csv SpotifyData.xlsx &gt; SpotifyData.csv</code></li><li><code>in2csv SpotifyData.xlsx --sheet "Worksheet1_Popularity" &gt; Spotify_Popularity.csv</code>, Only converting a sheet</li></ul><h3 id="csvlook">csvlook</h3><ul><li><code>csvlook -h</code>, data preview on the command line.</li><li><code>csvlook SpotifyData.csv</code></li></ul><h3 id="csvsort">csvsort</h3><ul><li><code>csvsort -c 2 Spotify_Popularity.csv | csvlook</code></li></ul><h3 id="csvstat">csvstat</h3><ul><li><code>csvstat Spotify_Popularity.csv</code>, summary statistics</li></ul><h3 id="csvcut">csvcut</h3><ul><li><code>csvcut -n Spotify_MusicAttributes.csv</code>, Print a list of column headers in data file</li><li><code>csvcut -c 1,3,5 Spotify_MusicAttributes.csv</code>, Print the first column, by position</li><li><code>csvcut -c "track_id","duration_ms","loudness" Spotify_MusicAttributes.csv</code>, Print the track id, song duration, and loudness, by name</li></ul><h3 id="csvgrep">csvgrep</h3><ul><li><code>csvgrep -c "danceability" -m 0.812 Spotify_MusicAttributes.csv</code>, filter row danceability by value 0.812, column name must with "".</li></ul><h3 id="csvstack">csvstack</h3><ul><li><code>csvstack</code>, merge files.</li><li><code>csvstack Spotify_Rank6.csv Spotify_Rank7.csv &gt; Spotify.csv</code>, merge two files to one</li><li><code>csvstack -g "Rank6","Rank7" \ Spotify_Rank6.csv Spotify_Rank7.csv &gt; Spotify_Al</code>, merge two files to one and add a source column.</li></ul><h3 id="chain-commands">chain commands</h3><ul><li><code>;</code>, links commands together and runs sequentially</li><li><code>&amp;&amp;</code>, links commands together, but only runs the 2nd command if the 1st succeeds</li><li><code>&gt;</code>, using outputs from the 1st command</li><li><code>|</code>, using outputs form the 1st as input to the 2nd</li></ul><h3 id="sql2csv">sql2csv</h3><ul><li><code>sql2csv -v</code> or <code>sql2csv --verbose</code>, printing more tracebacks and logs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pull the entire Spotify_Popularity table and print in log</span></span><br><span class="line">sql2csv --db <span class="string">&quot;sqlite:///SpotifyDatabase.db&quot;</span> \</span><br><span class="line">        --query <span class="string">&quot;SELECT * FROM Spotify_Popularity&quot;</span></span><br></pre></td></tr></table></figure><h3 id="csvsql">csvsql</h3><p>Manipulating data using SQL syntax (Small to medium files only) :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reformat the output using csvlook</span></span><br><span class="line">csvsql --query <span class="string">&quot;SELECT * FROM Spotify_MusicAttributes ORDER BY duration_ms LIMIT 1&quot;</span> \</span><br><span class="line">Spotify_MusicAttributes.csv | csvlook</span><br></pre></td></tr></table></figure><p>using bash variable:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Store SQL query as shell variable</span></span><br><span class="line">sqlquery=<span class="string">&quot;SELECT * FROM Spotify_MusicAttributes ORDER BY duration_ms LIMIT 1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply SQL query to Spotify_MusicAttributes.csv</span></span><br><span class="line">csvsql --query <span class="string">&quot;<span class="variable">$sqlquery</span>&quot;</span> Spotify_MusicAttributes.csv</span><br></pre></td></tr></table></figure><p>join two file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Store SQL query as shell variable</span></span><br><span class="line">sql_query=<span class="string">&quot;SELECT ma.*, p.popularity FROM Spotify_MusicAttributes ma INNER JOIN Spotify_Popularity p ON ma.track_id = p.track_id&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Join 2 local csvs into a new csv using the saved SQL</span></span><br><span class="line">csvsql --query <span class="string">&quot;<span class="variable">$sql_query</span>&quot;</span> Spotify_MusicAttributes.csv Spotify_Popularity.csv &gt; Spotify_FullData.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preview newly created file</span></span><br><span class="line">csvstat Spotify_FullData.csv</span><br></pre></td></tr></table></figure><p>Pushing data back to database:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Store SQL for querying from SQLite database</span></span><br><span class="line">sqlquery_pull=<span class="string">&quot;SELECT * FROM SpotifyMostRecentData&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply SQL to save table as local file</span></span><br><span class="line">sql2csv --db <span class="string">&quot;sqlite:///SpotifyDatabase.db&quot;</span> --query <span class="string">&quot;<span class="variable">$sqlquery_pull</span>&quot;</span> &gt; SpotifyMostRecentData.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store SQL for UNION of the two local CSV files</span></span><br><span class="line">sqlquery_union=<span class="string">&quot;SELECT * FROM SpotifyMostRecentData UNION ALL SELECT * FROM Spotify201812&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply SQL to union the two local CSV files and save as local file</span></span><br><span class="line">csvsql --query <span class="string">&quot;<span class="variable">$sqlquery_union</span>&quot;</span> SpotifyMostRecentData.csv Spotify201812.csv &gt; UnionedSpotifyData.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Push UnionedSpotifyData.csv to database as a new table</span></span><br><span class="line">csvsql --db <span class="string">&quot;sqlite:///SpotifyDatabase.db&quot;</span> --insert UnionedSpotifyData.csv</span><br></pre></td></tr></table></figure><h1 id="bash-script">Bash Script</h1><h2 id="stream-editor">Stream editor</h2><p><code>sed</code>: stream editor.</p><p><code>cat soccer_scores.csv | sed 's/Cherno/Cherno City/g' &gt; soccer_scores_edited.csv</code> : replace word <code>Cherno</code> to <code>herno City</code> then save it to a new file, for more, check <a href="https://coolshell.cn/articles/9104.html">this</a>.</p><h2 id="argument">Argument</h2><p><code>$1</code> or <code>$2</code> in bash script file, receive ARGV in bash scripts. <code>$@</code> , <code>$*</code> means get ARGV list, <code>$#</code> means get ARGV length. <code>cat hire_data/*.csv | grep "$1" &gt; "$1".csv</code>: take in a city (an argument) as a variable, filter all the files by this city and output to a new CSV with the city name.</p><h2 id="quotes">Quotes</h2><p>Single,double,backticks.</p><ul><li>Single quotes ('sometext') = Shell interprets what is between literally</li><li>Double quotes ("sometext") = Shell interpret literally except using $ and backticks</li><li>Backticks (`sometext`) = Shell runs the command and captures STDOUT back into a variable</li></ul><h2 id="numeric-variables">Numeric variables</h2><p>In bash, Type <code>&gt;&gt;&gt; 1 + 5</code> will get error. instead, you need type <code>expr 1 + 5</code>. <code>expr</code> is utility program just like <code>cat</code> and <code>grep</code>. but <code>expr</code> cannot natively handle decimal places. <code>expr 1 + 2.5</code> will get <code>not a decimal nuber error</code>.</p><p>Introduce <code>bc</code> (basic calculator), a useful command-line program. using <code>bc</code> without opening the calculator:</p><p><code>echo "5+7.5" | bc</code> , <code>bc</code> has a <code>scale</code> argument for how many decimal places: <code>echo "scale=3; 10 /3 | bc"</code>, <code>;</code> is to separate lines in terminal.</p><h2 id="array">Array</h2><h3 id="normal-array">Normal array</h3><p>Create array: <code>capital_cities=("Sydney" "New York" "Paris")</code></p><p>Add element:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a normal array with the mentioned elements using the declare method</span></span><br><span class="line"><span class="built_in">declare</span> -a capital_cities</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add (append) the elements</span></span><br><span class="line">capital_cities+=(<span class="string">&quot;Sydney&quot;</span>)</span><br><span class="line">capital_cities+=(<span class="string">&quot;New York&quot;</span>)</span><br><span class="line">capital_cities+=(<span class="string">&quot;Paris&quot;</span>)</span><br></pre></td></tr></table></figure><p>Get all element and length of array:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The array has been created for you</span></span><br><span class="line">capital_cities=(<span class="string">&quot;Sydney&quot;</span> <span class="string">&quot;New York&quot;</span> <span class="string">&quot;Paris&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the entire array</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;capital_cities[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the array length</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#capital_cities[@]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="associative-arrays">Associative arrays</h3><blockquote><p>Like dictionary in python.</p></blockquote><p>Create:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create empty associative array</span></span><br><span class="line"><span class="built_in">declare</span> -A model_metrics</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the key-value pairs</span></span><br><span class="line">model_metrics[model_accuracy]=98</span><br><span class="line">model_metrics[model_name]=<span class="string">&quot;knn&quot;</span></span><br><span class="line">model_metrics[model_f1]=0.82</span><br></pre></td></tr></table></figure><p>Create in one line:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># An associative array has been created for you</span></span><br><span class="line"><span class="built_in">declare</span> -A model_metrics=([model_accuracy]=98 [model_name]=<span class="string">&quot;knn&quot;</span> [model_f1]=0.82)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out just the keys</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;____model_metrics[____]&#125;</span></span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create variables from the temperature data files</span></span><br><span class="line">temp_b=<span class="string">&quot;<span class="subst">$(cat temps/region_B)</span>&quot;</span></span><br><span class="line">temp_c=<span class="string">&quot;<span class="subst">$(cat temps/region_C)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array with these variables as elements</span></span><br><span class="line">region_temps=(<span class="variable">$temp_b</span> <span class="variable">$temp_c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call an external program to get average temperature</span></span><br><span class="line">average_temp=$(<span class="built_in">echo</span> <span class="string">&quot;scale=2; (<span class="variable">$&#123;region_temps[0]&#125;</span> + <span class="variable">$&#123;region_temps[1]&#125;</span>) / 2&quot;</span> | bc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Append to array</span></span><br><span class="line">region_temps+=(<span class="variable">$average_temp</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the whole array</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;region_temps[@]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="control-statements">Control Statements</h2><h3 id="if-statements">IF statements</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ] &amp;&amp; [ condition2 ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># some code</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># some code</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>Move files based on content:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extract Accuracy from first ARGV element</span></span><br><span class="line">accuracy=$(grep Accuracy <span class="variable">$1</span> | sed <span class="string">&#x27;s/.* //&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Conditionally move into good_models folder</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$accuracy</span> -ge 90 ]; <span class="keyword">then</span></span><br><span class="line">    mv <span class="variable">$1</span> ./good_models</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conditionally move into bad_models folder</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$accuracy</span> -lt 90 ]; <span class="keyword">then</span></span><br><span class="line">    mv <span class="variable">$1</span> ./bad_models</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Normal flags</span></span><br><span class="line">-eq =</span><br><span class="line">-ne !=</span><br><span class="line">-lt &lt;</span><br><span class="line">-le &lt;=</span><br><span class="line">-gt &gt;</span><br><span class="line">-ge &gt;=</span><br><span class="line"></span><br><span class="line"><span class="comment"># File related flags</span></span><br><span class="line">-e <span class="keyword">if</span> the file exists</span><br><span class="line">-s <span class="keyword">if</span> the file exists and has size greater than zero</span><br><span class="line">-r <span class="keyword">if</span> the file exists and is readable</span><br><span class="line">-w <span class="keyword">if</span> the file exists and is writable</span><br><span class="line"></span><br><span class="line"><span class="comment">## And and OR</span></span><br><span class="line">&amp;&amp; <span class="keyword">for</span> and</span><br><span class="line">|| <span class="keyword">for</span> or</span><br></pre></td></tr></table></figure><h2 id="for-loops">For loops</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use a FOR loop on files in directory</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> inherited_folder/*.R</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Echo out each file</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Move python file to to_keep if it using random forest class fier</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> robs_files/*.py</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Create IF statement using grep</span></span><br><span class="line">    <span class="keyword">if</span> grep -q <span class="string">&#x27;RandomForestClassifier&#x27;</span> <span class="variable">$file</span> ; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># Move wanted files to to_keep/ folder</span></span><br><span class="line">        mv <span class="variable">$file</span> to_keep/</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="case">Case</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a CASE statement matching the first ARGV element</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">  <span class="comment"># Match on all weekdays</span></span><br><span class="line">  Monday|Tuesday|Wednesday|Thursday|Friday)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;It is a Weekday!&quot;</span>;;</span><br><span class="line">  <span class="comment"># Match on all weekend days</span></span><br><span class="line">  Saturday|Sunday)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;It is a Weekend!&quot;</span>;;</span><br><span class="line">  <span class="comment"># Create a default</span></span><br><span class="line">  *)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Not a day!&quot;</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h2 id="function">Function</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> function_name &#123;</span><br><span class="line"><span class="comment">#function_code</span></span><br><span class="line"><span class="built_in">return</span> <span class="comment">#something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">print_hello</span></span> () &#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_hello</span><br></pre></td></tr></table></figure><blockquote><p><strong>Scope: All variables in Bash are global by default!</strong>Using <code>local val</code> to restrict variable scope.</p></blockquote><p>To get data out from function:</p><ol type="1"><li>Assign to a global variable</li><li><code>echo</code> what we want back in last line and capture using shell-within-shell</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> convert &#123;</span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$1</span>)</span><br><span class="line">&#125;</span><br><span class="line">converted = $(convert 30)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a function with a local base variable</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum_array</span></span> () &#123;</span><br><span class="line">  <span class="built_in">local</span> sum=0</span><br><span class="line">  <span class="comment"># Loop through, adding to base variable</span></span><br><span class="line">  <span class="keyword">for</span> number <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    sum=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$sum</span> + <span class="variable">$number</span>&quot;</span> | bc)</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># Echo back the result</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># Call function with array</span></span><br><span class="line">test_array=(14 12 23.5 16 19.34)</span><br><span class="line">total=$(sum_array <span class="string">&quot;<span class="variable">$&#123;test_array[@]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The total sum of the test array is <span class="variable">$total</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="python-script-on-bash">Python script on bash</h1><blockquote><p>Scheduling a job with crontab</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Preview both Python script and requirements text file</span></span><br><span class="line">cat create_model.py</span><br><span class="line">cat requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pip install Python dependencies in requirements file</span></span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Python script on command line</span></span><br><span class="line">python create_model.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add CRON job that runs create_model.py every minute</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* * * * * python create_model.py&quot;</span> | crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify that the CRON job has been scheduled via CRONTAB</span></span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure><h1 id="cron">Cron</h1><ul><li>crontab -l, list the crons</li></ul><blockquote><p>set your editor to nano, default vim</p></blockquote><ul><li>export EDITOR=/user/bin/nano</li><li>crontab -e, open editor</li><li>press i to input</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Algorhythm for schuel you task with time</span><br><span class="line"></span><br><span class="line"># ┌───────────── minute (0 - 59)</span><br><span class="line"># │ ┌───────────── hour (0 - 23)</span><br><span class="line"># │ │ ┌───────────── day of month (1 - 31)</span><br><span class="line"># │ │ │ ┌───────────── month (1 - 12)</span><br><span class="line"># │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday;</span><br><span class="line"># │ │ │ │ │                                       7 is also Sunday on some systems)</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># * * * * *  command_to_execute</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Do complex things with just a few keystrokes!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="bash" scheme="http://wittyfans.com/tags/bash/"/>
    
    <category term="linux" scheme="http://wittyfans.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>机器学习相关概念解读P1</title>
    <link href="http://wittyfans.com/article/1775964342.html"/>
    <id>http://wittyfans.com/article/1775964342.html</id>
    <published>2019-12-27T08:30:13.000Z</published>
    <updated>2021-11-19T14:12:08.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天开始准备对机器学习相关概念做个总结，part1会包括以下概念：Cross Validation、Confusion Matrix、Sensitivity 与 Specificity、Bias 与 Variance、ROC 与 AUC、Odds Ratios 与 Log(Odds Ratios)。</p></blockquote><span id="more"></span><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="cross-validation">Cross Validation</h1><p>假设你需要根据肩膀痛、血液状况、动脉阻塞、体重与否来预测患者有没有心脏病，输出的结果为是与否。 当你对数据进行训练的时候，你需要指定使用的机器学习模型，常用的比如：</p><ul><li>LR</li><li>KNN</li><li>SVM</li></ul><p>但你怎么知道选择哪一种模型呢？Cross Validation 可以让我们大概知道哪些模型会fit比较好，哪些模型在实际应用的时候表现会更好。</p><p>当训练模型的时候，需要将数据切割成训练组与测试组。如果你把所有的数据都拿去训练，那你就没有了测试数据，因为你的模型必须用它没有见过的数据来做测试。</p><p>通常我们使用数据中的前面百分之75的数据作为训练数据</p><p><img src="https://i.loli.net/2019/12/26/bH8Ep7IUjYXOziB.png" /></p><p>后面的部分作为测试数据</p><p><img src="https://i.loli.net/2019/12/26/xqAwCLeT2GObjB9.png" /></p><p>但是你怎么知道按照75:25的划分是最好的呢？如果我们使用前面百分之25的数据测试呢？或者是取中间的25%测试，其余的作为训练数据？</p><p>担心选择哪一段数据作为训练和测试数据，我们用Cross Validation，它会逐一将所有的数据都测试一遍，然后汇总结果。这样每一组数据都作为测试数据参与过模型训练，也参与过模型的检测。逐一测试后，再汇总所有结果，我们就可以选择最适合数据的模型。</p><p><img src="https://i.loli.net/2019/12/26/Hg4LjJTUpye7GlZ.png" /></p><p>在这，如果你把数据分成4份，就叫4-Fold Cross Validation, 5份就叫5fold，以此类推。</p><h1 id="confusion-matrix">Confusion Matrix</h1><p>Confusion Matrix这个概念告诉我们，机器学习的算法预测的结果中，正确了多少、错了多少以及正确的分布在哪里，错的又分布在哪里。</p><p><img src="https://i.loli.net/2019/12/24/yndGs7EN8UCvbVz.png" /></p><p>比如这个例子中，我们想要根据肩膀痛、血液状况、动脉阻塞、体重与否来预测患者有没有心脏病，输出的结果为是与否。</p><p>我们可以使用逻辑回归、knn、随机森林等模型来预测，或者你也可以使用任何其他的模型，但是我们如何来衡量这个模型的好坏呢？</p><p>首先将数据切分成训练组与测试组，在对上述模型进行训练之后，我们可以拿模型来对测试组的数据进行测试，然后将预测的结果与实际的结果进行对比，根据下面的表填入结果：</p><p><img src="https://i.loli.net/2019/12/24/eKaHMGr3tw8nDUb.png" /></p><p>通过这个表，就可以知道你的模型预测的结果分布如何，对于每一个模型我们都可以绘制此表用来对比模型的性能。</p><h1 id="sensitivity-与-specificity">Sensitivity 与 Specificity</h1><p><img src="https://i.loli.net/2019/12/26/FxOVkEmXPRdB1qH.png" /></p><p>在你理解了Confusion Matrix之后，我们再来讨论Sensitivity 与 Specificity.</p><p>这里的Sensitivity，也可以理解为我们在sklearn课程中提及到的<em>Recall</em>，它等于 tp/(tp+fn)，即所有有心脏病的人中，多少预测对了；</p><p>这是Sensitivity的计算: <img src="https://i.loli.net/2019/12/26/EV8fWqBlXdxHChQ.png" /></p><p>而Specificity，等于 tn/(tn+fp)，即所有真实没有心脏病的人中，多少预测对了。 这是Specificity的计算： <img src="https://i.loli.net/2019/12/26/bHhlMj8qpY29TIQ.png" /></p><p>我们可以对不同的模型（如LR与随机森林）计算它们的Sensitivity 和 Specificity做比较。</p><p><img src="https://i.loli.net/2019/12/26/H8aXwTIn37Bo2Pq.png" /></p><p>可以看到随机森林的sensitivity分数比较高，这意味着它对于区分positives的结果比较擅长，也就是预测哪些病人有心脏病。</p><p><img src="https://i.loli.net/2019/12/26/84bWv12kqtLTAfh.png" /></p><p>而LR则在预测哪些病人没有心脏病方面比较擅长。</p><p>如果对你来说，更重要的是找出那些人有心脏病，那么你应该使用随机森林，如果你更看重那些人没有心脏病，那么应该使用LR.</p><p>如果你的Confusion Matrix是三行三列，那么计算方式就不一样了，不过也没那么复杂，注意好对应关系就好了：</p><p><img src="https://i.loli.net/2019/12/26/CLuoHWsUnjSIDXh.png" /></p><p><img src="https://i.loli.net/2019/12/26/Zc2hEtBXgyvbxJ5.png" /></p><p>更多请参考<a href="https://www.youtube.com/watch?v=vP06aMoz4v8&amp;list=PLblh5JKOoLUICTaGLRoHQDuF_7q2GfuJF&amp;index=4">油管视频</a>.</p><h1 id="bias-与-variance">Bias 与 Variance</h1><p>你有一组老鼠的长度与体重数据，可以想象，老鼠的重量与长度是正比的，但它长到一定长度后，重量不会一直增长。我们使用LR训练一批老鼠数据，得到下面的图像:</p><p><img src="https://i.loli.net/2019/12/26/HcPiQa9w38V6XN7.png" /></p><p>LR无法完全与训练数据重合，这就叫做bias，你的模型也可能完美的穿过这些测试数据，这样它的模型bias就为0.</p><p><img src="https://i.loli.net/2019/12/26/184lbpAgnfQ5G6i.png" /></p><p>当我们用最小二乘法来衡量模型对测试数据的fit程度时，曲线模型无疑是最好的，但是基础，我们训练模型是用来做预测的，<strong>一个好的模型不是fit得好不好，而是预测的好不好。</strong></p><p><img src="https://i.loli.net/2019/12/26/kNMRjqLJuyDtrBb.png" /></p><p>同样当我们用最小二乘法来测试预测结果时，LR直线模型却更好，这是因为曲线模型的Variance太高了。</p><p>bias高，可以理解为反应慢，但很稳。而Variance高，则意味反应很灵敏，发挥可能有时候很好，有时候很差。</p><p>直线的Variance比较低，因为对于不同的数据集的预测结果，算出来的最小二乘法之和比较低。</p><p>另外一种机器学习的描述方式，虽然我们的曲线模型对与训练数据fit的非常完美，但是在测试数据中却不理想，我们说这个模型overfit了。</p><p>理想的模型是variance和bias都比较低，能准确的反映数据的分布关系，以及做出稳定的预测。</p><p>要找到这个值，需要我们对模型做出调整，通常有三种方法：</p><ol type="1"><li>regularization</li><li>boosting</li><li>bagging</li></ol><p>后续我们再来介绍这些概念。</p><h1 id="roc-与-auc">ROC 与 AUC</h1><h1 id="roc">ROC</h1><p>还是这组老鼠的数据，根据它们的体总来判定它是否是肥胖症，蓝色的点是判断为肥胖症的老鼠，红色的则没有肥胖症，其中有一个红点很特殊，它看起来体重很高但是没有肥胖（这肯定是只肌肉鼠），同时数据中也有一些不是很重但患有肥胖症的，这是因为它很短小，却很胖。</p><p><img src="https://i.loli.net/2019/12/27/jVYtvS4xTFE3qQh.png" /></p><p>我们用LR fit这组数据，会得到这样的一个曲线，在LR中，y轴是我们的概率，值域为0-1，当你的LR模型绘制出来了的时候，给我一个老鼠的体重，我大概就可以判断它是不是有肥胖症，但是这需要一个threshold（临界值）作为判断点，比如在这里我们取概率为0.5对应的体重值。</p><p><img src="https://i.loli.net/2019/12/27/joR8bKSrmVMJ5IC.png" /></p><p>当你将这个threshold定位0.5，我们就可以用test数据统计confusion matrax,并计算Sensitivity 与 Specificity,如果你觉得threshold设为0.5不太合适，你可以将其设为0.6，然后再计算Sensitivity 与 Specificity对比看看。</p><p>这个threshold可以不断的做出调整，以适应（fit）我们的数据。</p><p>比如，我们设置为它为0.1。</p><p><img src="https://i.loli.net/2019/12/27/3PNanWbGdTUR41K.png" /></p><p>在这种情况下，所有0.1以上的都被标记成肥胖，增加了对肥胖预测的准确率，但会有一些非肥胖症的老鼠被预测称肥胖症。</p><p>你也可以设为0.9，所有0.9以下的老鼠都标记成非肥胖，这样会增加那些对非肥胖症预测的准确率，但会有一些肥胖的老鼠也被预测称非肥胖。</p><p><img src="https://i.loli.net/2019/12/27/fPx6QpAHoB2XqUm.png" /></p><p>threshold可能是这其中的任何一个点，我们到底选哪个比较好呢？</p><p>这时候我们就可以使用ROC图像了，ROC图中x轴为 Specificity,y轴为Sensitivity，我们开始画图，第一步我们假设所有的老鼠都有肥胖症：</p><p><img src="https://i.loli.net/2019/12/27/8IqkjMU4FnhRtim.png" /></p><p>对于Sensitivity，我们计算后为1，它是所有真实肥胖症老鼠中有多少预测对了。这意味着所有的老鼠都标记为肥胖症，也就是说所有真实患有肥胖症的老鼠都预测成功了。</p><p>对于Specificity，计算后也为1，它是所有真实没有肥胖症的老鼠中，多少预测对了。这意味着所有不是肥胖症的老鼠都被标记为肥胖症了。</p><p>我们可以将这个点与0连线，在这条线上，Sensitivity和Specificity相等，这意味着我们对测试数据预测正确的值与预测错误的比例相等（那还不如靠猜）。</p><p><img src="https://i.loli.net/2019/12/27/1G5jS2O9QcAPiUT.png" /></p><p>现在我们把threshold设为0.3，我们得到sensitivity为1，specificity为0.75.</p><p><img src="https://i.loli.net/2019/12/27/nOaAb3Tz8hjfcLZ.png" /></p><p>它的sensitivity&gt;specificity,所以在图上它出现在绿虚线的左边，所以threshold为0.3比之前的值要好。</p><p>我们继续增加threshold</p><p><img src="https://i.loli.net/2019/12/27/TcK1jJfu8sClVew.png" /></p><p>这个结果又要好一点，我们一直继续，直到我们把所有的老鼠都预测为非肥胖症，将所有的点连起来，这就是我们的ROC曲线了。</p><ul><li>y轴为：真实数据中，肥胖的预测正确了多少。</li><li>x轴为：真实数据中，非肥胖的预测正确了多少。</li><li>x轴也可能为：预测数据中，肥胖的预测正确了多少。</li></ul><p><img src="https://i.loli.net/2019/12/27/YyrmfONXWc9Ub45.png" /></p><p>这个图中越靠近左上的点，结果越好。同时我们可以根据我们可以接受多大的错误率，来选择threshold,</p><p><img src="https://i.loli.net/2019/12/27/aDWEdetqAZnKoTy.png" /></p><h2 id="auc">AUC</h2><p>AUC就是ROC下面的曲线，如果我们通过更换模型，让曲线下方的面积变大了，那么新模型就比原来的模型更好。</p><p><img src="https://i.loli.net/2019/12/27/hbskK9xymApwYTF.png" /></p><p>如果图中蓝色部分是随机森林模型生成的AUC，红色部分是LR生成的，那么你应该选择LR作为你的模型。</p><p>注：有时候人们会用precision代替specificity, 即precision=True Positive / True Positive + False positive</p><p>对比它们的定义：</p><p>specificity： 所有有肥胖症的老鼠中，预测正确了多少。 precision：所有预测为肥胖症的老鼠中，预测正确了多少。</p><h1 id="odds-与-probability">Odds 与 Probability</h1><p>odds是你想要的结果除以你不想要的结果，而Probability是你想要的结果除以所有的结果。如在比赛中，你赢了5次，输了3次，那odds就是5/3,而概率测试5/8.</p><p><img src="https://i.loli.net/2019/12/25/QnURimjxBKEIMXt.png" /></p><p>odds是可以通过概率来计算得出的，它的公式是：</p><p><span class="math display">\[\frac{p}{1-p}\]</span></p><p>我们可以思考一下odds的取值范围，如果有一场比赛，因为我的实力很差，10次比赛输了8次，那么我的odds就是2/8,如果更糟，0/10，也就是0。</p><p>可见odds的值域中，最低值是0，从1-0是你所有输掉比赛的情况，而从1到无穷大则是你赢了比赛的情况，因为你赢了一万场输一场的情况也是有可能的，它的odds值为10000/1=10000。</p><p>把odds的值放到数轴上看，你会发现这样的一条线：</p><p><img src="https://i.loli.net/2019/12/25/A6cUjIDus1orLbv.png" /></p><p>但这里存在一个小问题，比如对于1:6和6:1，我输了6场和赢了6场，这两个结果看起来是对成的，得到的值画在数轴上却是不对称的。</p><p><img src="https://i.loli.net/2019/12/25/nl5tHL3TOx26FXE.png" /></p><p>而使用log函数则可以解决这个问题：</p><p><img src="https://i.loli.net/2019/12/25/7YJxzFTvLpuE4Ij.png" /></p><h1 id="odds-ratios-与-logodds-ratios">Odds Ratios 与 Log(Odds Ratios)</h1><p>odds本质上是ratio，但odds≠odds ratio,我们说odds ratio,指的是odds之间的运算，也就是两个不同结果之间odds值的运算。</p><p>odds ratio算出来的值可能在0-1之间，也可能在1到无穷大之间，如果我们需要让odds ratio值数轴上显示，对它取对数会比较好。</p><p>我们来举个例子，下面是癌症与基因突变的一组数据：</p><p><img src="https://i.loli.net/2019/12/25/lAECMGIj62ZOW8k.png" /></p><p>这是什么意思呢？ odds ratio和log(ratio)说明了两个事物（这里是癌症与基因突变）之间的关系。</p><p>odds ratio值越大，基因突变这个变量对于预测癌症就越好用，越小，则说明这个变量不适合用来预测癌症。</p><p>然而要证明相关，还需要证明它们之间存在统计显著性，主要有三种方法：</p><ul><li>Fisher's Exact Test</li><li>Chi-Square Test</li><li>The Wald Test</li></ul><p>有人比较喜欢用Fisher's Exact Test和Chi-Square Test计算P-Value,有人比较喜欢用The Wald Test计算P-Value和置信区间。</p><p>假设有如下表：</p><p><img src="https://i.loli.net/2019/12/27/sPfknqYcBOL7INl.png" /></p><h2 id="fishers-exact-test">Fisher's Exact Test</h2><blockquote><p>参考:<a href="https://youtu.be/udyAvvaMjfM">Fisher's Exact Test</a></p></blockquote><h2 id="chi-square-test">Chi-Square Test</h2><p>这是一种先假设癌症与基因变异之间没有关系的方法。 首先算出正常人患癌症的概率为：29/356 = 0.08.</p><p>有基因突变的为140人，如果按照正常人患癌症的概率，那么有基因突变的人中应该是 140*0.08=11.2 人有癌症，剩下 140-11.2=128.8 人无癌症。</p><p>同样的对于没有基因突变的人，患癌症的人为 216*0.08 = 17.3, 剩下 216-17.3 = 198.7人无癌症。</p><p>最后对比两个表，就可以算出p-vlue，如果你不知道具体如何算，可以参考别的文章。</p><p><img src="https://i.loli.net/2019/12/27/W5op2s8JqCfcawF.png" /></p><h2 id="the-wald-test">The Wald Test</h2><blockquote><p>todo.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天开始准备对机器学习相关概念做个总结，part1会包括以下概念：Cross Validation、Confusion Matrix、Sensitivity 与 Specificity、Bias 与 Variance、ROC 与 AUC、Odds Ratios 与 Log(Odds Ratios)。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="machine learning" scheme="http://wittyfans.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>加密货币市值分析</title>
    <link href="http://wittyfans.com/article/3333606907.html"/>
    <id>http://wittyfans.com/article/3333606907.html</id>
    <published>2019-12-06T07:22:17.000Z</published>
    <updated>2021-11-19T14:12:08.911Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/06/UD9XlmW3fxoSIa5.png" /></p><blockquote><p>自从08年比特币发布以来，数以百计类似的基于区块链技术的产品层出不穷。我们称这些为加密货币，时至今日，某些加密货币已经大幅上涨，某些在未来可能也极具上涨空间。实际上，在2017年12月6日，比特币的市值超过2000亿美元。</p></blockquote><span id="more"></span><p>加密货币市值分析</p><h1 id="席卷全球的加密货币">席卷全球的加密货币</h1><p>让我们来研究研究加密货币，第一个任务，我们将从coinmarketcap API加载当前数据，并将其显示在输出中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Importing pandas</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># Importing matplotlib and setting aesthetics for plotting later.</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format = &#x27;svg&#x27; </span><br><span class="line">plt.style.use(&#x27;fivethirtyeight&#x27;)</span><br><span class="line"></span><br><span class="line"># Reading in current data from coinmarketcap.com</span><br><span class="line">current = pd.read_json(&quot;https://api.coinmarketcap.com/v1/ticker/&quot;)</span><br><span class="line"></span><br><span class="line"># Printing out the first few lines</span><br><span class="line">print(current.head())</span><br></pre></td></tr></table></figure><p>从api返回的结果只包含了100条数据，像这种开放的api基本上都是只提供试用，如果想要更多更全的数据一般需要付费，这里我们使用一份我从网站里下载的csv数据，包括了17年6月的数据，这个数据集保存在本地，叫做<code>datasets/coinmarketcap_06122017.csv.</code></p><h1 id="加载数据">加载数据</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Reading datasets/coinmarketcap_06122017.csv into pandas</span><br><span class="line">dec6 = pd.read_csv(&#x27;datasets/coinmarketcap_06122017.csv&#x27;)</span><br><span class="line"></span><br><span class="line"># Selecting the &#x27;id&#x27; and the &#x27;market_cap_usd&#x27; columns</span><br><span class="line">market_cap_raw = dec6[[&#x27;id&#x27;,&#x27;market_cap_usd&#x27;]]</span><br><span class="line"></span><br><span class="line"># Counting the number of values</span><br><span class="line">market_cap_raw.count()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id                1326</span><br><span class="line">market_cap_usd    1031</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>从输出种，我们看到这两个数据的条目数不一样，这是因为在列 <code>market_cap_usd</code> 种，存在一些空值（na值），而count函数是不将空值计算入内的，我们将它去掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Filtering out rows without a market capitalization</span><br><span class="line">cap = market_cap_raw.query(&#x27;market_cap_usd &gt; 0&#x27;)</span><br><span class="line"></span><br><span class="line"># Counting the number of values again</span><br><span class="line">cap.count()</span><br></pre></td></tr></table></figure><h1 id="比较比特币与其他加密货币">比较比特币与其他加密货币</h1><p>现在比特币正处于与其他加密货币的激烈竞争中，但它仍然在市值中占主导地位，我们来比较一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Declaring these now for later use in the plots</span><br><span class="line">TOP_CAP_TITLE = &#x27;Top 10 market capitalization&#x27;</span><br><span class="line">TOP_CAP_YLABEL = &#x27;% of total cap&#x27;</span><br><span class="line"></span><br><span class="line"># Selecting the first 10 rows and setting the index</span><br><span class="line">cap10 = cap.head(10).set_index(&#x27;id&#x27;)</span><br><span class="line"></span><br><span class="line"># Calculating market_cap_perc</span><br><span class="line">cap10 = cap10.assign(market_cap_perc =</span><br><span class="line">    lambda x: (x.market_cap_usd / cap.market_cap_usd.sum()) * 100)</span><br><span class="line"></span><br><span class="line"># Plotting the barplot with the title defined above </span><br><span class="line">ax = cap10.market_cap_perc.plot.bar(title=&#x27;Top 10 market capitalization&#x27;)</span><br><span class="line"></span><br><span class="line"># Annotating the y axis with the label defined above</span><br><span class="line">ax.set_ylabel(&#x27;% of total cap&#x27;)</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://i.loli.net/2019/12/06/XFakbKp1f4ML5ul.png" /></p><p>可以看到比特币在整个加密货币中所占的份额多大，但是这个图还存在一个信息，可以对其进行改进，那就是比特币所占份额太大了，其他的加密货币之间就很难区分。</p><h1 id="可视化优化">可视化优化</h1><p>解决上面的办法是我们需要更改坐标轴的单位，我们从百分比换成 log^10,如果你不知道如何优化你的数据可视化步骤，可以参考我的<a href="http://wittyfans.com/coding/数据可视化基础与技术.html">另一篇文章</a></p><p>另外，我们把类似的加密货币合并成同一个颜色,把x轴上的信息隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Colors for the bar plot</span><br><span class="line">COLORS = [&#x27;orange&#x27;, &#x27;green&#x27;, &#x27;orange&#x27;, &#x27;cyan&#x27;, &#x27;cyan&#x27;, &#x27;blue&#x27;, &#x27;silver&#x27;, &#x27;orange&#x27;, &#x27;red&#x27;, &#x27;green&#x27;]</span><br><span class="line"></span><br><span class="line"># Plotting market_cap_usd as before but adding the colors and scaling the y-axis  </span><br><span class="line">ax = cap10.market_cap_perc.plot.bar(title=&#x27;Top 10 market capitalization&#x27;,color=COLORS)</span><br><span class="line"></span><br><span class="line"># Annotating the y axis with &#x27;USD&#x27;</span><br><span class="line">ax.set_ylabel(&#x27;USD&#x27;)</span><br><span class="line"></span><br><span class="line"># Final touch! Removing the xlabel as it is not very informative</span><br><span class="line">ax.set_xlabel(&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/06/QJCehqgOsF6EdZT.png" /></p><p><strong>隐藏X轴上的字的另一种方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_axis = ax.xaxis</span><br><span class="line">x_axis.label.set_visible(False)</span><br></pre></td></tr></table></figure><h1 id="恐怖的波动性">恐怖的波动性</h1><p>加密货币发布以来就以其惊人的波动性著称，让我们来探索一下这种波动性，我们会选择24小时和一周的时间短来统计波动性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Selecting the id, percent_change_24h and percent_change_7d columns</span><br><span class="line">volatility = dec6[[&#x27;id&#x27;,&#x27;percent_change_24h&#x27;,&#x27;percent_change_7d&#x27;]]</span><br><span class="line"></span><br><span class="line"># Setting the index to &#x27;id&#x27; and dropping all NaN rows</span><br><span class="line">volatility = volatility.set_index(&#x27;id&#x27;).dropna()</span><br><span class="line"></span><br><span class="line"># Sorting the DataFrame by percent_change_24h in ascending order</span><br><span class="line">volatility = volatility.sort_values(by=&#x27;percent_change_24h&#x27;)</span><br><span class="line"></span><br><span class="line"># Checking the first few rows</span><br><span class="line">print(volatility.head())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">               percent_change_24h  percent_change_7d</span><br><span class="line">id                                                  </span><br><span class="line">flappycoin                 -95.85             -96.61</span><br><span class="line">credence-coin              -94.22             -95.31</span><br><span class="line">coupecoin                  -93.93             -61.24</span><br><span class="line">tyrocoin                   -79.02             -87.43</span><br><span class="line">petrodollar                -76.55             542.96</span><br></pre></td></tr></table></figure><p>第一名flappycoin，24小时内的波动为95%，这意味着1万块钱的投入24小时后只剩500.</p><p>的确，波动性如此之大的产品亏损起来是很快的，但高风险也意味着高收益，我们来看一下24小时内最大的赢家与输家的对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#Defining a function with 2 parameters, the series to plot and the title</span><br><span class="line">def top10_subplot(volatility_series, title):</span><br><span class="line">    # Making the subplot and the figure for two side by side plots</span><br><span class="line">    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 6))</span><br><span class="line">    </span><br><span class="line">    # Plotting with pandas the barchart for the top 10 losers</span><br><span class="line">    ax = volatility_series[:10].plot.bar(color=&#x27;darkred&#x27;,ax=axes[0])</span><br><span class="line">    </span><br><span class="line">    # Setting the figure&#x27;s main title to the text passed as parameter</span><br><span class="line">    fig.suptitle(title)</span><br><span class="line">    </span><br><span class="line">    # Setting the ylabel to &#x27;% change&#x27;</span><br><span class="line">    ax.set_ylabel(&#x27;% change&#x27;)</span><br><span class="line">    </span><br><span class="line">    # Same as above, but for the top 10 winners</span><br><span class="line">    ax = volatility_series[-10:].plot.bar(color=&#x27;darkblue&#x27;,ax=axes[1])</span><br><span class="line">    </span><br><span class="line">    # Returning this for good practice, might use later</span><br><span class="line">    return fig, ax</span><br><span class="line"></span><br><span class="line">DTITLE = &quot;24 hours top losers and winners&quot;</span><br><span class="line"></span><br><span class="line"># Calling the function above with the 24 hours period series and title DTITLE  </span><br><span class="line">fig, ax = top10_subplot(volatility.percent_change_24h,&#x27;24 hours top losers and winners&#x27;)</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://i.loli.net/2019/12/06/6JMto7jFVD5gknu.png" /></p><p>24小时百分之800的收益？为什么你还在看这篇文章不赶快去买比特币！（开玩笑😝）</p><p>我们再来看看周收益吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Sorting in ascending order</span><br><span class="line">volatility7d = volatility.sort_values(by=&#x27;percent_change_7d&#x27;)</span><br><span class="line"></span><br><span class="line">WTITLE = &quot;Weekly top losers and winners&quot;</span><br><span class="line"></span><br><span class="line"># Calling the top10_subplot function</span><br><span class="line">fig, ax = top10_subplot(volatility7d.percent_change_7d,WTITLE)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/06/tyx5TMCD8J3Hszh.png" /></p><p>3500的收益，好了我不说什么了。</p><h1 id="关注低市值加密货币">关注低市值加密货币</h1><p>上面的这些加密货币感觉都没见过，事实上这些加密货币的市值都很小,而投资低市值的加密货币风险也是很高的，这也印证了之前说的高风险高收益。</p><p>对于市值要怎么划分呢？多少可以划分成高市值，多少又是低市值呢？我们一般按下表来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Large cap: +10 billion</span><br><span class="line">Mid cap: 2 billion - 10 billion</span><br><span class="line">Small cap: 300 million - 2 billion</span><br><span class="line">Micro cap: 50 million - 300 million</span><br><span class="line">Nano cap: Below 50 million</span><br></pre></td></tr></table></figure><p>我们来看一下大于一百亿市值的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Selecting everything bigger than 10 billion </span><br><span class="line">largecaps = cap.query(&#x27;market_cap_usd&gt;10000000000&#x27;)</span><br><span class="line"></span><br><span class="line"># Printing out largecaps</span><br><span class="line">print(largecaps)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             id  market_cap_usd</span><br><span class="line">0       bitcoin    2.130493e+11</span><br><span class="line">1      ethereum    4.352945e+10</span><br><span class="line">2  bitcoin-cash    2.529585e+10</span><br><span class="line">3          iota    1.475225e+10</span><br></pre></td></tr></table></figure><h1 id="大多数加密货币市值很低">大多数加密货币市值很低</h1><p>通过将加密货币按照市值分类，进而对其按区间统计个数，我们可以看到🧍‍♂️市值区间加密货币的个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Making a nice function for counting different marketcaps from the</span><br><span class="line"># &quot;cap&quot; DataFrame. Returns an int.</span><br><span class="line"># INSTRUCTORS NOTE: Since you made it to the end, consider it a gift :D</span><br><span class="line">def capcount(query_string):</span><br><span class="line">    return cap.query(query_string).count().id</span><br><span class="line"></span><br><span class="line"># Labels for the plot</span><br><span class="line">LABELS = [&quot;biggish&quot;, &quot;micro&quot;, &quot;nano&quot;]</span><br><span class="line"></span><br><span class="line"># Using capcount count the biggish cryptos</span><br><span class="line">biggish = capcount(&#x27;market_cap_usd&gt;3000000000&#x27;)</span><br><span class="line"></span><br><span class="line"># Same as above for micro ...</span><br><span class="line">micro = capcount(&#x27;market_cap_usd&gt;50000000 and market_cap_usd&lt;300000000&#x27;)</span><br><span class="line"></span><br><span class="line"># ... and for nano</span><br><span class="line">nano =  capcount(&#x27;market_cap_usd&lt;50000000&#x27;)</span><br><span class="line"></span><br><span class="line"># Making a list with the 3 counts</span><br><span class="line">values = [biggish,micro,nano]</span><br><span class="line"></span><br><span class="line"># Plotting them with matplotlib </span><br><span class="line">plt.bar(range(len(values)),values,label=LABELS)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/06/arEDO1QFAGVwqCB.png" /></p><p>可以发现，大部分的加密货币市值都很小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/06/UD9XlmW3fxoSIa5.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自从08年比特币发布以来，数以百计类似的基于区块链技术的产品层出不穷。我们称这些为加密货币，时至今日，某些加密货币已经大幅上涨，某些在未来可能也极具上涨空间。实际上，在2017年12月6日，比特币的市值超过2000亿美元。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="data analysis" scheme="http://wittyfans.com/tags/data-analysis/"/>
    
    <category term="pandas" scheme="http://wittyfans.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python神经网络分析基础</title>
    <link href="http://wittyfans.com/article/1648150364.html"/>
    <id>http://wittyfans.com/article/1648150364.html</id>
    <published>2019-12-04T08:30:41.000Z</published>
    <updated>2021-11-19T14:12:08.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/04/b8mhdtkcqeSiwEg.png" /></p><blockquote><p>今天我们学习神经网络与nexworkX.</p></blockquote><span id="more"></span><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="网络基础">网络基础</h1><p>什么是神经网络呢？我们可以想象它是我们的社交网络，或者是我们的高铁运输网络，神经网络对于模拟 <em>实体之间的关系</em> 非常有用，通过这种模拟，你可以了解到，在整个网络中，哪一个实体（或者说节点node）是比较重要的,各个实体之间的联系，实体之间的距离怎么走最短。</p><p>对于网络 <em>graph</em>，是由节点与关系组成的，节点叫做 <em>node</em>,关系叫做 <em>edge</em>.</p><p>网络中的<em>node</em>与<em>edge</em>都可以有自己的属性。来看下面这张社交关系的图：</p><p><img src="https://i.loli.net/2019/12/01/dlXxE2yc73U8Lez.png" /></p><p>图中Hugo和Eric是朋友，他们各自都有各自的属性</p><ul><li>id</li><li>age</li></ul><p>他们是朋友，所以关系edge即 Friendship，关系也有属性，标注了他们第一次成为朋友的时间。</p><h1 id="networkx基础">NetworkX基础</h1><p>在python中，我们如何表示网络与网络节点之间的关系呢？在python中，我们使用networkX这个包。下面建立一个网络的基本代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import networkx as nx</span><br><span class="line">G = nx.Graph()</span><br></pre></td></tr></table></figure><p>G即为一个网络，可以通过 <code>‌G.add_nodes_from([1, 2, 3])</code>往其中添加节点，节点添加进去以后，就可以使用<code>G.nodes()</code>来查看节点，此处会返回这个网络的所有节点。</p><p>那关系又要怎么定义呢？我们可以直接使用G.add_edge(1, 2) 方法将两个实体连接起来，这会在节点1与2之间创建关系。</p><p>前面提到了，我们的节点可以有属性，给节点的属性赋值很简单，直接赋值即可：<code>G.node[1]['label'] = 'blue'</code>.</p><p>如果你想知道网络的节点有哪些属性，通过<code>G.nodes(data=True)</code>即可查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: [(1, &#123;&#x27;label&#x27;: &#x27;blue&#x27;&#125;), (2, &#123;&#125;), (3, &#123;&#125;)]</span><br></pre></td></tr></table></figure><h1 id="图的类型">图的类型</h1><p>图的类型简单就是说节点之间的关系，举例来说，Facebook是undirected graphs,当一个人与另一个人成为朋友之后，这两个人自动就连接到了一起，在这种关系中，两个节点知识连接到了一起，没有方向性。undirected graphs类型的图在networkx中的类型就是graph，当你用<code>type</code>命令检测它的类型时,会显示<code>networkx.classes.graph.Graph</code>.</p><p>另外第一种是Directed grarphs,这种图里的节点就好像twitter中的用户之间的关系，比如一个用户也许关注了一个人，但是另外一个人可能却没有关注它，这时候两者的关系就是单向的关系，这两个node之间的关系我们会用一个箭头表示，这种类型的图在networkx中用<code>networkx.classes.graph.Digraph</code>表示。</p><p>两个节点之间的关系也会有多条edge存在的情况,比如两个站点之间所有的路线，这种图叫做MutilDIGraph。</p><p>对于两个两个节点之间，如果存在多个edge，这会导致计算量变得很大，这时候我们会将它们之间edge的管家信息保存成edge的属性，方便计算，比如将3条edge合并成1条，同时指定这条edge的metadata为3.</p><p>需要注意，在我们的车站的例子中，还有一种情况是我们的起点与终点是同一个站，这种特殊的情况叫做self-loops.</p><h1 id="绘制图">绘制图</h1><p>我们使用 nxviz 这个包来绘制接下来介绍的三种图，Matrix、arc和Circos图，强烈推荐你安装，你可以通过pip <code>pip install nxviz</code> 或者conda命令<code>conda install -c conda-forge nxviz</code>安装，<a href="https://pypi.org/project/nxviz/">更多</a>关于nxviz的资料.</p><h2 id="matrix-plots">Matrix plots</h2><p>Matrix plots图是一种用矩阵方格来表示节点之间关系的图，左边是Matrix图，右边是我们的节点关系。</p><p><img src="https://i.loli.net/2019/12/02/d78ojGXvCaFiJTE.png" /></p><ul><li>A-A是白的，表示它与它自己没有联系</li><li>A-B是黑色的，表示A指向B之间存在联系</li><li>B-A是白色的，表示B指向A无联系</li></ul><p>每个节点都对应一列与一行，两个节点之间的边由值1表示。但是，这样做仅保留了weight元数据（edge上的属性）；</p><p>下面是使用nxviz绘制graph对象T的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Import nxviz</span><br><span class="line">import nxviz as nv</span><br><span class="line"></span><br><span class="line"># Create the MatrixPlot object: m</span><br><span class="line">m = nv.MatrixPlot(T)</span><br><span class="line"></span><br><span class="line"># Draw m to the screen</span><br><span class="line">m.draw()</span><br><span class="line"></span><br><span class="line"># Display the plot</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># Convert T to a matrix format: A</span><br><span class="line">A = nx.to_numpy_matrix(T)</span><br><span class="line"></span><br><span class="line"># Convert A back to the NetworkX form as a directed graph: T_conv</span><br><span class="line">T_conv = nx.from_numpy_matrix(A, create_using=nx.DiGraph())</span><br><span class="line"></span><br><span class="line"># Check that the `category` metadata field is lost from each node</span><br><span class="line">for n, d in T_conv.nodes(data=True):</span><br><span class="line">    assert &#x27;category&#x27; not in d.keys()</span><br></pre></td></tr></table></figure><p>图像如下：</p><figure><img src="https://i.loli.net/2019/12/02/5VGJYM3B8kzFA2q.png" alt="Matrix plots with nxviz" /><figcaption aria-hidden="true">Matrix plots with nxviz</figcaption></figure><h2 id="circos-plots">Circos plots</h2><p>Circos plots是一种围绕着圆心绘制的图，看起来非常美观。</p><p><img src="https://i.loli.net/2019/12/02/iPw4r5xAB6lYds8.png" /></p><p>绘制上图的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Import necessary modules</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from nxviz import CircosPlot</span><br><span class="line"></span><br><span class="line"># Create the CircosPlot object: c</span><br><span class="line">c = CircosPlot(T)</span><br><span class="line"></span><br><span class="line"># Draw c to the screen</span><br><span class="line">c.draw()</span><br><span class="line"></span><br><span class="line"># Display the plot</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="arc-plots">Arc plots</h2><p>Arc plots即弧形图，它就好像把Circos plots展开成一条线，正因如此它需要我们指定排序。</p><p><img src="https://i.loli.net/2019/12/02/qe7yQNREpa5KzhT.png" /></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Import necessary modules</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from nxviz import ArcPlot</span><br><span class="line"></span><br><span class="line"># Create the un-customized ArcPlot object: a</span><br><span class="line">a = ArcPlot(T)</span><br><span class="line"></span><br><span class="line"># Draw a to the screen</span><br><span class="line">a.draw()</span><br><span class="line"></span><br><span class="line"># Display the plot</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># Create the customized ArcPlot object: a2</span><br><span class="line">a2 = ArcPlot(T,node_order=&#x27;category&#x27;,node_color=&#x27;category&#x27;)</span><br><span class="line"></span><br><span class="line"># Draw a2 to the screen</span><br><span class="line">a2.draw()</span><br><span class="line"></span><br><span class="line"># Display the plot</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><code>node_order='keyX'</code> 与 <code>node_color='keyX'</code> 即指定这个图的排序方式与颜色区分参考选项。</p><h1 id="重要的节点">重要的节点</h1><p>如果我们需要分析图，我们就需要对图的节点有所了解，对于一张图来说，其中有重要的节点，也有不那么重要的节点，比如对于地铁来说，那些市中心的换乘站比其他线路的终点站要重要，接下来我们介绍几个与节点有关的概念。</p><h2 id="degree-centrality">Degree Centrality</h2><p>Degree即一个node拥有多少个邻居，Degree Centrality即根据图中节点邻居的个数来给每个节点打分，如果一个节点连接的邻居更多，那它就更重要，分数也更高，Degree Centrality的定义为:</p><p><span class="math display">\[\frac{Neighbors\ I\ Have}{Neighbors\ I\ Could\ Possible\ Have}\]</span></p><p>这里的 <em>Neighbors I could possible have</em> 就是所有的节点，如果我们的讨论氛围允许self-loops存在，则它也包括我们自己，如果不允许，则只算所有除我之外的节点。</p><p>在networkx中，你可以使用 <code>G.neighbors(node_name)</code> 来查看一个节点拥有多少个邻居，如果你传进一个没有的节点，networkx则会抛出一个错误。</p><p>当我们有了所有节点的邻居数，就可以根据它来计算每个节点在图中的重要性，你可以使用 <em>nx.degree_centrality(G)</em> 来查看所有节点的Degree Centrality分数，注意这里分数的计算中，不包含self-loops的情况。</p><p>我们定义一个函数，它会找到我们网络中邻居数最高的节点,有了它我们就可以很方便的处理一些问题，如找到Twitter用户中，那些最有影响力的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Define find_nodes_with_highest_deg_cent()</span><br><span class="line">def find_nodes_with_highest_deg_cent(G):</span><br><span class="line"></span><br><span class="line">    # Compute the degree centrality of G: deg_cent</span><br><span class="line">    deg_cent = nx.degree_centrality(G)</span><br><span class="line"></span><br><span class="line">    # Compute the maximum degree centrality: max_dc</span><br><span class="line">    max_dc = max(list(deg_cent.values()))</span><br><span class="line"></span><br><span class="line">    nodes = set()</span><br><span class="line"></span><br><span class="line">    # Iterate over the degree centrality dictionary</span><br><span class="line">    for k, v in deg_cent.items():</span><br><span class="line"></span><br><span class="line">        # Check if the current value has the maximum degree centrality</span><br><span class="line">        if v == max_dc:</span><br><span class="line"></span><br><span class="line">            # Add the current node to the set of nodes</span><br><span class="line">            nodes.add(k)</span><br><span class="line"></span><br><span class="line">    return nodes</span><br><span class="line"></span><br><span class="line"># Find the node(s) that has the highest degree centrality in T: top_dc</span><br><span class="line">top_dc = find_nodes_with_highest_deg_cent(T)</span><br><span class="line">print(top_dc)</span><br><span class="line"></span><br><span class="line"># Write the assertion statement</span><br><span class="line">for node in top_dc:</span><br><span class="line">    assert nx.degree_centrality(T)[node] == max(nx.degree_centrality(T).values())</span><br></pre></td></tr></table></figure><h2 id="path-finding">Path finding</h2><p>path finding有很多的应用范围，比如两个车站之间最短路线的寻找，消息、病毒的传播，我们知道两个节点之间有很多种路线可以选择，那么要如何找到最短的这条路线呢？</p><p>一种解决方案是，使用Bread-first search算法，它的原理如下图：</p><p>我们从黄色的节点开始，第一次找黄色节点的邻居，并检查目标节点是否在当前节点的邻居中，如果不存在就继续搜寻下一层节点，找到为止。</p><p>我们首先定一个寻找节点之间路径的算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Define path_exists()</span><br><span class="line">def path_exists(G, node1, node2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function checks whether a path exists between two nodes (node1, node2) in graph G.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    visited_nodes = set()</span><br><span class="line"></span><br><span class="line">    # Initialize the queue of nodes to visit with the first node: queue</span><br><span class="line">    queue = [node1]</span><br><span class="line"></span><br><span class="line">    # Iterate over the nodes in the queue</span><br><span class="line">    for node in queue:</span><br><span class="line"></span><br><span class="line">        # Get neighbors of the node</span><br><span class="line">        neighbors = G.neighbors(node)</span><br><span class="line"></span><br><span class="line">        # Check to see if the destination node is in the set of neighbors</span><br><span class="line">        if node2 in neighbors:</span><br><span class="line">            print(&#x27;Path exists between nodes &#123;0&#125; and &#123;1&#125;&#x27;.format(node1, node2))</span><br><span class="line">            return True</span><br><span class="line">            break</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个算法会确定两个节点之间是否存在路径，仔细查看上面的代码，如果两个节点直接存在路径，该函数就返回true，如果不存在呢？不存在我们则需要对剩下的节点进一步的搜寻，让我们把剩下的代码补全：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def path_exists(G, node1, node2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function checks whether a path exists between two nodes (node1, node2) in graph G.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    visited_nodes = set()</span><br><span class="line">    queue = [node1]</span><br><span class="line"></span><br><span class="line">    for node in queue:</span><br><span class="line">        neighbors = G.neighbors(node)</span><br><span class="line">        if node2 in neighbors:</span><br><span class="line">            print(&#x27;Path exists between nodes &#123;0&#125; and &#123;1&#125;&#x27;.format(node1, node2))</span><br><span class="line">            return True</span><br><span class="line">          </span><br><span class="line">        else:</span><br><span class="line">            # Add current node to visited nodes</span><br><span class="line">            visited_nodes.add(node)</span><br><span class="line"></span><br><span class="line">            # Add neighbors of current node that have not yet been visited</span><br><span class="line">            queue.extend([n for n in neighbors if n not in visited_nodes])</span><br></pre></td></tr></table></figure><p>如果函数中的queue已经空了，也就是找完了了都没找到路径，那我们也要返回结果：即这两个节点之间没有路径存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def path_exists(G, node1, node2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function checks whether a path exists between two nodes (node1, node2) in graph G.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    visited_nodes = set()</span><br><span class="line">    queue = [node1]</span><br><span class="line"></span><br><span class="line">    for node in queue:</span><br><span class="line">        neighbors = G.neighbors(node)</span><br><span class="line">        if node2 in neighbors:</span><br><span class="line">            print(&#x27;Path exists between nodes &#123;0&#125; and &#123;1&#125;&#x27;.format(node1, node2))</span><br><span class="line">            return True</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            visited_nodes.add(node)</span><br><span class="line">            queue.extend([n for n in neighbors if n not in visited_nodes])</span><br><span class="line"></span><br><span class="line">        # Check to see if the final element of the queue has been reached</span><br><span class="line">        if node == queue[-1]:</span><br><span class="line">            print(&#x27;Path does not exist between nodes &#123;0&#125; and &#123;1&#125;&#x27;.format(node1, node2))</span><br><span class="line"></span><br><span class="line">            # Place the appropriate return statement</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><h2 id="betweenness-centrality">Betweenness centrality</h2><p>Betweenness centrality这个概念与最短路径息息相关，上面我们已经定义了如何找到最短路径的算法，那么对于我们图中所有的节点对（两个节点），都有它们的最短路径，这些最短路径通过的节点中，哪些节点的通过数是最高的，则它的重要性就更高，这就是Betweenness centrality的意思，它的定义为：</p><p><span class="math display">\[\frac{num.\ shortest\ paths\ through\ node}{all\ possible\ shortest\ paths}\]</span></p><p>Betweenness centrality对于找到两个群体之间联系必须通过的那些实体很有帮助，比如那些帮助两个党派之间的联系的，充当桥梁作用的人，互联网中两个地区之间的网络流量交流，确定那些很重要的节点。</p><p>Betweenness centrality可以直接通过nx的方法计算得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bet_cen = nx.betweenness_centrality(T)</span><br></pre></td></tr></table></figure><h1 id="communities-cliques">Communities &amp; cliques</h1><p>cliques即我们所说的小团体、小集团，事实上这个说法就来源于我们的社交生活，在我们所说的小团体中，我们认识其他所有人，而cliques也是这样，每个一个节点都与其他的节点都有连接。</p><p>举例，一个最简单的cliques就是一个三角形，在Facebook的社交网络中，如果a认识b，b认识c，如果c也认识a，那么这就是一个三角形，但是如果不认识，我们就可以推荐他们认识，如何找到这些缺了一条联系就可以组成三角形的关系呢？</p><p>我们定义一个函数，它接受两个参数，G：一个网络，n一个节点，这个函数会确定n节点在G网络中，是否存在<strong>三角关系</strong>,即: node <code>n</code> in graph <code>G</code> is in a triangle relationship or not.</p><p>在我们的算法中，我们根据传入的网络，找到n的所有邻居，然后遍历其所有邻居对，如果其中有某一对存在edge关系，那么这就组成了一个三角关系（因为这两者已经是n的邻居，而这两者之间又有关系）</p><p>算法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from itertools import combinations</span><br><span class="line"></span><br><span class="line"># Define is_in_triangle()</span><br><span class="line">def is_in_triangle(G, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Checks whether a node `n` in graph `G` is in a triangle relationship or not.</span><br><span class="line"></span><br><span class="line">    Returns a boolean.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    in_triangle = False</span><br><span class="line"></span><br><span class="line">    # Iterate over all possible triangle relationship combinations</span><br><span class="line">    for n1, n2 in combinations(G.neighbors(n),2):</span><br><span class="line"></span><br><span class="line">        # Check if an edge exists between n1 and n2</span><br><span class="line">        if G.has_edge(n1,n2):</span><br><span class="line">            in_triangle = True</span><br><span class="line">            break</span><br><span class="line">    return in_triangle</span><br></pre></td></tr></table></figure><blockquote><p>combinations是一个遍历工具，用于组合节点的所有邻居对。</p></blockquote><p>我们修改一下，找出所有的三角关系:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from itertools import combinations</span><br><span class="line"></span><br><span class="line"># Write a function that identifies all nodes in a triangle relationship with a given node.</span><br><span class="line">def nodes_in_triangle(G, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Returns the nodes in a graph `G` that are involved in a triangle relationship with the node `n`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    triangle_nodes = set([n])</span><br><span class="line"></span><br><span class="line">    # Iterate over all possible triangle relationship combinations</span><br><span class="line">    for n1, n2 in combinations(G.neighbors(n),2):</span><br><span class="line"></span><br><span class="line">        # Check if n1 and n2 have an edge between them</span><br><span class="line">        if G.has_edge(n1,n2):</span><br><span class="line"></span><br><span class="line">            # Add n1 to triangle_nodes</span><br><span class="line">            triangle_nodes.add(n1)</span><br><span class="line"></span><br><span class="line">            # Add n2 to triangle_nodes</span><br><span class="line">            triangle_nodes.add(n2)</span><br><span class="line"></span><br><span class="line">    return triangle_nodes</span><br><span class="line"></span><br><span class="line"># Write the assertion statement</span><br><span class="line">assert len(nodes_in_triangle(T, 1)) == 35</span><br></pre></td></tr></table></figure><p>如果你想要做一个好友推荐系统，那么你可能需要找出那些open triangle关系，即我们刚才提到的，a认识b，b认识c，而a并不认识c，让我们写一个找这种open triangle关系的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from itertools import combinations</span><br><span class="line"></span><br><span class="line"># Define node_in_open_triangle()</span><br><span class="line">def node_in_open_triangle(G, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Checks whether pairs of neighbors of node `n` in graph `G` are in an &#x27;open triangle&#x27; relationship with node `n`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    in_open_triangle = False</span><br><span class="line"></span><br><span class="line">    # Iterate over all possible triangle relationship combinations</span><br><span class="line">    for n1, n2 in combinations(G.neighbors(n),2):</span><br><span class="line"></span><br><span class="line">        # Check if n1 and n2 do NOT have an edge between them</span><br><span class="line">        if not G.has_edge(n1,n2):</span><br><span class="line"></span><br><span class="line">            in_open_triangle = True</span><br><span class="line"></span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><p>我们可以利用这个函数来查看一个图中，有多少个open triangle:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Compute the number of open triangles in T</span><br><span class="line">num_open_triangles = 0</span><br><span class="line"></span><br><span class="line"># Iterate over all the nodes in T</span><br><span class="line">for n in T.nodes():</span><br><span class="line"></span><br><span class="line">    # Check if the current node is in an open triangle</span><br><span class="line">    if node_in_open_triangle(T,n):</span><br><span class="line"></span><br><span class="line">        # Increment num_open_triangles</span><br><span class="line">        num_open_triangles += 1</span><br><span class="line"></span><br><span class="line">print(num_open_triangles)</span><br></pre></td></tr></table></figure><h2 id="maximal-cliques">Maximal cliques</h2><p>我们已经有了cliques的概念，maximal cliques的意思是，在一个团体中，我们增加一个node，如果整个图像中的节点还是彼此互相连接着的，那么这个cliques还是一个cliques，但如果我们增加node后，整个图像的节点不再是彼此连接着，那增加前的图像就是我们的maximal cliques.</p><p>nexworkx提供了一个<code>find_cliques</code>方法来寻找所有的cliques与Maximal cliques。</p><p>下面是对<code>find_cliques</code>方法的一个实践，我们定义了一个函数用来寻找一个图中拥有size数的max_cliques的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Define maximal_cliques()</span><br><span class="line">def maximal_cliques(G, size):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Finds all maximal cliques in graph `G` that are of size `size`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    mcs = []</span><br><span class="line">    for clique in nx.find_cliques(G):</span><br><span class="line">        if len(clique) == size:</span><br><span class="line">            mcs.append(clique)</span><br><span class="line">    return mcs</span><br><span class="line"></span><br><span class="line"># Check that there are 33 maximal cliques of size 3 in the graph T</span><br><span class="line">assert len(maximal_cliques(T, 3)) == 33</span><br></pre></td></tr></table></figure><h2 id="subgraphs">Subgraphs</h2><p>Subgraphs即子图的意思，对于一个图，我们需要对一些感兴趣的信息突出展示，这时候就需要用到子图。</p><p>下面是绘制子图的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 导入包</span><br><span class="line">In [1]: import networkx as nx</span><br><span class="line"># 创建图</span><br><span class="line">In [2]: G = nx.erdos_renyi_graph(n=20, p=0.2)</span><br><span class="line"># 查看节点</span><br><span class="line">In [3]: G.nodes()</span><br><span class="line">Out[3]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,</span><br><span class="line">17, 18, 19]</span><br><span class="line"></span><br><span class="line"># 将上面图中的节点8复制给nodes</span><br><span class="line">In [4]: nodes = G.neighbors(8)</span><br><span class="line">In [5]: nodes</span><br><span class="line">Out[5]: [2, 3, 4, 10]</span><br><span class="line">In [6]: nodes.append(8)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 将子图添加到G</span><br><span class="line">In [7]: G_eight = G.subgraph(nodes)</span><br><span class="line"></span><br><span class="line"># 查看G_eight的edges</span><br><span class="line">In [8]: G_eight.edges()</span><br><span class="line">Out[8]: [(8, 2), (8, 3), (8, 4), (8, 10), (2, 10)]</span><br><span class="line">In [9]: G_eight</span><br><span class="line">Out[9]: &lt;networkx.classes.graph.Graph at 0x10cae39e8&gt;</span><br><span class="line">In [10]: G</span><br><span class="line">Out[10]: &lt;networkx.classes.graph.Graph at 0x10cad1f60&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://i.loli.net/2019/12/04/JzZorRNK7sd95X1.png" /></p><p>因为绘制子图的操作经常要用到，我们可以写一个函数来简化这个步骤，这个函数接受一个图与节点数组（即感兴趣的节点）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Define get_nodes_and_nbrs()</span><br><span class="line">def get_nodes_and_nbrs(G, nodes_of_interest):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Returns a subgraph of the graph `G` with only the `nodes_of_interest` and their neighbors.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nodes_to_draw = []</span><br><span class="line"></span><br><span class="line">    # Iterate over the nodes of interest</span><br><span class="line">    for n in nodes_of_interest:</span><br><span class="line"></span><br><span class="line">        # Append the nodes of interest to nodes_to_draw</span><br><span class="line">        nodes_to_draw.append(n)</span><br><span class="line"></span><br><span class="line">        # Iterate over all the neighbors of node n</span><br><span class="line">        for nbr in G.neighbors(n):</span><br><span class="line"></span><br><span class="line">            # Append the neighbors of n to nodes_to_draw</span><br><span class="line">            nodes_to_draw.append(nbr)</span><br><span class="line"></span><br><span class="line">    return G.subgraph(nodes_to_draw)</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nodes_of_interest = [29, 38, 42]</span><br><span class="line"></span><br><span class="line"># Extract the subgraph with the nodes of interest: T_draw</span><br><span class="line">T_draw = get_nodes_and_nbrs(T,nodes_of_interest)</span><br><span class="line"></span><br><span class="line"># Draw the subgraph to the screen</span><br><span class="line">nx.draw(T_draw)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/04/JqXiLphy4bBcFaZ.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/04/b8mhdtkcqeSiwEg.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天我们学习神经网络与nexworkX.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
    <category term="data analysis" scheme="http://wittyfans.com/tags/data-analysis/"/>
    
    <category term="nexworkX" scheme="http://wittyfans.com/tags/nexworkX/"/>
    
  </entry>
  
  <entry>
    <title>机器学习：泛化误差与随机森林</title>
    <link href="http://wittyfans.com/article/2942468479.html"/>
    <id>http://wittyfans.com/article/2942468479.html</id>
    <published>2019-11-24T13:03:54.000Z</published>
    <updated>2021-11-19T14:12:08.913Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/11/24/xpv9ZiqB734oNAO.png" /></p><blockquote><p>这一篇文章我们来了解误差，如何处理误差，以及学习随机森林的基础知识。</p></blockquote><span id="more"></span><p>机器学习：泛化误差与随机森林</p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="泛化误差-generalization-error">泛化误差 (Generalization Error)</h1><h2 id="介绍">介绍</h2><p>我们知道在监督学习的线性模型中，我们数据分布符合下面的函数，即:</p><p><span class="math display">\[y=f(x)\]</span></p><p>其中，y和x是已知的，而 <em>f</em> 是未知的。</p><p>同时在我们的数据分布中，数据集不可能完全按照我们的函数分布，总是有些点（噪音）事覆盖在我们的函数周边：</p><p><img src="https://i.loli.net/2019/11/22/V1xpq4uPFtJl6XM.png" /></p><p>当你训练你的模型的时候，你希望这些噪音尽可能的去除，同时预测的结果尽可能少出错。</p><p>为了实现这个目标，你会遇到两个难题，即过度拟合与欠拟合。</p><p>过度拟合即我们的模型过于敏感，欠拟合即模型过于迟钝，如下面两张图图所示：</p><figure><img src="https://i.loli.net/2019/11/22/JzMd6FZbENkY23s.png" alt="过度拟合-Overfitting" /><figcaption aria-hidden="true">过度拟合-Overfitting</figcaption></figure><figure><img src="https://i.loli.net/2019/11/22/1mp6JLoCWhESyKG.png" alt="欠拟合-Underfitting" /><figcaption aria-hidden="true">欠拟合-Underfitting</figcaption></figure><p>什么是泛化误差呢？这是一种衡量我们模型与数据分布之间误差，对于一个模型的泛化误差，即它对于新的数据的预测中的误差，由三个部分组成：</p><p><span class="math display">\[\hat{f}=bias^2+variance+irreducible\ error\]</span></p><p>先看第一个参数，bias。</p><p>下面是一组老鼠的体重与体长的分布数据，我们把它分割成train组与test组，我们在train组中训练我们的模型得到一条直线，可以看到数据集的分布是一条曲线，而当我们的数据集分布是一个曲线的时候，我们用一条直线是无法完整的描述数据集的分布的，无论我们怎么调整这根直线，这种情况就叫做bias:</p><p><img src="https://i.loli.net/2019/11/24/VocITXg4FG23kWY.png" /></p><p>另外，我们模型也可能是生成一条曲线，而这条曲线完美的穿过了我们的train数据集：</p><p><img src="https://i.loli.net/2019/11/24/TvAPh3HNk2uOE1o.png" /></p><p>当我们用最小二乘法去衡量模型的好坏时，无疑第二个模型是最完美的，它与每个点的的距离都是0。</p><p>但是，当我们该曲线与test组的数据放到一起时，情况可能就不一样了，这就引出了variance的定义：</p><p><img src="https://i.loli.net/2019/11/24/1qIShcuvRgAj5zr.png" /></p><p><img src="https://i.loli.net/2019/11/24/AF2SmliXMGOZtHo.png" /></p><p><img src="https://i.loli.net/2019/11/24/eKsd9pgExNOlLmB.png" /></p><p>现在知道了bias以及variance，我们就知道如何去优化模型了， 我们需要均衡设置这三个参数，让他们各自都在一个最合适的位置：</p><p><img src="https://i.loli.net/2019/11/22/JTEIruvo58VG6Mn.png" /></p><h2 id="处理误差">处理误差</h2><p>我们尽可能的使这些误差最小，但这并不容易，首先 <em>f</em> 函数我们不知道，你只有一对数据，并且噪声事无法避免的。</p><p>怎么办呢？还是按照以前的方法，将数据分为train组和test组，而且我们需要使用之前介绍过的 <em>cross-validation</em> 技术，CV。</p><p>CV有两种：</p><ul><li>K-Fold CV</li><li>Hold-Out CV</li></ul><p>在这里，我们只介绍K-Fold CV, Cross-validation技术我们之前已经有过介绍，可以查看之前的文章了解详情。</p><p>在我们对数据进行fold的时，每一次fold都可以算出一次error，随后再算总的fold error平均，我们来看一个10fold的公式，其中E为每一次fold的error：</p><p><span class="math display">\[CV_{error}=\frac{E_1+...+E_{10}}{10}\]</span></p><p><img src="https://i.loli.net/2019/11/24/J1u4OSiMqdWrwIa.png" /></p><p>如果我们CV后的方差比train组的值要高，那就说明我们我们过度拟合了，在tree model上来看就是说我们无视了那些应该视为leaf的节点，而将其继续拆分了。如果你发现过度拟合的情况，应该降低你的模型的复杂性，比如将模型的 <em>Max depth</em> 降低，收集更多的数据。</p><p>如果我们的bias过高，即CV后的bias值与train组的值近似或者大于它，这意味着欠拟合，则需要增加模型的复杂性，增加模型的 <em>Max depth</em>,增加更多的features。</p><h2 id="ensemble-learning">Ensemble Learning</h2><p>回归一下CARTs的优点：</p><ol type="1"><li>易于理解</li><li>容易使用</li><li>可以描述线性回归无法描述的情况</li><li>不需要标准化数据</li></ol><p>但CARTs也有缺点，那就是容易高方差，过度拟合，不过我们可以通过 ensemble learning 解决这个问题。</p><p>简单描述一下Ensemble Learning的步骤：</p><ol type="1"><li>用不同的模型training同一份数据</li><li>每个模型预测其自己的结果</li><li>聚合所有模型的结果</li><li>最终的预测：更可靠的数据</li></ol><p><strong>Ensemble prediction:</strong></p><p><img src="https://i.loli.net/2019/11/24/UxRoDOCBf3ZsvKP.png" /></p><p>我们考虑一个Ensemble prediction的例子，叫做voting classifier，假设我们有i个预测器对同一组数据进行预测，产生i个结果叫做p1,p2,pi，结果只有两种，0或者1，i个结果都预测出来之后，我用投票的方式来觉得使用哪个结果，比如下面的图中，有两个预测器的结果是1，那么我们的结果就是1.</p><p><img src="https://i.loli.net/2019/11/24/aZ1oXrnkP39HphQ.png" /></p><p><strong>Ensemble Learning code:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Set seed for reproducibility</span><br><span class="line">SEED=1</span><br><span class="line"></span><br><span class="line"># Instantiate lr</span><br><span class="line">lr = LogisticRegression(random_state=SEED)</span><br><span class="line"></span><br><span class="line"># Instantiate knn</span><br><span class="line">knn = KNN(n_neighbors=27)</span><br><span class="line"></span><br><span class="line"># Instantiate dt</span><br><span class="line">dt = DecisionTreeClassifier(min_samples_leaf=0.13, random_state=SEED)</span><br><span class="line"></span><br><span class="line"># Define the list classifiers</span><br><span class="line">classifiers = [(&#x27;Logistic Regression&#x27;, lr), (&#x27;K Nearest Neighbours&#x27;, knn), (&#x27;Classification Tree&#x27;, dt)]</span><br><span class="line"></span><br><span class="line"># Iterate over the pre-defined list of classifiers</span><br><span class="line">for clf_name, clf in classifiers:    </span><br><span class="line"> </span><br><span class="line">    # Fit clf to the training set</span><br><span class="line">    clf.fit(X_train, y_train)    </span><br><span class="line">   </span><br><span class="line">    # Predict y_pred</span><br><span class="line">    y_pred = clf.predict(X_test)</span><br><span class="line">    </span><br><span class="line">    # Calculate accuracy</span><br><span class="line">    accuracy = accuracy_score(y_test,y_pred) </span><br><span class="line">   </span><br><span class="line">    # Evaluate clf&#x27;s accuracy on the test set</span><br><span class="line">    print(&#x27;&#123;:s&#125; : &#123;:.3f&#125;&#x27;.format(clf_name, accuracy))</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>Voting:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Import VotingClassifier from sklearn.ensemble</span><br><span class="line">from sklearn.ensemble import VotingClassifier</span><br><span class="line"></span><br><span class="line"># Instantiate a VotingClassifier vc</span><br><span class="line">vc = VotingClassifier(estimators=classifiers)     </span><br><span class="line"></span><br><span class="line"># Fit vc to the training set</span><br><span class="line">vc.fit(X_train, y_train)   </span><br><span class="line"></span><br><span class="line"># Evaluate the test set predictions</span><br><span class="line">y_pred = vc.predict(X_test)</span><br><span class="line"></span><br><span class="line"># Calculate accuracy score</span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line">print(&#x27;Voting Classifier: &#123;:.3f&#125;&#x27;.format(accuracy))</span><br></pre></td></tr></table></figure><h1 id="bagging">Bagging</h1><p><em>‌Ensemble Learning</em> 中，我们使用不同的算法对同一组数据进行处理再投票出结果，而 <em>Bagging</em> 正好相反，它用同一个算法，选取数据集中的不同组数据，计算结果，Bagging可以减少Variance。它和我们之前提及的 <em>Bootstrap</em> 方法类似。</p><figure><img src="https://i.loli.net/2019/11/24/F2YAbs6IBEJQmik.png" alt="Bootstrap" /><figcaption aria-hidden="true">Bootstrap</figcaption></figure><p><img src="https://i.loli.net/2019/11/24/4wjQF79uSWYsxUg.png" /></p><p>bagging不同model的结果，也是通过voting的出来的：</p><p><img src="https://i.loli.net/2019/11/24/DIGNp2niJ9xFjwa.png" /></p><p>对于分类问题，结果通过major voting 获得，对于regression问题，结果通过平均结果获得。</p><p><strong>Bagging python code:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Import DecisionTreeClassifier</span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"># Import BaggingClassifier</span><br><span class="line">from sklearn.ensemble import BaggingClassifier</span><br><span class="line"></span><br><span class="line"># Instantiate dt</span><br><span class="line">dt = DecisionTreeClassifier(random_state=1)</span><br><span class="line"></span><br><span class="line"># Instantiate bc</span><br><span class="line">bc = BaggingClassifier(base_estimator=dt, n_estimators=50,random_state=1)</span><br></pre></td></tr></table></figure><p><strong>Bagging performance:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Fit bc to the training set</span><br><span class="line">bc.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"># Predict test set labels</span><br><span class="line">y_pred = bc.predict(X_test)</span><br><span class="line"></span><br><span class="line"># Evaluate acc_test</span><br><span class="line">acc_test = accuracy_score(y_test,y_pred)</span><br><span class="line">print(&#x27;Test set accuracy of bc: &#123;:.2f&#125;&#x27;.format(acc_test)) </span><br></pre></td></tr></table></figure><p>在 <strong>bagging</strong> 中，那些我们分割出来的test数据没有参与模型训练，这些模型没有见过的数据叫做 <em>out of bag</em>(OOB)，我们可以在每一次模型sample数据的时候，将这些数据分割为train和test数据组，如下图所示：</p><p><img src="https://i.loli.net/2019/11/24/jcvZGonAzmar6yt.png" /></p><h1 id="随机森林">随机森林</h1><p>随机森林也是一种基于决策树的算法，假设我们有一组心脏病数据，根据它来创建随机森林。</p><p>首先我们根据原始数据创建bootstrap dataset,即随机的（可重复）从原数据选择：</p><p><img src="https://i.loli.net/2019/11/24/j3YVgtX1v45TnGu.png" /></p><p>拿到随机创建的数据之后，我们随机的选择n个（这里暂时定为2个）feature，建立决策树，如何确定第一个树呢？可以根据gini算法，这里我们假设Good Blood最适合作为root节点，第一个树确定以后，我们可以再从剩下的树中随机的选择两棵树作为其他节点，示例图如下：</p><p><img src="https://i.loli.net/2019/11/24/B7c4ygI2wZ8UHWe.png" /></p><p><img src="https://i.loli.net/2019/11/24/ChGPzE321nA5BdR.png" /></p><blockquote><p>从剩下的树中选的时候，我们需要根据feature来选，根据哪些features来选， 以及多少features，都是需要提前定好的，在这里我们定为2。在sklearn中，是features的平方根，即如果我们有100个features，则每次用10个。</p></blockquote><p>于是我们得到了一颗树，现在重复上述步骤，创建bootstrap数据，再建立树，这样我们可以重复很多次，于是随机森林就建立起来了。</p><p><img src="https://i.loli.net/2019/11/24/xpv9ZiqB734oNAO.png" /></p><p>随机森林建立好后，就可以开始预测，对于分类问题，我们使用投票机制决定输出，对于regresion问题，我们还是一样采用平均值。</p><p><strong>随机森林python code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Import RandomForestRegressor</span><br><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line"></span><br><span class="line"># Instantiate rf</span><br><span class="line">rf = RandomForestRegressor(n_estimators=25,</span><br><span class="line">            random_state=2)</span><br><span class="line">            </span><br><span class="line"># Fit rf to the training set    </span><br><span class="line">rf.fit(X_train, y_train) </span><br><span class="line"></span><br><span class="line"># Import mean_squared_error as MSE</span><br><span class="line">from sklearn.metrics import mean_squared_error as MSE</span><br><span class="line"></span><br><span class="line"># Predict the test set labels</span><br><span class="line">y_pred = rf.predict(X_test)</span><br><span class="line"></span><br><span class="line"># Evaluate the test set RMSE</span><br><span class="line">rmse_test = MSE(y_test, y_pred)**(1/2)</span><br><span class="line"></span><br><span class="line"># Print rmse_test</span><br><span class="line">print(&#x27;Test set RMSE of rf: &#123;:.2f&#125;&#x27;.format(rmse_test))</span><br></pre></td></tr></table></figure><p><strong>查看feature权重：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Create a pd.Series of features importances</span><br><span class="line">importances = pd.Series(data=rf.feature_importances_,</span><br><span class="line">                        index= X_train.columns)</span><br><span class="line"></span><br><span class="line"># Sort importances</span><br><span class="line">importances_sorted = importances.sort_values()</span><br><span class="line"></span><br><span class="line"># Draw a horizontal barplot of importances_sorted</span><br><span class="line">importances_sorted.plot(kind=&#x27;barh&#x27;, color=&#x27;lightgreen&#x27;)</span><br><span class="line">plt.title(&#x27;Features Importances&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/24/xpv9ZiqB734oNAO.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这一篇文章我们来了解误差，如何处理误差，以及学习随机森林的基础知识。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
    <category term="data analysis" scheme="http://wittyfans.com/tags/data-analysis/"/>
    
    <category term="sklearn" scheme="http://wittyfans.com/tags/sklearn/"/>
    
    <category term="data science" scheme="http://wittyfans.com/tags/data-science/"/>
    
  </entry>
  
  <entry>
    <title>机器学习：Classification and Regression Trees</title>
    <link href="http://wittyfans.com/article/1854275205.html"/>
    <id>http://wittyfans.com/article/1854275205.html</id>
    <published>2019-11-22T08:06:42.000Z</published>
    <updated>2021-11-19T14:12:08.912Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/11/22/poSKWwveBCuU16n.png" /></p><blockquote><p>机器学习决策树的第一部分，分类与回归树（CART）的原理（多图)。</p></blockquote><span id="more"></span><h1 id="介绍">介绍</h1><p>为什么使用决策树呢，主要有两个原因，一是决策树通常模仿人类的思维，因此它很容易理解数据并做出一些很好的解释。二是决策树可以让你看到数据的逻辑。</p><p>我们看一个金融机构决定是否投资一家公司决策树：</p><p><img src="https://i.loli.net/2019/11/22/xqRKiL3Qa2Cr4UI.png" /></p><p>从决策树的组成来看，它是由一系列节点（nodes）的继承关系组成的，节点可以看作是对问题做出回答，也可以是问题的答案。这些问题有些依据数据的分类，如你是否吸烟，有的是数据本身你一天吸几根，（数值型），决策树中主要有三类节点：</p><ol type="1"><li>Root, root节点没有父节点，有两个子节点</li><li>Internal root, 一个父节点，两个子节点</li><li>Leaf, 一个父节点，没有子节点</li></ol><p>每一个internal root代表一个“test” on an attribute，即在这个节点根据这个属性做出的判断，每一个分支则代表了判断的输出，每一个leaf代表了一个class label，即最后的决定。</p><p>下面是一些决策树中的常见名词：</p><ol type="1"><li>Root Node: It represents entire population or sample and this further gets divided into two or more homogeneous sets.</li><li>Splitting: It is a process of dividing a node into two or more sub-nodes.</li><li>Decision Node: When a sub-node splits into further sub-nodes, then it is called decision node.</li><li>Leaf/ Terminal Node: Nodes do not split is called Leaf or Terminal node.</li><li>Pruning: When we remove sub-nodes of a decision node, this process is called pruning. You can say opposite process of splitting.</li><li>Branch / Sub-Tree: A sub section of entire tree is called branch or sub-tree.</li><li>Parent and Child Node: A node, which is divided into sub-nodes is called parent node of sub-nodes whereas sub-nodes are the child of parent node.</li></ol><h1 id="决策树如何学习">决策树如何学习</h1><p>要建立决策树，就得对数据进行分类，第一个节点即根节点的分类范围是最大的，它把所有的问题分成两类。</p><p>如何找到这个分类呢？这取决于那些最能对数据集进行分类的属性，怎么确定哪些分类最能对数据进行分类呢？</p><p>看下面一个心脏病的例子，我们把每一个分类的都单独拿出来，计算分别统计它相对结果的预测量，如下图：</p><p><img src="https://i.loli.net/2019/11/22/XrWPkLu2aAMoGfT.png" /></p><p>有没有心脏病是我们的leaf，也就是结果输出，而胸痛是feature。我们统计胸痛的值与现有的心脏病的值的对应关系，如果胸痛，是否是心脏病？如果胸不痛，是否是心脏病？这样我们就得到四列数据，结束对胸痛这个feature的统计后，继续对Good Blood进行同样的操作。</p><p><img src="https://i.loli.net/2019/11/22/cFErmQLRdjSGANk.png" /></p><p>可以看到这个结果中，不管是胸痛，还是血液情况，都没办法在yes与no后就准确预测心脏病，所以上面的这些数据都是impurity的，那我们如何衡量这种impurity的程度呢？</p><p>有很多衡量 impurity 的方法，其中一种叫做Gini, 下面是Gini的计算方式：</p><p><img src="https://i.loli.net/2019/11/22/bNtKIPiq3QS7uXF.png" /></p><p>同样的方法计算右边的节点:</p><p><img src="https://i.loli.net/2019/11/22/VosX56SFIqnPd1k.png" /></p><p>但是左右两边的患者数量是不一样的，一个是144,一个是159:</p><p><img src="https://i.loli.net/2019/11/22/R8wpJ6X7HPgmrlI.png" /></p><p>我们需要对左右节点都平均一下再相加：</p><p><img src="https://i.loli.net/2019/11/22/ujM8EtbcvxDTmK5.png" /></p><p>再把所有的feature都算一遍，</p><p><img src="https://i.loli.net/2019/11/22/oKLqZMGXEfDTxd2.png" /></p><p>我们选择gini数最低的那个一，作为root node</p><p><img src="https://i.loli.net/2019/11/22/c29ySGZYRu3rdpT.png" /> <img src="https://i.loli.net/2019/11/22/LqWxzZajrP4QnDC.png" /></p><p>root node确定了之后，我们还需要确定后续的节点使用哪个feature，这个步骤和前面确定root node是一样的：</p><p><img src="https://i.loli.net/2019/11/22/Rg865Yih9Xo3BDE.png" /></p><p>进一步往下面确定子节点的时候，我们发现，在动脉阻塞(blocked)的两个子节点下， 没有发生动脉阻塞这个节点中，只有13个患有心脏病，也就是说89%的患者都没有心脏病！</p><p><img src="https://i.loli.net/2019/11/22/poSKWwveBCuU16n.png" /></p><p>我们来算一下这个节点的gini值与进一步按照胸痛往下面细分后的gini值：</p><p><img src="https://i.loli.net/2019/11/22/6cGaSCwIEmQPXsq.png" /></p><p>可以看到按照胸痛细分后的gini值为0.29，而不细分的值则为0.2，所以对于这个节点来说，就没有必要再往下面细分节点了，所以我们就不处理 <code>13/102</code> 这个节点了，它也就成了我们说的 leaf 节点。</p><p>将剩下的部分以及右边的子节点补上，我们的决策树就建好了:</p><p><img src="https://i.loli.net/2019/11/22/EP5aXncFzWkSysY.png" /></p><p>不过还有一个问题，我们前面都是基于yes or no的问题，那如果遇到数值型的数据怎么办？</p><p>首先，我们将数值数据从小到大排列：</p><p><img src="https://i.loli.net/2019/11/22/XP1On7DCsAFzxya.png" /></p><p>两两取数值中间的平均值，计算gini值：</p><p><img src="https://i.loli.net/2019/11/22/CJgeWPEai8zuvdt.png" /></p><p><img src="https://i.loli.net/2019/11/22/fDPcg3Ts2WjLrAR.png" /></p><p><img src="https://i.loli.net/2019/11/22/pfD1JGA5UICPlhb.png" /></p><p>重复计算所有其他的gini值，最后选出最小的那个。</p><p><img src="https://i.loli.net/2019/11/22/Nowl8QfDPbpWRZO.png" /></p><p>这就是数值型数据的计算了。不过还有一些数据它是选择型的，如颜色的选择，对于颜色的选择，我们可以把选择分开来计算，如下图：</p><p><img src="https://i.loli.net/2019/11/22/UJevq6O9CKyR1wk.png" /></p><blockquote><p>关于决策数的<a href="https://www.youtube.com/watch?v=7VeUPuFGJHk">视频</a></p></blockquote><p>上面的这个gini值，我们又叫做IG(Information Gain)值，我们知道，如果IG值为0，或者我们发现该node分割后gini值更高，我们就不继续分割，该node就叫做leaf。如果我们固定了一颗数的深度，那么当分割node的时候，超过了规定的深度，我们也会停止分割子节点。</p><p>另外，拆分内部节点总是涉及最大化信息增益！</p><h1 id="使用决策树">使用决策树</h1><p>决策树可以解决classfication问题，也可以解决regression问题，我们先讨论分类树。</p><p>训练决策树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Import DecisionTreeClassifier from sklearn.tree</span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"># Instantiate a DecisionTreeClassifier &#x27;dt&#x27; with a maximum depth of 6</span><br><span class="line">dt = DecisionTreeClassifier(max_depth=6,random_state=SEED)</span><br><span class="line"></span><br><span class="line"># Fit dt to the training set</span><br><span class="line">dt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"># Predict test set labels</span><br><span class="line">y_pred = dt.predict(X_test)</span><br><span class="line">print(y_pred[0:5])</span><br></pre></td></tr></table></figure><p>决策树评分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Import accuracy_score</span><br><span class="line">from sklearn.metrics import accuracy_score</span><br><span class="line"></span><br><span class="line"># Predict test set labels</span><br><span class="line">y_pred = dt.predict(X_test)</span><br><span class="line"></span><br><span class="line"># Compute test set accuracy  </span><br><span class="line">acc = accuracy_score(y_pred, y_test)</span><br><span class="line">print(&quot;Test set accuracy: &#123;:.2f&#125;&quot;.format(acc))</span><br></pre></td></tr></table></figure><p>逻辑回归与分类树:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Import LogisticRegression from sklearn.linear_model</span><br><span class="line">from sklearn.linear_model import  LogisticRegression</span><br><span class="line"></span><br><span class="line"># Instatiate logreg</span><br><span class="line">logreg = LogisticRegression(random_state=1)</span><br><span class="line"></span><br><span class="line"># Fit logreg to the training set</span><br><span class="line">logreg.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"># Define a list called clfs containing the two classifiers logreg and dt</span><br><span class="line">clfs = [logreg, dt]</span><br><span class="line"></span><br><span class="line"># Review the decision regions of the two classifiers</span><br><span class="line">plot_labeled_decision_regions(X_test, y_test, clfs)</span><br></pre></td></tr></table></figure><h2 id="分类树">分类树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Import DecisionTreeClassifier from sklearn.tree</span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"># Instantiate dt_entropy, set &#x27;entropy&#x27; as the information criterion</span><br><span class="line">dt_entropy = DecisionTreeClassifier(max_depth=8, criterion=&#x27;entropy&#x27;, random_state=1)</span><br><span class="line"></span><br><span class="line"># Fit dt_entropy to the training set</span><br><span class="line">dt_entropy.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"># Import accuracy_score from sklearn.metrics</span><br><span class="line">from sklearn.metrics import accuracy_score</span><br><span class="line"></span><br><span class="line"># Use dt_entropy to predict test set labels</span><br><span class="line">y_pred = dt_entropy.predict(X_test)</span><br><span class="line"></span><br><span class="line"># Evaluate accuracy_entropy</span><br><span class="line">accuracy_entropy = accuracy_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"># Print accuracy_entropy</span><br><span class="line">print(&#x27;Accuracy achieved by using entropy: &#x27;, accuracy_entropy)</span><br><span class="line"></span><br><span class="line"># Print accuracy_gini</span><br><span class="line">print(&#x27;Accuracy achieved by using the gini index: &#x27;, accuracy_gini)</span><br></pre></td></tr></table></figure><h2 id="回归树">回归树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Import DecisionTreeRegressor from sklearn.tree</span><br><span class="line">from sklearn.tree import DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line"># Instantiate dt</span><br><span class="line">dt = DecisionTreeRegressor(max_depth=8,</span><br><span class="line">             min_samples_leaf=0.13,</span><br><span class="line">            random_state=3)</span><br><span class="line"></span><br><span class="line"># Fit dt to the training set</span><br><span class="line">dt.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><h3 id="衡量回归树">衡量回归树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Import mean_squared_error from sklearn.metrics as MSE</span><br><span class="line">from sklearn.metrics import mean_squared_error as MSE</span><br><span class="line"></span><br><span class="line"># Compute y_pred</span><br><span class="line">y_pred = dt.predict(X_test)</span><br><span class="line"></span><br><span class="line"># Compute mse_dt</span><br><span class="line">mse_dt = MSE(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"># Compute rmse_dt</span><br><span class="line">rmse_dt = mse_dt**(1/2)</span><br><span class="line"></span><br><span class="line"># Print rmse_dt</span><br><span class="line">print(&quot;Test set RMSE of dt: &#123;:.2f&#125;&quot;.format(rmse_dt))</span><br></pre></td></tr></table></figure><h2 id="linear-regression-vs-regression-tree">Linear regression vs regression tree</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Predict test set labels </span><br><span class="line">y_pred_lr = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"># Compute mse_lr</span><br><span class="line">mse_lr = MSE(y_test, y_pred_lr)</span><br><span class="line"></span><br><span class="line"># Compute rmse_lr</span><br><span class="line">rmse_lr = mse_lr**(1/2)</span><br><span class="line"></span><br><span class="line"># Print rmse_lr</span><br><span class="line">print(&#x27;Linear Regression test set RMSE: &#123;:.2f&#125;&#x27;.format(rmse_lr))</span><br><span class="line"></span><br><span class="line"># Print rmse_dt</span><br><span class="line">print(&#x27;Regression Tree test set RMSE: &#123;:.2f&#125;&#x27;.format(rmse_dt))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/22/poSKWwveBCuU16n.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;机器学习决策树的第一部分，分类与回归树（CART）的原理（多图)。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
    <category term="data analysis" scheme="http://wittyfans.com/tags/data-analysis/"/>
    
    <category term="sklearn" scheme="http://wittyfans.com/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>非监督学习：PCA and NMF</title>
    <link href="http://wittyfans.com/article/1777482023.html"/>
    <id>http://wittyfans.com/article/1777482023.html</id>
    <published>2019-11-21T08:20:37.000Z</published>
    <updated>2021-11-19T14:12:08.914Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/11/21/I34aLMFuywnHqzA.png" /></p><blockquote><p>非监督学习的最后两章，我们会学习 Dimension reduction, Dimension reduction就是从数据中发现一定的模式，通过这种模式我们就可以对数据进行压缩，这对于计算和存储来说都是非常有利的，特别是在大数据时代。</p></blockquote><span id="more"></span><p>dimension reduction核心的功能是去除数据中的噪音，保留那些最基本的东西，噪音去除之后，有助于减少我们处理 classfication 与 regression 中碰到的问题。</p><p>接下来我们介绍最基本的 dimension reduction 算法，<em>Principal Component Analysis</em> (PCA).</p><h1 id="pca">PCA</h1><p>PCA 主要有两个步骤：</p><ol type="1"><li>decorrlation</li><li>dimension reduction</li></ol><p>我们先讲第一个步骤，decorrlation, decorrlation会将数据旋转到与坐标轴对齐，并将其均值移动到0附近，所以PCA并不会改变原始数据。</p><p><img src="https://i.loli.net/2019/11/20/qolJbVCpOUg5PBY.png" /></p><p>PCA和 StandardScaler 一样，有fit和transform方法，fit方法会学习如何去shift与rotate数据，但并不会做出任何操作。</p><p>transform方法，则会应用fit学习到的东西。</p><p>在PCA对数据transform后，原来数据的columns对应数据的features，转换后的数据列则对应pca的features。</p><p>我们用皮尔逊系数来衡量相关性，如果原来的数据是有相关性的，则转化后的数据不会再具备这种特性。</p><p>以我们的谷物的长、宽数据为例，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Perform the necessary imports</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from scipy.stats import pearsonr</span><br><span class="line"></span><br><span class="line"># Assign the 0th column of grains: width</span><br><span class="line">width = grains[:,0]</span><br><span class="line"></span><br><span class="line"># Assign the 1st column of grains: length</span><br><span class="line">length = grains[:,1]</span><br><span class="line"></span><br><span class="line"># Scatter plot width vs length</span><br><span class="line">plt.scatter(width, length)</span><br><span class="line">plt.axis(&#x27;equal&#x27;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># Calculate the Pearson correlation</span><br><span class="line">correlation, pvalue = pearsonr(width,length)</span><br><span class="line"></span><br><span class="line"># Display the correlation</span><br><span class="line">print(correlation)</span><br></pre></td></tr></table></figure><figure><img src="https://i.loli.net/2019/11/20/XuxqSG6vWB7Ddlf.png" alt="transform前" /><figcaption aria-hidden="true">transform前</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Import PCA</span><br><span class="line">from sklearn.decomposition import PCA</span><br><span class="line"></span><br><span class="line"># Create PCA instance: model</span><br><span class="line">model = PCA()</span><br><span class="line"></span><br><span class="line"># Apply the fit_transform method of model to grains: pca_features</span><br><span class="line">pca_features = model.fit_transform(grains)</span><br><span class="line"></span><br><span class="line"># Assign 0th column of pca_features: xs</span><br><span class="line">xs = pca_features[:,0]</span><br><span class="line"></span><br><span class="line"># Assign 1st column of pca_features: ys</span><br><span class="line">ys = pca_features[:,1]</span><br><span class="line"></span><br><span class="line"># Scatter plot xs vs ys</span><br><span class="line">plt.scatter(xs, ys)</span><br><span class="line">plt.axis(&#x27;equal&#x27;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># Calculate the Pearson correlation of xs and ys</span><br><span class="line">correlation, pvalue = pearsonr(xs, ys)</span><br><span class="line"></span><br><span class="line"># Display the correlation</span><br><span class="line">print(correlation)</span><br></pre></td></tr></table></figure><figure><img src="https://i.loli.net/2019/11/20/kPyiZ9QhEKxY58S.png" alt="transform后" /><figcaption aria-hidden="true">transform后</figcaption></figure><p>可以看到，谷物的长与宽是有相关性的，即它的叶片越长，宽度也越宽。但在transofor后，数据就与坐标系对齐了。</p><h2 id="intrinsic-dimension">Intrinsic dimension</h2><p>Intrinsic dimension 即在降维或者压缩数据过程中，为了让你的数据特征最大程度的保持，你最低限度需要保留哪些features。</p><p>它同时也告诉了我们可以把数据压缩到什么样的程度，所以你需要了解哪些 feature 对你的数据集影响是最大的。</p><p>比如我们衡量电脑性能，我们可以把键盘鼠标这些feature去掉，但是cpu、gpu、内存性能这些你肯定要保留对不对？cpu、gpu、内存性能，这就是我们说的 features required to approximate it。</p><p>但有的人说，我觉得硬盘也得加上去，这样我们的 intrinsic dimension 就从 3 增加到4了。</p><p>所以你看，intrinsic dimension 数量是一个视不同情况而定的值。</p><p>那我们将设为多少比较合适呢？考虑我们的iris数据，我们选择</p><ul><li>sepal width</li><li>sepal length</li><li>petal width</li></ul><p>这3个变量，这样我们就可以将它绘制到3维空间，但我们发现它的图像在3维空间是很平的，这意味着某个变量的值的方差很小，也就是说它对整个图像的影响不大，我们只选择另外2个变量，也可以不损失太多的细节。</p><p><img src="https://i.loli.net/2019/11/20/iUkctja8u2RovbA.png" /></p><p>但scatter图只能表示3维以下的数据，如果我们的 features 有很多个，我们要如何找到那些影响程度大的 features 呢？</p><p>这就是 PCA 擅长的地方，我们可以统计 PCA 中那些方差显著的features。</p><p>下面是iris数据集各个features的方差排序图：</p><p><img src="https://i.loli.net/2019/11/20/qDPFfX7E8xjMwAu.png" /></p><p>可以看到最后的那个数据方差非常小，所以它对我们数据集的影响完全可以去除掉。</p><p>那么如何绘制数据集的 variances 呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Perform the necessary imports</span><br><span class="line">from sklearn.decomposition import PCA</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.pipeline import make_pipeline</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Create scaler: scaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line"></span><br><span class="line"># Create a PCA instance: pca</span><br><span class="line">pca = PCA()</span><br><span class="line"></span><br><span class="line"># Create pipeline: pipeline</span><br><span class="line">pipeline = make_pipeline(scaler,pca)</span><br><span class="line"></span><br><span class="line"># Fit the pipeline to &#x27;samples&#x27;</span><br><span class="line">pipeline.fit(samples)</span><br><span class="line"></span><br><span class="line"># Plot the explained variances</span><br><span class="line">features = range(pca.n_components_)</span><br><span class="line">plt.bar(features,pca.explained_variance_)</span><br><span class="line">plt.xlabel(&#x27;PCA feature&#x27;)</span><br><span class="line">plt.ylabel(&#x27;variance&#x27;)</span><br><span class="line">plt.xticks(features)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="pca降维">PCA降维</h2><p>我们在做数据降维的时候，得指定需要保留的features，即通过指定pca的参数<code>n_components=2</code>, 我们保留多少个features，这可以通过Intrinsic dimension来计算。</p><p>我们以iris数据为例，当我们用PCA把数据从四维（petal width,length和sepal length,width）降到2维后，我们再绘制它的scatter图，会发现它们还是分为三部分。</p><p>但是对于如字词统计的例子中，我们可能需要用其他的算法来代替，在这种数据中，每一行代表一个文档，每一列代表某个固定词组（fixed vocabulary）中的词语.</p><p>我们会统计，每个词语在每个文档中出现的次数array。不过，只有少数的词语会出现很多的文档之中，大部分词语在某些文档中的出现次数都是0，这样的array叫做sparse(稀疏的），sparse array中大部分的值都是0.</p><p>我们使用 <em>csr_matrix</em> 来代替 <em>numpy array</em> 去处理这样的数据。</p><p><em>csr_matrix</em> 只会保存那些非0值，这样就更方便，但是PCA不支持 <em>csr_matrix</em>，我们需要用 <em>TruncatedSVD</em> 来代替 PCA。</p><p><em>‌TruncatedSVD</em> 的效果与 PCA 是一样的，只不过它接受 <em>csr_matrix</em> 数组，除此之外使用方法都是一样的。</p><p>示例，我们来对一组词语进行分词操作，我们的词组如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># data</span><br><span class="line">documents=[&#x27;cats say meow&#x27;, &#x27;dogs say woof&#x27;, &#x27;dogs chase cats&#x27;]</span><br><span class="line"></span><br><span class="line"># Import TfidfVectorizer</span><br><span class="line">from sklearn.feature_extraction.text import TfidfVectorizer</span><br><span class="line"></span><br><span class="line"># Create a TfidfVectorizer: tfidf</span><br><span class="line">tfidf = TfidfVectorizer() </span><br><span class="line"></span><br><span class="line"># Apply fit_transform to document: csr_mat</span><br><span class="line">csr_mat = tfidf.fit_transform(documents)</span><br><span class="line"></span><br><span class="line"># Print result of toarray() method</span><br><span class="line">print(csr_mat.toarray())</span><br><span class="line"></span><br><span class="line"># Get the words: words</span><br><span class="line">words = tfidf.get_feature_names()</span><br><span class="line"></span><br><span class="line"># Print words</span><br><span class="line">print(words)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: [[0.51785612 0.         0.         0.68091856 0.51785612 0.        ]</span><br><span class="line"> [0.         0.         0.51785612 0.         0.51785612 0.68091856]</span><br><span class="line"> [0.51785612 0.68091856 0.51785612 0.         0.         0.        ]]</span><br><span class="line"> </span><br><span class="line"> [&#x27;cats&#x27;, &#x27;chase&#x27;, &#x27;dogs&#x27;, &#x27;meow&#x27;, &#x27;say&#x27;, &#x27;woof&#x27;]</span><br></pre></td></tr></table></figure><h1 id="nmf">NMF</h1><p>NMF与PCA一样，都是降维算法。不过NMF不能用于所有的预测，只能用于非负值。</p><p>NMF会将数据集中的每组数据分解并分别计算其和。</p><p>考虑字词统计的例子，NMF使用tf-idf来计算字词出现的频率。 tf是词语出现的频率，在每一个document中，如果一个词占整个document中文字的百分之10，那么NMF的输出的tf就是0.1.</p><p>而idf用来降低那些常用词的影响，如,<code>的,那个，这个</code>等等。</p><p>我们知道，在PCA中，我们定义了多少个<code>n_components</code>,就相当于是保留了多少个features。</p><p>在NMF中，它也会去学习数据集的 <em>component dimension</em>。</p><p>需注意，NMF的条目，以及features的值，总是正数。</p><h2 id="nmf算法使用">NMF算法使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Import NMF</span><br><span class="line">from sklearn.decomposition import NMF</span><br><span class="line"></span><br><span class="line"># Create an NMF instance: model</span><br><span class="line">model = NMF(n_components=6)</span><br><span class="line"></span><br><span class="line"># Fit the model to articles</span><br><span class="line">model.fit(articles)</span><br><span class="line"></span><br><span class="line"># Transform the articles: nmf_features</span><br><span class="line">nmf_features = model.transform(articles)</span><br><span class="line"></span><br><span class="line"># Print the NMF features</span><br><span class="line">print(nmf_features)</span><br></pre></td></tr></table></figure><h2 id="论文字词统计">论文字词统计</h2><blockquote><p>Components correspond to topics of documents, and the NMF features reconstruct the documents from the topics</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Import pandas</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># Create a DataFrame: components_df</span><br><span class="line">components_df = pd.DataFrame(model.components_,columns=words)</span><br><span class="line"></span><br><span class="line"># Print the shape of the DataFrame</span><br><span class="line">print(components_df.shape)</span><br><span class="line"></span><br><span class="line"># Select row 3: component</span><br><span class="line">component = components_df.iloc[3]</span><br><span class="line"></span><br><span class="line"># Print result of nlargest</span><br><span class="line">print(component.nlargest())</span><br></pre></td></tr></table></figure><h2 id="用户喜好预测">用户喜好预测</h2><p>NMF有一个重要的应用是作为内容推荐，假设我们有一个用户和一部电影，我们想要根据电影的内容做出预测：</p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">喜剧片</th><th style="text-align: left;">动作片</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">小雅</td><td style="text-align: left;">喜欢</td><td style="text-align: left;">不喜欢</td></tr><tr class="even"><td style="text-align: left;">百货战警</td><td style="text-align: left;">3</td><td style="text-align: left;">1</td></tr></tbody></table><blockquote><p>红番区是动作喜剧片。</p></blockquote><p>现在假设小雅喜欢喜剧片，不喜欢动作片，同时假设我们现在只根据一部电影拥有多少喜剧成分与动作片成分来评价它。</p><p>现在因为小雅喜欢喜剧片<code>+3</code>，不喜欢动作片<code>+0</code>，所以它可能给出的评价是 3分 。</p><p>我们再来考虑小明的情况：</p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">喜剧片</th><th style="text-align: left;">动作片</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">小明</td><td style="text-align: left;">不喜欢</td><td style="text-align: left;">喜欢</td></tr><tr class="even"><td style="text-align: left;">红番区</td><td style="text-align: left;">3</td><td style="text-align: left;">1</td></tr></tbody></table><p>小明喜欢动作片，不喜欢喜剧片，所以喜剧片的3分不计，动作片1分计入，即小明只给出了1分的评价。</p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">喜剧片</th><th style="text-align: left;">动作片</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">小雅</td><td style="text-align: left;">喜欢</td><td style="text-align: left;">喜欢</td></tr><tr class="even"><td style="text-align: left;">红番区</td><td style="text-align: left;">3</td><td style="text-align: left;">1</td></tr></tbody></table><p>再考虑一个例子：</p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">喜剧片</th><th style="text-align: left;">动作片</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">小刘</td><td style="text-align: left;">喜欢</td><td style="text-align: left;">喜欢</td></tr><tr class="even"><td style="text-align: left;">让子弹飞</td><td style="text-align: left;">1</td><td style="text-align: left;">3</td></tr></tbody></table><p>小刘喜欢喜剧也喜欢动作，所以这部电影他可能会给出1+3，四分的评价。</p><p>我们把一批电影编号为M1-M5,列表示分别占喜剧与动作的成分，同时把一批用户分类为他们是否喜欢喜剧或动作片。</p><p><img src="https://i.loli.net/2019/11/21/1RKTpP4MFcVuyfS.png" /></p><p>当我们把左边的两个表结合，就可以得到后面的这个表：</p><p><img src="https://i.loli.net/2019/11/21/PTgzFwfcnsX5uQp.png" /></p><p>这是通过算点积算出来的，你可以看到：</p><p><img src="https://i.loli.net/2019/11/21/Astuv1eTKCGHDyP.png" /></p><ul><li>有些人的喜好一样，则他们给出的电影评分也是一样的</li><li>如果两个电影所占的成分差不多，则也会得到一样的评分</li><li>B+C=D,这是因为B的喜欢与C的喜好相反，而D对与这两者都喜欢</li><li>M2与M3的平均值是M5，即M5的喜剧与动作成分是M2与M3的平均值，所以M5的评分也是M2与M3的平均值</li></ul><p>上面的这个表叫做Matrix Factorization, 我们要存储这个表是非常费存储的，假设我们有很多的电影与用户，算一下我们需要一个多大的Matrix.</p><p><img src="https://i.loli.net/2019/11/21/SnX2JGWdIgsM6oL.png" /></p><p>所以我们在存储的时候，只存储用户的喜好与电影的信息,再通过图表演示一下：</p><p><img src="https://i.loli.net/2019/11/21/TqmufiSXRHQchPZ.png" /></p><p>第一种方案是我们直接存储用户对所有电影评分与可能的评分，假设有2000个用户，1000部电影，这意味着200万份数据。</p><p><img src="https://i.loli.net/2019/11/21/8fwGTU7L96uIc5e.png" /></p><p>如果我们通过feature计算，则只需要30万份数据</p><p><img src="https://i.loli.net/2019/11/21/k9Ml5mUPoBg4SZC.png" /></p><p>现在我们回到以前，对与NMP算法，其中一个问题是，</p><p><img src="https://i.loli.net/2019/11/21/Astuv1eTKCGHDyP.png" /></p><p>如何通过中间的点积，得到两边的数据？就像24可以是2x12,也可以是4x6.</p><p>最开始我们可以随机的将两边的数据列出来，算出点积并与手上的点积比对，如果过低，那么我们将相应的用户喜好与电影评分做出调整，直到所有的值接近我们已有的点积中的值。</p><p><img src="https://i.loli.net/2019/11/21/c9QkmIZ5TbEUFMY.png" /></p><p>我们算到什么程度，才停止呢？我们需要定义一个error function,它就是告诉机器，你哪里错了，做的还不够，得继续算。</p><p><img src="https://i.loli.net/2019/11/21/I34aLMFuywnHqzA.png" /></p><p>这里的error就是我们手上的数据与机器算出来的数据的差的平方，我们把每个用户或者每个电影的error加起来，error function的作用就是尽量让error的和最小。</p><p>在现实的情况中，我们不可能每个用户对每个电影都有评分，所以我们拿到的点积图中间可能有很多空白:</p><p><img src="https://i.loli.net/2019/11/21/q865U2sbpad9x3l.png" /></p><p>但是我们可以根据这些值算出来用户与电影的属性,进而给用户推荐电影:</p><p><img src="https://i.loli.net/2019/11/21/qUIHQT75DZ6Rhdk.png" /></p><blockquote><p><a href="https://www.youtube.com/watch?v=ZspR5PZemcs&amp;t=693s">参考:How does Netflix recommend movies? Matrix Factorization</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/21/I34aLMFuywnHqzA.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非监督学习的最后两章，我们会学习 Dimension reduction, Dimension reduction就是从数据中发现一定的模式，通过这种模式我们就可以对数据进行压缩，这对于计算和存储来说都是非常有利的，特别是在大数据时代。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
    <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
    <category term="data analysis" scheme="http://wittyfans.com/tags/data-analysis/"/>
    
    <category term="sklearn" scheme="http://wittyfans.com/tags/sklearn/"/>
    
  </entry>
  
</feed>
