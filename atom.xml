<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2021-11-28T13:50:30.117Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 设计模式-抽象工厂与组合模式</title>
    <link href="https://scottzhang.pro/article/72c6f483.html"/>
    <id>https://scottzhang.pro/article/72c6f483.html</id>
    <published>2021-11-28T13:44:50.000Z</published>
    <updated>2021-11-28T13:50:30.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="抽象工厂模式">抽象工厂模式</h1><p>想让你的系统根据配置或平台的问题有多个可能的实现，就可以利用抽象工厂模式。</p><p>你调用抽象工厂会返回一个对象，这个对象的实现会基于你的需求而变化。</p><ul><li>对于一个在线的商城，它对于不同的国家有不同的语言、货币以及税收的计算方式。</li><li>对于一套 GUI 工具，在 Windows 上可能返回的是 WinForm，在 Mac 上返回的则是 Cocoa 组件。</li><li>对于 Django，它会根据当前站点的配置而返回相关的对象以对不同数据库后端的支持。</li></ul><p>想象一个格式化日期与货币的需求，我们需要支持中英文两种情况下的货币和日期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaDateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot; &#123;&#125; 年 &#123;&#125; 月 &#123;&#125; 日 &quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USADateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27; 2021 年 01 月 01 日 &#x27;</span></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;27&#x27;</span>)  <span class="comment"># &#x27; 2021 年 11 月 27 日 &#x27;</span></span><br><span class="line"></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>) <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>再来定义两个处理货币的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaCurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¥ &#123;&#125;.&#123;&#125; 元&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USACurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;$ &#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChinaCurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;¥ 143,958,766,111,111.05 元&#x27;</span></span><br><span class="line">USACurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;$ 143,958,766,111,111.05&#x27;</span></span><br></pre></td></tr></table></figure><p>将上面的代码按照国家组织在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USAFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USADateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USACurrencyFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaDateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaCurrencyFormatter()</span><br></pre></td></tr></table></figure><p>在使用的时候，可以直接使用字典去找对应的抽象工厂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factory_map = &#123;</span><br><span class="line">    <span class="string">&#x27;US&#x27;</span>: USAFormatterFactory,</span><br><span class="line">    <span class="string">&#x27;China&#x27;</span>: ChinaFormatterFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置区域为中国：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = &#x27;China&#x27;</span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(&#x27;21&#x27;, &#x27;1&#x27;, &#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line"># &#x27; 2021 年 01 月 01 日 &#x27;</span><br></pre></td></tr></table></figure><p>设置区域为美国：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = <span class="string">&#x27;US&#x27;</span></span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>在实际的项目架构中，我们会有一个后端的模块来支持对不同国家提供服务，它的结构可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">localize/</span><br><span class="line">__init__.py</span><br><span class="line">backends/</span><br><span class="line">__init__.py</span><br><span class="line">USA.py</span><br><span class="line">China.py</span><br></pre></td></tr></table></figure><p>那么我们可以在 localize 下面的 <code>__init__.py</code> 文件中，动态的选择区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .backends <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> country_code == <span class="string">&#x27;China&#x27;</span>:</span><br><span class="line">current_backend = <span class="string">&#x27;China&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="组合模式">组合模式</h1><p>组合模式一般通过组建来构造复杂的树状结构，它在文件夹和文件夹树中的应用比较多。</p><p>文件目录中通常有两种类型的对象，文件和文件夹。首先来定义这两个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.children = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">sejlf</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把一些常用的方法抽象到基类中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compoment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      get_path 方法会在外部实现</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">        new_folder = get_path(new_path)</span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br><span class="line">        new_folder.children[self.name] = self</span><br><span class="line">        self.parent = new_folder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br></pre></td></tr></table></figure><p>这样 File 和 Folder 类就可以少去一些代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        child.parent = self</span><br><span class="line">        self.children[child.name] = child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这种方式，我们使用的时候，可以进行任意的组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root = Folder(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">folder1 = Folder(<span class="string">&#x27;F1&#x27;</span>)</span><br><span class="line">folder2 = Folder(<span class="string">&#x27;F2&#x27;</span>)</span><br><span class="line">hello_file = File(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line">folder2.add_child(hello_file)</span><br><span class="line">folder1.add_child(folder2)</span><br><span class="line">root.add_child(folder1)</span><br><span class="line"></span><br><span class="line">root.children[<span class="string">&#x27;F1&#x27;</span>].children[<span class="string">&#x27;F2&#x27;</span>].children[<span class="string">&#x27;hello&#x27;</span>].contents</span><br></pre></td></tr></table></figure><p>当你在编程的时候，遇到了树状结构的时候，可以想想是否可以应用组合模式。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-适配器与外观模式</title>
    <link href="https://scottzhang.pro/article/2b511f30.html"/>
    <id>https://scottzhang.pro/article/2b511f30.html</id>
    <published>2021-11-26T09:46:19.000Z</published>
    <updated>2021-11-28T13:50:12.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="适配器模式">适配器模式</h1><p>适配器模式，顾名思义就好像是电脑的转接头一样，目的就是让不同的系统之间可以协同工作。</p><p>比如现在已经存在一些代码了，但你不想对它做任何更改，因为这意味着你要修改大量的内容，这时候你可以写一个适配器，将输入转化成现有代码可以直接使用的，这就叫适配器。</p><p>举个例子，假设我们有一个奇怪的日期格式，它的年和月中间有一个14，现在有一个代码的逻辑是得到初始日期和结束日期中间的天数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysCalculator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        start = datetime.datetime.strptime(self.start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strptime(self.end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (end - start).days</span><br><span class="line"></span><br><span class="line">DaysCalculator(start=<span class="string">&#x27;20211403&#x27;</span>, end=<span class="string">&#x27;20211409&#x27;</span>).get_days()</span><br><span class="line"><span class="comment"># 输出 184</span></span><br></pre></td></tr></table></figure><p>现在你有一些方法需要依赖这段代码，你不得不也按照这个奇怪的格式工作，那么这时候你可以写一个适配器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysAdaptor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        start = datetime.datetime.strftime(start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strftime(end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        self.calculator = DaysCalculator(start, end)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.calculator.get_days()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造两个标准日期对象作为输入</span></span><br><span class="line">start = datetime.datetime.strptime(<span class="string">&#x27;2021/3&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line">end = datetime.datetime.strptime(<span class="string">&#x27;2021/9&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里传入的日期类的日期，但也可以正常工作</span></span><br><span class="line">DaysAdaptor(start, end).get_days()</span><br></pre></td></tr></table></figure><h1 id="外观模式">外观模式</h1><p>外观模式更关注外部的体验，为了用户体验的方便，它将复杂的内部代码封装起来，只暴露一个简单的方法接受参数供用户调用，从而实现不同的功能。</p><p>一个例子是，你想编写一个接受/发送邮件的客户端，对于用户而言，它只需关心：</p><ul><li>发件人地址</li><li>邮件内容</li><li>接受人地址</li></ul><p>所以我们可以编写一个简单的方法，只关心这几个参数，而其余的对于地址的处理、检查，对于用户密码的验证等等则隐藏在函数内部。</p><p>相信你已经在自己的代码中使用过外观模式，此处不在举例。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-享元与命令模式</title>
    <link href="https://scottzhang.pro/article/56f28bda.html"/>
    <id>https://scottzhang.pro/article/56f28bda.html</id>
    <published>2021-11-26T09:42:59.000Z</published>
    <updated>2021-11-28T13:50:17.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章讨论了享元模式与命令模式。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="享元模式">享元模式</h1><p>元、气之始，引申为元气。享元模式即共享最初的那部分，哪部分呢？</p><p>假设你有一个需求需要创建大量的类实例，利用享元模式，就可以保证<strong>共享同一状态的对象，可以同时使用该共享状态的内存。</strong></p><p>举个例子，之前聊过的汽车销售系统。对于每一辆车，我们可以加装不同的配置，比如有尊享版、豪华版等等。</p><p>不同版本之间，其实是大同小异。</p><p>如果对于每辆车我们都去统计它有什么功能，没有什么功能，则会产生巨大的浪费。</p><p>我们可以通过共享对象去存储那些与型号相关的特性列表。</p><p>享元在 Python 中的实现类似单例模式。</p><p>但单例模式返回的是一个类的实例，而享元模式则是根据指定的不同参数，返回对应的实例。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc  <span class="comment"># 垃圾回收器</span></span><br><span class="line"><span class="keyword">import</span> weakref <span class="comment"># 弱引用数据结构包</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarModel</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;弱引用的字典，内部的对象弱没有被引用，则会被回收。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _models = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, model_name, *avgs, **kvargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;这里对新实例的创建自定义，与单例模式有点类似</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        model = cls._models.get(model_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> model:</span><br><span class="line">            model = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">            cls._models[model_name] = model</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name, air=<span class="literal">False</span>, title=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 cruise_control=<span class="literal">False</span>, power_locks=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 allow_whells=<span class="literal">False</span>, use_charger=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例的初始化，在这里完成</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.model_name = model_name</span><br><span class="line">        self.air = air</span><br><span class="line">        self.title = title</span><br><span class="line">        self.cruise_control = cruise_control</span><br><span class="line">        self.power_locks = power_locks</span><br><span class="line">        self.allow_whells = allow_whells</span><br><span class="line">        self.use_charger = use_charger</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self, serial_number</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Sorry We are anble to check&quot;</span>,</span><br><span class="line">            <span class="string">&quot;the seria number &#123;0&#125; on the &#123;1&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;at this time&quot;</span>.<span class="built_in">format</span>(self.number, self.model_name)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model, color, serial</span>):</span></span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = color</span><br><span class="line">        self.serial = serial</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model.check_serial(self.serial)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>上面定义了两个类，一个是汽车模版，一个是汽车。我们来生产几辆车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dx = CarModel(<span class="string">&quot;FIT DX&quot;</span>)</span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产一些车</span></span><br><span class="line">car1 = Car(model=dx, color=<span class="string">&#x27;blue&#x27;</span>, serial=<span class="string">&#x27;DX001&#x27;</span>)</span><br><span class="line">car2 = Car(model=dx, color=<span class="string">&#x27;black&#x27;</span>, serial=<span class="string">&#x27;DX002&#x27;</span>)</span><br><span class="line">car3 = Car(model=lx, color=<span class="string">&quot;red&quot;</span>, serial=<span class="string">&quot;LX003&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在来观察他们的内存地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># display(id(lx)) -&gt; 4402294352</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 lx 和对它的引用，让垃圾回收器回收</span></span><br><span class="line"><span class="keyword">del</span> lx</span><br><span class="line"><span class="keyword">del</span> car3</span><br><span class="line">gc.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新创建一个新的 lx，其地址已经变了，因为生成了新的 lx</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个其它版本的 lx，没有 air 和其他的选项，发现返回的还是第二遍创建的</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br></pre></td></tr></table></figure><p>享元模式使用起来比普通的类实现更负责，但如果你有成百上千的类实例需要创建的时候，享元模式可以极大的节省你的内存，可以说享元模式是专为节省内存而设计的。</p><h1 id="命令模式">命令模式</h1><p>命令模式在<strong>必须被完成的行为</strong>和<strong>调用这些动作的对象</strong>之间添加了一个抽象层，这句话可能比较难理解，我们看一个例子。</p><p>这个模式在图形窗口中的操作中应用的比较多。</p><p>我们实现一个窗口程序，它有退出和保存的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_name</span>):</span></span><br><span class="line">        self.file_name = file_name</span><br><span class="line">        self.content = <span class="string">&quot;This file can not be modified&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToolBarButton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, iconname</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.iconname = iconname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, menu_name, manu_itemname</span>):</span></span><br><span class="line">        self.manu_name = menu_name</span><br><span class="line">        self.menu_itemname = manu_itemname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyboardShortCut</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, modifier</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.modifier = modifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keypress</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExitCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个窗口</span></span><br><span class="line">window = Window()</span><br><span class="line"><span class="comment"># 新建一个文档</span></span><br><span class="line">document = Document(<span class="string">&quot;A Great Document!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建两个指令，需要传入文档</span></span><br><span class="line">save_command = SaveCommand(document)</span><br><span class="line">exit_command = ExitCommand(document)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定操作</span></span><br><span class="line"><span class="comment"># 举例：当 ToolBarButton 内部的 click 被调用</span></span><br><span class="line"><span class="comment"># click -&gt; save_command.execute（内部引用了document） -&gt; document.save</span></span><br><span class="line">save_button = ToolBarButton(<span class="string">&#x27;save&#x27;</span>, <span class="string">&#x27;save.png&#x27;</span>)</span><br><span class="line">save_button.command = save_command</span><br><span class="line"></span><br><span class="line">save_keystroke = KeyboardShortCut(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;ctrl&#x27;</span>)</span><br><span class="line">save_keystroke.command = save_command</span><br><span class="line"></span><br><span class="line">exit_menu = MenuItem(<span class="string">&#x27;File&#x27;</span>, <span class="string">&#x27;Exit&#x27;</span>)</span><br><span class="line">exit_menu.command = exit_command</span><br></pre></td></tr></table></figure><p>还有一种更简洁、更 Python 的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command()</span><br><span class="line"></span><br><span class="line">window = Window()</span><br><span class="line">menu_item = MenuItem()</span><br><span class="line">menu_item.command = window.exit</span><br></pre></td></tr></table></figure><p>或者直接调用类，只需实现 <code>__call__</code> 方法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;实现了 call 方法的类可以直接被调用&quot;&quot;&quot;</span></span><br><span class="line">        self.document.save()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章讨论了享元模式与命令模式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记录 Airflow 的部署</title>
    <link href="https://scottzhang.pro/article/c6a5215a.html"/>
    <id>https://scottzhang.pro/article/c6a5215a.html</id>
    <published>2021-11-26T07:06:25.000Z</published>
    <updated>2021-11-27T08:28:31.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个 Python 编写的调度工具，在此记录它的部署过程。</p></blockquote><span id="more"></span><h1 id="部署">部署</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy new server</span></span><br><span class="line">From vultr</span><br><span class="line"></span><br><span class="line"><span class="comment"># win10 generate ssh key</span></span><br><span class="line">ssh-keygen</span><br><span class="line">cat | Users/YourUserName/.ssh/id_rsa.pub | set-clibboard</span><br><span class="line"></span><br><span class="line">使用 Docker 配置 Airflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull puckel/docker-airflow</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -d -p 8080:8080 puckel/docker-airflow webserver</span><br><span class="line"><span class="comment"># 进入启动的容器并启动 shell</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置登录密码</span></span><br><span class="line"><span class="comment">## 创建 py 文件</span></span><br><span class="line">vim set_password.py</span><br><span class="line"></span><br><span class="line"><span class="comment">## 贴入代码</span></span><br><span class="line">import airflow</span><br><span class="line">from airflow import models, settings</span><br><span class="line">from airflow.contrib.auth.backends.password_auth import PasswordUser</span><br><span class="line"></span><br><span class="line">user = PasswordUser(models.User())</span><br><span class="line">user.username = <span class="string">&#x27;new_user_name&#x27;</span></span><br><span class="line">user.email = <span class="string">&#x27;new_user_email@example.com&#x27;</span></span><br><span class="line">user.password = <span class="string">&#x27;set_the_password&#x27;</span></span><br><span class="line">session = settings.Session()</span><br><span class="line">session.add(user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件，将配置文件拷贝出来用vim修改</span></span><br><span class="line">sudo docker cp a3a3dc6b79fe:/usr/<span class="built_in">local</span>/airflow/airflow.cfg .</span><br><span class="line">vim airflow.cfg . <span class="comment"># 修改</span></span><br><span class="line">sudo docker cp airflow.cfg  dc8b159da311:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 py 文件拷贝到容器</span></span><br><span class="line">sudo docker cp set_password.py  1291e03f85fc:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f85fc bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码</span></span><br><span class="line">python set_password.py <span class="comment"># 提示缺少包 flask_bcrypt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 flask_bcrypt 包</span></span><br><span class="line">pip intall flask_bcrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码, 重启</span></span><br><span class="line">python set_password.py</span><br><span class="line">docker container restart 1291e03f85fc</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"><span class="comment"># list dags</span></span><br><span class="line"></span><br><span class="line">airflow list_dags</span><br><span class="line"></span><br><span class="line">Filling up the DagBag from /home/repl/workspace/dags , 加粗部分为 dags 所在文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置文件</span></span><br><span class="line">cat ~/airflow/airflow.cfg</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line"><span class="comment"># 容器启动失败查看日志</span></span><br><span class="line">sudo docker logs <span class="variable">$&#123;container_id&#125;</span></span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://notbe.cn/2019/05/12/1557726443776.html">airflow 使用心得，从环境到部署上线</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个 Python 编写的调度工具，在此记录它的部署过程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="docker" scheme="https://scottzhang.pro/tags/docker/"/>
    
    <category term="airflow" scheme="https://scottzhang.pro/tags/airflow/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-模版模式</title>
    <link href="https://scottzhang.pro/article/ebf9c4b3.html"/>
    <id>https://scottzhang.pro/article/ebf9c4b3.html</id>
    <published>2021-11-21T07:51:22.000Z</published>
    <updated>2021-11-28T13:50:07.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><p>模版模式有助于去除重复代码，并满足了”DRY-不要重复自己“原则。</p><p>平时遇到数据处理的需求，我们需要执行一些常见的任务，如：</p><ol type="1"><li>去数据库取数，并将某些结果打印至控制台</li><li>去数据库取数，简单处理后，将结果保存到 csv 文件</li></ol><p>在这两个步骤中，有些子步骤是一样的，比如连接数据库，发出查询请求，执行 query 语句等。</p><p>可以将这部分功能集成到基类中，而其他特殊的功能可以放到子类中。</p><p>我们举例来说明，首先准备一个数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;CREATE TABLE sales&quot;</span></span><br><span class="line">    <span class="string">&quot;(&quot;</span></span><br><span class="line">    <span class="string">&quot;salespersion txt,&quot;</span></span><br><span class="line">    <span class="string">&quot;amt currency,&quot;</span></span><br><span class="line">    <span class="string">&quot;year integer,&quot;</span></span><br><span class="line">    <span class="string">&quot;model text,&quot;</span></span><br><span class="line">    <span class="string">&quot;new boolen&quot;</span></span><br><span class="line">    <span class="string">&quot;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入一些假数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete all rows from db before any new rows insert into table</span></span><br><span class="line">conn.execute(<span class="string">&quot;delete from sales&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert rows</span></span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Scott&#x27;, 1400, 2007, &#x27;Toyota&#x27;, &#x27;false&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Desmond&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Burney&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Austin&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cursor = conn.execute(<span class="string">&quot;select * from sales&quot;</span>)</span><br><span class="line">cursor.fetchall()</span><br></pre></td></tr></table></figure><p>查询结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&#x27;Scott&#x27;</span>, 1400, 2007, <span class="string">&#x27;Toyota&#x27;</span>, <span class="string">&#x27;false&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Desmond&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Burney&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Austin&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>现在我们设计一个 query 的模版类，想想它需要有哪些功能？</p><p>一个可能的基类是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_format</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;暴露给外部调用的方法，用来保证每个方法按照顺序执行。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.connect()</span><br><span class="line">        self.construct_query()</span><br><span class="line">        self.do_query()</span><br><span class="line">        self.format_results()</span><br><span class="line">        self.output_results()</span><br></pre></td></tr></table></figure><p>基类定义了我们需要有哪些功能，现在根据我们的需求，将其中一些可以共用的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个类提供了连接数据库、执行 query，格式化结果的功能</span></span><br><span class="line"><span class="string">       而对于构造 query、导出结果的功能，则抽象成接口交给子类去实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.conn.execute(self.query)  <span class="comment"># query 待 construct_query 实现</span></span><br><span class="line">        self.result = result.fetchall()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> self.result:</span><br><span class="line">            row = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> row]</span><br><span class="line">            output.append(row)</span><br><span class="line">        self.formated_result = <span class="string">&#x27;\n&#x27;</span>.join(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>现在实现我们自己的需求就很容易了，因为我们只需要将精力放在构造 query 和 输出结果这两个方法上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewVehiclesQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.query = <span class="string">&quot;select * from sales where new = &#x27;true&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.format_result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.do_query = <span class="string">&quot;select * from sales&quot;</span>  <span class="comment"># do what you want to do</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        file_name = <span class="string">&quot;output_file.csv&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span> (file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.formated_result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-单例模式及其实现原理</title>
    <link href="https://scottzhang.pro/article/18dbdeeb.html"/>
    <id>https://scottzhang.pro/article/18dbdeeb.html</id>
    <published>2021-11-18T13:25:00.000Z</published>
    <updated>2021-11-28T13:50:00.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="面向对象">面向对象</h1><h2 id="方法是怎么工作的">方法是怎么工作的？</h2><p>方法是绑定在类中的函数。你可以像下面这样声明一个 pizza 类以及它的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接访问类的 get_size 方法，会告诉你这个方法未绑定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 中不会提示</span></span><br><span class="line">Pizza.get_size</span><br><span class="line">&lt;unbound method Pizza.get_size&gt;</span><br></pre></td></tr></table></figure><p>我们无法调用这个方法，因为它没有绑定给任何 Pizza 的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 会直接报错</span></span><br><span class="line">Pizza.get_size()</span><br><span class="line">TypeError: unbound method get_size() must be called <span class="keyword">with</span> Pizza instance <span class="keyword">as</span> first argument (got nothing instead)</span><br></pre></td></tr></table></figure><p>它提示你第一个参数必须是 Pizza 的实例，那我们将它的 Pizza 的实例传进去看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 方法，同时传入实例，正常</span></span><br><span class="line">Pizza.get_size(Pizza(<span class="number">42</span>))</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>成功了! 不过这样使用也太麻烦了，好在 Python 会帮我们自动实现这些繁琐的工作。它会自动将 Pizza 中所有的方法绑定给任何 Pizza 的实例，当我们定义类方法的时候，其中写的 self 就等于类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = Pizza(<span class="number">42</span>).get_size</span><br><span class="line">m()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>如果你想知道方法被绑定给了那个对象，可以通过 <code>m.__self__</code> 来查看方法被绑定到了哪个对象。</p><h2 id="静态方法">静态方法</h2><p>静态方法不需要提供 self 或 cls 等参数，因为声明为静态方法后，它不会绑定给任何实例或者类, 这减少了类实例创建时候的开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mix_ingredients</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mix_ingredients(self.cheese, self.vegetables)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到两个实例的方法是不想等的，而静态方法的对于实例和类都是相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pizza().cook <span class="keyword">is</span> Pizza().cook</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza.mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza().mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="类方法">类方法</h2><p>类方法的概念和实例方法类似，不同的是它会被绑定给类本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    radius = <span class="number">42</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">cls</span>):</span>  <span class="comment"># cls 为类</span></span><br><span class="line">        <span class="keyword">return</span> cls.radius</span><br></pre></td></tr></table></figure><p>对于类方法来说，不管你通过类还是类的实例调用，它引用的也都是同一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pizza.get_radius</span><br><span class="line">&lt;bound method <span class="built_in">type</span>.get_radius of &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">type</span>.<span class="title">get_radius</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span> == <span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span>()</span></span><br><span class="line"><span class="class">42</span></span><br></pre></td></tr></table></figure><p>什么时候使用类方法呢？</p><p>第一种情况是工厂模式中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ingredients</span>):</span></span><br><span class="line">        self.ingredients = ingredients</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_fridge</span>(<span class="params">cls, fridge</span>):</span></span><br><span class="line">        <span class="comment"># 会返回一个新的类的实例，这允许你在类的实例被初始化之前做一些事情，</span></span><br><span class="line">        <span class="comment"># 它的初始化参数来自于fridge 的两个方法 get_cheese() + get_vegetables()</span></span><br><span class="line">        <span class="keyword">return</span> cls(fridge.get_cheese() + fridge.get_vegetables())</span><br></pre></td></tr></table></figure><p>这样写的好处是，你可以通过 <code>Pizza.from_fridge(...)</code> 的方式生成实例。</p><p>第二种情况是调用静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius, height</span>):</span></span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.height = height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span>(<span class="params">radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> math.pi * (radius ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_volume</span>(<span class="params">cls, height, radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> height * cls.compute_area(radius)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_volume</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.compute_volume(self.height, self.radius)</span><br></pre></td></tr></table></figure><p>这里的 cls 可以写成 Pizza, 但通过 cls 的方式避免将 Pizza 类写死在类中。</p><h2 id="抽象方法">抽象方法</h2><p>抽象方法（Abstract methods）是定义在基类中的，未实现的方法，它有点类似于 java 中的接口。它规定了一种方法的形式，任何继承基类的子类都必须实现此方法才可以工作。</p><p>一个简单的抽象方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>根据这个定义，任何继承了 Pizza 类的子类，都必须实现并重写 get_redius 方法，如果你忘记实现，实例调用 get_radius 就会出错。</p><p>如果你想要让这种错误发生的更早一点，比如发生在实例刚创建的时候，那么可以设置 Pizza 的 metaclass 为 abc 模块中的 ABCMeta。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="string">&quot;&quot;&quot;Method that should do something.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这里继承自 BasePizza 的类中，必须实现 get_radius 方法。BasePizza 对实现的细节并不关心，可以是类方法，实例方法，或者是静态方法。同样它也不关心返回的结果。</p><blockquote><p>参考: <a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">The definitive guide on how to use static, class or abstract methods in Python.</a></p></blockquote><h2 id="super-类">super 类</h2><p>是的，这标题没有错！super 是一个类，实例化之后得到的是一个代理的对象，而不是得到了父类，我们使用这个代理对象来调用父类或者兄弟类的方法。</p><p>但是当继承的父类比较多时，去哪个父类中调用方法就是个问题。对于子类的实例来说，可以通过 <code>obj.__mro__</code> 或者是 <code>cls.mro()</code> 访问父类的列表，python 通过它用管理类的继承顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问一个实例的 MRO 列表</span></span><br><span class="line"><span class="built_in">type</span>(B()).__mro__</span><br><span class="line">(__main__.B, __main__.A, <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>如果你提供一个 MRO 列表以及一个 MRO 中的类 C 给 super()，它将返回一个从 MRO 列表中 C 之后的类中查找到的方法的对象。</p><p>假设有个MRO列表为 [A, B, C, D, E, object]，执行 super(C, A).foo() 它只会从 C 之后查找，即: 只会在 D 或 E 或 object 中查找 foo 方法。</p><p>super() 它有几种使用方法：</p><ul><li>super() -&gt; same as super(<strong>class</strong>, <first argument>)</li><li>super(type) -&gt; unbound super object</li><li>super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</li><li>super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</li></ul><p>举个 super(type, obj) 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Base&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 super 的 func</span></span><br><span class="line"><span class="built_in">super</span>(A, C()).func()  <span class="comment"># 输出 &#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么是 B 呢？首先看一下 MRO 列表，Python 会根据第二个参数来计算 MRO，也就是这里提供的 C() 产生的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C.mro()</span><br><span class="line">[__main__.C, __main__.A, __main__.B, __main__.Base, <span class="built_in">object</span>]</span><br></pre></td></tr></table></figure><p>super 会计算出来的 mro 列表中，跳过参数A，从后面开始找父类的 func 方法，所以这里会执行 B 的 func。</p><p>然后再来说说 super(type, obj) 和 super(type, type2)的区别，他们的区别是第二个参数，super的第二个参数传递的是类，得到的是函数，super的第二个参数传递的是对象，得到的是绑定方法。</p><blockquote><p>理解绑定方法，有兴趣的再可以深入了解<a href="(https://docs.python.org/zh-cn/3.7/howto/descriptor.html)">描述器</a>的介绍。</p></blockquote><h1 id="单例模式">单例模式</h1><p>掌握了面向对象的知识和 super 的使用，就可以介绍单例模式了。单例模式是一种确保一个类只有一个实例会被创建出来的模式。</p><p>在其他语言中，单例通过构造函数私有化实现，Python 中没有私有构造函数，但可以通过类方法 <code>__new__</code> 实现。</p><p>我们知道 <code>__init__</code> 函数，但 <code>__init__</code> 是对创建好的实例初始化，而 <code>__new__</code> 才创建实例。</p><p>摘录网上一段关于这两个方法的解释：</p><ul><li>new (cls[, ...]) 是在一个对象实例化的时候所调用的第一个方法，在调用 init 初始化前，先调用new 。</li><li>new 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给 init 。</li><li>new 对当前类进行了实例化，并将实例返回，传给 init 的self。但是，执行了new ，并不一定会进入 init ，只有new 返回了，当前类cls的实例，当前类的 init 才会进入。</li><li>若new 没有正确返回当前类cls的实例，那 init 是不会被调用的，即使是父类的实例也不行，将没有 init 被调用。</li><li>new 方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径。</li></ul><blockquote><p>为 markdown 渲染方便，这里的 new 即 <code>__new__</code>, init 即 <code>__init__</code></p></blockquote><p>来看一个实现了这两个方法的类的调用顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Scott&quot;</span>, <span class="number">25</span>)</span><br><span class="line">__new__</span><br><span class="line">__init__</span><br></pre></td></tr></table></figure><p>可以看到先调用了 <code>__new__</code>, 才是 <code>__init__</code>，利用 new 的特性，我们可以用它来实现单例模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span>:</span></span><br><span class="line">    _singleton = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># super(OnlyOne, cls) 即上面的 super(type, type2) 模式</span></span><br><span class="line">        <span class="comment"># 这里相当于根据 cls 找 MRO 列表中，OnlyOne后的父类</span></span><br><span class="line">        <span class="comment"># 使用它的 __new__ 方法创建一个 cls（即本类）的实例</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._singleton:</span><br><span class="line">            cls._singleton = <span class="built_in">super</span>(</span><br><span class="line">                OnlyOne, cls</span><br><span class="line">            ).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._singleton</span><br></pre></td></tr></table></figure><p>我们首先检查这个单件的实例是否被创建出来，如果没有，我们用 super 函数来创建它。因此，每当我们调用 OnlyOne 的时候，总是可以得到完全相同的实例。</p><p>单例模式还有其他的实现，比如装饰器、MetaClass，感兴趣的可以看<a href="https://zhuanlan.zhihu.com/p/37534850">这篇</a>文章。</p><p>单例的这种思想，可以用在模块中。比如对于我们前面状态模式中的例子，状态模式中对于不同的状态，我们都有对应的类会初始化作为对状态的记录（如 First tag, Open tag）。</p><p>其实我们可以将状态设置为变量，这就避免了每次都初始化状态类产生一个新的实例，同时在每一个状态类内部，不再对解析器做引用，具体的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildNode</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remaining_str, parser</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        parser.state = child_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">child_node = ChildNode()</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>单例模式设计的内容还是挺多的，如装饰器、静态方法、类方法、继承、多态、MRO、装饰器、super 方法等。为了理解单例模式，我也是花了不少时间复习这块的内容，希望整理的这些笔记可以帮到你，如果要彻底理解这些内容，重要的还是要多去练习、多动手写代码。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/37534850">Python单例模式 Singleton 的N种实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/261579683">python魔法方法，详解 new 和 init 方法</a></li><li><a href="https://www.cnblogs.com/maple-shaw/p/9288018.html">你会使用super()吗？你确定你了解它吗？</a></li><li><a href="https://docs.python.org/zh-cn/3.7/howto/descriptor.html">实现描述器</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="OOP" scheme="https://scottzhang.pro/tags/OOP/"/>
    
    <category term="singleton" scheme="https://scottzhang.pro/tags/singleton/"/>
    
    <category term="super" scheme="https://scottzhang.pro/tags/super/"/>
    
    <category term="staticmethod" scheme="https://scottzhang.pro/tags/staticmethod/"/>
    
    <category term="classmethod" scheme="https://scottzhang.pro/tags/classmethod/"/>
    
    <category term="Abstract methods" scheme="https://scottzhang.pro/tags/Abstract-methods/"/>
    
    <category term="abc" scheme="https://scottzhang.pro/tags/abc/"/>
    
    <category term="MRO" scheme="https://scottzhang.pro/tags/MRO/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-策略与状态模式</title>
    <link href="https://scottzhang.pro/article/8a706eb8.html"/>
    <id>https://scottzhang.pro/article/8a706eb8.html</id>
    <published>2021-11-16T13:32:21.000Z</published>
    <updated>2021-11-28T13:49:55.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="策略模式">策略模式</h1><p>策略模式是一种面向对象编程中的抽象模式。针对同样的问题，它实现了不同的解决方案，你的代码可以在运行的时候自由选择最恰当的方案。</p><p>策略模式的一个应用是排序，比如你要实现一个排序算法，它可以自动选择排序方法来对输入的数组进行排序，排序的方法是自动选择的，而结果是不变的。</p><p>还有一个例子是设置电脑的墙纸，当你设置墙纸的时候，你的电脑会自动帮你设置很多事情：</p><ol type="1"><li>根据屏幕的分辨率，自动将图片缩放到合适的大小</li><li>自动处理图片与系统组件之间的缩放、虚化关系</li><li>图片与背景色的结合</li></ol><p>你可以定义不同的对象，它们接受的 input 是一样的（目标图片，屏幕分辨率），不管怎样，这些对象都都能达到设置屏幕壁纸的目的。</p><p>有人说我通过 if 判断也可以达到同样的目的，但是这意味着你需要将你的代码放到一个巨大的方法中，随着新的策略的增加，你的函数将变得非常笨重。</p><p>这里略过策略模式的实例。</p><h1 id="状态模式">状态模式</h1><p>状态模式的目的是实现“状态切换”，对象的状态可以被外面知道，并且可能会被一些活动改变。来一个例子，需求是要对一个 <a href="https://www.w3.org/XML/">xml 文件</a>进行解析，一个简单的 xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>welcome to scott&#x27;s blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想把这样的文件解析出来，结果是我可以通过 node.attr 的方式访问 xml 文件的内容。比如 xml_file.body 作为一个节点。该节点有一个属性叫子节点，我可以通过 xml_file.body.children 的方式拿到，对于 title 中的内容，我已通过 xml_file.body.title.text 的方式拿到。</p><p>首先需要一个节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点类，记录节点的名字，文本，节点之间有上下级关系，所以它</span></span><br><span class="line"><span class="string">       还需要一个指向父节点的指针。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tagname, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.parent=parent</span><br><span class="line">        self.tagname = tagname</span><br><span class="line">        <span class="comment"># text 和 children 都由其他组件操作</span></span><br><span class="line">        self.children = []</span><br><span class="line">        self.text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.text:</span><br><span class="line">            <span class="keyword">return</span> self.tagname + <span class="string">&#x27;:&#x27;</span> + self.text</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.tagname</span><br></pre></td></tr></table></figure><p>有了节点后，我们还需要一个解析器，解析器会一层一层的解析字符串，我们可以定义解析器有几种状态，即处于：</p><ul><li>开始节点</li><li>子节点</li><li>结束节点</li></ul><p>如何根据解析器的状态判断是否还可以深入一步呢？可以这么定义：</p><ul><li>开始节点</li><li>子节点</li><li>打开的节点</li><li>结束节点</li><li>文本节点（最底层无子节点的节点）</li></ul><p>来看代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parser 是一个解析器。它会负责去切换状态，下图的状态之间会互相转换。</span></span><br><span class="line"><span class="string">       第一个状态是 First Tag，它永远将切换至子节点，再由子节点来决定切换到其他哪个状态。</span></span><br><span class="line"><span class="string">       每一个状态都会用自己的方法处理收到的剩余字符，然后将状态再设置为 Children Node，告诉解析器来处理剩下的部分。</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">        |                     .-------------.                      |</span></span><br><span class="line"><span class="string">        |                    (   First Tag   )                     |</span></span><br><span class="line"><span class="string">        |                     `-------------&#x27;                      |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                     .------v------.                      |</span></span><br><span class="line"><span class="string">        |         +---------&gt;( Children Node )&lt;----------+         |</span></span><br><span class="line"><span class="string">        |         |           `-------------&#x27;            |         |</span></span><br><span class="line"><span class="string">        |         |                  ^                   |         |</span></span><br><span class="line"><span class="string">        |         v                  v                   v         |</span></span><br><span class="line"><span class="string">        |  .-------------.    .-------------.     .-------------.  |</span></span><br><span class="line"><span class="string">        | (   Open tag    )  (  Closed tag   )   (     Text      ) |</span></span><br><span class="line"><span class="string">        |  `-------------&#x27;    `-------------&#x27;     `-------------&#x27;  |</span></span><br><span class="line"><span class="string">        |                                                          |</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parse_str</span>):</span></span><br><span class="line">        self.parse_str = parse_str</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.current_node = <span class="literal">None</span></span><br><span class="line">        self.state = FirstTag()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str</span>):</span></span><br><span class="line">        remainning = self.state.process(remain_str, self)</span><br><span class="line">        <span class="keyword">if</span> remainning:</span><br><span class="line">            self.process(remainning)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.process(self.parse_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理剩余的字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str (string): 剩余需要解析的字符</span></span><br><span class="line"><span class="string">            parser (Parser): parser 即上面定义的的 Parser，它会被闯进来修改它的属性，如current_node, root, state</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 剩余需要解析的字符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line"></span><br><span class="line">        root = Node(tag_name)</span><br><span class="line">        parser.root = parser.current_node = root</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;同样只需要一个 process 方法来处理字符串。</span></span><br><span class="line"><span class="string">           作为 ChildrenNode，它需要根据字符来判断需要使用什么样的类状态器，</span></span><br><span class="line"><span class="string">           类状态器的 process 方法将会完成对剩余字符的处理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str ([type]): [description]</span></span><br><span class="line"><span class="string">            parser ([type]): [description]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        striped = remain_str.strip()</span><br><span class="line">        <span class="keyword">if</span> striped.startswith(<span class="string">&#x27;&lt;&#x27;</span>):</span><br><span class="line">            parser.state = OpenTag()</span><br><span class="line">        <span class="keyword">elif</span> striped.startswith(<span class="string">&#x27;&gt;&#x27;</span>):</span><br><span class="line">            parser.state = CloseTag()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parser.state = TextNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line">        <span class="comment"># parser.current_node 未被更改还是上一层节点，将其设为父节点</span></span><br><span class="line">        node = Node(tag_name, parser.current_node)</span><br><span class="line">        parser.current_node.children.append(node)</span><br><span class="line">        parser.current_node = node</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        <span class="comment"># assert 断言中</span></span><br><span class="line">        <span class="comment"># 第一个确保 &lt; 后是/，如 &lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 第二个确保以同一个tag名开始结束，如 &lt;h1&gt;Hi&lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 以及因当前是结束tag，重置parser当前节点为其父节点</span></span><br><span class="line">        <span class="keyword">assert</span> remain_str[i_start_tag+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        tagname = remain_str[i_end_tag+<span class="number">2</span>:i_end_tag]</span><br><span class="line">        <span class="keyword">assert</span> tagname == parser.current_node.tagname</span><br><span class="line">        parser.current_node = parser.current_node.parent</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:].strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">         i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">         text = remain_str[:i_start_tag]</span><br><span class="line">         parser.current_node.text = text</span><br><span class="line">         parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> remain_str[i_start_tag:]</span><br></pre></td></tr></table></figure><p>启动代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.xml&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        p = Parser(file.read())</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">        nodes = [p.root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            nodes = node.children + nodes</span><br></pre></td></tr></table></figure><p>将会产生下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">title:welcome to scott&#x27;s blog</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-装饰器与观察者模式</title>
    <link href="https://scottzhang.pro/article/140cd416.html"/>
    <id>https://scottzhang.pro/article/140cd416.html</id>
    <published>2021-11-15T12:50:18.000Z</published>
    <updated>2021-11-28T13:50:21.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="装饰器模式">装饰器模式</h1><p>装饰器可以将一个提供核心功能的对象，和其他可以改变这个功能的对象“包裹”在一起使用。</p><p>它主要有两种用途：</p><ul><li>增强一个组件给另一个组件发送数据时的<strong>响应能力</strong></li><li>支持<strong>多种可选的行为</strong>（适当的代替多重继承）</li></ul><h2 id="装饰器">装饰器</h2><p>如果你不知道什么是装饰器，可以看下这篇 <a href="https://medium.com/citycoddee/python%E9%80%B2%E9%9A%8E%E6%8A%80%E5%B7%A7-3-%E7%A5%9E%E5%A5%87%E5%8F%88%E7%BE%8E%E5%A5%BD%E7%9A%84-decorator-%E5%97%B7%E5%97%9A-6559edc87bc0">文章</a>，其中有一段代码可以让你很容易理解它的原理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span>(<span class="params">a_func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之前做一些无聊的工作&quot;</span>)</span><br><span class="line"></span><br><span class="line">        a_func()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之后做一些无聊的工作&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;就是你! 来包装我吧!&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是一个需要被包装的家伙&quot;</span></span><br><span class="line">          <span class="string">&quot;快来拯救我！&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br></pre></td></tr></table></figure><h2 id="网络编程装饰器实例">网络编程装饰器实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法，即不管你传进来的啥东西，只要有 send 和 close</span></span><br><span class="line"><span class="string">       方法即可。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个常量数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP，另外还有 UDP（这属于计算机网络的知识）</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(client)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br></pre></td></tr></table></figure><p>上面的 respond 方法只关注接受的对象有没有 send, close 方法。</p><p>我们甚至可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法可以继续工作。</p><p>让我们来实现一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</p><p>下面的例子是一个网络编程实例的实现，它有一个服务端和客户端，服务端会一直处于待命状态，只要有客户端连接，服务端就会做出回应.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogSocket</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上面的 respond 方法只关注接受的对象有没有 send, close 方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    我们可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法就还是可以继续工作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    所以，我们可以写一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    下面举一个例子是在 send，close 调用的时候执行答应。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sending <span class="subst">&#123;data&#125;</span> to <span class="subst">&#123;self.socket.getpeername()[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        self.socket.send(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(LogSocket(client))  <span class="comment"># client 被包装（装饰），或者说被替换了</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用装饰器的好处是，你可以灵活的切换，比如你可以另外写一个装饰器，用于对发送的数据压缩。 然后你就可以实现类似这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GzipSocket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        buf = BytesIO(data)</span><br><span class="line">        zipfile = gzip.GzipFile(fileobj=buf, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        zipfile.write(data)</span><br><span class="line">        zipfile.close()</span><br><span class="line"></span><br><span class="line">        self.socket.send(buf.getvalues())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">client, addr = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> log_send:</span><br><span class="line">    client = LogSocket(client)</span><br><span class="line"><span class="keyword">if</span> gzip_send:</span><br><span class="line">    client = GzipSocket(client)</span><br></pre></td></tr></table></figure><h2 id="自定义打印的实例">自定义打印的实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_calls</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个新的函数，替换原来传入的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用：&#123;0&#125;, 携带参数 &#123;1&#125;, &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__, args, kwargs</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        return_value = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函数 &#123;&#125; 用时 &#123;&#125; &quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__,</span><br><span class="line">            time.time() - now</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> return_value</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用方法实现的装饰器的使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test = log_calls(test)</span><br><span class="line">result = test(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 特殊的方法使用装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@log_calls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用：<span class="built_in">test</span>, 携带参数 (2, 3), &#123;&#125;</span><br><span class="line">函数 <span class="built_in">test</span> 用时 2.002716064453125e-05</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="装饰器技巧">装饰器技巧</h2><p>想象一下，如果你需要给一个类中的所有方法添加一个装饰器，你会怎么办？也许你不会有这样的需求，但有时候，你可能需要对某几个函数添加装饰器，但你又不想在原来的类旁边添加任何代码。</p><p>这可以通过 metaclass 来实现，或者通过循环类的方法使用 setattr 方法修改，有兴趣的可以研究一下。</p><p>这里放一个 StackOverflow 上的 <a href="https://stackoverflow.com/questions/3467526/attaching-a-decorator-to-all-functions-within-a-class">讨论</a>。</p><h1 id="观察者模式">观察者模式</h1><p>观察者模式适用于<strong>状态监测</strong>和<strong>事件处理</strong>。</p><p>它有一个核心对象，以及观察者。核心对象由一组未知，并可能正在扩展的 “观察者” 对象来监控。一旦核心对象的值发生了变化，便会通过 update 方法告诉每一个观察者。观察者收到更新后，可能会做不一样的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inventory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.observers = []</span><br><span class="line">        self._product = <span class="literal">None</span></span><br><span class="line">        self._quantity = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._product</span><br><span class="line"></span><br><span class="line"><span class="meta">    @product.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._product = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._quantity</span><br><span class="line"></span><br><span class="line"><span class="meta">    @quantity.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._quantity = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_observers</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            <span class="comment"># 调用 observer 对象，为了让一个对象可以被调用，它需要实现</span></span><br><span class="line">            <span class="comment"># __call__ 方法</span></span><br><span class="line">            observer()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleObserver</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inventory</span>):</span></span><br><span class="line">        self.inventory = inventory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwds</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;观察者模式可以用于备份数据至不同的地方，比如文件、数据库或互联网应用。</span></span><br><span class="line"><span class="string">           它将正在被观察的代码，和执行的代码分离。</span></span><br><span class="line"><span class="string">           如果不使用这种模式，则必须在每个属性中处理可能出现的情况，这意味着任务代码和</span></span><br><span class="line"><span class="string">           被观察的对象耦合在一起，维护起来会很麻烦。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.inventory.product)</span><br><span class="line">        <span class="built_in">print</span>(self.inventory.quantity)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">invt = Inventory()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以很容易的添加观察者</span></span><br><span class="line">console_1 = ConsoleObserver(invt)</span><br><span class="line">console_2 = ConsoleObserver(invt)</span><br><span class="line"></span><br><span class="line">invt.attach(console_1)</span><br><span class="line">invt.attach(console_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到每次对 product 或者 quantity 的修改</span></span><br><span class="line"><span class="comment"># 都会产生两次打印，这是因为两个观察者都做出了响应</span></span><br><span class="line">invt.product = <span class="string">&#x27;元气森林&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">invt.quantity = <span class="number">100</span>,<span class="number">000</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级导入技巧</title>
    <link href="https://scottzhang.pro/article/935fa388.html"/>
    <id>https://scottzhang.pro/article/935fa388.html</id>
    <published>2021-09-21T15:33:14.000Z</published>
    <updated>2021-11-27T08:36:36.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章深入研究了 <code>import</code> 命令以及它的工作原理。</p></blockquote><span id="more"></span><h1 id="基本导入命令">基本导入命令</h1><p>在 <a href="https://wittyfans.com/article/c8bc6f6.html">Python-模块与包</a> 一文中，我们看到过 <code>import</code> 命令，它可以用来导入包和模块。</p><p><code>import</code> 命令有几种形式:</p><ul><li><code>import math</code></li><li><code>from math import pi</code></li><li><code>import math as m</code></li></ul><p>对于 <code>import</code> 命令，它不关心 <code>import</code> 的是一个包还是一个模块，因为语法是一样的，只是包在构建的时候有些不同。</p><blockquote><p>一个没有 <code>__init__.py</code> 文件的目录，也会被当做一个包，只是不是普通的包，有时候称其为命名空间包 (namespace packages)。</p></blockquote><p>通常情况下，在一个普通的包中，子模块和子包默认不会导入，除非你在 <code>__init__.py</code> 中有 <code>import</code> 子包和子模块。</p><p>举一例，有个叫 world 包的包，其目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">world/</span><br><span class="line">│</span><br><span class="line">├── africa/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── zimbabwe.py</span><br><span class="line">│</span><br><span class="line">├── europe/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── greece.py</span><br><span class="line">│   ├── norway.py</span><br><span class="line">│   └── spain.py</span><br><span class="line">│</span><br><span class="line">└── __init__.py</span><br></pre></td></tr></table></figure><p>如果你要使用 world 包，若其中没有 <code>__init__.py</code> 是不会包括子包的。</p><p>导入一个包会加载包的内容，并创建命名空间，命名空间是一个字典，你可以通过 <code>__dict__</code> 属性访问到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.__dict__[<span class="string">&quot;pi&quot;</span>]</span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>同样的，全局变量也是一个命名空间，可以通过 <code>globals()</code> 访问。</p><h1 id="常见导入问题">常见导入问题</h1><p>假设你现在有一个包，它的目录结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── files.py</span><br><span class="line">└── structure.py</span><br></pre></td></tr></table></figure><p><code>structure.py</code> 中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># structure.py</span></span><br><span class="line"><span class="keyword">import</span> files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>运行 <code>python structure.py .</code> 后的输出: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python structure.py .</span><br><span class="line">Create file: /home/gahjelle/structure/001/structure.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/files.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/__pycache__/files.cpython-38.pyc</span><br></pre></td></tr></table></figure></p><p>当你在 <code>structure.py</code> 需要用到 files 时，如果这两个文件在同一目录，这样是没有问题的。</p><p>现在为了满足 Pyinstaller guide 而创建了一个程序入口，你的目录结构变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── structure/</span><br><span class="line">│   ├── files.py</span><br><span class="line">│   └── structure.py</span><br><span class="line">│</span><br><span class="line">└── cli.py</span><br></pre></td></tr></table></figure><p>在 <code>cli.py</code> 中，你导入了 structure 中的 main 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> structure.structure <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>此时，如果你在 <code>cli.py</code> 所在目录执行 <code>python cli.py structure</code>，则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;cli.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from structure.structure import main</span><br><span class="line">  File &quot;/home/gahjelle/structure/structure/structure.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    import files</span><br><span class="line">ModuleNotFoundError: No module named &#x27;files&#x27;</span><br></pre></td></tr></table></figure><p>因为 <code>import files</code> 基于当前目录去寻找 files，而当执行目录变化以后，肯定就找不到了。</p><p>一种解决办法是，在引用文件中，找到引用文件的父目录，并将其加入到 <code>sys.path</code> 中（即 implicit relative imports，隐式相对导入）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local imports</span></span><br><span class="line"> sys.path.insert(<span class="number">0</span>, <span class="built_in">str</span>(pathlib.Path(__file__).parent))</span><br><span class="line"> <span class="keyword">import</span> files</span><br></pre></td></tr></table></figure><p>你可能会像在 <code>structure.py</code> 中，使用相对路径导入 <code>files</code>，如：<code>from . import files</code></p><p>但这样也是不行的，因为<a href="https://www.python.org/dev/peps/pep-0328/#relative-imports-and-name">相对导入在脚本中的解析方式与导入模块中的解析方式不同</a>。</p><p>一个更好的方式是使用 <code>pip</code>, 你自己创建一个包，使用起来就好像其他的包一样。</p><h1 id="何不创建自己的包">何不创建自己的包？</h1><p>当你通过 pip 安装一个包的时候，它可以在任何地方使用，事实上你也可以做到，首先在你的包文件夹旁边新建两个文件：</p><ul><li><code>setup.cfg</code></li><li><code>setup.py</code></li></ul><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># setup.cfg</span><br><span class="line"></span><br><span class="line">[metadata]</span><br><span class="line">name = local_structure</span><br><span class="line">version = 0.1.0</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line">packages = structure</span><br><span class="line"></span><br><span class="line"># setup.py</span><br><span class="line"></span><br><span class="line">import setuptools</span><br><span class="line"></span><br><span class="line">setuptools.setup()</span><br></pre></td></tr></table></figure><p>name 和 version，随意。名字的话建议打上标识，比如 local 或者你的用户名，这样可以方便的找出你自己的包。</p><p>准备好了之后，就可以创建你自己的包了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -e .</span><br></pre></td></tr></table></figure><p><code>-e</code> 的意思是 <code>editable</code>， 这个非常重要，因为这可以让你更改你的源代码，而不用重新安装你的包。</p><p>这条命令会将你的包安装到系统，你可以在任何地方使用你的包，只需执行 <code>from structure import files</code>。不用担心相对路径，绝对路径等问题。</p><blockquote><p>简单的包可以这样直接建立，但如果比较复杂的包则最好附上更多详细的信息，可参考 [<a href="https://realpython.com/pypi-publish-python-package/">How to Publish an Open-Source Python Package to PyPI</a>.</p></blockquote><h1 id="介绍命名空间包">介绍命名空间包</h1><p>命名空间包可以允许不存在 <code>__init__.py</code> 文件，特别的，它还允许文件分布在不同的文件夹。当你的文件夹中有 py 文件，但是没有 <code>__init__.py</code> 文件，命名空间包会被自动创建。</p><p>为了更理解命名空间包，我们直接实现它。</p><p>考虑一个需求，要将歌曲的信息序列化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>song = Song(song_id=<span class="string">&quot;1&quot;</span>, title=<span class="string">&quot;The Same River&quot;</span>, artist=<span class="string">&quot;Riverside&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>song.serialize()</span><br><span class="line"><span class="string">&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;title&quot;: &quot;The Same River&quot;, &quot;artist&quot;: &quot;Riverside&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在已经有第三方社区为你实现了一部分工作。</p><p>对于 <code>song.serialize()</code>，它接收一个序列化对象，这个序列化对象有基于 json 实现的，有基于 xml 实现的，可能内部实现代码不一样，但暴露的方法名一样，你可以在 <code>song.serialize()</code> 中自动处理。</p><p>这两个序列化对象，分别放在不同文件实现，文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">third_party/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    ├── json.py</span><br><span class="line">    └── xml.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前看起来不错，这时候你可能想再加一个自己的 yaml 的序列化方法，同样的创建目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    └── yaml.py</span><br></pre></td></tr></table></figure><p>这里虽然代码在不同的目录，但是对于 <code>serializers</code> 来说，在这2个目录里，都有着共同的命名空间。</p><p>所以你可以直接这样导入全部的序列化对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">&quot;third_party&quot;</span>, <span class="string">&quot;local&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> serializers <span class="keyword">import</span> json, xml, yaml</span><br></pre></td></tr></table></figure><p>再举一例：</p><p>假设你有Python代码的两个不同的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo-package/</span><br><span class="line">    spam/</span><br><span class="line">        blah.py</span><br><span class="line"></span><br><span class="line">bar-package/</span><br><span class="line">    spam/</span><br><span class="line">        grok.py</span><br></pre></td></tr></table></figure><p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有 <code>__init__.py</code> 文件。</p><p>让我们看看，如果将 <code>foo-package</code> 和 <code>bar-package</code> 都加到python 模块路径并尝试导入会发生什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.extend([&#x27;foo-package&#x27;, &#x27;bar-package&#x27;])</span><br><span class="line">&gt;&gt;&gt; import spam.blah</span><br><span class="line">&gt;&gt;&gt; import spam.grok</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>两个不同的包目录被合并到一起，你可以导入 <code>spam.blah</code> 和<code>spam.grok</code>，并且它们能够工作。</p><p>在这里工作的机制被称为“包命名空间”的一个特征。</p><p>从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p><h1 id="导入包的风格规范">导入包的风格规范</h1><p>导入包不可以太随意，建议将标准包、第三方包、用户自定义包区分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Standard library imports</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Third party imports</span></span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader imports</span></span><br><span class="line"><span class="keyword">from</span> reader <span class="keyword">import</span> URL</span><br></pre></td></tr></table></figure><h1 id="如何导入数据资源">如何导入数据资源？</h1><p>有时候你的包需要依赖一些数据，如果你想要将这些数据也一起打包分发给你的用户，可能会有一些问题：</p><ul><li>数据文件的路径不确定，这取决于用户的配置，包如何分发的，以及安装在哪里</li><li>你的数据文件可能在压缩文件或者 <code>.egg</code> 文件中无法直接使用</li></ul><p>历史上有过一些对数据资源的解决方案，包括 <a href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html"><code>setuptools.pkg_resources</code></a>，不过现在在 python3.7 中，有了官方的标准库来解决这个问题，那就是 <code>importlib.resources</code>，对于之前的版本，则需要使用 <code>importlib_resources</code></p><blockquote><p>命名空间包不支持 importlib.resources</p></blockquote><p>假设你有一个数据文件是关于书籍的，你的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">books/</span><br><span class="line">│</span><br><span class="line">├── __init__.py  # 空文件，构造包所用</span><br><span class="line">├── alice_in_wonderland.png</span><br><span class="line">└── alice_in_wonderland.txt</span><br></pre></td></tr></table></figure><p>如果需要这两个文件，只需要按如下代码操作即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="comment"># 文本文件, books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_text(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.txt&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    alice = fid.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制文件，books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_binary(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.png&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    cover = fid.read()</span><br></pre></td></tr></table></figure><p>如果是较老的版本，可以在 import 的时候换成支持的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><p>再来一个例子，你现在需要将你的程序添加一个 logo，你的包目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello_gui/</span><br><span class="line">│</span><br><span class="line">├── gui_resources/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── hand.png</span><br><span class="line">│   └── logo.png</span><br><span class="line">│</span><br><span class="line">└── __main__.py</span><br></pre></td></tr></table></figure><p>下面的代码显示了你应该如何引用你的 logo 文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">with</span> resources.path(<span class="string">&quot;hello_gui.gui_resources&quot;</span>, <span class="string">&quot;logo.png&quot;</span>) <span class="keyword">as</span> path:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># or do you work</span></span><br></pre></td></tr></table></figure><h1 id="使用动态导入">使用动态导入</h1><p>Python 是一门动态语言（尽管这有时候也算是缺点），这意味着你可以在 python 程序运行的时候，增加类的属性，修改函数的定义、模块的 docstring，甚至你可以修改 <code>print()</code> 函数让它什么都不输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello dynamic world!&quot;</span>)</span><br><span class="line">Hello dynamic world!</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Redefine the built-in print()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> = <span class="keyword">lambda</span> *args, **kwargs: <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hush, everybody!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Nothing is printed</span></span><br></pre></td></tr></table></figure><p>所以你也可以动态的导入一个包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docreader.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">module_name = <span class="built_in">input</span>(<span class="string">&quot;Name of module? &quot;</span>)</span><br><span class="line">module = importlib.import_module(module_name)</span><br><span class="line"><span class="built_in">print</span>(module.__doc__)</span><br></pre></td></tr></table></figure><h1 id="深入python-的导入系统">深入Python 的导入系统</h1><p>当你执行导入操作时候，背后主要发生了三件事：</p><ol type="1"><li>搜索</li><li>加载</li><li>绑定到命名空间</li></ol><p><code>import</code> 命令执行的时候，这三步会自动完成，而<code>importlib</code> 只会完成前两步。</p><p>有一点需要注意的是，即便你只导入了某个包中的一个属性，整个模块也会被导入，只是其余的部分没有绑定到当前命名空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[<span class="string">&quot;math&quot;</span>].cos(pi)</span><br><span class="line">-<span class="number">1.0</span></span><br></pre></td></tr></table></figure><p><code>sys.modules</code> 相当于系统对导入模块的缓存。当 python 在执行导入的时候，会先去缓存中查找，如果存在了，则不会执行导入。</p><h2 id="只导入一次">只导入一次</h2><p>你的包中有一些方法，它依赖一些数据，这些数据需要从磁盘或者网络读取，你的类在初始化的时候，可能会刷新这些数据，但如果每次初始化就刷新数据，会导致大量时间花在磁盘或网络IO上，可以设计一个单例模式来解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Population</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Prepare to read the population file&quot;&quot;&quot;</span></span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line">        self.variant = <span class="string">&quot;Medium&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment"># 创建只读属性的装饰器，名字不变，调用无需加括号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Read data from disk&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._data:  <span class="comment"># 已存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件，保存到 self._data</span></span><br><span class="line">        <span class="keyword">with</span> resources.open_text(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, <span class="string">&quot;WPP2019_TotalPopulationBySex.csv&quot;</span></span><br><span class="line">        ) <span class="keyword">as</span> fid:</span><br><span class="line">            <span class="comment"># Read data, filter the correct variant</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>property</code> 参考 <a href="https://www.tianqiweiqi.com/python-property.html">Python内置属性函数@property详解</a></p></blockquote><h2 id="刷新要导入的包">刷新要导入的包</h2><p>当模块属性或者方法有更新，可以使用 <code>importlib</code> 重载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importlib.reload(module_name)</span><br></pre></td></tr></table></figure><h2 id="理解导入顺序">理解导入顺序</h2><p>如果你的模块名字和标准库中的一样，系统会优先使用标准库的。</p><p><code>import</code> 执行时有几步：</p><ol type="1"><li>检查模块缓存，<code>sys.modules</code></li><li>通过查找器查找模块</li><li>通过加载器加载模块</li></ol><p>你可以继承 python 的查找器实现你自己的 finder，甚至是自己的 loader，当然可能目前没有必要。</p><p>这里想说明的是，导入操作是有顺序的，在执行查找操作时， <code>sys.meta_path</code> 会控制哪个查找器会被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">FrozenImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib_external</span>.<span class="title">PathFinder</span>&#x27;&gt;]</span></span><br></pre></td></tr></table></figure><p>这里可以看到，内置的模块先于自定义的被加载。</p><p>如果你把当前环境下所有查找器移除，python 就无法查找任何包了，但 python 仍然可以导入一些包，因为有些包已经位于缓冲中了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;math&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib  <span class="comment"># Autoimported at start-up, still in the module cache</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib</span><br><span class="line">&lt;module <span class="string">&#x27;importlib&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;.../python/lib/python3.8/importlib/__init__.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>咱们自定义一下系统的查找器，让它在查找的时候打印，这样我们就知道了当我导入一个包，有哪些包导入了。</p><p>对于查找器，有一个要求就是它必须要实现 <code>.find_spec()</code> 这个类方法，这个方法会尝试去查找模块，如果它不知道怎么查，它应该返回 None，如果知道，则返回 <code>nodule spec</code>, 如果模块无法找到，则发起 <code>ModuleNotFoundError</code> 错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debug_importer.py</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DebugFinder</span>:</span></span><br><span class="line"><span class="meta">     @classmethod  </span><span class="comment"># 类方法，无需示例即可使用</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">f&quot;Importing <span class="subst">&#123;name!r&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">sys.meta_path.insert(<span class="number">0</span>, DebugFinder)</span><br></pre></td></tr></table></figure><p>上面的查找器打印后，返回 None, 表示它不知道怎么查，随后会交给其他查找器查。</p><p>你可以按需要自定义 <code>sys.meta_path</code> 的加载顺序。</p><p>将这个自定义查找器，放在 <code>sys.meta_path</code> 第一位，每次执行 <code>import</code> 你就可以看到所有被导入的模块。</p><p>通过这种自定义查找的方法，我们甚至可以写一个自动安装包的查找器，把它插到 <code>sys.meta_path</code> 末尾，因为如果在末尾的位置被执行，这意味着前面的查找器都没有找到你想要的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip_importer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipFinder</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Module <span class="subst">&#123;name!r&#125;</span> not installed.  Attempting to pip install&quot;</span>)</span><br><span class="line">        cmd = <span class="string">f&quot;<span class="subst">&#123;sys.executable&#125;</span> -m pip install <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subprocess.run(cmd.split(), check=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> util.find_spec(name)</span><br><span class="line"></span><br><span class="line">sys.meta_path.append(PipFinder)</span><br></pre></td></tr></table></figure><blockquote><p>只是随便一说，不要放到自己项目中用！可能会带来灾难性后果</p></blockquote><h2 id="例子-数据文件导入">例子: 数据文件导入</h2><p>这个例子灵感的来源是 Aleksey Bilogur, 他有一篇文章(<a href="https://blog.quiltdata.com/import-almost-anything-in-python-an-intro-to-module-loaders-and-finders-f5e7b15cda47">Import Almost Anything in Python: An Intro to Module Loaders and Finders</a>)，介绍了模块的加载器和查找器。</p><p>你可能实现过自定义的加载器加载数据文件，但能不能利用加载器和查找器直接 <code>import</code> csv 文件呢？就好像下面这个代码一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv_importer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> employees</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.name  <span class="comment"># 直接访问列名</span></span><br><span class="line">(<span class="string">&#x27;John Smith&#x27;</span>, <span class="string">&#x27;Erica Meyers&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> employees.data:  <span class="comment"># 直接访问数据</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row[<span class="string">&quot;department&quot;</span>])</span><br><span class="line">...</span><br><span class="line">Accounting</span><br><span class="line">IT</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.__file__  <span class="comment"># 访问文件名</span></span><br><span class="line"><span class="string">&#x27;employees.csv&#x27;</span></span><br></pre></td></tr></table></figure><p>其实是可以的，我们可以将路径传给查找器处理路径的问题，然后通过加载器读取数据文件，最终实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> ModuleSpec</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CsvImporter</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, csv_path</span>):</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod  </span><span class="comment"># 类方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 处理路径</span></span><br><span class="line">    <span class="comment"># 其他操作</span></span><br><span class="line"><span class="keyword">return</span> ModuleSpec(name, cls(csv_path))  <span class="comment"># 此处 cls() 构造一个类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_module</span>(<span class="params">self, module</span>):</span></span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line"><span class="comment"># 绑定到模块中</span></span><br><span class="line">module.__dict__.update(fields)</span><br><span class="line">        module.__dict__[<span class="string">&quot;data&quot;</span>] = data</span><br><span class="line">        module.__dict__[<span class="string">&quot;fieldnames&quot;</span>] = fieldnames</span><br><span class="line">        module.__file__ = <span class="built_in">str</span>(self.csv_path)</span><br></pre></td></tr></table></figure><h1 id="其他导入技巧">其他导入技巧</h1><h2 id="导入特定版本">导入特定版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><h2 id="有条件导入你喜欢的包">有条件导入你喜欢的包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> ujson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line">   </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> quicktions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br></pre></td></tr></table></figure><h2 id="处理包的缺失">处理包的缺失</h2><p>你可能有一些比较酷的想法，比如利用 <a href="https://pypi.org/project/colorama/">Colorama</a> 这个包来给你的输出增加一些颜色，但是这个包并不是一个必要的，如果用户电脑上有这个包，那可以，要是没有你希望也可以正常使用你的程序。</p><p>你可以参考 <a href="https://realpython.com/python-testing/">testing</a> 中对于 <a href="https://realpython.com/python-mock-library/">mocks</a> 的使用实现这个想法。</p><h2 id="将脚本导入为模块">将脚本导入为模块</h2><p>脚本和模块的区别在于，脚本主要是去 do_something, 而模块则提供函数以供使用。他们都存在于 python 文件中，就 Python 而言，其实它们并没有什么区别。</p><blockquote><p>有时候你的模块可能比较复杂，有脚本也有模块，这时候可以考虑<a href="https://realpython.com/python-refactoring/">refactor</a>你的模块。</p></blockquote><p>但你也可以让你的模块提供两者的功能，既有函数，也可以直接执行，相信你看到过这种 python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="从-zip-文件启动脚本">从 ZIP 文件启动脚本</h2><p>新建一个 <code>__main__.py</code> 文件，打包成压缩包，你便可以直接通过 <code>python zip_file_name.zip</code> 这种形式运行。</p><p>你可以将你自己的包也按照这种方式处理，但 python 有提供了一个工具 <a href="https://docs.python.org/library/zipapp.html"><code>zipapp</code></a>，它可以帮你处理这些事情。</p><p>你只需要在你的包目录执行 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m zipapp population_quiz -m population_quiz:main</span><br></pre></td></tr></table></figure><p>它会做两件事，一是为你的程序添加入口，二是打包你的程序。</p><p>这里的 <code>__main__.py</code> 会自动生成，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> population_quiz</span><br><span class="line">population_quiz.main()</span><br></pre></td></tr></table></figure><p>上面的命令执行后，会产生 <code>.pyz</code> 的打包文件，在 windows 上应该可以直接执行，因为 <code>.pyz</code> 文件应该自动关联了运行程序，而在 Linux 或者 Mac 上，可以通过 -p 指定运行环境:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m zipapp population_quiz -m population_quiz:main \</span><br><span class="line">&gt;   -p <span class="string">&quot;/usr/bin/env python&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意在 zip 文件中，如果处理数据文件，open 方法会无法使用</p></blockquote><h2 id="处理循环导入">处理循环导入</h2><p>循环导入就是你中有我我中有你，比如</p><p><img src="https://i.loli.net/2021/09/21/V4rsyDKYe312CT7.png" /></p><p>这种情况本会发生无限递归循环，但是因为我们的老朋友模块缓存所以避免了惨剧的发生。</p><p>但是在下面这种情况，则会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yin.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yin&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yang</span><br><span class="line">number = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yang.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># yang.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yang&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yin</span><br><span class="line">number = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;yin and yang combined is <span class="subst">&#123;combine()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yang&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行 <code>import yin</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yin <span class="comment">#导入 yin 的时候，yin 中的 number 没有还没有定义</span></span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">  File <span class="string">&quot;.../yang.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> combine</span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line">AttributeError: module <span class="string">&#x27;yin&#x27;</span> has no attribute <span class="string">&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure><p>执行 <code>import yang</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yang  <span class="comment">#yang 调用 combine() 的时候，yin 已经初始化完成</span></span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Goodbye <span class="keyword">from</span> yin</span><br><span class="line">yin <span class="keyword">and</span> yang combined <span class="keyword">is</span> <span class="number">66</span></span><br><span class="line">Goodbye <span class="keyword">from</span> yang</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢？其实你的模块如果有存在互相引用，这意味着你的模块设计的不好，你需要想想怎么去组织你的代码。</p><h2 id="优化你的导入速度">优化你的导入速度</h2><p>你可能有些包导入的速度很慢，你想了解具体是在哪里速度变慢，自从 Python3.7 你可以有一个非常简单的办法了解你导入包的速度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python -X importtime -c <span class="string">&quot;import datetime&quot;</span></span><br><span class="line">import time: self [us] | cumulative | imported package</span><br><span class="line">...</span><br><span class="line">import time:        87 |         87 |   time</span><br><span class="line">import time:       180 |        180 |   math</span><br><span class="line">import time:       234 |        234 |   _datetime</span><br><span class="line">import time:       820 |       1320 | datetime</span><br></pre></td></tr></table></figure><p>cumulative 列按包显示了导入的累计时间（以微秒为单位）。</p><h1 id="总结">总结</h1><p>这篇文章主要介绍了：</p><ul><li>命名空间包</li><li>导入资源和数据文件</li><li>使用动态导入</li><li>扩展 Python 的导入机制</li><li>处理不同版本的包</li></ul><p>这里还有一些优秀的参考信息：</p><ul><li><a href="https://docs.python.org/reference/import.html">The import system</a></li><li><a href="https://docs.python.org/library/importlib.html">The <code>importlib</code> package</a></li><li><a href="https://www.python.org/dev/peps/pep-0420/">PEP 420: Implicit namespace packages</a></li><li><a href="https://docs.python.org/library/modules.html">Importing modules</a></li></ul><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-import/#basic-python-import">Python import: Advanced Techniques and Tips</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p05_separate_directories_import_by_namespace.html">利用命名空间导入目录分散的代码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章深入研究了 &lt;code&gt;import&lt;/code&gt; 命令以及它的工作原理。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="https://scottzhang.pro/categories/python/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 模块与包</title>
    <link href="https://scottzhang.pro/article/c8bc6f6.html"/>
    <id>https://scottzhang.pro/article/c8bc6f6.html</id>
    <published>2021-09-18T09:59:07.000Z</published>
    <updated>2021-11-27T08:36:33.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章会介绍 Python 中的模块和包。</p></blockquote><span id="more"></span><h1 id="python---模块与包">Python - 模块与包</h1><p>引申出模块化编程的概念，即将代码分解成小模块，各自解决不同的问题，这样使得代码更简单 (<strong>Simplicity</strong>)，容易维护 (<strong>Maintainability</strong>)，也更容易分享、重用代码 (<strong>Reusability</strong>)。</p><p>Python 中的模块主要有三种：</p><ol type="1"><li>用Python写的模块</li><li>用C 写的模块</li><li>内置的模块如 <code>itertools</code> 模块</li></ol><p>这篇文章只关注 Python 写的模块。</p><h1 id="模块的搜索路径">模块的搜索路径</h1><p>假设你写了个模块 <code>mod.py</code> , 怎么使用呢？</p><p>如果你当前工作目录在合适的位置，你可以执行 <code>import mod</code>, 然后你便可以引用其中的对象，那什么叫合适的位置？</p><ol type="1"><li>与 <code>mod.py</code> 同一位置</li><li>你的模块位置被包含在 <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> 中</li><li>模块位置在安装 Python 时标准链接库目录是定义过</li><li>你创建了一个 <code>.pth</code> 文件告诉 Python 去哪里找，此模块位于其中</li></ol><p>上面四种情况，只有 <code>PYTHONPATH</code> 环境变量和路径文件可以被用户配置。</p><p>Python 会自动去寻找这些地方是否有你需要的包，你可以通过 <code>sys.path</code> 查看它的搜索顺序。</p><p>所以还有一种方法导入包，即将你的包地址放入 <code>sys.path</code>，它是一个列表，所以你可以执行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">r&#x27;C:\Users\john&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> mod</span><br></pre></td></tr></table></figure><p>当模块被导入后，你也可以通过 <code>mod.__file__</code> 查看包的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Users\\john\\mod.py&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Python36\\lib\\re.py&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="导入模块">导入模块</h1><p>模块的存在是为了被导入 <code>import</code> 以使用, 就像钢琴的存在是被人演奏以产生音乐。</p><h2 id="import-module_name">import module_name</h2><p><code>import</code> 上面已有例子，需注意 <code>import</code> 不能让你直接使用所有模块内的内容。模块有其私有符号表 (<strong>private symbol table</strong>), 模块以此来确定各自之间的边界。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zoo</span><br><span class="line"><span class="built_in">print</span>(zoo.dog)  <span class="comment"># yes</span></span><br><span class="line"><span class="built_in">print</span>(dog)  <span class="comment"># no, dog 位于 zoo 中</span></span><br></pre></td></tr></table></figure><h2 id="from-module_name-import-name">from module_name import name</h2><p>另一种导入模块的方式是直接导入模块内的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module_name&gt; <span class="keyword">import</span> &lt;name(s)&gt;</span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> dog, pig  <span class="comment"># 只需要特定对象</span></span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> *  <span class="comment"># 需要所有对象</span></span><br></pre></td></tr></table></figure><p>需要小心 <code>from &lt;module_name&gt; import *</code> 这种方式，除非你很清楚自己在做什么。</p><h2 id="from-module_name-import-name-as-alt_name">from module_name import name as alt_name</h2><p>这种方式和上面的一样，只是多了 <code>as</code> 关键字以定义别名。</p><h2 id="导入提示">导入提示</h2><p>导入模块的语句通常写在文件首部，但也可以写在函数中，不过 Python3 不允许在函数中 <code>import *</code>。</p><p>防止模块导入失败，可以使用 <code>try...except...</code> 语句捕捉 <code>ImportError</code>错误。</p><p><code>dir()</code> 函数可以返回当前命名空间中所有的变量。</p><p>导入模块的时候，模块的代码将会执行，如果希望模块内的某些代码只是在你需要的时候才调用执行，可以加入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__name__ == <span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line"><span class="keyword">pass</span>  <span class="comment"># do you work</span></span><br></pre></td></tr></table></figure><p>导入模块的操作只会执行一次，考虑以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.a</span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br></pre></td></tr></table></figure><p>发现第二次和第三次导入并未输出，如果想要每次导入操作都重新导入，可利用 <code>importlib</code> 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib.reload(mod)</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">&lt;module <span class="string">&#x27;mod&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\Users\\john\\Documents\\Python\\doc\\mod.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>模块可以被当作脚本执行，只需要在模块所在文件夹增加一个 <code>__main__.py</code> 文件。</p><h1 id="python-包">Python 包</h1><p>包是一组或多组模块，包可以让你通过包的名字简单的访问其下面的各种模块。</p><p>下面是一个包的结构，其中有两个模块。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br></pre></td></tr></table></figure> 这时候如果你在 <code>pkg</code> 上级目录执行 <code>import pkg</code> 该包里将不会包括任何东西，无法引用 mod1 也无法引用 mod2 中的内容。</p><h2 id="init__.py"><code>__init__.py</code></h2><p>如果在 pkg 目录下新增 <code>__init__.py</code> 文件，则可以引用 <code>__init__</code>中的的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br><span class="line">__init__.py</span><br></pre></td></tr></table></figure><p>在内部 mod1 模块中，你也可以访问<code>__init__</code> 中的对象。</p><p>如果想在外部通过 <code>import pkg</code> 的方式，通过 <code>pkg</code> 访问 <code>mod1</code> 或 <code>mod2</code> 中的对象，则需要在 <code>__init__</code> 中导入 <code>mod1</code> 和 <code>mod2</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In __init__.py</span></span><br><span class="line"><span class="keyword">import</span> pkg.mod1, pkg.mod2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 Mod1 和 Mod2</span></span><br><span class="line"><span class="keyword">import</span> pkg</span><br><span class="line"></span><br><span class="line">pkg.mod1.foo()</span><br><span class="line"></span><br><span class="line">pkg.mod2.bar()</span><br></pre></td></tr></table></figure><blockquote><p>在 Python3.3 之后，<a href="https://www.python.org/dev/peps/pep-0420/">Implicit Namespace Packages</a> 发布了，定义包也可以不新建 <code>__init__</code> 了。</p></blockquote><h2 id="all__"><code>__all__</code></h2><p>你肯定写过 <code>from &lt;package_name&gt; import *</code> 这样的代码，其中 * 代表的是 import 什么？</p><p>如果在包的 <code>__init__.py</code> 中定义 <code>__all__</code> 来进行控制。</p><p><em><strong>pkg/__init__.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [</span><br><span class="line">        <span class="string">&#x27;mod1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod4&#x27;</span></span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>则所有其中的内容都会在写 <code>from pkg import *</code> 的时候，自动导入。</p><p>在模块中定义 <code>__all__</code> 亦是。</p><p><em><strong>pkg/mod1.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"><span class="comment"># 当使用 `from pkg.mod1 import *` 的时候，只有 foo 会被导入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod1] foo()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>区别是：</p><ul><li>对于一个包，如果<code>__all__</code> 没有定义，<code>import *</code> 不会导入任何对象</li><li>对于一个模块，如果<code>__all__</code> 没有定义，<code>import *</code> 默认导入所有对象</li></ul><h1 id="python-子包">Python 子包</h1><p>包中可以放子包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg1</span><br><span class="line">    │      mod1.py</span><br><span class="line">    │      mod2.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg2</span><br><span class="line">    │      mod3.py</span><br><span class="line">    │      mod4.py</span><br></pre></td></tr></table></figure><p>使用方式则需要一层一层使用 <code>.</code> 语法下钻:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg.sub_pkg1.mod1</span><br><span class="line">pkg.sub_pkg1.mod1.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1 <span class="keyword">import</span> mod2</span><br><span class="line">mod2.bar()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod3 <span class="keyword">import</span> baz</span><br><span class="line">baz()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod4 <span class="keyword">import</span> qux <span class="keyword">as</span> grault</span><br><span class="line">grault()</span><br></pre></td></tr></table></figure><p>如果是兄弟模块之间要导入模块怎么办？有两种方式：</p><p>全路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>相对路径: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> sub_pkg1</span><br><span class="line"><span class="built_in">print</span>(sub_pkg1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-modules-packages/">Real Python - Python Modules and Packages – An Introduction</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章会介绍 Python 中的模块和包。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="https://scottzhang.pro/categories/python/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 与 Go 开发环境配置</title>
    <link href="https://scottzhang.pro/article/dfea7f59.html"/>
    <id>https://scottzhang.pro/article/dfea7f59.html</id>
    <published>2021-09-14T04:50:03.000Z</published>
    <updated>2021-11-27T08:34:21.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。</p></blockquote><span id="more"></span><h1 id="centos-7-开发环境配置">CentOS 7 开发环境配置</h1><h2 id="git">Git</h2><blockquote><p>略过。</p></blockquote><h2 id="docker">Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 docker 进程</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 docker 阿里云镜像，容器镜像服务</span></span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://8szzfxmd.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 docker-compose</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html">如何检查进程？</a></p></blockquote><h2 id="mysql">Mysql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 mysql</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 mysql</span></span><br><span class="line">docker run -p 3306:3306 --name mymysql -v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d -V <span class="variable">$PWD</span>/logs:logs -v <span class="variable">$PWD</span>/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234@Abc -d mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 docker 的容器</span></span><br><span class="line">docker ps -a (ps: Process Status, from linux)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 mysql 容器并启动 bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -it a7a8e9df1270 /bin/bash</span><br><span class="line">myql -uroot -pyoupassword</span><br></pre></td></tr></table></figure><h2 id="python">Python</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anaconda in centos7</span></span><br><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh</span><br><span class="line">bash naconda3-5.3.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://linuxize.com/post/how-to-install-anaconda-on-centos-7/">Install &amp; uninstall Anaconda on centos7</a></p></blockquote><h2 id="go">Go</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go 环境变量</span></span><br><span class="line">go env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 go module</span></span><br><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello golang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行运行 </span></span><br><span class="line"><span class="keyword">go</span> run .\hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译文件, c/c++ -&gt; .so .lib .dll; java -&gt; .class; go -&gt; windows exe</span></span><br><span class="line"><span class="keyword">go</span> build .\hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="go" scheme="https://scottzhang.pro/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库-维度建模</title>
    <link href="https://scottzhang.pro/article/c721127b.html"/>
    <id>https://scottzhang.pro/article/c721127b.html</id>
    <published>2021-09-14T03:39:28.000Z</published>
    <updated>2021-11-27T08:44:53.725Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据仓库、商业智能初步，常用维度建模架构对比。</p></blockquote><span id="more"></span><h1 id="业务管理的问题">业务管理的问题</h1><p>信息系统存在的目的是解决业务的问题，对于数据仓库 Data WareHouse 和商业智能 Business Intelligence 来说，下面这些问题已经存在了几十年了：</p><ul><li>收集了很多数据却无法访问</li><li>需要对数据做切片、切块</li><li>分析师、业务人员需要方便的获取数据</li><li>怎么展示最重要的事情</li><li>花费大量时间在研究数字的正确性，而不是业务决策</li><li>希望使用信息做更多基于事实的决策</li></ul><p>这些问题对应了数据仓库与商业智能的目标，解决这些业务问题，信息系统必须做到：</p><ul><li>方便的存取信息</li><li>一致性的形式展示信息</li><li>能够适应变化</li><li>及时的展示信息</li><li>保护信息财富</li><li>成为提高决策制定能力的权威</li><li>业务群体的认可</li></ul><p>作为一个 DW/BI 管理者，你的责任则更具体：</p><ol type="1"><li>理解业务用户</li><li>对业务用户发布高质量、相关的、可访问的信息和分析</li><li>维护 DW/BI 环境</li></ol><h1 id="维度建模">维度建模</h1><blockquote><p>爱因斯坦曾说: <strong>凡事应该尽量简单，直到不能再简单为止</strong>。</p></blockquote><p>维度建模是展示分析数据的首选技术，它的优势在于能以商业用户可理解的方式发布数据并提供了高效的查询性能。它最初是用来简化数据库的，在维度建模中最开始使用的数据模型通常越简单越好，复杂的开始会导致最终的模型也很复杂。</p><p>维度模型通常建立在关系型数据库上，但这不意味着维度模型必须满足关系型数据库的要求，比如第三范式（3NF）。</p><p>3NF 是为了减少数据冗余，它会将数据划分成不同的实体，每个实体构成一个关系表。</p><p>但 3NF 不适用于 BI，主要是其模式太复杂，3NF 主要应用在操作性过程中，而不是 BI 查询，维度建模可以解决模式过分复杂的问题。</p><p>维度建模在不同的数据库系统中有不同的叫法：</p><ul><li>关系数据库 -&gt; 星型模式</li><li>多维数据库 -&gt; 联机分析处理</li></ul><h2 id="事实表与维度表">事实表与维度表</h2><p>在维度建模中，存在两类表：</p><ul><li>事实表（数量，销售额，需注意可加性和不可加性，比如账户结余不可加）</li><li>维度表（谁、什么、哪里、何时、如何、为什么）</li></ul><p>事实表中一条记录所表达的业务细节程度被称为<strong>粒度</strong>。通常粒度可以通过两种方式来表述：一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。</p><p>事实表的粒度有三类：事务周期快照累快照，个。 事实表通常只有很少的列和很多行，是一种<strong>“瘦高”</strong>型的表。事实表定义为以下三种类型之一：</p><ul><li>事务事实表:记录有关特定事件的事实（例如，销售事件，保存在原子的粒度，也称为原子事实表）</li><li>周期快照事实表记录给定时间点的事实（例如，月末的帐户详细信息）</li><li>累积快照事实表记录了给定时间点的汇总事实（例如，某产品的当月迄今总销售额）</li></ul><p>作为度量业务过程的事实，一般为整型或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完全不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚集。</p><p>一般事实表具有两个或更多外键与维度表关联，比如事实表中的产品键始终与产品维度中的特定产品键匹配。如果事实表中所有键与维度表中的都匹配，则满足了 <code>参照完整性</code>, 可以通过维度表使用连接操作访问事实表。</p><figure><img src="https://i.loli.net/2021/09/14/1GKmvWe2dBNwols.jpg" alt="事实表与维度表" /><figcaption aria-hidden="true">事实表与维度表</figcaption></figure><p>事实表通常包含外键集合的主键，具有组合键的表即事实表，事实表通常具有多对多的关系。</p><p>维度是维度建模的基础和灵魂。在维度建模中，将度量称为<strong>事实</strong>，将环境描述为<strong>维度</strong>，维度是用于分析事实所需要的多样环境。</p><p>维度表通常有很多列、属性，维度表倾向于包含少量的行，一般用维度表来作为查询的约束、分组。</p><p>多数情况下，数据仓库的好坏直接取决于维度属性的设置，也决定了 DW/BI 的分析能力，强大的维度属性等于健壮的分片、分块分析能力。</p><p>对维度表的设计重点关注简单性和可访问性，可以不满足第三范式。</p><h1 id="kimball-的-dwbi-架构">Kimball 的 DW/BI 架构</h1><figure><img src="https://i.loli.net/2021/09/14/9LHTwZXSxevy48a.png" alt="Kimball 架构" /><figcaption aria-hidden="true">Kimball 架构</figcaption></figure><h2 id="操作型源系统">操作型源系统</h2><p>该系统面对很多用户，并发事务很多。多是插入、更新操作。对数据的插入，更新性能要求更高，因此数据多是规范化的，规范化是指冗余度比较少。</p><h2 id="etl-系统">ETL 系统</h2><p>处理操作型源系统与DW/BI 之间，该系统对数据的处理分为三个部分：</p><ol type="1"><li>获取 Extract，从操作型系统导入到 DW/BI</li><li>转换 Transformation，清洗，合并，复制等</li><li>加载 Load，构建和加载数据到<code>展现区域</code>的目标维度模型</li></ol><p>展现区域用于组织、存储，用户也可以在这里制作报表，查询，这是用户主要关注的区域，关于展现区，该书作者有两点建议：</p><ol type="1"><li>数据应该以维度模型来展现（星型或OLAP多维数据库）</li><li>必须包含到最详细的原子数据级别</li></ol><h2 id="bi-应用">BI 应用</h2><p>这是最后一个主要的部件，BI 突出的是支持商业决策的能力，它可以很简单，也可以很复杂。</p><h1 id="其他-dwbi-架构">其他 DW/BI 架构</h1><p>第一种是独立数据集市，特点是以部门为架构组织，只考虑本部门的需要与业务规则，但不同部门之间的数据访问与标准各异，很多数值无法匹配。</p><p>这种架构代表了一种 DW/BI 架构，但其实属于没有结构，容易造成混乱。虽然可以低成本实现快速开发，但会存在分析数据冗余的问题，不是长远之计。</p><figure><img src="https://i.loli.net/2021/09/14/XUFEgK8xyf6VS4L.jpg" alt="简化的独立数据集市" /><figcaption aria-hidden="true">简化的独立数据集市</figcaption></figure><p>第二种是辐射状企业信息工厂(Corporate Information Factory) Inmon 架构，它的数据从操作型数据库获取，经过 ETL 会保存在满足第三范式的数据库中，称为 EDW (Enterprise Data Warehouse).</p><p>EDW 中的数据都是规范化的，原子级别的，相当于有一个中间过程协调与集成数据，缺点是它的下游数据组织形式以部门为单位，且包含的是聚集数据，非原子级别的数据，而对业务用户暴露原子级别的数据是有必要的，<strong>聚集数据比原子数据提供了更好的性能，但不能取代细节数据</strong>。</p><figure><img src="https://i.loli.net/2021/09/14/bNcup7VxdTjy1If.jpg" alt="CIF" /><figcaption aria-hidden="true">CIF</figcaption></figure><p>最后还有一种混合了 CIF 与 Kimball 模式的架构，有人说这是最好的架构因为混合了前面的两种架构，但是这也意味着更多的开销与时间，无论是开发还是运行期间，因为数据需要更多次的移动，细节数据冗余存储。</p><p>如果你已经建立了第三范式的 EDW，但无法让用户更灵活的实现报表与分析，可以采用这种模式。</p><h1 id="维度建模的误解">维度建模的误解</h1><p>维度模型被广泛使用，但也还存在很多误解，如：</p><ul><li>它仅包含汇总数据</li><li>它是部门级的，不是企业级的</li><li>它不可扩展</li><li>它仅用于预测</li><li>它不能被集成</li></ul><p>实际上，维度模型可以存储大量历史数据，按照业务过程组织即可满足企业级的要求，事实表非常容易扩展，数据库提供商也在不断优化维度模型的可扩展性和性能。</p><p>维度模型对业务的适应性也很强，业务需求可能是经常变化的，但维度模型具有对称性，只要以最细粒度级别构建事实表，加上维度结构非常灵活，可以很好的满足业务需要。</p><blockquote><p>细节就是上帝。—— 建筑师 Mies van der Rohe</p></blockquote><h1 id="参考">参考</h1><ul><li><a href="https://jiamaoxiang.top/2020/07/11/数仓-大数据时代-维度建模过时了吗/">数仓-大数据时代-维度建模过时了吗?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据仓库、商业智能初步，常用维度建模架构对比。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据工程" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="数据仓库" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    <category term="商业智能" scheme="https://scottzhang.pro/tags/%E5%95%86%E4%B8%9A%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>B 树索引与位图索引简述</title>
    <link href="https://scottzhang.pro/article/a8fa00e8.html"/>
    <id>https://scottzhang.pro/article/a8fa00e8.html</id>
    <published>2021-09-09T13:04:16.000Z</published>
    <updated>2021-11-27T08:28:55.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。</p></blockquote><span id="more"></span><p>在 Oracle 中， 可以使用 <code>CREATE INDEX</code> 创建索引，索引的类型有以下几种：</p><ul><li><p>Normal indexes (Oracle Database 默认使用的 B-tree 索引)</p></li><li><p>Bitmap indexes (用一个bit位来标记某个元素 rowid 对应的Value)</p></li></ul><blockquote><p>Refer <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5010.htm">Oracle 官方文档</a></p></blockquote><h1 id="b-tree">B-tree</h1><p>B-tree 的出现主要是为了提高访问磁盘的速度。那为什么使用 B-tree 实现而不是其他的数据结构呢？</p><p>对于二叉搜索树，红黑树，avl 树来说，每一个节点只能存储一个 key，如果你需要存储大量的 key，使用这些数据结构就会让树变得很高，但 B-tree 在一个节点内就可以存储多个 key，且可以拥有多个子节点，这就可以降低树的高度，提高磁盘访问速度。</p><p>那一个节点内可以存储多少个 key，可以拥有多少个子节点呢？</p><p>假设用 k (取值范围M-M/2)表示，则 B-tree 中的每个节点可以有 k-1 个 key，以及 k 个子树。</p><p>所谓 M 阶（m-way）B树，其中 M 就是表示 B-tree 中每个节点最多可以有几个子树。</p><h1 id="b-tree-1">B+ tree</h1><p>B+ tree 是 B-tree 的升级版，一棵 B+ 树需要满足以下条件:</p><ol type="1"><li>节点的子树数和关键字(Key)数相同（B 树是关键字数比子树数少一）</li><li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li><li>叶子节点包含了全部数据，同时符合左小右大的顺序</li></ol><p>B+ 树数据都在叶子节点，并使用一个链表将它们排列起来，这样在查询时效率更快。</p><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。</p><h1 id="bitmap-索引">Bitmap 索引</h1><p>我们知道计算机所有信息最终都是通过“位bit”来运算的，二进制位运算在计算机中非常高效。而位图索引也是用0或1来处理索引进程，故得名位图索引。 位图索引主要针对大量相同值的列而创建的，索引块的一个索引行中存储键值、起止RowId及此键值的位图，根据位图信息可以得知每一条记录的ROWID。它为列的每个键值建立位图，位图中的每一位可能对应多个列，位图中位的值为1表示此行的值为对应的键值。</p><p>特点：</p><ul><li>可以存储null值；</li><li>不适合键值较多的列（重复数据较少的列）,适合只有几个固定值的列；如性别、婚姻状况、行政区等等</li><li>相对于B*Tree索引,占用的空间非常小,创建和使用非常快；</li><li>适合静态数据，而不适合索引频繁更新的列；</li><li>使用count、and、or或in查询时,直接用索引的位图进行或运算,快速得出结果行数据。</li></ul><h1 id="参考">参考</h1><ul><li><a href="https://juejin.cn/post/6844903613915987975">理解 B 树、B+ 树特点及使用场景</a></li><li><a href="https://www.programiz.com/dsa/b-tree">B-tree 介绍与代码实现</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-tree 动态交互图</a></li><li><a href="https://bbs.huaweicloud.com/blogs/114861">Oracle 索引概述</a></li><li><a href="http://tech.jasonsoso.com/2015/01/B-tree-indexes-and-bitmap-indexes/">B 树索引与位图索引简述</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据库" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://scottzhang.pro/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>数据分析在做什么</title>
    <link href="https://scottzhang.pro/article/a31aaf3c.html"/>
    <id>https://scottzhang.pro/article/a31aaf3c.html</id>
    <published>2021-09-06T15:42:25.000Z</published>
    <updated>2021-11-27T08:43:13.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据分析即做比较。</p></blockquote><span id="more"></span><h1 id="数据分析在做什么">数据分析在做什么？</h1><p>数据分析本质上做对比，所以首先考虑的问题是和谁比，怎么比，比什么。 其次，分析对应的是分解问题，分析拆解后的复杂事物，得到拆解元素之间的联系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据分析 -&gt; 拆分、分解问题 -&gt; 比较</span><br></pre></td></tr></table></figure><p>数据的字段 (Field) 有各种类型，如：</p><ol type="1"><li>定类尺度（性别）</li><li>定序尺度（成绩优良中下）</li><li>定距尺度（30比20高10）</li><li>定比尺度（项目数，每月工时）</li></ol><p>同样，对于数据的属性也有好几种，如离散属性以及连续属性。离散属性中有频率与频数。连续属性则有：</p><ol type="1"><li>平均值</li><li>中位数、分位数</li><li>众数</li><li>方差、标准差、自由度</li><li>偏态系数</li><li>峰态系数</li></ol><h1 id="怎么比">怎么比</h1><p>首先来看怎么比的问题，简单的多少、长短也是比较，对于数据分析我们有如下几种常用的类型。</p><ol type="1"><li>假设检验，一致还是不一致</li><li>多维分析与钻取分析（Drill Down，Roll up）</li><li>交叉分析与透视表</li><li>秩次比较</li><li>相关分析</li><li>回归探索</li><li>自由分组与归类</li></ol><blockquote><p>这里说的是什么暂时不理解没关系，之后会单独拿出来讲。</p></blockquote><h2 id="一致还是不一致">一致还是不一致</h2><p>我们可以通过假设检验来回答一致还是不一致的问题，先解释假设检验中的两个单词: <code>H0</code> 和 <code>H1</code>。</p><ul><li><code>H0</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差是由自然误差引起的</li><li><code>H1</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差存在本质上的差别</li></ul><p>拒绝<code>H0</code> 的成立，就可以对数据的比较做出结论推断，通常需要确定最大概率，用 <span class="math inline">\(\alpha\)</span> 表示，常见的情况下取 0.05 或 0.01， 如果原假设发生的概率小于 <span class="math inline">\(\alpha\)</span> 则可以拒绝 <code>H0</code>。 为了拒绝原假设，需要进行检验，即检验统计量，检验统计量的方法有很多种，在不同的场景下对应着不同的检验方法，常见的检验方法及应用场景有：</p><ul><li>Z 检验， 样本均值是否与正态分布总体一致？</li><li>T 检验，样本平均数与整体平均数</li><li>F 检验，多组样本间的一致性比较</li><li>卡方检验， 两个分部是否一致的差异</li><li>秩和检验， 摆脱对总体分布的依赖，秩理解为名次</li><li>A/B Test，新功能衡量部分用户的表现，上不上？</li><li>低功效实验，P值</li></ul><p>需注意不同的检验方法的要求与统计量的计算方式不同，需要根据实际情况选择。</p><p>假设检验的结果也有可能是错的，主要有两类错误：</p><ul><li>第一类错误，是真实情况为 <em><code>H0</code></em> 成立，但判断结论为拒绝 <em><code>H0</code></em>， 也就是把真的当成了假的</li><li>第二类错误，是真实情况为 <em><code>H0</code></em> 不成立，但判断结果接受 <em><code>H0</code></em>，也就是把假的当成了真的</li></ul><p>在饱和的情况下，这两类的错误属于此消彼长的关系，当降低第一类错误发生概率时，第二类错误发生的概率会增加，反之亦然。</p><h2 id="假设检验公式">假设检验公式</h2><ul><li>Z检验, <span class="math inline">\(Z = \frac{(\bar{x}-\mu_0)}{s}\)</span> = <span class="math inline">\(\frac{(sample average-mean)}{standard\ deviation}\)</span></li></ul><h2 id="多维分析与钻取分析">多维分析与钻取分析</h2><p>多维分析的问题类似，调查北京有多少厨师？你需要列举所有可能的与厨师数量的属性，比如餐馆的数量、门店类型、分布规律等。</p><p>钻取分析的例子，假设某月，可乐的销量突然上涨，你想知道具体是在什么地区上涨（Contributing)。</p><p>多维分析是从多个角度、多个维度分析。钻取分析则是从维度变化的角度考虑，扩大或者缩小分析粒度。</p><p>多维分析可以在不同对象的相同维度下进行比较，也可以在相同对象的不同维度下，甚至是不同对象的不同维度，只要有业务支持。具体的方法可以比数值、也可以比占比。其精髓在于尽可能的罗列所有维度。</p><p>钻取分析需要注意其陷阱，因为<strong>下钻的层次越深，复合特征的样本越来越少，越少的样本代表着越高的风险，也会导致越不可靠的结论。</strong></p><p>其次钻取的顺序也需要注意，比如调查离职员工的规律，为什么先从部门开始钻取，而不是其他？这里需要有个标准，一般来说<strong>区分程度最大的下钻方式应该排在最前面</strong>，如何衡量这个区分度呢？这就属于决策树中的内容了。</p><p>另外一个钻取的陷阱是<a href="https://wiki.mbalib.com/wiki/辛普森悖论">辛普森悖论</a>， 这里不做多介绍，感兴趣的可以打开链接了解。</p><h2 id="交叉分析与透视表">交叉分析与透视表</h2><p>这部分如果会使用 Excel 的 Pivot Table，或者 Pandas 里的 <code>groupby</code>， <code>pivot</code> 或 <code>pivot_table</code> 方法就懂了，在此不做解释。</p><h2 id="秩次比较">秩次比较</h2><blockquote><p>未完待续...</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据分析即做比较。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据分析" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>统计基础概念</title>
    <link href="https://scottzhang.pro/article/4187072417.html"/>
    <id>https://scottzhang.pro/article/4187072417.html</id>
    <published>2021-08-15T15:03:54.000Z</published>
    <updated>2021-11-27T08:22:27.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概率与统计的基础概念。</p></blockquote><span id="more"></span><h1 id="统计">统计</h1><p>数据类型： - 离散类型，只能是某些既定的值 - 连续类型，可以是一个范围里任何的值</p><p>离散数据是数出来的，连续数据是测量出来的。对于离散概率分布，我们关心的是取得一个特定数值的概率。例如抛硬币正面向上的概率为:p(x=正面)=1/2</p><p>而对于连续概率分布来说，我们无法给出每一个数值的概率，因为我们不可能列举每一个精确数值。</p><h2 id="histograms直方图">1. Histograms（直方图）</h2><p>定义：是一种对数据分布情况的图形表示，横轴是统计样本，纵轴是统计样本某个属性的度量。</p><p>我们测试人的身高，把这些数据放到数轴上，并分段，把数据这个段（bins）的数据从下往上堆，就得到了直方图。</p><p>有了这个图，我们就可以预测未来的到某个身高值的概率。</p><p>比如，你敢打赌下一个测量的人，有很大的几率处在直方图靠近中间的位置。</p><p>如果你想要用一个图，来近似表示你的数据，或未来预测的测量值，就可以使用直方图。</p><p>直方图中的bins的选择，很重要，太小或太大都不行，不要仅仅依靠程序的默认值。</p><h2 id="statistical-distribution概率分布">2. Statistical distribution（概率分布）</h2><p>现在你拿到了直方图，你的bins可能需要调整一下，你从1调整为0.5，这样让你的图像更直观，同时，也让你对数据的预测更准确。</p><p>你会发现，你的数据量越多，和你的bins越小，都可以提高你对数据预测的准确率。</p><p>你可以用一条曲线来表示分布，他比直方图更准确，因为直方图总会有在某个区间的值比较少或没有的情况，而曲线是连续的，且很方便计算。</p><p>另外，当你没有足够的资源和钱做足够的测试，你其实可以用既有的数据算出这跟我曲线。曲线图和分布图都是描述分布的一种方式。</p><h2 id="normal-distribution正态分布">3. Normal Distribution（正态分布）</h2><p>我们看过身高的数据，会发现它是左右对称的，事实上人类身高是一种正态分布。</p><p>刚出生的小孩和成年人的分布不一样，成年人高矮的区间比较大，而刚出生的小孩身高区间都在一个比较小的范围。</p><p>这个分布的宽度（即身高的区间）由数据的标准差决定。</p><p>知道这个标准差很重要，如在小孩的分布中，图像标准差为0.6，成人的为4.</p><p>我们可以知道 95% 的数据会落在（平均值 +- 2* 标准差），自然界的很多事物都遵循正态分布，这是因为什么呢？这就是中心极限定理</p><h2 id="population-parameters总体参数">4. Population Parameters（总体参数）</h2><p>我们选择测量一些基因数据，得到了一个直方图，通过直方图计算概率。</p><p><img src="https://i.loli.net/2020/03/28/lbg2cPIiaHqfGBD.png" /></p><p>这个分布的 mean=20, std=10。</p><p>同样的，我们也可以根据曲线图来计算概率。</p><p><img src="https://i.loli.net/2020/03/28/FgTQjHkDPYcIoUs.png" /></p><p>因为上述的直方图和曲线图，表示了所有的基因数据分布，在统计上会叫它为population，而mean和std，叫做 population mean 和 population std.</p><p>分布有很多种，有： - 指数分布，指数分布的参数是rate,即population rate. - Gamma 分布, 参数是 shape 和 rate</p><p>知道 population 参数的原因是，你的分布可以重复计算. 如果你有机器学习基础，你可以把 population参数看作是 training dataset, 曲线则是我们想要根据我们的方法作出的预测。</p><p>事实上，你测量的数据得到的population参数，每次都是不一样的，那怎么估计真实的参数呢？事实上，当你做的测量越多，你得到的参数，就越接近真实的参数。</p><p>统计的一个目的就是，根据你现有测量的数据，你对这个真实的参数，有多大的信心估计正确了。</p><p>特别的，我们一般用 p-value 和 置信区间来描述这种信心。</p><p>数据也多，你的信心就越大，</p><h3 id="bootstrap-refresher">bootstrap refresher</h3><p>我们测量12只母老鼠的体重，并计算这组老鼠体重的的平均值，这个平均值只是这12只老鼠的，而利用sample，我们可以利用手中已有的值，去估计所有老鼠体重的平均值。</p><p>怎么做的，用 sampling with replacement，即有放回的抽样，抽12次之后，计算平均值。</p><p>重复上面的步骤很多次，对这些平均值再取平均，即得到了你想要的值。</p><p>再来说置信区间，我们一般说95%的置信区间，意思就是，那个包含了上述95%的平均值的范围。</p><p>如果你拿母老鼠和公老鼠的数据对比，分别看他们95%的平均值的范围，如果彼此没有重合，那就可以说他们是不一样的，两组值的mean是统计显著的，而如果有重合的部分，就需要做t-test了。</p><h2 id="meanvariancestd">5. Mean，Variance，STD</h2><p>我们以上面的基因例子为例，对240万个基因值计算平均值，即得到了平均值，注意，这是对所有的值计算平均值，所以不是population mean，而是 真正的mean。</p><p>注意区分：</p><ul><li>sample mean，estimated mean（x-bar）</li><li>population mean（mu）</li></ul><p>总结：</p><p>如果你有所有的值，那直接除以数量，就得到了平均值（mu） 如果你没有所有值，可以利用（x-bar）估计population mean，x-bar是你既有的值算出来的平均值。</p><p>population variance，用你的data减去population mean（mu），平方后再除以样本数。</p><p>population std则是对population variance开根号。</p><p>然而，更多的情况是，你不可能直接算出来population mean，std，variance这些值，因为你只有有限的样本。</p><p>所以你得用x-bar代替mu，并将n-1代替n作为样本空间，计算variance，以及std。</p><p>因为我们算的是sample mean，而不是population mean，所以n需要减1。</p><p>为什么呢？请看下图</p><p><img src="https://i.loli.net/2020/03/29/Dch4BEqaHNTnJ7b.png" /></p><p><img src="https://i.loli.net/2020/03/29/ElgYG5SktiePJZu.jpg" /></p><p>因为数据与sample mean之间的差值，要小于数据与population mean之间的差值。</p><h2 id="what-is-a-statistical-model">6. What is a statistical model?</h2><p>model，即模型。比如根据老鼠体重，预测体长，这就是一个 model.</p><p>在这个语境下，model是一种关系。</p><p>体重越大，体长越长。</p><p>有时候model中，x和y的关系，并不是一条直线。</p><p>model 可以很简单，也可以很复杂。</p><h2 id="sampling-a-distribution">7. Sampling A Distribution</h2><p>对一个分布进行抽样，假设你现在有一个随机的分布，我们可以从中抽样，来计算这个分布的mean值（x-bar）</p><p>你可以抽样很多次，于是你会得到一个mean值的分布，这个分布图像的mean，随着抽样的个数（sample size）的增加，抽样分布的mean，会趋向于真正的mean，即（population mean），抽样分布的图像，会接近正态分布，符合中心极限定理的定义。</p><p>这里的n增加，我们的图像的std会变小，即图像变得更窄，但更高。</p><h2 id="python-实践">Python 实践</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="population-parametersactual">Population parameters(actual)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 Numpy 自带包计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Population Mean: &#123;&#125; \nPopulation Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.mean(arr),np.var(arr)))</span><br></pre></td></tr></table></figure><pre><code>Population Mean: 50.29 Population Variance:687.2659000000001</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mean</span></span><br><span class="line">population_mean = np.mean(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># variance</span></span><br><span class="line">value_squares = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">    value = num - population_mean</span><br><span class="line">    value_square = np.square(value)</span><br><span class="line">    value_squares.append(value_square)</span><br><span class="line">    </span><br><span class="line">variance = np.<span class="built_in">sum</span>(value_squares) / <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Population Mean: &#123;&#125; \nPopulation Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(population_mean,variance))</span><br></pre></td></tr></table></figure><pre><code>Population Mean: 50.29 Population Variance:687.2659000000001</code></pre><h3 id="samples-parametersestimate">Samples parameters(estimate)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sampling</span></span><br><span class="line">sample = np.random.choice(arr,size=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample mean, x-bar</span></span><br><span class="line">sample_x_bar = np.mean(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample variance with numpy</span></span><br><span class="line">sample_var = np.var(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample variance by hand, n as denominator</span></span><br><span class="line">absolute_values = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sample:</span><br><span class="line">    absolute_value = i - np.mean(sample)</span><br><span class="line">    absolute_value_square = np.square(absolute_value)</span><br><span class="line">    absolute_values.append(absolute_value_square)</span><br><span class="line"></span><br><span class="line">biased_variance = np.<span class="built_in">sum</span>(absolute_values)/<span class="built_in">len</span>(sample)</span><br><span class="line">unbiased_variance = np.<span class="built_in">sum</span>(absolute_values)/<span class="built_in">len</span>(sample) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Mean:&#123;&#125;\nSample Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(sample_x_bar,sample_var))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Variance Biased:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(biased_variance))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Variance Unbiased:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(unbiased_variance))</span><br></pre></td></tr></table></figure><pre><code>Sample Mean:50.54Sample Variance:726.8484Sample Variance Biased:726.8484Sample Variance Unbiased:725.8484</code></pre><h3 id="sampling-distribution">Sampling Distribution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x_bars = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># sampling</span></span><br><span class="line">    sample = np.random.choice(arr,size=<span class="number">100</span>)</span><br><span class="line">    <span class="comment"># sample mean, x-bar</span></span><br><span class="line">    sample_x_bar = np.mean(sample)</span><br><span class="line">    x_bars.append(sample_x_bar)</span><br><span class="line"></span><br><span class="line">plt.hist(x_bars)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/30/FCkgKPpLjIShmrH.png" /></p><h1 id="p-values">8. P-values</h1><p>对于两个药物的测试结果如下，我们完全可以观察出，A药物明显有效果，而B无效，且无法断定说，这两者的表现，只是一种随机现象。</p><figure><img src="https://i.loli.net/2020/03/29/Ez6BOw4moXCx7gM.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这时候就可以请p value发挥作用了。</p><figure><img src="https://i.loli.net/2020/03/29/lItcEZOfhXn8Vju.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/03/29/QbJnsG5hw7TdLUp.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="calculate-p-values">Calculate P-values</h2><p>P-values有两种，One-Sided 和 Two-Sided。</p><p>我们一般谈后面那种，并避免使用第一种。</p><p>你扔了两次硬币，都是国徽面朝上，你觉得这个硬币应该是不正常的，你搞到了一个神奇硬币！</p><p>你想知道，这真的是一个神奇硬币吗？</p><p>于是你想验证，你假设，这个这个硬币和别的硬币没什么区别（Null Hypothesis）。</p><p>如果你接下，推翻了这个假设，即，这个硬币和别的是有区别的，那么你拿到的，就是神奇硬币了。</p><p>为了验证这个假设，我们来计算抛两次硬币的概率, 使用树形图来看，很明显，两枚硬币都是国徽面的概率是25%。</p><figure><img src="https://i.loli.net/2020/04/05/syJ5TqSHGOrA4pf.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在，我们再来算，我们得到两个人像面的p value,p-value 由 3 部分组成：</p><ol type="1"><li>The probability random chance would result in the observation，在这里就是一个正常硬币，扔两次得到两次人像的概率，即0.25。</li><li>The probability of observing something else that is equally rare, 这里是两个人像或是两个国徽，也是0.25.</li><li>The probability of observing something rarer or more extreme. 这里是0，因为没有其他的结果比两个人像、两个国徽的概率更低。</li></ol><p>​</p><p>现在，p-value 就是 0.25 + 0.25 + 0 = 0.5. 注意我们计算 p-value 的目的是测试假设：</p><p>我的硬币和其他硬币是一样的。</p><p>通常来说，当 p-value 小于0.05 的时候，我们会拒绝这个假设，但是现在的概率是0.5,所以这个假设是真的，也就是你拿到的，不是神奇硬币啦。</p><blockquote><p>注意， 得到两个人像面概率为0.25与得到两个人像面得p-value为0.25，这两者不一样。</p></blockquote><p>为什么我们需要关心上面得条件2和3呢？</p><p>举个例子，当你送一朵花给你得意中人，你说：这是这个品种的花中最特别的。于是你得到了它的芳心。</p><p>但当她收到了10朵花，你说：这朵花和其余9朵花一样都很特殊。那这朵花，她也许就觉得不特别了，这是2的情况，所以我们把2的概率加进来。</p><p>也有可能是这样，你跟她说：还有很多的花，比现在这朵更稀有。她也会觉得这朵花不特别，这是3的情况。</p><p>现在我们知道扔2次，得到2个人像面的情况，如果扔5次得到4次人像呢？我们计算 p-value 看看(我们不关心顺序)：</p><figure><img src="https://i.loli.net/2020/04/05/Ve46vSliGoZ7Uth.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/Ve46vSliGoZ7Uth.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/U5dWXOKJkA1Hshq.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>我们需要p-value小于0.05就可以拒绝这个假设了，但目前来看，好像还是无法拒绝:</p><figure><img src="https://i.loli.net/2020/04/05/jK7meLAH9l1WEZU.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>对于连续的数据计算p-value，我们一般通过概率分布来计算，考虑一个身高的例子：</p><figure><img src="https://i.loli.net/2020/04/05/dvnTr6PucGeQFUm.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/ReZDQBT7lgu92H5.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/NegynLJ7pU3xTKB.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="covariance-and-correlation">9. Covariance and Correlation</h1><p>Covariance 一般可以分为三类，斜率为正的图像，斜率为负的图像，平行于x或y轴的图像。</p><p>即 positive trends, negative trends, no trends.</p><p>但 covariance 只能告诉你，数据是positive还是 negative 的trend，无法告诉你这个图像的slope，是陡峭还是平缓。</p><p>它也无法告诉你各个点与图像之间的距离。</p><p>如果所有的图像的 x或者y 值，是一样的，则 covariance 为0.</p><p>如果我们根据x和x本身来算 Covariance, 同时对比 2*x与 2*x 本身的图像，会发现两者的图像是一致的:</p><figure><img src="https://i.loli.net/2020/04/07/1FbmP3zsrGCL8fg.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>总的来说，Covariance 是根据各个点与平均值之间的距离来算的，这意味着它会受到点与均值之间距离的影响，也会受到坐标轴的影响。解决这个问题，引入下一个概念，即 Correlation。</p><h1 id="r-squared">10. R-squared</h1><p>我们已经知道 Correlation 的概念。为什么需要 <span class="math inline">\(R^{2}\)</span> 的概念，某些时候，它更容易解释，如 0.7 是 0.5 的两倍不容易理解，而0.7方是0.5方的两倍却很简单。</p><p>另外看一个老鼠的例子：</p><figure><img src="https://i.loli.net/2020/04/16/YrKQpu8G6xnB9mj.png" alt="老鼠的例子" /><figcaption aria-hidden="true">老鼠的例子</figcaption></figure><p>我们分别计算各点对于平均值（黑线）的方差，以及平均值对于fit的蓝线的方差，然后计算<span class="math inline">\(R^{2}\)</span>。</p><p>公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var(mean) - var(blue line) / var(mean)</span><br></pre></td></tr></table></figure><p>结果是 81%, 这意味着蓝线比平均值小了81%的方差。</p><p>对于两个变量之间的关系来说，<span class="math inline">\(R^{2}\)</span> 越高，说明拟合程度越好。</p><p>需要<a href="https://www.zhihu.com/question/32021302">区别</a>: <span class="math inline">\(R^{2}\)</span> 和相关系数的关系。</p><h1 id="central-limit-theorem">11. Central Limit Theorem</h1><p>中心极限定理，如果我们对0-1之间的数据抽样20个，计算mean，得出一个结果，然后绘制在另一个<strong>直方图</strong>上，如此反复几百遍后，我们得到的mean将会是一个正态分布的图。</p><p>这个原理，对于任何分布的图都适用。</p><p>摘录几则关于中心极限定理的话：</p><blockquote><p>摘录来自: “赤裸裸的统计学。” Apple Books.</p></blockquote><ul><li>“中心极限定理是许多统计活动的“动力源泉”，这些活动存在着一个共同的特点，那就是使用样本对一个更大的数量对象进行推理”</li><li>“个大型样本的正确抽样与其所代表的群体存在相似关系。当然，每个样本之间肯定会存在差异（比如前往马拉松起点的这么多辆客车，每辆客车乘客的组成都不可能完全相同），但是任一样本与整体之间存在巨大差异的概率是较低的”</li><li>“如果我们掌握了某个正确抽取的样本的具体信息（平均数和标准差），就能对其所代表的群体做出令人惊讶的精确推理”</li><li>“如果我们掌握了某个样本的数据，以及某个群体的数据，就能推理出该样本是否就是该群体的样本之一”</li><li>“通过中心极限定理，我们就能计算出某个样本（客车上的肥胖乘客）属于某个群体（马拉松比赛选手）的概率是多少，如果概率非常低，那么我们就能自信满满地说该样本不属于该群体”</li><li>“如果我们已知两个样本的基本特性，就能推理出这两个样本是否取自同一个群体。”</li></ul><p>那么，中心极限定理的实际意义是什么呢？</p><ol type="1"><li>计算置信区间</li><li>t-test，即两个sample的mean是否不同</li><li>ANAVO,即三个sample或以上的mean是否不同</li></ol><p><em>通常来说，为了中心极限定理的有效性，sample size必须要至少大于30.</em></p><h1 id="standard-deviation-vs-standard-error">12. Standard Deviation vs Standard Error</h1><ul><li>“标准差（Standard Deviation）是用来衡量群体中所有个体的离散性”，如心脏研究中所有参与者的体重分布”</li><li>“标准误差（Standard Error）衡量的仅仅是样本平均值的离散性。如果我们反复从弗雷明汉心脏研究数据库中抽取100名参与者作为样本，并计算其平均值，那么这些样本平均值的分布会是怎样一种情况？”</li></ul><p>另外：</p><p><strong>“标准误差就是所有样本平均值的标准差！”</strong></p><p>“如果标准误差差很大，就意味着样本平均值在群体平均值周围分布得极为分散；如果标准误差差很小，就意味着样本平均值之间的聚集程度很高。”</p><p>关于这两者，还有一些图像上的规律：</p><ul><li>“样本数量越多，其平均值就越不容易偏离整体平均值。图像也就越集中，因为大型样本受极端异常值的影响相对较小”</li><li>“数据分布越分散，那么其样本平均值的聚集程度就越低。”</li></ul><p>其次，需要注意的是：</p><p><strong>“如果标准差本身的数值很大，那么标准误差的数值也不会小。取自一个高度离散群体的大规模样本，其离散程度也会很高；与之对应，如果是一个高度聚集的群体，其样本围绕平均值的聚集程度也会很高。”</strong></p><p>由于样本的平均值是正态分布的，即中心极限定理的内容，我们有以下的规律：</p><p>“差不多有68%的样本平均值会在群体平均值一个标准误差的范围之内，有95%的样本平均值会在群体平均值的两个标准误差的范围之内，有99.7%的样本平均值会在群体平均值3个标准误差的范围之内。”</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概率与统计的基础概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="https://scottzhang.pro/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://scottzhang.pro/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="统计" scheme="https://scottzhang.pro/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法参考</title>
    <link href="https://scottzhang.pro/article/1895500896.html"/>
    <id>https://scottzhang.pro/article/1895500896.html</id>
    <published>2021-08-15T14:40:06.000Z</published>
    <updated>2021-11-27T08:27:54.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统的复习一下数据结构与算法的知识，包括 Python 实现的代码模板。</p></blockquote><span id="more"></span><blockquote><p>Update: 2021-8-22, 更新链表 python 实现</p></blockquote><h1 id="数组链表跳表">数组、链表、跳表</h1><h2 id="数组">数组</h2><p>申请数组，计算机在内存中给你开辟一段 <strong>连续</strong> 的地址。如果直接访问数组中的某个元素，不管是前后，时间复杂度是一样的 O(1).</p><p>问题：</p><ul><li>在中间位置插入元素，后面的元素都要移动，导致插入操作的时间复杂度不再是常数级的了，而是 O(n)，在最坏的情况下</li><li>删除的时候，也一样，时间复杂度和插入一样</li></ul><h3 id="java-数组实现">Java 数组实现</h3><p>操作</p><ol type="1"><li>判断数组的 Size 是否够</li><li>如果够，插入元素</li><li>如果不够，申请一个新的数组，size是当前的2倍，并将原来的数组拷贝到新的数组</li><li>将后面的元素往后挪</li></ol><p>可见数组的操作中，存在大量的元素拷贝。</p><h2 id="链表">链表</h2><p>在修改，添加，删除等操作频繁的情况下，数组并不好用，这时候推荐使用链表。链表的每一个元素都有 <code>value</code> 和 <code>next</code>，其中 <code>next</code> 指向下一个元素。这个元素一般使用 <code>class</code> 来定义，叫 <code>node</code>。</p><p>如果只有一个指针叫单链表，如果有两个双向的，叫双链表，头指针叫 <code>head</code>，尾指针叫 <code>tail</code>，如果 <code>head</code> 连接了 <code>tail</code>，叫<code>循环链表</code>。</p><p>Python 实现单链表，来自<a href="https://zhuanlan.zhihu.com/p/60057180">知乎</a>，该文章还有关于双链表，循环列表的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表的结点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># next是下一个节点的标识</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始指针指向head</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 指针指向None 表示到达尾部</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针下移</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">items</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取head指针</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="comment"># 循环遍历</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 返回生成器</span></span><br><span class="line">            <span class="keyword">yield</span> cur.item</span><br><span class="line">            <span class="comment"># 指针下移</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;向链表头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 新结点指针指向原头部结点</span></span><br><span class="line">        node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="comment"># 头部结点指针修改为新结点</span></span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 先判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 空链表，_head 指向新结点</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不是空链表，则找到尾部，将尾部next结点指向新结点</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置插入元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 指定位置在第一个元素之前，在头部插入</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="comment"># 指定位置超过尾部，在尾部插入</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; (self.length() - <span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 创建元素结点</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="comment"># 循环到需要插入的位置</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除节点&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 找到指定元素</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 如果第一个就是删除的节点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                    <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 继续按链表后移节点</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self.items()</span><br></pre></td></tr></table></figure><h3 id="链表复杂度">链表复杂度</h3><p>操作</p><ol type="1"><li>将插入位置前的元素的next指向新节点，新节点的指向后节点，操作两次，常数级别，O(1)</li><li>与插入类似</li></ol><p>优点：</p><ul><li>不用群移，不需要复制元素</li><li>移动，修改的效率很高</li></ul><p>缺点</p><ul><li>访问中间节点，必须一步一步往后挪，所以复杂度为O(n)</li></ul><h2 id="跳表">跳表</h2><figure><img src="https://i.loli.net/2021/03/07/5ryvJGuCsPS4cpN.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>弥补链表的设计缺陷而设计，为了加速链表访问的速度，在节点之间搭建快速路（索引）。</li><li>索引越多，速度越快，但是也没有降到O(1)，而是 O(logn)</li><li>现实中，因为索引经常操作，维护成本较高</li><li>空间复杂度为 O(n)，但肯定还是比链表高</li></ul><h1 id="栈队列">栈、队列</h1><ul><li><p>栈相当于一个瓶子，先放进去的后面才能拿出来。</p></li><li><p>队列相当于一个管子，先放进去的先出来。</p></li></ul><p>这两个，复杂度添加删除都是 O(1)，查询则是 O(n)，因为它们内部元素是无序的，查任何元素都需要遍历整个数据结构。</p><p>实战中，其实纯粹的栈、队列用的很少，更多的用的是双端队列(Double-End queue)，一个栈和队列的结合体，它两边都可以 push，pop，复杂度和正常的栈、队列都一样。</p><figure><img src="https://i.loli.net/2021/08/12/JUxhPSH6LqB74CO.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>栈的一些操作，可以直接通过 python 中的列表实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="built_in">list</span>.append() == push</span><br><span class="line"><span class="built_in">list</span>.pop() == pop</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] == peek</span><br></pre></td></tr></table></figure><h2 id="优先队列">优先队列</h2><p>也就是元素是有优先级的，它的插入是 O(1), 取出操作 O(logN), 因为需要按照元素的优先级取出。底层的实现方式较为多样和负责，有 heap, bst, treap.</p><h1 id="哈希表映射集合">哈希表、映射、集合</h1><p>哈希表也叫散列表，现实中用的比较多，类似字典的key value对，但它是通过哈希函数建立一个映射关系，key 相当于关键码值，value 也就是存放数据的地方叫哈希表。</p><p>现实中一般应用在电话号码，用户信息表，缓存，键值对存储（Redis）。</p><p>哈希函数有很多种，选的好可以让生成的地址比较分散，不会重复，这里重复的意思就是，比如我字符 scott 生成的地址是 9，然后 zhang 生成的也是9，这就重复了，这叫哈希碰撞。</p><p>但发生了碰撞怎么办呢？可以在相同得位置，拉出一个链表出来，把信息存在这个链表上，如果哈希函数选的不好，链表很长，复杂度会变成O(n)，而没有链表得情况下是 O(1)。</p><figure><img src="https://i.loli.net/2021/08/12/6bKBh2UTQecgLqX.png" alt="发生哈希碰撞后的哈希表" /><figcaption aria-hidden="true">发生哈希碰撞后的哈希表</figcaption></figure><figure><img src="https://i.loli.net/2021/08/12/YyGFwVB43sMe9Tj.png" alt="哈希表的复杂度" /><figcaption aria-hidden="true">哈希表的复杂度</figcaption></figure><p>哈希表在 python 中有两种，Dictionary 和 Set，在 Java 中，可能只是一个接口，比如 Set 的实现有很多种，有基于红黑树的，基于二叉树的等等。</p><h1 id="树二叉树二叉搜索树">树、二叉树、二叉搜索树</h1><blockquote><p>2 维数据结构。</p></blockquote><h2 id="树">树</h2><p>树的示意图</p><figure><img src="https://i.loli.net/2021/08/13/6bpLCrNwEKTWOvy.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>为什么会出现树呢？工程实践就是二维的,树和链表没有本质上的区别，只是从1维到了二维。。树的遍历怎么办？对于一维数组，你可以直接循环遍历，而对于树，则有好几种方式：</p><ol type="1"><li>前序 (Pre-order)：根，左边，右边</li><li>中序 (In-order)：左边，根，右边</li><li>后序 (Post-order)：左边，右边，根</li></ol><p>树的循环，效率是比较麻烦的，反倒是写递归比较简单，树的各种操作，不要害怕递归。</p><h2 id="二叉树">二叉树</h2><p>二叉树，也就是儿子节点只有两个</p><figure><img src="https://i.loli.net/2021/08/13/jGRmsLDIFeryCP9.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="二叉搜索树">二叉搜索树</h2><p>如果树要查找元素，就必须要遍历，如果树里的元素没有顺序，那和列表什么的没区别。于是为了方便搜索，我们对树进行了排序，定义了二叉搜索树，它的特点是<strong>一颗空树</strong>或者<strong>具有以下性质的二叉树</strong>：</p><ol type="1"><li>左子树上所有节点的值均小于根节点的值；</li><li>右子树上所有节点的值均大于它的根节点的值；</li><li>以此类推：左右子树也分别为二叉查找树（重复性）</li></ol><p>中序遍历：升序排列</p><p>排序后的树，查询和操作都是 logn 的复杂度，相当于是加速了，因为它在查询的时候，会将当前节点与查询的节点做比较，每次可以筛掉一般的值，所以变成logn，虽然不是 O(1)，但logn 还是比 n 是不知道快多少了。</p><p>看树的查询动画，see also <a href="https://visualgo.net/en">Visualgo</a>.</p><p>二叉搜索树遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        self.preorder(root.left)</span><br><span class="line">        self.preorder(self.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        self.inorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.postorder(root.left)</span><br><span class="line">        self.postorder(root.right)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br></pre></td></tr></table></figure><h2 id="图">图</h2><p>图又是什么呢？图就是上面的节点中，子节点又连接到兄弟节点甚至是父节点去了。</p><blockquote><p>Linked List 是特殊化的 Tree，Tree是特殊化的 Graph.</p></blockquote><h1 id="递归">递归</h1><p>递归本质上类似与循环，即通过循环调用自己，以前使用的汇编语言，那时候没有循环嵌套这么一说，更多的时候就是你之前的指令写在上面地方，就不断的调用，从汇编的角度看，其实汇编的代码里，循环和递归差不多。</p><p>递归的特点，类似于盗梦空间。</p><ul><li>向下进入梦境，向上回到原来那层，只能一层一层进入或者退出。</li><li>每一层的环境和周围的人都是一份拷贝</li><li>通过声音返回上一层（return）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n*Factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure><img src="https://i.loli.net/2021/08/13/7mQvWfEewTYuPjA.png" alt="执行逻辑" /><figcaption aria-hidden="true">执行逻辑</figcaption></figure><p>递归代码模板：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span>(<span class="params">level, param1, param2, ...</span>):</span></span><br><span class="line"><span class="comment"># recursion terminator 终结条件</span></span><br><span class="line"><span class="keyword">if</span> level &gt; max_level:</span><br><span class="line">process_result</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># process logic in current level 处理当前层的逻辑</span></span><br><span class="line">    process(level, data...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># drill down 下探到下一层，带上参数</span></span><br><span class="line">    self.recursion(level+<span class="number">1</span>, p1, ...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse the current level states if needed 如果需要递归完了清理当前层</span></span><br></pre></td></tr></table></figure><p>思维要点：</p><ul><li>不要人肉递归</li><li>找到最近，最简的方法，拆解成可重复解决的问题（最近重复子问题）</li><li>数学归纳法的思维</li></ul><h1 id="分治回溯">分治、回溯</h1><blockquote><p>递归里面的细分类</p></blockquote><p>碰到一个题目，我们要去找重复性，重复性有两种：</p><ul><li>最近重复性 -&gt; 分支、回溯，递归</li><li>最优重复性 -&gt; 动态规划</li></ul><h2 id="分治">分治</h2><p>大问题都是子问题、复杂问题构成的，解决问题本质上就是找重复性，分解问题，组合子问题的结果。</p><figure><img src="https://i.loli.net/2021/08/13/UJNRMharPXo53V8.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>分治的代码模板:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_conquer</span>(<span class="params">problem, param1, param2, ...</span>):</span></span><br><span class="line">    <span class="comment"># recursion terminator</span></span><br><span class="line">    <span class="keyword">if</span> problem <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   <span class="comment"># prepare data</span></span><br><span class="line">    data = prepare_data(problem)</span><br><span class="line">    subproblems = split_problem(problem, data)</span><br><span class="line">    <span class="comment"># conquer subproblems</span></span><br><span class="line">    subresult1 = self.divide_conquer(subproblems[<span class="number">0</span>], p1, ...)</span><br><span class="line">    subresult2 = self.divide_conquer(subproblems[<span class="number">1</span>], p1, ...)</span><br><span class="line">    subresult3 = self.divide_conquer(subproblems[<span class="number">2</span>], p1, ...)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># process and generate the final result</span></span><br><span class="line">    result = process_result(subresult1, subresult2, subresult3)</span><br><span class="line">    <span class="comment"># revert the current level states</span></span><br></pre></td></tr></table></figure><h2 id="回溯">回溯</h2><p>采用试错的思想，分步解决一个问题，如果分布方案不解决问题，会取消上一步或几步的计算，再通过其他可能的分步方案寻找答案。</p><p>简单来说就是，每一层我都有不同的办法，一个一个试。</p><h1 id="深度优先广度优先搜索">深度优先、广度优先搜索</h1><h2 id="深度优先">深度优先</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>深度优先就是先往最深处的节点走，发现没有子节点了，返回到有子节点的节点，继续往下面走。</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">self, tree</span>):</span></span><br><span class="line"><span class="keyword">if</span> tree.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">visited, stack = [], [tree.root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)</span><br><span class="line">        stack.push(nodes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, visited</span>):</span></span><br><span class="line"><span class="comment"># terminator</span></span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment"># already visited</span></span><br><span class="line">visited.add(node)</span><br><span class="line"><span class="comment"># process current node here</span></span><br><span class="line"><span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">dfs(next_node, visited)</span><br></pre></td></tr></table></figure><h2 id="广度优先">广度优先</h2><p>广度优先遍历，类似与一个水滴滴到根节点，然后像水波一样一层一层扩散下去，这种思想在算最短路径的时候，比深度优先效率高。遍历的方式使用队列实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)</span><br><span class="line">        queue.push(nodes)</span><br><span class="line">     <span class="comment"># othres processing work</span></span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>这里的算法为了方便理解，举个例子，就好像要访问公司的人员信息，首先先看老总的信息，老总看完了，放到 visited 数组，然后看他有没有其他下属，有的话全部取出来放到队列（先进先出）</p><h1 id="贪心算法">贪心算法</h1><p>贪心算法在每一步选择中，都采取当前状态下最好或最优的选择，从而导致结果是最好的或最优的算法。（有一定的局限性，因为当下最优不一定全局最优）</p><p>动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心法主要解决一些最优化问题，图中的最小生成树，求哈夫曼编码等。</p><p>一旦一个问题可以通过贪心算法解决，那么贪心法一般是解决这个问题的最好办法。</p><p>适用于贪心的情况，即<code>问题可以分解成子问题，子问题的最优解可以递推到最终问题的最优解</code></p><h1 id="二分查找">二分查找</h1><p>一定记住二分查找的前提（肌肉记忆）:</p><ol type="1"><li>目标函数单调性（单调递增或递减），才可以通过特征排除掉前半部分或后半部分</li><li>存在上下界（bounded），没有上下界，空间可能无限大</li><li>能够通过索引访问（index acccessible)，如果是单链表，即使有序，也比较难</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设数组是有序的</span></span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = (left + right) /<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target!</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><ul><li>Dynamic Programming（一种解决问题的办法）, 本质就是将复杂问题，分解成小问题，可以理解为动态的递推，每一步保存最优解，淘汰掉那些不怎么好的，然后最终求得总体的最优解。</li><li>直接递归的复杂度是指数级的，如果淘汰掉一些解，可以变成 n 平方</li></ul><h1 id="字典树">字典树</h1><h2 id="字典树的数据结构">字典树的数据结构</h2><p>之前我们的树，内部就是值本身，而是把字符串拆成单个得字幕存储。</p><figure><img src="https://i.loli.net/2021/08/14/zYdmwyHZCFXQovM.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>节点本身不存完整单词</li><li>根节点到某一结点，连起来即为单词</li><li>每个不同的边都是不一样的字符</li></ul><p>这种结构中，节点还可以存储其他信息，比如这个节点所得到的单词出现的频次。这种结构的核心思想是空间换时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end_of_word = <span class="string">&quot;#&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            node = node.setdefault(char, &#123;&#125;)</span><br><span class="line">        node[self.end_of_word] = self.end_of_word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">           node = node[char]</span><br><span class="line">        <span class="keyword">return</span> self.end_of_word <span class="keyword">in</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[char]</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><p>属于一种比较跳跃式的数据结构，如果你会就很简单，如果不会就很难，它使用情景主要是在组团、配对问题。</p><p>这两个个体是不是在一个集合之中。</p><h3 id="基本操作">基本操作</h3><ul><li><p>makeSets(s): 新建并查集，其中包括s个单元素集合。</p></li><li><p>unionSet(x, y): 集合合并，要求不相交才合并</p></li><li><p>find(x): 判断 x 所在集合的代表</p></li></ul><p>每个元素都有一个 parent 数组指向自己，表示自己是自己的集合。</p><h3 id="合并">合并</h3><figure><img src="https://i.loli.net/2021/08/14/rE8CmX27OjkgKcl.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="路径优化">路径优化</h3><figure><img src="https://i.loli.net/2021/08/14/aXNWL3ogTiyGZ7w.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="实现">实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">p</span>):</span></span><br><span class="line">    p = []i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, i, j</span>):</span></span><br><span class="line">    p1 = self.parent(p, i)</span><br><span class="line">    p2 = self.parent(p, j)</span><br><span class="line">    p[p1] = p2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span>(<span class="params">self, p, i</span>):</span></span><br><span class="line">    root = i</span><br><span class="line">    <span class="keyword">while</span> p[root] != root:</span><br><span class="line">        root = p[root]</span><br><span class="line">    <span class="keyword">while</span> p[i] != i:</span><br><span class="line">        x = i</span><br><span class="line">        i = p[i]</span><br><span class="line">        p[x] = root</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="高级搜索">高级搜索</h1><h2 id="剪枝">剪枝</h2><p>说高级搜索前，什么是初级搜索呢？</p><ol type="1"><li><p>朴素搜索</p></li><li><p>优化方式：不重复、剪枝，剪枝就是在搜索的时候去掉重复，或者剪去是一些没必要的访问</p></li><li><p>搜索方向</p><ol type="1"><li><p>DFS，深度优先，没有优先级，傻搜</p></li><li><p>BFS，广度优先</p></li></ol></li></ol><p>搜索的话可以通过双向搜索，启发式搜索来优化。</p><figure><img src="https://i.loli.net/2021/08/14/tUCHVGfwRDlAZIo.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="双向bfs">双向BFS</h2><p>问题：找出A到L的最短路径</p><figure><img src="https://i.loli.net/2021/08/14/24WjlLP5qa7dDKS.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这种需求，我们一般使用广度优先算法，而双向 BFS 的意思是，从两边一起进行广度优先算法的遍历，两边一起逼近中间，这样就可以提高效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image.png](https://i.loli.net/2021/08/14/J3fKMgXRkuynHOd.png)</span><br></pre></td></tr></table></figure><h2 id="启发式搜索-heuristic-search-a">启发式搜索 Heuristic Search (A*)</h2><p>只能搜索，根据某项条件，我们去优化条件，也可以理解为思考型搜索，本质上是用优先级。</p><p>这里就要用到优先队列了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AstarSearch</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line">    pq = collections.priority_queue() <span class="comment"># 优先级，估价函数</span></span><br><span class="line">    pq.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        node = pq.pop()  <span class="comment"># 能更智能一点吗？</span></span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)  <span class="comment"># 正常的BFS代码</span></span><br><span class="line"></span><br><span class="line">        unvisited=[node <span class="keyword">for</span> node <span class="keyword">in</span> nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">        pq.push(unvisited)</span><br></pre></td></tr></table></figure><p>这里怎么来定优先级呢？这就需要你按照对题目的理解把估价函数写出来。</p><h1 id="avl和红黑树">AVL和红黑树</h1><blockquote><p>二三树，B树，B+树，B-树。</p></blockquote><p>如何保持一棵树的平衡？</p><h2 id="avl">AVL</h2><ol type="1"><li>Balance Factor，因为二叉树的查找只与高度有关，平衡因子是它的左子树的高度减去右子树的高度（有时候相反）,balance factor = {-1, 0, 1}</li><li>通过旋转操作来进行平衡（四种）</li></ol><p>那么如何判断高度呢?</p><figure><img src="https://i.loli.net/2021/08/14/4GL5jIuWhpclkzS.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>通过高度的值不超过1，不小于-1来判断一棵树是否需要调整，即旋转，旋转的方式有：</p><ol type="1"><li>左旋</li><li>右选</li><li>左右旋</li><li>右左旋</li></ol><p>缺点：需要额外的信息存储，且调整次数频繁。</p><h2 id="红黑树">红黑树</h2><p>也是一种<code>近似平衡</code>的二叉搜索树，它能确保任何一个节点的左右子树高度差小于两倍，具体来说：</p><ul><li>每个节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>每个叶节点（NIL节点，空节点）是黑色的。</li><li>不能有相邻接的两个红色节点</li><li>从任何一个节点到每个叶子的所有路径都包含相同数目的黑色节点</li></ul><p>这些性质就让红黑树的时间复杂度可以保持在 logn 的水平，不会退化，需要调整的时间也是相对比较折中。</p><p>下面是 AVL 与 红黑树的对比：</p><figure><img src="https://i.loli.net/2021/08/15/8JMDFWkV2CG9dxc.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>如果读操作非常多写操作少就用 AVL，它插入、删除需要的操作比较多。</li><li>插入操作也很多，或者操作、查询需求差不多，就用红黑树</li></ul><h1 id="位运算">位运算</h1><p>位运算简单说就是进制转换，比如十进制转二进制，在进制表示中，<code>4(d)</code> 中的 d 表示的是十进制，<code>0100</code> 中零开头表示2进制。</p><p>具体转换的算法可以参考<a href="https://zh.wikihow.com/%E4%BB%8E%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6">这里</a>。</p><h2 id="位运算符">位运算符</h2><table><thead><tr class="header"><th style="text-align: center;">含义</th><th style="text-align: center;">运算符</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">左移</td><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;">0011 =&gt; 0110</td></tr><tr class="even"><td style="text-align: center;">右移</td><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;">0110 =&gt; 0011</td></tr><tr class="odd"><td style="text-align: center;">按位或，有1则1</td><td style="text-align: center;">|</td><td style="text-align: center;">0011 | 1011 =&gt; 1011</td></tr><tr class="even"><td style="text-align: center;">按位与，有0则0</td><td style="text-align: center;">&amp;</td><td style="text-align: center;">0011 &amp; 1011 =&gt; 0011</td></tr><tr class="odd"><td style="text-align: center;">按位取反，0变1，1变0</td><td style="text-align: center;">~</td><td style="text-align: center;">0011 =&gt; 1100</td></tr><tr class="even"><td style="text-align: center;">按位异或，相同0不同1</td><td style="text-align: center;">^</td><td style="text-align: center;">0011 ^ 1011 =&gt; 1000</td></tr></tbody></table><h2 id="异或特点">异或特点</h2><p>异或操作的一些特点：</p><ul><li><code>x^0 = x</code>, 只要 <code>x</code> 和 <code>0</code> 相同的就为 <code>0</code>，不同的为 <code>1</code>，所以这里 <code>x^0</code> 就等于 <code>x</code></li><li><code>x^1s = ~x</code>, <code>1s</code> 指的是全1，也就是等于0取反 <code>~</code></li><li><code>x^(~x)=1s</code>, 取反后，所有位置都不一样，所有都不同，都是1，1s</li><li><code>x^x=0</code>, 异或相同为0，所有都是0</li><li><code>c=a^b</code> ,<code>a^c=b</code> 则 <code>b^c=a</code>, 交换两数</li><li><code>a^b^c = a^(b^c) = (a^b)^c</code>, associative</li></ul><h2 id="指定位置的位运算">指定位置的位运算</h2><figure><img src="https://i.loli.net/2021/08/15/Us8dBF7LNfHVIbh.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="实战运算要点">实战运算要点</h2><figure><img src="https://i.loli.net/2021/08/15/yvDgQ5d7JhCejr1.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="布隆过滤器lru-cache">布隆过滤器，LRU Cache</h1><h2 id="布隆过滤器">布隆过滤器</h2><p>在说布隆过滤器之前，回顾一下哈希表，前面说过哈希表在哈希操作的时候，有可能会得到一样的地址（整数），这时候会采用拉链的办法，也就是在同样的地址上叠罗汉。</p><p>在哈希表的应用中，我们发现，有时候我们并不需要去存储元素的信息本身，而是只需要知道某个信息在我们的表中有没有。</p><p>如果我们只是需要知道某个信息在表里有没有，这时候 Bloom filter 就设计出来了。</p><h3 id="布隆过滤器具-vs-哈希表">布隆过滤器具 vs 哈希表</h3><ul><li>空间效率和查询时间都远远超过一般算法</li><li>缺点是有一定的误识别率和删除困难</li></ul><h3 id="布隆过滤器具原理">布隆过滤器具原理</h3><figure><img src="https://i.loli.net/2021/08/15/zMKNUgRTZF73ht4.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在有 xyz 三个元素需要存储，布隆过滤器会对每一个元素执行哈希，得到一组值，然后再将这组值插入到下面的框框中，y 和 z 也是同理，这样下次查询的时候，只需要查看这些对应的位置是否为1就好了，而且查询的时候，我只需要判断任意一个元素是0，那么就可以判断这个元素是不在这个表中的。</p><p>但是这种查法可能会有问题，比如下面的这个B：</p><figure><img src="https://i.loli.net/2021/08/15/Hw9t4BfN3cp2OWe.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>对于一个元素，布隆过滤器可以确定一个元素不存在，但只可以说某个元素有可能存在。</p><p>布隆过滤器一般放在数据库的外层当作缓存使用。</p><h3 id="布隆过滤器具案例">布隆过滤器具案例</h3><ol type="1"><li>比特币网络</li><li>分布式系统（Map-Reduce）- Hadooop，search engine</li><li>Redis 缓存</li><li>垃圾邮件、评论等的过滤</li></ol><h3 id="布隆过滤器具-python实现">布隆过滤器具 Python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bfrom bitarray <span class="keyword">import</span> bitarray</span><br><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size, hash_num</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.hash_num = hash_num</span><br><span class="line">        self.bit_array = bitarray(size)</span><br><span class="line">        self.bit_array.setall(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_num):</span><br><span class="line">            result = mmh3.<span class="built_in">hash</span>(s, seed) % self.size</span><br><span class="line">            self.bit_array[result] = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookup</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_num):</span><br><span class="line">            result = mmh3.<span class="built_in">hash</span>(s, seed) % self.size</span><br><span class="line">            <span class="keyword">if</span> self.bit_array[result] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Nope&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Probably&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bf = BloomFilter(500000, 7)</span><br><span class="line">bf.add(&quot;scott&quot;)</span><br><span class="line">bf.lookup(&quot;scott&quot;)</span><br><span class="line">&#x27;Probably&#x27;</span><br><span class="line"></span><br><span class="line">bf.lookup(&quot;zhang&quot;)</span><br><span class="line">&#x27;Nope&#x27;</span><br></pre></td></tr></table></figure><h2 id="lru-cache-缓存">LRU Cache 缓存</h2><blockquote><p>Least Rencent Used,</p></blockquote><ul><li>两个要素：大小、替换策略</li><li>使用 Hash Table + Double LinkedList 实现</li><li>O(1) 查询，O(1) 更新、更新</li></ul><h3 id="工作示例">工作示例</h3><figure><img src="https://i.loli.net/2021/08/15/noydHrUWJNVbB3F.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="排序算法">排序算法</h1><blockquote><p>To be continued.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;系统的复习一下数据结构与算法的知识，包括 Python 实现的代码模板。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://scottzhang.pro/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>cx_Oracle 在 Linux 上的安装与配置</title>
    <link href="https://scottzhang.pro/article/3551438313.html"/>
    <id>https://scottzhang.pro/article/3551438313.html</id>
    <published>2021-03-04T14:23:56.000Z</published>
    <updated>2021-11-27T08:28:18.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>cx_Oracle 是一个Python扩展模块，用来支持访问Oracle数据库，在 python 下，即便你使用其它的数据库 <a href="http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html">ORM 映射框架</a>, 也需要配置 cx_Oracle, 这篇文章介绍了如何配置 cx_Oracle 以便让你可以访问 Oracle 数据库。</p></blockquote><span id="more"></span><h1 id="cx_oracle">cx_Oracle</h1><p>下面这种图介绍了 cx_Oracle 在与 Oracle 数据库交互中起的作用。</p><p><img src="https://cx-oracle.readthedocs.io/en/latest/_images/cx_Oracle_arch.png" /></p><p>安装 cx_Oracle 本身很简单:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install cx_Oracle --upgrade</span><br></pre></td></tr></table></figure><p>但是我们还需要安装 Oracle 客户端的库, 可以选择 Oracle Instant Client 或者 Oracle Database Express Edition (“XE”), 后者需要你本地安装了 oracle 数据库， 我们选择 Instant Client, Instant Client 提供了两种版本，<code>zip</code> 和 <code>rpm</code> 版本，<code>zip</code> 版本解压到本地电脑即可开始配置，<code>rpm</code> 则是提供给 Linux 使用的，要详细了解 <code>rpm</code> ，这里可以推荐一篇 <a href="https://developer.ibm.com/zh/articles/l-lo-rpm-build-package/">IBM 的文章</a>。</p><p>安装 Instant Client 的步骤：</p><ol type="1"><li>前往 Oracle Instant Client <a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html">下载页面</a> 下载<strong>正确的版本</strong>，一定要参考服务端的 Oracle 版本，因为客户端的高版本并不支持连接低版本的服务端，例如我第一次使用客户端 21 版本连接服务端 11 的版本就报错: <code>ORA-28547</code></li></ol><p>下图说明了 Oracle 客户端与服务端的兼容关系:</p><figure><img src="https://i.loli.net/2021/03/04/RQmyUibWJtaSulD.png" alt="IMG_4465.PNG" /><figcaption aria-hidden="true">IMG_4465.PNG</figcaption></figure><ol start="2" type="1"><li>在 Linux 上，使用 <code>unzip</code> 命令解压到你需要的文件夹</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/oracle</span><br><span class="line">cd /opt/oracle</span><br><span class="line">unzip instantclient-basic-linux.x64-你下载的版本.zip</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>安装 libaio, libaio是Linux下的一个异步非阻塞接口，它提供了以异步非阻塞方式来读写文件的方式，读写效率比较高。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libaio</span><br><span class="line"># 有的 linux 叫做libaio1</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>如果你不担心影响其它的程序，可以永久的将 Instant Client 添加到<a href="https://www.zhihu.com/question/20484931">动态库链接</a>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo /opt/oracle/instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>如果你使用 <code>tnsnames.ora</code>, <code>sqlnet.ora</code> 或 <code>oraaccess.xml</code> 则需要更改 cx_Oracle 初始化配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import cx_Oracle</span><br><span class="line">cx_Oracle.init_oracle_client(config_dir=&quot;/home/your_username/oracle/your_config_dir&quot;)</span><br></pre></td></tr></table></figure><p>或者设置环境变量 <code>TNS_ADMIN</code>, 并将相关文件放至 <code>network/admin</code> 子文件夹。</p><p>通过 RPMs 安装的方式类似，在此不再赘述。</p><h1 id="docker-file">Docker file</h1><p>下面是一个 Flask 应用配置 Oracle 的部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7.3</span><br><span class="line"># Set up Oracle</span><br><span class="line">WORKDIR    /opt/oracle</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y libaio1 wget unzip \</span><br><span class="line">    &amp;&amp; cp /app/query_eda_tool/oracle_configs/instantclient-basic-linux.x64-12.2.0.1.0.zip . \</span><br><span class="line">    &amp;&amp; unzip instantclient-basic-linux.x64-12.2.0.1.0.zip \</span><br><span class="line">    &amp;&amp; rm -f instantclient-basic-linux.x64-12.2.0.1.0.zip \</span><br><span class="line">    &amp;&amp; cd /opt/oracle/instantclient* \</span><br><span class="line">    &amp;&amp; rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \</span><br><span class="line">    &amp;&amp; echo /opt/oracle/instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf \</span><br><span class="line">    &amp;&amp; ldconfig \</span><br><span class="line">    &amp;&amp; mkdir -p /opt/oracle/instantclient_12_2/network/admin \</span><br><span class="line">    &amp;&amp; cp /app/query_eda_tool/oracle_configs/tnsnames.ora /opt/oracle/instantclient_12_2/network/admin/ \</span><br><span class="line">    &amp;&amp; cp /app/query_eda_tool/oracle_configs/sqlnet.ora /opt/oracle/instantclient_12_2/network/admin/</span><br></pre></td></tr></table></figure><blockquote><p>注：我的项目文件中已经从官网下载好 <code>instantclient-basic-linux.x64-12.2.0.1.0.zip</code> 文件。</p></blockquote><h1 id="参考">参考</h1><ul><li><a href="https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html">cx_Oracle 8 Installation</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;cx_Oracle 是一个Python扩展模块，用来支持访问Oracle数据库，在 python 下，即便你使用其它的数据库 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html&quot;&gt;ORM 映射框架&lt;/a&gt;, 也需要配置 cx_Oracle, 这篇文章介绍了如何配置 cx_Oracle 以便让你可以访问 Oracle 数据库。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="oracle" scheme="https://scottzhang.pro/tags/oracle/"/>
    
    <category term="cx_Oracle" scheme="https://scottzhang.pro/tags/cx-Oracle/"/>
    
    <category term="database" scheme="https://scottzhang.pro/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Spark 笔记</title>
    <link href="https://scottzhang.pro/article/3170800033.html"/>
    <id>https://scottzhang.pro/article/3170800033.html</id>
    <published>2021-03-02T13:27:00.000Z</published>
    <updated>2021-11-27T08:38:42.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A platform for cluster computing.</p></blockquote><span id="more"></span><p>Spark lets you spread data and computations over <em>clusters</em> with multiple <em>nodes</em> (think of each node as a separate computer). Spark is a platform for cluster computing. Spark lets you spread data and computations over <em>clusters</em> with multiple <em>nodes</em> (think of each node as a separate computer). Splitting up your data makes it easier to work with very large datasets because each node only works with a small amount of data.</p><p>As each node works on its own subset of the total data, it also carries out a part of the total calculations required, so that both data processing and computation are performed <em>in parallel</em> over the nodes in the cluster. It is a fact that parallel computation can make certain types of programming tasks much faster.</p><h1 id="连接集群">连接集群</h1><p>The first step in using Spark is connecting to a cluster.</p><p>In practice, the cluster will be hosted on a remote machine that's connected to all other nodes. There will be one computer, called the <em>master</em> that manages splitting up the data and the computations. The master is connected to the rest of the computers in the cluster, which are called <em>worker</em>. The master sends the workers data and calculations to run, and they send their results back to the master.</p><p>Creating the connection is as simple as creating an instance of the <code>SparkContext</code> class. The class constructor takes a few optional arguments that allow you to specify the attributes of the cluster you're connecting to.</p><p>An object holding all these attributes can be created with the <code>SparkConf()</code> constructor. Take a look at the <a href="http://spark.apache.org/docs/2.1.0/api/python/pyspark.html">documentation</a> for all the details!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">SparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 sc 对象</span></span><br><span class="line"><span class="built_in">print</span>(sc)</span><br><span class="line">&lt;SparkContext master=local[*] appName=pyspark-shell&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line"><span class="built_in">print</span>(sc.version)</span><br></pre></td></tr></table></figure><h1 id="spark-中的数据">Spark 中的数据</h1><p>Spark's core data structure is the Resilient Distributed Dataset (RDD). This is a low level object that lets Spark work its magic by splitting data across multiple nodes in the cluster. However, RDDs are hard to work with directly</p><p>The Spark DataFrame was designed to behave a lot like a SQL table (a table with variables in the columns and observations in the rows). Not only are they easier to understand, DataFrames are also more optimized for complicated operations than RDDs.</p><p>When you start modifying and combining columns and rows of data, there are many ways to arrive at the same result, but some often take much longer than others. When using RDDs, it's up to the data scientist to figure out the right way to optimize the query, but the DataFrame implementation has much of this optimization built in!</p><p>To start working with Spark DataFrames, you first have to create a <code>SparkSession</code> object from your <code>SparkContext</code>. You can think of the <code>SparkContext</code> as your connection to the cluster and the <code>SparkSession</code> as your interface with that connection.</p><p>we will have a <code>SparkSession</code> called <code>spark</code> .</p><p>Creating multiple <code>SparkSession</code>s and <code>SparkContext</code>s can cause issues, so it's best practice to use the <code>SparkSession.builder.getOrCreate()</code> method. This returns an existing <code>SparkSession</code> if there's already one in the environment, or creates a new one if necessary!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import SparkSession from pyspark.sql</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create my_spark</span></span><br><span class="line">my_spark = SparkSession.builder.getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print my_spark</span></span><br><span class="line"><span class="built_in">print</span>(my_spark)</span><br></pre></td></tr></table></figure><p>Once you've created a <code>SparkSession</code>, you can start poking around to see what data is in your cluster!</p><p>Your <code>SparkSession</code> has an attribute called <code>catalog</code> which lists all the data inside the cluster. This attribute has a few methods for extracting different pieces of information.</p><p>One of the most useful is the <code>.listTables()</code> method, which returns the names of all the tables in your cluster as a list.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Print the tables in the catalog</span></span><br><span class="line"><span class="built_in">print</span>(spark.catalog.listTables())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running a query on this table</span></span><br><span class="line">query = <span class="string">&quot;FROM flights SELECT * LIMIT 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the first 10 rows of flights</span></span><br><span class="line">flights10 = spark.sql(query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the results</span></span><br><span class="line">flights10.show()</span><br></pre></td></tr></table></figure><h2 id="读取-spark-数据到-pandas">读取 Spark 数据到 Pandas</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Don&#x27;t change this query</span></span><br><span class="line">query = <span class="string">&quot;SELECT origin, dest, COUNT(*) as N FROM flights GROUP BY origin, dest&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the query</span></span><br><span class="line">flight_counts = spark.sql(query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the results to a pandas DataFrame</span></span><br><span class="line">pd_counts = flight_counts.toPandas()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of pd_counts</span></span><br><span class="line"><span class="built_in">print</span>(pd_counts.head())</span><br></pre></td></tr></table></figure><h2 id="pandas-data-frame-写入到-spark">Pandas Data Frame 写入到 Spark</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create pd_temp</span></span><br><span class="line">pd_temp = pd.DataFrame(np.random.random(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create spark_temp from pd_temp</span></span><br><span class="line">spark_temp = spark.createDataFrame(pd_temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Examine the tables in the catalog</span></span><br><span class="line"><span class="built_in">print</span>(spark.catalog.listTables())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add spark_temp to the catalog</span></span><br><span class="line">spark_temp.createOrReplaceTempView(<span class="string">&quot;temp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Examine the tables in the catalog again</span></span><br><span class="line"><span class="built_in">print</span>(spark.catalog.listTables())</span><br></pre></td></tr></table></figure><p>The <code>.createDataFrame()</code> method takes a <code>pandas</code> DataFrame and returns a Spark DataFrame.</p><p>The output of this method is stored locally, not in the <code>SparkSession</code> catalog. This means that you can use all the Spark DataFrame methods on it, but you can't access the data in other contexts.</p><p>For example, a SQL query (using the <code>.sql()</code> method) that references your DataFrame will throw an error. To access the data in this way, you have to save it as a <em>temporary table</em>.</p><p>You can do this using the <code>.createTempView()</code> Spark DataFrame method, which takes as its only argument the name of the temporary table you'd like to register. This method registers the DataFrame as a table in the catalog, but as this table is temporary, it can only be accessed from the specific <code>SparkSession</code> used to create the Spark DataFrame.</p><p>There is also the method <code>.createOrReplaceTempView()</code>. This safely creates a new temporary table if nothing was there before, or updates an existing table if one was already defined. You'll use this method to avoid running into problems with duplicate tables.</p><p>Check out the diagram to see all the different ways your Spark data structures interact with each other.</p><figure><img src="https://i.loli.net/2021/03/01/OsewxPRf3JFbGd4.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="spark-读取文本文件">Spark 读取文本文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Don&#x27;t change this file path</span></span><br><span class="line">file_path = <span class="string">&quot;/usr/local/share/datasets/airports.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the airports data</span></span><br><span class="line">airports = spark.read.csv(file_path,header=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the data</span></span><br><span class="line">airports.show()</span><br></pre></td></tr></table></figure><h1 id="操作数据">操作数据</h1><p>In Spark you can do this using the <code>.withColumn()</code> method, which takes two arguments. First, a string with the name of your new column, and second the new column itself.</p><p>The new column must be an object of class <code>Column</code>. Creating one of these is as easy as extracting a column from your DataFrame using <code>df.colName</code>.</p><p>Updating a Spark DataFrame is somewhat different than working in <code>pandas</code> because the Spark DataFrame is <em>immutable</em>. This means that it can't be changed, and so columns can't be updated in place.</p><p>Thus, all these methods return a new DataFrame. To overwrite the original DataFrame you must reassign the returned DataFrame using the method like so:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.withColumn(<span class="string">&quot;newCol&quot;</span>, df.oldCol + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>The above code creates a DataFrame with the same columns as <code>df</code> plus a new column, <code>newCol</code>, where every entry is equal to the corresponding entry from <code>oldCol</code>, plus one.</p><p>To overwrite an existing column, just pass the name of the column as the first argument!</p><h2 id="filter-data">Filter Data</h2><p>The <code>.filter()</code> method takes either an expression that would follow the <code>WHERE</code> clause of a SQL expression as a string, or a Spark Column of boolean (<code>True</code>/<code>False</code>) values.</p><p>For example, the following two expressions will produce the same output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flights.<span class="built_in">filter</span>(<span class="string">&quot;air_time &gt; 120&quot;</span>).show()</span><br><span class="line">flights.<span class="built_in">filter</span>(flights.air_time &gt; <span class="number">120</span>).show()</span><br></pre></td></tr></table></figure><h2 id="select-data">Select Data</h2><p>The Spark variant of SQL's <code>SELECT</code> is the <code>.select()</code> method. This method takes multiple arguments - one for each column you want to select. These arguments can either be the column name as a string (one for each column) or a column object (using the <code>df.colName</code> syntax). When you pass a column object, you can perform operations like addition or subtraction on the column to change the data contained in it, much like inside <code>.withColumn()</code>.</p><p>The difference between <code>.select()</code> and <code>.withColumn()</code> methods is that <code>.select()</code> returns only the columns you specify, while <code>.withColumn()</code> returns all the columns of the DataFrame in addition to the one you defined. It's often a good idea to drop columns you don't need at the beginning of an operation so that you're not dragging around extra data as you're wrangling. In this case, you would use <code>.select()</code> and not <code>.withColumn()</code>.</p><p>Similar to SQL, you can also use the <code>.select()</code> method to perform column-wise operations. When you're selecting a column using the <code>df.colName</code> notation, you can perform any column operation and the <code>.select()</code> method will return the transformed column. For example,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flights.select(flights.air_time/<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>returns a column of flight durations in hours instead of minutes. You can also use the <code>.alias()</code> method to rename a column you're selecting. So if you wanted to <code>.select()</code> the column <code>duration_hrs</code> (which isn't in your DataFrame) you could do</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flights.select((flights.air_time/<span class="number">60</span>).alias(<span class="string">&quot;duration_hrs&quot;</span>))</span><br></pre></td></tr></table></figure><p>with the SQL <code>as</code> keyword being equivalent to the <code>.alias()</code> method. To select multiple columns, you can pass multiple strings.</p><h2 id="aggregating">Aggregating</h2><p>All of the common aggregation methods, like <code>.min()</code>, <code>.max()</code>, and <code>.count()</code> are <code>GroupedData</code> methods. These are created by calling the <code>.groupBy()</code> DataFrame method. You'll learn exactly what that means in a few exercises. For now, all you have to do to use these functions is call that method on your DataFrame. For example, to find the minimum value of a column, <code>col</code>, in a DataFrame, <code>df</code>, you could do</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupBy().<span class="built_in">min</span>(<span class="string">&quot;col&quot;</span>).show()</span><br></pre></td></tr></table></figure><p>This creates a <code>GroupedData</code> object (so you can use the <code>.min()</code> method), then finds the minimum value in <code>col</code>, and returns it as a DataFrame.</p><h3 id="grouping-and-aggregating-i">Grouping and Aggregating I</h3><p>Part of what makes aggregating so powerful is the addition of groups. PySpark has a whole class devoted to grouped data frames: <code>pyspark.sql.GroupedData</code>, which you saw in the last two exercises.</p><p>You've learned how to create a grouped DataFrame by calling the <code>.groupBy()</code> method on a DataFrame with no arguments.</p><p>Now you'll see that when you pass the name of one or more columns in your DataFrame to the <code>.groupBy()</code> method, the aggregation methods behave like when you use a <code>GROUP BY</code> statement in a SQL query!</p><h3 id="grouping-and-aggregating-ii">Grouping and Aggregating II</h3><p>In addition to the <code>GroupedData</code> methods you've already seen, there is also the <code>.agg()</code> method. This method lets you pass an aggregate column expression that uses any of the aggregate functions from the <code>pyspark.sql.functions</code> submodule.</p><p>This submodule contains many useful functions for computing things like standard deviations. All the aggregation functions in this submodule take the name of a column in a <code>GroupedData</code> table.</p><h2 id="joining">Joining</h2><p>Another very common data operation is the <em>join</em>. Joins are a whole topic unto themselves, so in this course we'll just look at simple joins. If you'd like to learn more about joins, you can take a look <a href="https://www.datacamp.com/courses/merging-dataframes-with-pandas">here</a>.</p><p>A join will combine two different tables along a column that they share. This column is called the <em>key</em>. Examples of keys here include the <code>tailnum</code> and <code>carrier</code> columns from the <code>flights</code> table.</p><p>For example, suppose that you want to know more information about the plane that flew a flight than just the tail number. This information isn't in the <code>flights</code> table because the same plane flies many different flights over the course of two years, so including this information in every row would result in a lot of duplication. To avoid this, you'd have a second table that has only one row for each plane and whose columns list all the information about the plane, including its tail number. You could call this table <code>planes</code></p><p>When you join the <code>flights</code> table to this table of airplane information, you're adding all the columns from the <code>planes</code> table to the <code>flights</code> table. To fill these columns with information, you'll look at the tail number from the <code>flights</code> table and find the matching one in the <code>planes</code> table, and then use that row to fill out all the new columns.</p><h3 id="joining-ii">Joining II</h3><p>In PySpark, joins are performed using the DataFrame method <code>.join()</code>. This method takes three arguments. The first is the second DataFrame that you want to join with the first one. The second argument, <code>on</code>, is the name of the key column(s) as a string. The names of the key column(s) must be the same in each table. The third argument, <code>how</code>, specifies the kind of join to perform. In this course we'll always use the value <code>how="leftouter"</code>.</p><h1 id="machine-learning-pipelines">Machine learning pipelines</h1><p>In the next two chapters you'll step through every stage of the machine learning pipeline, from data intake to model evaluation. Let's get to it!</p><p>At the core of the <code>pyspark.ml</code> module are the <code>Transformer</code> and <code>Estimator</code> classes. Almost every other class in the module behaves similarly to these two basic classes.</p><p><code>Transformer</code> classes have a <code>.transform()</code> method that takes a DataFrame and returns a new DataFrame; usually the original one with a new column appended. For example, you might use the class <code>Bucketizer</code> to create discrete bins from a continuous feature or the class <code>PCA</code> to reduce the dimensionality of your dataset using principal component analysis.</p><p><code>Estimator</code> classes all implement a <code>.fit()</code> method. These methods also take a DataFrame, but instead of returning another DataFrame they return a model object. This can be something like a <code>StringIndexerModel</code> for including categorical data saved as strings in your models, or a <code>RandomForestModel</code> that uses the random forest algorithm for classification or regression.</p><h2 id="join-the-dataframes">Join the DataFrames</h2><p>In the next two chapters you'll be working to build a model that predicts whether or not a flight will be delayed based on the flights data we've been working with. This model will also include information about the plane that flew the route, so the first step is to join the two tables: <code>flights</code> and <code>planes</code>!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rename year column</span></span><br><span class="line">planes = planes.withColumnRenamed(<span class="string">&#x27;year&#x27;</span>,<span class="string">&#x27;plane_year&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Join the DataFrames</span></span><br><span class="line">model_data = flights.join(planes, on=<span class="string">&#x27;tailnum&#x27;</span>, how=<span class="string">&quot;leftouter&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="data-types">Data types</h2><p>Good work! Before you get started modeling, <strong>it's important to know that Spark only handles numeric data</strong>. That means all of the columns in your DataFrame must be either integers or decimals (called 'doubles' in Spark).</p><p>When we imported our data, we let Spark guess what kind of information each column held. Unfortunately, Spark doesn't always guess right and you can see that some of the columns in our DataFrame are strings containing numbers as opposed to actual numeric values.</p><p>To remedy this, you can use the <code>.cast()</code> method in combination with the <code>.withColumn()</code> method. It's important to note that <code>.cast()</code> works on columns, while <code>.withColumn()</code> works on DataFrames.</p><p>The only argument you need to pass to <code>.cast()</code> is the kind of value you want to create, in string form. For example, to create integers, you'll pass the argument <code>"integer"</code> and for decimal numbers you'll use <code>"double"</code>.</p><p>You can put this call to <code>.cast()</code> inside a call to <code>.withColumn()</code> to overwrite the already existing column, just like you did in the previous chapter!</p><h3 id="string-to-integer">String to integer</h3><p>Now you'll use the <code>.cast()</code> method you learned in the previous exercise to convert all the appropriate columns from your DataFrame <code>model_data</code> to integers!</p><p>To convert the type of a column using the <code>.cast()</code> method, you can write code like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cast the columns to integers</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;arr_delay&quot;</span>, model_data.arr_delay.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;air_time&quot;</span>, model_data.air_time.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;month&quot;</span>, model_data.month.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;plane_year&quot;</span>, model_data.plane_year.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the column plane_age</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;plane_age&quot;</span>, model_data.year - model_data.plane_year)</span><br></pre></td></tr></table></figure><h3 id="making-a-boolean">Making a Boolean</h3><p>Consider that you're modeling a yes or no question: is the flight late? However, your data contains the arrival delay in minutes for each flight. Thus, you'll need to create a boolean column which indicates whether the flight was late or not!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create is_late</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;is_late&quot;</span>, model_data.arr_delay &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert to an integer</span></span><br><span class="line">model_data = model_data.withColumn(<span class="string">&quot;label&quot;</span>, model_data.is_late.cast(<span class="string">&#x27;integer&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove missing values</span></span><br><span class="line">model_data = model_data.<span class="built_in">filter</span>(<span class="string">&quot;arr_delay is not NULL and dep_delay is not NULL and air_time is not NULL and plane_year is not NULL&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="strings-and-factors">Strings and factors</h3><p>As you know, Spark requires numeric data for modeling. So far this hasn't been an issue; even boolean columns can easily be converted to integers without any trouble. But you'll also be using the airline and the plane's destination as features in your model. These are coded as strings and there isn't any obvious way to convert them to a numeric data type.</p><p>Fortunately, PySpark has functions for handling this built into the <code>pyspark.ml.features</code> submodule. You can create what are called 'one-hot vectors' to represent the carrier and the destination of each flight. A <em>one-hot vector</em> is a way of representing a categorical feature where every observation has a vector in which all elements are zero except for at most one element, which has a value of one (1).</p><p>Each element in the vector corresponds to a level of the feature, so it's possible to tell what the right level is by seeing which element of the vector is equal to one (1).</p><p>The first step to encoding your categorical feature is to create a <code>StringIndexer</code>. Members of this class are <code>Estimator</code>s that take a DataFrame with a column of strings and map each unique string to a number. Then, the <code>Estimator</code> returns a <code>Transformer</code> that takes a DataFrame, attaches the mapping to it as metadata, and returns a new DataFrame with a numeric column corresponding to the string column.</p><p>The second step is to encode this numeric column as a one-hot vector using a <code>OneHotEncoder</code>. This works exactly the same way as the <code>StringIndexer</code> by creating an <code>Estimator</code> and then a <code>Transformer</code>. The end result is a column that encodes your categorical feature as a vector that's suitable for machine learning routines!</p><p>This may seem complicated, but don't worry! All you have to remember is that you need to create a <code>StringIndexer</code> and a <code>OneHotEncoder</code>, and the <code>Pipeline</code> will take care of the rest.</p><h3 id="carrier-destination">Carrier &amp; Destination</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a StringIndexer</span></span><br><span class="line">carr_indexer = StringIndexer(inputCol=<span class="string">&quot;carrier&quot;</span>,outputCol=<span class="string">&quot;carrier_index&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a OneHotEncoder</span></span><br><span class="line">carr_encoder = OneHotEncoder(inputCol=<span class="string">&quot;carrier_index&quot;</span>,outputCol=<span class="string">&quot;carrier_fact&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a StringIndexer</span></span><br><span class="line">dest_indexer = StringIndexer(inputCol=<span class="string">&#x27;dest&#x27;</span>,outputCol=<span class="string">&#x27;dest_index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a OneHotEncoder</span></span><br><span class="line">dest_encoder = OneHotEncoder(inputCol=<span class="string">&#x27;dest_index&#x27;</span>,outputCol=<span class="string">&#x27;dest_fact&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="assemble-a-vector">Assemble a vector</h3><p>The last step in the <code>Pipeline</code> is to combine all of the columns containing our features into a single column. This has to be done before modeling can take place because every Spark modeling routine expects the data to be in this form. You can do this by storing each of the values from a column as an entry in a vector. Then, from the model's point of view, every observation is a vector that contains all of the information about it and a label that tells the modeler what value that observation corresponds to.</p><p>Because of this, the <code>pyspark.ml.feature</code> submodule contains a class called <code>VectorAssembler</code>. This <code>Transformer</code> takes all of the columns you specify and combines them into a new vector column.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a VectorAssembler</span></span><br><span class="line">vec_assembler = VectorAssembler(inputCols=[<span class="string">&quot;month&quot;</span>, <span class="string">&quot;air_time&quot;</span>, <span class="string">&quot;carrier_fact&quot;</span>, <span class="string">&quot;dest_fact&quot;</span>, <span class="string">&quot;plane_age&quot;</span>], outputCol=<span class="string">&quot;features&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="create-the-pipeline">Create the pipeline</h3><p>ou're finally ready to create a <code>Pipeline</code>!</p><p><code>Pipeline</code> is a class in the <code>pyspark.ml</code> module that combines all the <code>Estimators</code> and <code>Transformers</code> that you've already created. This lets you reuse the same modeling process over and over again by wrapping it up in one simple object. Neat, right?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import Pipeline</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the pipeline</span></span><br><span class="line">flights_pipe = Pipeline(stages=[dest_indexer, dest_encoder, carr_indexer, carr_encoder, vec_assembler])</span><br></pre></td></tr></table></figure><h3 id="test-and-train">Test and Train</h3><p>After you've cleaned your data and gotten it ready for modeling, one of the most important steps is to split the data into a <em>test set</em> and a <em>train set</em>. After that, don't touch your test data until you think you have a good model! As you're building models and forming hypotheses, you can test them on your training data to get an idea of their performance.</p><p>Once you've got your favorite model, you can see how well it predicts the new data in your test set. This never-before-seen data will give you a much more realistic idea of your model's performance in the real world when you're trying to predict or classify new data.</p><p>In Spark it's important to make sure you split the data <strong>after</strong> all the transformations. This is because operations like <code>StringIndexer</code> don't always produce the same index even when given the same list of strings.</p><h3 id="transform-the-data">Transform the data</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fit and transform the data</span></span><br><span class="line">piped_data = flights_pipe.fit(model_data).transform(model_data)</span><br></pre></td></tr></table></figure><h3 id="split-the-data">Split the data</h3><p>Now that you've done all your manipulations, the last step before modeling is to split the data!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Split the data into training and test sets</span></span><br><span class="line">training, test = piped_data.randomSplit([<span class="number">.6</span>, <span class="number">.4</span>])</span><br></pre></td></tr></table></figure><h1 id="model-tuning-and-selection">Model tuning and selection</h1><h2 id="what-is-logistic-regression">What is logistic regression?</h2><p>The model you'll be fitting in this chapter is called a <em>logistic regression</em>. This model is very similar to a linear regression, but instead of predicting a numeric variable, it predicts the probability (between 0 and 1) of an event.</p><p>To use this as a classification algorithm, all you have to do is assign a cutoff point to these probabilities. If the predicted probability is above the cutoff point, you classify that observation as a 'yes' (in this case, the flight being late), if it's below, you classify it as a 'no'!</p><p>You'll tune this model by testing different values for several <em>hyperparameters</em>. A <em>hyperparameter</em> is just a value in the model that's not estimated from the data, but rather is supplied by the user to maximize performance. For this course it's not necessary to understand the mathematics behind all of these values - what's important is that you'll try out a few different choices and pick the best one.</p><h3 id="建立模型">建立模型</h3><p>The <code>Estimator</code> you'll be using is a <code>LogisticRegression</code> from the <code>pyspark.ml.classification</code> submodule.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import LogisticRegression</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.classification <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a LogisticRegression Estimator</span></span><br><span class="line">lr = LogisticRegression()</span><br></pre></td></tr></table></figure><h3 id="cross-validation">Cross validation</h3><p>In the next few exercises you'll be tuning your logistic regression model using a procedure called <em>k-fold cross validation</em>. This is a method of estimating the model's performance on unseen data (like your <code>test</code> DataFrame).</p><p>It works by splitting the training data into a few different partitions. The exact number is up to you, but in this course you'll be using PySpark's default value of three. Once the data is split up, one of the partitions is set aside, and the model is fit to the others. Then the error is measured against the held out partition. This is repeated for each of the partitions, so that every block of data is held out and used as a test set exactly once. Then the error on each of the partitions is averaged. This is called the <em>cross validation error</em> of the model, and is a good estimate of the actual error on the held out data.</p><p>You'll be using cross validation to choose the hyperparameters by creating a grid of the possible pairs of values for the two hyperparameters, <code>elasticNetParam</code> and <code>regParam</code>, and using the cross validation error to compare all the different models so you can choose the best one!</p><h3 id="create-the-evaluator">Create the evaluator</h3><p>The first thing you need when doing cross validation for model selection is a way to compare different models. Luckily, the <code>pyspark.ml.evaluation</code> submodule has classes for evaluating different kinds of models. Your model is a binary classification model, so you'll be using the <code>BinaryClassificationEvaluator</code> from the <code>pyspark.ml.evaluation</code> module.</p><p>This evaluator calculates the area under the ROC. This is a metric that combines the two kinds of errors a binary classifier can make (false positives and false negatives) into a simple number. You'll learn more about this towards the end of the chapter!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the evaluation submodule</span></span><br><span class="line"><span class="keyword">import</span> pyspark.ml.evaluation <span class="keyword">as</span> evals</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a BinaryClassificationEvaluator</span></span><br><span class="line">evaluator = evals.BinaryClassificationEvaluator(metricName=<span class="string">&quot;areaUnderROC&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="make-a-grid">Make a grid</h3><p>Next, you need to create a grid of values to search over when looking for the optimal hyperparameters. The submodule <code>pyspark.ml.tuning</code> includes a class called <code>ParamGridBuilder</code> that does just that (maybe you're starting to notice a pattern here; PySpark has a submodule for just about everything!).</p><p>You'll need to use the <code>.addGrid()</code> and <code>.build()</code> methods to create a grid that you can use for cross validation. The <code>.addGrid()</code> method takes a model parameter (an attribute of the model <code>Estimator</code>, <code>lr</code>, that you created a few exercises ago) and a list of values that you want to try. The <code>.build()</code> method takes no arguments, it just returns the grid that you'll use later.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the tuning submodule</span></span><br><span class="line"><span class="keyword">import</span> pyspark.ml.tuning <span class="keyword">as</span> tune</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the parameter grid</span></span><br><span class="line">grid = tune.ParamGridBuilder()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the hyperparameter</span></span><br><span class="line">grid = grid.addGrid(lr.regParam, np.arange(<span class="number">0</span>, <span class="number">.1</span>, <span class="number">.01</span>))</span><br><span class="line">grid = grid.addGrid(lr.elasticNetParam, [<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build the grid</span></span><br><span class="line">grid = grid.build()</span><br></pre></td></tr></table></figure><h3 id="make-the-validator">Make the validator</h3><p>The submodule <code>pyspark.ml.tuning</code> also has a class called <code>CrossValidator</code> for performing cross validation. This <code>Estimator</code> takes the modeler you want to fit, the grid of hyperparameters you created, and the evaluator you want to use to compare your models.</p><p>The submodule <code>pyspark.ml.tune</code> has already been imported as <code>tune</code>. You'll create the <code>CrossValidator</code> by passing it the logistic regression <code>Estimator</code> <code>lr</code>, the parameter <code>grid</code>, and the <code>evaluator</code> you created in the previous exercises.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create the CrossValidator</span></span><br><span class="line">cv = tune.CrossValidator(estimator=lr,</span><br><span class="line">               estimatorParamMaps=grid,</span><br><span class="line">               evaluator=evaluator</span><br><span class="line">               )</span><br></pre></td></tr></table></figure><h3 id="fit-the-models">Fit the model(s)</h3><p>You're finally ready to fit the models and select the best one!</p><p>Unfortunately, cross validation is a very computationally intensive procedure. Fitting all the models would take too long on DataCamp.</p><p>To do this locally you would use the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fit cross validation models</span></span><br><span class="line">models = cv.fit(training)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract the best model</span></span><br><span class="line">best_lr = models.bestModel</span><br></pre></td></tr></table></figure><p>Remember, the training data is called <code>training</code> and you're using <code>lr</code> to fit a logistic regression model. Cross validation selected the parameter values <code>regParam=0</code> and <code>elasticNetParam=0</code> as being the best. These are the default values, so you don't need to do anything else with <code>lr</code> before fitting the model.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Call lr.fit()</span></span><br><span class="line">best_lr = lr.fit(training)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print best_lr</span></span><br><span class="line"><span class="built_in">print</span>(best_lr)</span><br></pre></td></tr></table></figure><h2 id="evaluate-the-model">Evaluate the model</h2><p>For this course we'll be using a common metric for binary classification algorithms call the <em>AUC</em>, or area under the curve. In this case, the curve is the ROC, or receiver operating curve. The details of what these things actually measure isn't important for this course. All you need to know is that for our purposes, the closer the AUC is to one (1), the better the model is!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use the model to predict the test set</span></span><br><span class="line">test_results = best_lr.transform(test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate the predictions</span></span><br><span class="line"><span class="built_in">print</span>(evaluator.evaluate(test_results))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;A platform for cluster computing.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="大数据" scheme="https://scottzhang.pro/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="spark" scheme="https://scottzhang.pro/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Bash for Data Manipulation</title>
    <link href="https://scottzhang.pro/article/2196900071.html"/>
    <id>https://scottzhang.pro/article/2196900071.html</id>
    <published>2021-02-25T15:20:39.000Z</published>
    <updated>2021-11-27T08:44:10.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Do complex things with just a few keystrokes!</p></blockquote><span id="more"></span><p>Bash is a Unix shell and command language, it survived and thrived for almost 50 years because it lets people do complex things with just a few keystrokes. Sometimes called "the universal glue of programming," it helps users combine existing programs in new ways, automate repetitive tasks, and run programs on clusters and clouds that may be halfway around the world.</p><h1 id="basic">Basic</h1><blockquote><p>How to move around in the shell, and how to create, modify, and delete files and folders.</p></blockquote><ul><li><code>pwd</code> print working directory</li><li><code>ls</code>: listing files or directories</li><li><code>cd</code>: change directory</li><li><code>cp</code>: copy</li><li><code>mv</code>: move or rename</li><li><code>rm</code>: remove</li><li><code>$1</code> or <code>$2</code> in bash script file, receive ARGV in bash scripts. <code>$@</code> , <code>$*</code> means get ARGV list, <code>$#</code> means get ARGV length.</li></ul><h1 id="find-files">Find files</h1><h2 id="by-name">by name</h2><ul><li>find ., list all file and folder below current</li><li>find folder</li><li>find . -type d, find all foldre, no file</li><li>find . -type f, find all file , no foldre</li><li>find . -type f -name "test.txt", name as text txt file</li><li>find . -type f -name "text*", name as txt all file</li><li>find . -type f -iname "text*", 不区分大小写</li><li>find . -type f -name "*.py"</li></ul><h2 id="by-time">by time</h2><ul><li>find . -type f -mmin -10,过去十分钟修改过的文件</li><li>find . -type f -mmin +10</li><li>find . -type f -mmin +1 -mmin -5</li><li>find . -type f -mtime -20</li></ul><p>amin,atime: access min and access day; cmin,ctime: change min and change day; mmin,mtime: modify;</p><h2 id="by-size">by size</h2><ul><li>find . -size +5m, k,g is work too</li><li>ls -lah ./folders, info about sub folder and files,including size</li><li>find . -empty</li></ul><h2 id="by-permission">by permission</h2><ul><li>find. -perm 777, read, write, and excute</li><li>find folder -exec chown coreschafer:www-data {} +</li><li>find folder, will return all folder, -exec will run the command in that results, {} palceholder, + end of the command.</li><li>find folder -type f -exec chmod 664 {} +</li><li>find folder -perm 664</li><li>find . -type f -name "*.jpg"</li><li>find . -type f -name "*.jpg" -maxdepth 1, searched 1 level down</li><li>find . -type f -name "*.jpg" -maxdepth 1 -exec rm {} +, delete serched files</li></ul><h1 id="grep">Grep</h1><h2 id="grep-single-file">Grep single file</h2><blockquote><p>searched text</p></blockquote><ul><li>grep "text_you_want_search" filename.txt</li><li>grep -w "text_you_want_search" filename.txt, have to match all words</li><li>grep -wi "text_you_want_search" filename.txt, igore the lowcase and uppearcse.</li><li>grep -win "text_you_want_search" filename.txt, get info about the line number</li><li>grep -win -B 4 "text_you_want_search" filename.txt, return the context about the searched words, 4 line, behind</li><li>grep -win -A 4 "text_you_want_search" filename.txt, return the context about the searched words, 4 line, ahead</li><li>grep -win -C 4 "text_you_want_search" filename.txt, return the context about the searched words, 4 line, two line before and two behind.</li></ul><h2 id="grep-multi-file">Grep multi file</h2><ul><li>grep -win "text_" ./*, all file</li><li>grep -win "text_" ./*.txt, txt file</li><li>grep -winr "text" ./ , search all subdir</li><li>grep -wirl "text" ./ , no need match info, just file list</li><li>grep -wirc "text" ./ , show matched number in eatch file</li></ul><h2 id="grep-command-history">Grep command history</h2><ul><li>history | grep "git commit"</li><li>history | grep "git commit" | grep "dotfile"</li></ul><h2 id="grep-rgx">Grep rgx</h2><ul><li>grep -P "--" file.txt, work well in linux, mac need to config, I configed</li></ul><h1 id="curl">cURL</h1><h2 id="requests">Requests</h2><ul><li>curl url</li><li>curl http://localhost:5000</li><li>curl http:www.wittyfans.com/json_file</li><li>curl -i http:www.wittyfans.com/json_file, details info about the get</li><li>curl http:www.wittyfans.com/method</li><li>curl -d "first=name&amp;last=lastname" http:www.wittyfans.com/method, d for data, Post request</li><li>curl -X PUT -d "first=name&amp;last=lastname" http:www.wittyfans.com/method, d for data, Pust request</li><li>curl -X DELETE http:www.wittyfans.com/method, delete request</li></ul><h2 id="verify">Verify</h2><p>Could not verify your access ?</p><p><code>curl -u username:password http://wittyfans.com, Auth</code></p><h2 id="download">Download</h2><ul><li>curl http://wittyfans.com/folder, return binary file , error</li><li>curl -o filename.jpg http://wittyfans.com/folder , sucess</li><li>curl -o file_name.json http:/.api.wittyfans.com , Saving large json file</li></ul><h1 id="rsync">rsync</h1><h2 id="install">Install</h2><p>aviable in Mac, debian-based linux need to install</p><ul><li>apt-get install rsync</li><li>yum install rsync</li></ul><h2 id="use">Use</h2><ul><li>rsync folder1/* backup/ , sync fils to backup folder,will skping the subfolder's file, but affected subfolder</li><li>rsync -r folder1/* backup/ , including subfolder's file</li><li>rsync -r folder1 backup/, sync folder, not content in it</li></ul><h2 id="check-chage-before-run">Check chage before run</h2><ul><li>rsync -a --dry-run folder1/* backup/, check before the command run, now view showed</li><li>rsync -av --dry-run folder1/* backup/, auto view</li></ul><h2 id="source_folder-has-new-file">Source_folder has new file</h2><ul><li>rsync -av --delete --dry-run original/ backup/, check, be careful !</li></ul><h2 id="do-it-in-local-and-host">Do it in local and host</h2><ul><li>rsync -zaP -p local_folder username@ip:~/public/, z for compress, a for all, P for tarnsfer in internet</li><li>rsync 0zaP username@ip:~/public/file ~/Downloads/, revers</li></ul><h1 id="manipulating-data">Manipulating data</h1><blockquote><p>How to work with the data in those files</p></blockquote><p><code>cat</code>: view a files contents, meaning concatenate</p><p><code>less</code> &amp; <code>more</code>: view contents piece by piece, <code>more</code> is superseded by <code>less</code> now, In <code>less</code>:</p><ul><li><code>:n</code>, Move to next file</li><li><code>:p</code>, Go back to previous file</li><li><code>:q</code>, quit</li></ul><p><code>head</code>: look at the start of a text file, <code>head -3</code>, only display the first three lines</p><p><code>tail</code>: look at the end of a text file, <code>tail -n +7</code>, display content from line 7 to end</p><p><code>ls</code> : list everything below a directory, <code>ls -R -F</code>, <code>-R</code> recursive <code>-F</code>prints a <code>/</code> after the name of every directory and a <code>*</code> after the name of every runnable program.</p><p><code>man</code>: manual, automatically invokes <code>less</code></p><p><code>cut -f 2-5,8 -d values.csv</code>: select columns 2 through 5 and columns 8, using comma as the separator. <code>-d</code> means delimiter, <code>-f</code> meaning fields to specify columns</p><p><code>!command</code>: re-run the most recent use of that command matched</p><p><code>grep bicuspid seasonal/winter.csv</code>: prints lines from winter.csv that contain "bicuspid"</p><p><code>cat two_cities.txt | egrep 'Sydney Carton|Charles Darnay' | wc -l</code> : Count the number of lines in the book that contain <em>either</em> the character 'Sydney Carton' or 'Charles Darnay'.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c: <span class="built_in">print</span> a count of matching lines rather than the lines themselves</span><br><span class="line">-h: <span class="keyword">do</span> not <span class="built_in">print</span> the names of files when searching multiple files</span><br><span class="line">-i: ignore <span class="keyword">case</span> (e.g., treat <span class="string">&quot;Regression&quot;</span> and <span class="string">&quot;regression&quot;</span> as matches)</span><br><span class="line">-l: <span class="built_in">print</span> the names of files that contain matches, not the matches</span><br><span class="line">-n: <span class="built_in">print</span> line numbers <span class="keyword">for</span> matching lines</span><br><span class="line">-v: invert the match, i.e., only show lines that don<span class="string">&#x27;t match</span></span><br><span class="line"><span class="string">egrep: grep -E</span></span><br></pre></td></tr></table></figure><h2 id="combining-tools">Combining tools</h2><blockquote><p>How to use this power to select the data you want, and introduce commands for sorting values and removing duplicates.</p></blockquote><p><code>head -n 5 seasonal/summer.csv &gt; top.csv</code>: get first 5 rows content of summer.csv, write to top.csv</p><p><code>cut -d , -f 2 seasonal/summer.csv | grep -v Tooth</code>, select all of the tooth names from column 2 of the comma delimited file.</p><p><code>wc</code>, word count, count a date from a file. <code>grep 2017-07 seasonal/spring.csv | wc -l</code></p><p><code>head -n 3 seasonal/s*</code>, show all s* files first 3 rows.</p><ul><li><code>*</code>, all</li><li><code>?</code>, single word</li><li><code>[...]</code> matches any one of the characters inside the square brackets, <code>201[78].txt</code> matches <code>2017.txt</code> or <code>2018.txt</code>, but not <code>2016.txt</code></li><li><code>&#123;...&#125;</code> matches any of the comma-separated patterns inside the curly brackets, so <code>&#123;*.txt, *.csv&#125;</code> matches any file whose name ends with <code>.txt</code> or <code>.csv</code>, but not files whose names end with <code>.pdf</code>.</li></ul><p><code>sort</code>, <code>-n</code>: sort numerically, <code>-r</code>: reverse, <code>-b</code>: ignore leading blanks, <code>-f</code>: be case-insensitive</p><p><code>uniq</code>, remove <strong>adjacent</strong> duplicated lines .</p><p><code>wc -l seasonal/*.csv</code>, Print line numbers for each file in folder seasonal</p><p><code>wc -l seasonal/*.csv | grep -v 'total' | sort -n | head -n 1</code>, remove rows with word 'total' and select first row.</p><h2 id="batch-processing">Batch processing</h2><blockquote><p>How to make your own pipelines do that. Along the way, you will see how the shell uses variables to store information.</p></blockquote><p><code>set</code>: check <strong>environment variables</strong></p><p><code>echo</code>: print</p><ul><li><code>$User</code>, user name</li><li><code>$OSTYPE</code> name of the kind of operating system you are using</li></ul><p><code>training=seasonal/summer.csv</code> then <code>echo $training</code>, define a variable and print it.</p><p><strong>For loop:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example 1</span></span><br><span class="line"><span class="keyword">for</span> filetype <span class="keyword">in</span> gif jpg png; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$filetype</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># Example 2</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> seasonal/*.csv; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$filename</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># Example 3</span></span><br><span class="line">datasets=seasonal/*.csv</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> <span class="variable">$datasets</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$filename</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># Example 4</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> seasonal/*.csv; <span class="keyword">do</span> head -n 2 <span class="variable">$file</span> | tail -n 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>Do not using space in file name, it will causing issue in bash.</p></blockquote><h2 id="creating-new-tools">Creating new tools</h2><blockquote><p>How to go one step further and create new commands of your own.</p></blockquote><p><strong>Edit file using <code>nano</code>:</strong></p><p><code>nano filename.txt</code>, edit a file</p><ul><li><code>Ctrl</code> + <code>K</code>: delete a line.</li><li><code>Ctrl</code> + <code>U</code>: un-delete a line.</li><li><code>Ctrl</code> + <code>O</code>: save the file ('O' stands for 'output'). <em>You will also need to press Enter to confirm the filename!</em></li><li><code>Ctrl</code> + <code>X</code>: exit the editor.</li></ul><p><code>grep -h -v Tooth spring.csv summer.csv &gt; temp.csv</code>, <code>-h</code> stop it from printing filenames, <code>-v</code> printing all rows exclude Tooth</p><p><code>history | tail -n 3</code>, Show most recent 3 commands</p><p><code>$@</code>, pass filenames to scripts. <code>tail -q -n +2 $@ | wc -l</code></p><h2 id="downloading-data">Downloading data</h2><blockquote><p>how to download data files from web servers via the command line</p></blockquote><p><code>curl</code>, Client for URLs. <code>man curl</code> , check curl installation.</p><ul><li><code>curl -O url</code> save the file with it's original name</li><li><code>curl -o newname.txt url</code> new file name</li><li>Download all 100 data file, <code>curl -O https://s3.amazonaws.com/datafile[001-100].txt</code></li></ul><p><code>Wget</code>, World Wide Web and get. better than curl when downloading multiple files recursively. <code>which wget</code>, check <code>wget</code> installation.</p><p><code>wget -c -b https://wittyfans.com/201812SpotifyData.zip</code></p><ul><li><code>-c</code>, resume broken download</li><li><code>-b</code>, go to background</li><li><code>wget --wait=1 -i url_list.txt</code>, # Create a mandatory 1 second pause between downloading all files in url_list.txt</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use curl, download and rename a single file from URL</span></span><br><span class="line">curl -O Spotify201812.zip -L https://assets.datacamp.com/production/repositories/4180/datasets/eb1d6a36fa3039e4e00064797e1a1600d267b135/201812SpotifyData.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unzip, delete, then re-name to Spotify201812.csv</span></span><br><span class="line">unzip Spotify201812.zip &amp;&amp; rm Spotify201812.zip</span><br><span class="line">mv 201812SpotifyData.csv Spotify201812.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># View url_list.txt to verify content</span></span><br><span class="line">cat url_list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Wget, limit the download rate to 2500 KB/s, download all files in url_list.txt</span></span><br><span class="line">wget --limit-rate=2500k -i url_list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Take a look at all files downloaded</span></span><br><span class="line">ls</span><br></pre></td></tr></table></figure><h2 id="csv-kit">CSV Kit</h2><blockquote><p>Using <code>csvkit</code> to convert, preview, filter and manipulate files to prepare our data for further analyses.</p></blockquote><p><code>pip install csvk</code> for install, <a href="https://csvkit.readthedocs.io/en/latest/tutorial.html">Doc</a></p><h3 id="in2csv">in2csv</h3><ul><li><code>in2csv -h</code>, converting files to csv.</li><li><code>in2csv SpotifyData.xlsx &gt; SpotifyData.csv</code></li><li><code>in2csv SpotifyData.xlsx --sheet "Worksheet1_Popularity" &gt; Spotify_Popularity.csv</code>, Only converting a sheet</li></ul><h3 id="csvlook">csvlook</h3><ul><li><code>csvlook -h</code>, data preview on the command line.</li><li><code>csvlook SpotifyData.csv</code></li></ul><h3 id="csvsort">csvsort</h3><ul><li><code>csvsort -c 2 Spotify_Popularity.csv | csvlook</code></li></ul><h3 id="csvstat">csvstat</h3><ul><li><code>csvstat Spotify_Popularity.csv</code>, summary statistics</li></ul><h3 id="csvcut">csvcut</h3><ul><li><code>csvcut -n Spotify_MusicAttributes.csv</code>, Print a list of column headers in data file</li><li><code>csvcut -c 1,3,5 Spotify_MusicAttributes.csv</code>, Print the first column, by position</li><li><code>csvcut -c "track_id","duration_ms","loudness" Spotify_MusicAttributes.csv</code>, Print the track id, song duration, and loudness, by name</li></ul><h3 id="csvgrep">csvgrep</h3><ul><li><code>csvgrep -c "danceability" -m 0.812 Spotify_MusicAttributes.csv</code>, filter row danceability by value 0.812, column name must with "".</li></ul><h3 id="csvstack">csvstack</h3><ul><li><code>csvstack</code>, merge files.</li><li><code>csvstack Spotify_Rank6.csv Spotify_Rank7.csv &gt; Spotify.csv</code>, merge two files to one</li><li><code>csvstack -g "Rank6","Rank7" \ Spotify_Rank6.csv Spotify_Rank7.csv &gt; Spotify_Al</code>, merge two files to one and add a source column.</li></ul><h3 id="chain-commands">chain commands</h3><ul><li><code>;</code>, links commands together and runs sequentially</li><li><code>&amp;&amp;</code>, links commands together, but only runs the 2nd command if the 1st succeeds</li><li><code>&gt;</code>, using outputs from the 1st command</li><li><code>|</code>, using outputs form the 1st as input to the 2nd</li></ul><h3 id="sql2csv">sql2csv</h3><ul><li><code>sql2csv -v</code> or <code>sql2csv --verbose</code>, printing more tracebacks and logs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pull the entire Spotify_Popularity table and print in log</span></span><br><span class="line">sql2csv --db <span class="string">&quot;sqlite:///SpotifyDatabase.db&quot;</span> \</span><br><span class="line">        --query <span class="string">&quot;SELECT * FROM Spotify_Popularity&quot;</span></span><br></pre></td></tr></table></figure><h3 id="csvsql">csvsql</h3><p>Manipulating data using SQL syntax (Small to medium files only) :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reformat the output using csvlook</span></span><br><span class="line">csvsql --query <span class="string">&quot;SELECT * FROM Spotify_MusicAttributes ORDER BY duration_ms LIMIT 1&quot;</span> \</span><br><span class="line">Spotify_MusicAttributes.csv | csvlook</span><br></pre></td></tr></table></figure><p>using bash variable:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Store SQL query as shell variable</span></span><br><span class="line">sqlquery=<span class="string">&quot;SELECT * FROM Spotify_MusicAttributes ORDER BY duration_ms LIMIT 1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply SQL query to Spotify_MusicAttributes.csv</span></span><br><span class="line">csvsql --query <span class="string">&quot;<span class="variable">$sqlquery</span>&quot;</span> Spotify_MusicAttributes.csv</span><br></pre></td></tr></table></figure><p>join two file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Store SQL query as shell variable</span></span><br><span class="line">sql_query=<span class="string">&quot;SELECT ma.*, p.popularity FROM Spotify_MusicAttributes ma INNER JOIN Spotify_Popularity p ON ma.track_id = p.track_id&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Join 2 local csvs into a new csv using the saved SQL</span></span><br><span class="line">csvsql --query <span class="string">&quot;<span class="variable">$sql_query</span>&quot;</span> Spotify_MusicAttributes.csv Spotify_Popularity.csv &gt; Spotify_FullData.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preview newly created file</span></span><br><span class="line">csvstat Spotify_FullData.csv</span><br></pre></td></tr></table></figure><p>Pushing data back to database:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Store SQL for querying from SQLite database</span></span><br><span class="line">sqlquery_pull=<span class="string">&quot;SELECT * FROM SpotifyMostRecentData&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply SQL to save table as local file</span></span><br><span class="line">sql2csv --db <span class="string">&quot;sqlite:///SpotifyDatabase.db&quot;</span> --query <span class="string">&quot;<span class="variable">$sqlquery_pull</span>&quot;</span> &gt; SpotifyMostRecentData.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store SQL for UNION of the two local CSV files</span></span><br><span class="line">sqlquery_union=<span class="string">&quot;SELECT * FROM SpotifyMostRecentData UNION ALL SELECT * FROM Spotify201812&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply SQL to union the two local CSV files and save as local file</span></span><br><span class="line">csvsql --query <span class="string">&quot;<span class="variable">$sqlquery_union</span>&quot;</span> SpotifyMostRecentData.csv Spotify201812.csv &gt; UnionedSpotifyData.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Push UnionedSpotifyData.csv to database as a new table</span></span><br><span class="line">csvsql --db <span class="string">&quot;sqlite:///SpotifyDatabase.db&quot;</span> --insert UnionedSpotifyData.csv</span><br></pre></td></tr></table></figure><h1 id="bash-script">Bash Script</h1><h2 id="stream-editor">Stream editor</h2><p><code>sed</code>: stream editor.</p><p><code>cat soccer_scores.csv | sed 's/Cherno/Cherno City/g' &gt; soccer_scores_edited.csv</code> : replace word <code>Cherno</code> to <code>herno City</code> then save it to a new file, for more, check <a href="https://coolshell.cn/articles/9104.html">this</a>.</p><h2 id="argument">Argument</h2><p><code>$1</code> or <code>$2</code> in bash script file, receive ARGV in bash scripts. <code>$@</code> , <code>$*</code> means get ARGV list, <code>$#</code> means get ARGV length. <code>cat hire_data/*.csv | grep "$1" &gt; "$1".csv</code>: take in a city (an argument) as a variable, filter all the files by this city and output to a new CSV with the city name.</p><h2 id="quotes">Quotes</h2><p>Single,double,backticks.</p><ul><li>Single quotes ('sometext') = Shell interprets what is between literally</li><li>Double quotes ("sometext") = Shell interpret literally except using $ and backticks</li><li>Backticks (`sometext`) = Shell runs the command and captures STDOUT back into a variable</li></ul><h2 id="numeric-variables">Numeric variables</h2><p>In bash, Type <code>&gt;&gt;&gt; 1 + 5</code> will get error. instead, you need type <code>expr 1 + 5</code>. <code>expr</code> is utility program just like <code>cat</code> and <code>grep</code>. but <code>expr</code> cannot natively handle decimal places. <code>expr 1 + 2.5</code> will get <code>not a decimal nuber error</code>.</p><p>Introduce <code>bc</code> (basic calculator), a useful command-line program. using <code>bc</code> without opening the calculator:</p><p><code>echo "5+7.5" | bc</code> , <code>bc</code> has a <code>scale</code> argument for how many decimal places: <code>echo "scale=3; 10 /3 | bc"</code>, <code>;</code> is to separate lines in terminal.</p><h2 id="array">Array</h2><h3 id="normal-array">Normal array</h3><p>Create array: <code>capital_cities=("Sydney" "New York" "Paris")</code></p><p>Add element:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a normal array with the mentioned elements using the declare method</span></span><br><span class="line"><span class="built_in">declare</span> -a capital_cities</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add (append) the elements</span></span><br><span class="line">capital_cities+=(<span class="string">&quot;Sydney&quot;</span>)</span><br><span class="line">capital_cities+=(<span class="string">&quot;New York&quot;</span>)</span><br><span class="line">capital_cities+=(<span class="string">&quot;Paris&quot;</span>)</span><br></pre></td></tr></table></figure><p>Get all element and length of array:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The array has been created for you</span></span><br><span class="line">capital_cities=(<span class="string">&quot;Sydney&quot;</span> <span class="string">&quot;New York&quot;</span> <span class="string">&quot;Paris&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the entire array</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;capital_cities[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the array length</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#capital_cities[@]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="associative-arrays">Associative arrays</h3><blockquote><p>Like dictionary in python.</p></blockquote><p>Create:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create empty associative array</span></span><br><span class="line"><span class="built_in">declare</span> -A model_metrics</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the key-value pairs</span></span><br><span class="line">model_metrics[model_accuracy]=98</span><br><span class="line">model_metrics[model_name]=<span class="string">&quot;knn&quot;</span></span><br><span class="line">model_metrics[model_f1]=0.82</span><br></pre></td></tr></table></figure><p>Create in one line:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># An associative array has been created for you</span></span><br><span class="line"><span class="built_in">declare</span> -A model_metrics=([model_accuracy]=98 [model_name]=<span class="string">&quot;knn&quot;</span> [model_f1]=0.82)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out just the keys</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;____model_metrics[____]&#125;</span></span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create variables from the temperature data files</span></span><br><span class="line">temp_b=<span class="string">&quot;<span class="subst">$(cat temps/region_B)</span>&quot;</span></span><br><span class="line">temp_c=<span class="string">&quot;<span class="subst">$(cat temps/region_C)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array with these variables as elements</span></span><br><span class="line">region_temps=(<span class="variable">$temp_b</span> <span class="variable">$temp_c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call an external program to get average temperature</span></span><br><span class="line">average_temp=$(<span class="built_in">echo</span> <span class="string">&quot;scale=2; (<span class="variable">$&#123;region_temps[0]&#125;</span> + <span class="variable">$&#123;region_temps[1]&#125;</span>) / 2&quot;</span> | bc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Append to array</span></span><br><span class="line">region_temps+=(<span class="variable">$average_temp</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the whole array</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;region_temps[@]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="control-statements">Control Statements</h2><h3 id="if-statements">IF statements</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ] &amp;&amp; [ condition2 ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># some code</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># some code</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>Move files based on content:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extract Accuracy from first ARGV element</span></span><br><span class="line">accuracy=$(grep Accuracy <span class="variable">$1</span> | sed <span class="string">&#x27;s/.* //&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Conditionally move into good_models folder</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$accuracy</span> -ge 90 ]; <span class="keyword">then</span></span><br><span class="line">    mv <span class="variable">$1</span> ./good_models</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conditionally move into bad_models folder</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$accuracy</span> -lt 90 ]; <span class="keyword">then</span></span><br><span class="line">    mv <span class="variable">$1</span> ./bad_models</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Normal flags</span></span><br><span class="line">-eq =</span><br><span class="line">-ne !=</span><br><span class="line">-lt &lt;</span><br><span class="line">-le &lt;=</span><br><span class="line">-gt &gt;</span><br><span class="line">-ge &gt;=</span><br><span class="line"></span><br><span class="line"><span class="comment"># File related flags</span></span><br><span class="line">-e <span class="keyword">if</span> the file exists</span><br><span class="line">-s <span class="keyword">if</span> the file exists and has size greater than zero</span><br><span class="line">-r <span class="keyword">if</span> the file exists and is readable</span><br><span class="line">-w <span class="keyword">if</span> the file exists and is writable</span><br><span class="line"></span><br><span class="line"><span class="comment">## And and OR</span></span><br><span class="line">&amp;&amp; <span class="keyword">for</span> and</span><br><span class="line">|| <span class="keyword">for</span> or</span><br></pre></td></tr></table></figure><h2 id="for-loops">For loops</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use a FOR loop on files in directory</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> inherited_folder/*.R</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Echo out each file</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Move python file to to_keep if it using random forest class fier</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> robs_files/*.py</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Create IF statement using grep</span></span><br><span class="line">    <span class="keyword">if</span> grep -q <span class="string">&#x27;RandomForestClassifier&#x27;</span> <span class="variable">$file</span> ; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># Move wanted files to to_keep/ folder</span></span><br><span class="line">        mv <span class="variable">$file</span> to_keep/</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="case">Case</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a CASE statement matching the first ARGV element</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">  <span class="comment"># Match on all weekdays</span></span><br><span class="line">  Monday|Tuesday|Wednesday|Thursday|Friday)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;It is a Weekday!&quot;</span>;;</span><br><span class="line">  <span class="comment"># Match on all weekend days</span></span><br><span class="line">  Saturday|Sunday)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;It is a Weekend!&quot;</span>;;</span><br><span class="line">  <span class="comment"># Create a default</span></span><br><span class="line">  *)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Not a day!&quot;</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h2 id="function">Function</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> function_name &#123;</span><br><span class="line"><span class="comment">#function_code</span></span><br><span class="line"><span class="built_in">return</span> <span class="comment">#something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">print_hello</span></span> () &#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_hello</span><br></pre></td></tr></table></figure><blockquote><p><strong>Scope: All variables in Bash are global by default!</strong>Using <code>local val</code> to restrict variable scope.</p></blockquote><p>To get data out from function:</p><ol type="1"><li>Assign to a global variable</li><li><code>echo</code> what we want back in last line and capture using shell-within-shell</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> convert &#123;</span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$1</span>)</span><br><span class="line">&#125;</span><br><span class="line">converted = $(convert 30)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a function with a local base variable</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum_array</span></span> () &#123;</span><br><span class="line">  <span class="built_in">local</span> sum=0</span><br><span class="line">  <span class="comment"># Loop through, adding to base variable</span></span><br><span class="line">  <span class="keyword">for</span> number <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    sum=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$sum</span> + <span class="variable">$number</span>&quot;</span> | bc)</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># Echo back the result</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># Call function with array</span></span><br><span class="line">test_array=(14 12 23.5 16 19.34)</span><br><span class="line">total=$(sum_array <span class="string">&quot;<span class="variable">$&#123;test_array[@]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The total sum of the test array is <span class="variable">$total</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="python-script-on-bash">Python script on bash</h1><blockquote><p>Scheduling a job with crontab</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Preview both Python script and requirements text file</span></span><br><span class="line">cat create_model.py</span><br><span class="line">cat requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pip install Python dependencies in requirements file</span></span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Python script on command line</span></span><br><span class="line">python create_model.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add CRON job that runs create_model.py every minute</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* * * * * python create_model.py&quot;</span> | crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify that the CRON job has been scheduled via CRONTAB</span></span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure><h1 id="cron">Cron</h1><ul><li>crontab -l, list the crons</li></ul><blockquote><p>set your editor to nano, default vim</p></blockquote><ul><li>export EDITOR=/user/bin/nano</li><li>crontab -e, open editor</li><li>press i to input</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Algorhythm for schuel you task with time</span><br><span class="line"></span><br><span class="line"># ┌───────────── minute (0 - 59)</span><br><span class="line"># │ ┌───────────── hour (0 - 23)</span><br><span class="line"># │ │ ┌───────────── day of month (1 - 31)</span><br><span class="line"># │ │ │ ┌───────────── month (1 - 12)</span><br><span class="line"># │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday;</span><br><span class="line"># │ │ │ │ │                                       7 is also Sunday on some systems)</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># * * * * *  command_to_execute</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Do complex things with just a few keystrokes!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据工程" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="bash" scheme="https://scottzhang.pro/tags/bash/"/>
    
    <category term="linux" scheme="https://scottzhang.pro/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>机器学习相关概念解读P1</title>
    <link href="https://scottzhang.pro/article/1775964342.html"/>
    <id>https://scottzhang.pro/article/1775964342.html</id>
    <published>2019-12-27T08:30:13.000Z</published>
    <updated>2021-11-27T08:19:37.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天开始准备对机器学习相关概念做个总结，part1会包括以下概念：Cross Validation、Confusion Matrix、Sensitivity 与 Specificity、Bias 与 Variance、ROC 与 AUC、Odds Ratios 与 Log(Odds Ratios)。</p></blockquote><span id="more"></span><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="cross-validation">Cross Validation</h1><p>假设你需要根据肩膀痛、血液状况、动脉阻塞、体重与否来预测患者有没有心脏病，输出的结果为是与否。 当你对数据进行训练的时候，你需要指定使用的机器学习模型，常用的比如：</p><ul><li>LR</li><li>KNN</li><li>SVM</li></ul><p>但你怎么知道选择哪一种模型呢？Cross Validation 可以让我们大概知道哪些模型会fit比较好，哪些模型在实际应用的时候表现会更好。</p><p>当训练模型的时候，需要将数据切割成训练组与测试组。如果你把所有的数据都拿去训练，那你就没有了测试数据，因为你的模型必须用它没有见过的数据来做测试。</p><p>通常我们使用数据中的前面百分之75的数据作为训练数据</p><p><img src="https://i.loli.net/2019/12/26/bH8Ep7IUjYXOziB.png" /></p><p>后面的部分作为测试数据</p><p><img src="https://i.loli.net/2019/12/26/xqAwCLeT2GObjB9.png" /></p><p>但是你怎么知道按照75:25的划分是最好的呢？如果我们使用前面百分之25的数据测试呢？或者是取中间的25%测试，其余的作为训练数据？</p><p>担心选择哪一段数据作为训练和测试数据，我们用Cross Validation，它会逐一将所有的数据都测试一遍，然后汇总结果。这样每一组数据都作为测试数据参与过模型训练，也参与过模型的检测。逐一测试后，再汇总所有结果，我们就可以选择最适合数据的模型。</p><p><img src="https://i.loli.net/2019/12/26/Hg4LjJTUpye7GlZ.png" /></p><p>在这，如果你把数据分成4份，就叫4-Fold Cross Validation, 5份就叫5fold，以此类推。</p><h1 id="confusion-matrix">Confusion Matrix</h1><p>Confusion Matrix这个概念告诉我们，机器学习的算法预测的结果中，正确了多少、错了多少以及正确的分布在哪里，错的又分布在哪里。</p><p><img src="https://i.loli.net/2019/12/24/yndGs7EN8UCvbVz.png" /></p><p>比如这个例子中，我们想要根据肩膀痛、血液状况、动脉阻塞、体重与否来预测患者有没有心脏病，输出的结果为是与否。</p><p>我们可以使用逻辑回归、knn、随机森林等模型来预测，或者你也可以使用任何其他的模型，但是我们如何来衡量这个模型的好坏呢？</p><p>首先将数据切分成训练组与测试组，在对上述模型进行训练之后，我们可以拿模型来对测试组的数据进行测试，然后将预测的结果与实际的结果进行对比，根据下面的表填入结果：</p><p><img src="https://i.loli.net/2019/12/24/eKaHMGr3tw8nDUb.png" /></p><p>通过这个表，就可以知道你的模型预测的结果分布如何，对于每一个模型我们都可以绘制此表用来对比模型的性能。</p><h1 id="sensitivity-与-specificity">Sensitivity 与 Specificity</h1><p><img src="https://i.loli.net/2019/12/26/FxOVkEmXPRdB1qH.png" /></p><p>在你理解了Confusion Matrix之后，我们再来讨论Sensitivity 与 Specificity.</p><p>这里的Sensitivity，也可以理解为我们在sklearn课程中提及到的<em>Recall</em>，它等于 tp/(tp+fn)，即所有有心脏病的人中，多少预测对了；</p><p>这是Sensitivity的计算: <img src="https://i.loli.net/2019/12/26/EV8fWqBlXdxHChQ.png" /></p><p>而Specificity，等于 tn/(tn+fp)，即所有真实没有心脏病的人中，多少预测对了。 这是Specificity的计算： <img src="https://i.loli.net/2019/12/26/bHhlMj8qpY29TIQ.png" /></p><p>我们可以对不同的模型（如LR与随机森林）计算它们的Sensitivity 和 Specificity做比较。</p><p><img src="https://i.loli.net/2019/12/26/H8aXwTIn37Bo2Pq.png" /></p><p>可以看到随机森林的sensitivity分数比较高，这意味着它对于区分positives的结果比较擅长，也就是预测哪些病人有心脏病。</p><p><img src="https://i.loli.net/2019/12/26/84bWv12kqtLTAfh.png" /></p><p>而LR则在预测哪些病人没有心脏病方面比较擅长。</p><p>如果对你来说，更重要的是找出那些人有心脏病，那么你应该使用随机森林，如果你更看重那些人没有心脏病，那么应该使用LR.</p><p>如果你的Confusion Matrix是三行三列，那么计算方式就不一样了，不过也没那么复杂，注意好对应关系就好了：</p><p><img src="https://i.loli.net/2019/12/26/CLuoHWsUnjSIDXh.png" /></p><p><img src="https://i.loli.net/2019/12/26/Zc2hEtBXgyvbxJ5.png" /></p><p>更多请参考<a href="https://www.youtube.com/watch?v=vP06aMoz4v8&amp;list=PLblh5JKOoLUICTaGLRoHQDuF_7q2GfuJF&amp;index=4">油管视频</a>.</p><h1 id="bias-与-variance">Bias 与 Variance</h1><p>你有一组老鼠的长度与体重数据，可以想象，老鼠的重量与长度是正比的，但它长到一定长度后，重量不会一直增长。我们使用LR训练一批老鼠数据，得到下面的图像:</p><p><img src="https://i.loli.net/2019/12/26/HcPiQa9w38V6XN7.png" /></p><p>LR无法完全与训练数据重合，这就叫做bias，你的模型也可能完美的穿过这些测试数据，这样它的模型bias就为0.</p><p><img src="https://i.loli.net/2019/12/26/184lbpAgnfQ5G6i.png" /></p><p>当我们用最小二乘法来衡量模型对测试数据的fit程度时，曲线模型无疑是最好的，但是基础，我们训练模型是用来做预测的，<strong>一个好的模型不是fit得好不好，而是预测的好不好。</strong></p><p><img src="https://i.loli.net/2019/12/26/kNMRjqLJuyDtrBb.png" /></p><p>同样当我们用最小二乘法来测试预测结果时，LR直线模型却更好，这是因为曲线模型的Variance太高了。</p><p>bias高，可以理解为反应慢，但很稳。而Variance高，则意味反应很灵敏，发挥可能有时候很好，有时候很差。</p><p>直线的Variance比较低，因为对于不同的数据集的预测结果，算出来的最小二乘法之和比较低。</p><p>另外一种机器学习的描述方式，虽然我们的曲线模型对与训练数据fit的非常完美，但是在测试数据中却不理想，我们说这个模型overfit了。</p><p>理想的模型是variance和bias都比较低，能准确的反映数据的分布关系，以及做出稳定的预测。</p><p>要找到这个值，需要我们对模型做出调整，通常有三种方法：</p><ol type="1"><li>regularization</li><li>boosting</li><li>bagging</li></ol><p>后续我们再来介绍这些概念。</p><h1 id="roc-与-auc">ROC 与 AUC</h1><h1 id="roc">ROC</h1><p>还是这组老鼠的数据，根据它们的体总来判定它是否是肥胖症，蓝色的点是判断为肥胖症的老鼠，红色的则没有肥胖症，其中有一个红点很特殊，它看起来体重很高但是没有肥胖（这肯定是只肌肉鼠），同时数据中也有一些不是很重但患有肥胖症的，这是因为它很短小，却很胖。</p><p><img src="https://i.loli.net/2019/12/27/jVYtvS4xTFE3qQh.png" /></p><p>我们用LR fit这组数据，会得到这样的一个曲线，在LR中，y轴是我们的概率，值域为0-1，当你的LR模型绘制出来了的时候，给我一个老鼠的体重，我大概就可以判断它是不是有肥胖症，但是这需要一个threshold（临界值）作为判断点，比如在这里我们取概率为0.5对应的体重值。</p><p><img src="https://i.loli.net/2019/12/27/joR8bKSrmVMJ5IC.png" /></p><p>当你将这个threshold定位0.5，我们就可以用test数据统计confusion matrax,并计算Sensitivity 与 Specificity,如果你觉得threshold设为0.5不太合适，你可以将其设为0.6，然后再计算Sensitivity 与 Specificity对比看看。</p><p>这个threshold可以不断的做出调整，以适应（fit）我们的数据。</p><p>比如，我们设置为它为0.1。</p><p><img src="https://i.loli.net/2019/12/27/3PNanWbGdTUR41K.png" /></p><p>在这种情况下，所有0.1以上的都被标记成肥胖，增加了对肥胖预测的准确率，但会有一些非肥胖症的老鼠被预测称肥胖症。</p><p>你也可以设为0.9，所有0.9以下的老鼠都标记成非肥胖，这样会增加那些对非肥胖症预测的准确率，但会有一些肥胖的老鼠也被预测称非肥胖。</p><p><img src="https://i.loli.net/2019/12/27/fPx6QpAHoB2XqUm.png" /></p><p>threshold可能是这其中的任何一个点，我们到底选哪个比较好呢？</p><p>这时候我们就可以使用ROC图像了，ROC图中x轴为 Specificity,y轴为Sensitivity，我们开始画图，第一步我们假设所有的老鼠都有肥胖症：</p><p><img src="https://i.loli.net/2019/12/27/8IqkjMU4FnhRtim.png" /></p><p>对于Sensitivity，我们计算后为1，它是所有真实肥胖症老鼠中有多少预测对了。这意味着所有的老鼠都标记为肥胖症，也就是说所有真实患有肥胖症的老鼠都预测成功了。</p><p>对于Specificity，计算后也为1，它是所有真实没有肥胖症的老鼠中，多少预测对了。这意味着所有不是肥胖症的老鼠都被标记为肥胖症了。</p><p>我们可以将这个点与0连线，在这条线上，Sensitivity和Specificity相等，这意味着我们对测试数据预测正确的值与预测错误的比例相等（那还不如靠猜）。</p><p><img src="https://i.loli.net/2019/12/27/1G5jS2O9QcAPiUT.png" /></p><p>现在我们把threshold设为0.3，我们得到sensitivity为1，specificity为0.75.</p><p><img src="https://i.loli.net/2019/12/27/nOaAb3Tz8hjfcLZ.png" /></p><p>它的sensitivity&gt;specificity,所以在图上它出现在绿虚线的左边，所以threshold为0.3比之前的值要好。</p><p>我们继续增加threshold</p><p><img src="https://i.loli.net/2019/12/27/TcK1jJfu8sClVew.png" /></p><p>这个结果又要好一点，我们一直继续，直到我们把所有的老鼠都预测为非肥胖症，将所有的点连起来，这就是我们的ROC曲线了。</p><ul><li>y轴为：真实数据中，肥胖的预测正确了多少。</li><li>x轴为：真实数据中，非肥胖的预测正确了多少。</li><li>x轴也可能为：预测数据中，肥胖的预测正确了多少。</li></ul><p><img src="https://i.loli.net/2019/12/27/YyrmfONXWc9Ub45.png" /></p><p>这个图中越靠近左上的点，结果越好。同时我们可以根据我们可以接受多大的错误率，来选择threshold,</p><p><img src="https://i.loli.net/2019/12/27/aDWEdetqAZnKoTy.png" /></p><h2 id="auc">AUC</h2><p>AUC就是ROC下面的曲线，如果我们通过更换模型，让曲线下方的面积变大了，那么新模型就比原来的模型更好。</p><p><img src="https://i.loli.net/2019/12/27/hbskK9xymApwYTF.png" /></p><p>如果图中蓝色部分是随机森林模型生成的AUC，红色部分是LR生成的，那么你应该选择LR作为你的模型。</p><p>注：有时候人们会用precision代替specificity, 即precision=True Positive / True Positive + False positive</p><p>对比它们的定义：</p><p>specificity： 所有有肥胖症的老鼠中，预测正确了多少。 precision：所有预测为肥胖症的老鼠中，预测正确了多少。</p><h1 id="odds-与-probability">Odds 与 Probability</h1><p>odds是你想要的结果除以你不想要的结果，而Probability是你想要的结果除以所有的结果。如在比赛中，你赢了5次，输了3次，那odds就是5/3,而概率测试5/8.</p><p><img src="https://i.loli.net/2019/12/25/QnURimjxBKEIMXt.png" /></p><p>odds是可以通过概率来计算得出的，它的公式是：</p><p><span class="math display">\[\frac{p}{1-p}\]</span></p><p>我们可以思考一下odds的取值范围，如果有一场比赛，因为我的实力很差，10次比赛输了8次，那么我的odds就是2/8,如果更糟，0/10，也就是0。</p><p>可见odds的值域中，最低值是0，从1-0是你所有输掉比赛的情况，而从1到无穷大则是你赢了比赛的情况，因为你赢了一万场输一场的情况也是有可能的，它的odds值为10000/1=10000。</p><p>把odds的值放到数轴上看，你会发现这样的一条线：</p><p><img src="https://i.loli.net/2019/12/25/A6cUjIDus1orLbv.png" /></p><p>但这里存在一个小问题，比如对于1:6和6:1，我输了6场和赢了6场，这两个结果看起来是对成的，得到的值画在数轴上却是不对称的。</p><p><img src="https://i.loli.net/2019/12/25/nl5tHL3TOx26FXE.png" /></p><p>而使用log函数则可以解决这个问题：</p><p><img src="https://i.loli.net/2019/12/25/7YJxzFTvLpuE4Ij.png" /></p><h1 id="odds-ratios-与-logodds-ratios">Odds Ratios 与 Log(Odds Ratios)</h1><p>odds本质上是ratio，但odds≠odds ratio,我们说odds ratio,指的是odds之间的运算，也就是两个不同结果之间odds值的运算。</p><p>odds ratio算出来的值可能在0-1之间，也可能在1到无穷大之间，如果我们需要让odds ratio值数轴上显示，对它取对数会比较好。</p><p>我们来举个例子，下面是癌症与基因突变的一组数据：</p><p><img src="https://i.loli.net/2019/12/25/lAECMGIj62ZOW8k.png" /></p><p>这是什么意思呢？ odds ratio和log(ratio)说明了两个事物（这里是癌症与基因突变）之间的关系。</p><p>odds ratio值越大，基因突变这个变量对于预测癌症就越好用，越小，则说明这个变量不适合用来预测癌症。</p><p>然而要证明相关，还需要证明它们之间存在统计显著性，主要有三种方法：</p><ul><li>Fisher's Exact Test</li><li>Chi-Square Test</li><li>The Wald Test</li></ul><p>有人比较喜欢用Fisher's Exact Test和Chi-Square Test计算P-Value,有人比较喜欢用The Wald Test计算P-Value和置信区间。</p><p>假设有如下表：</p><p><img src="https://i.loli.net/2019/12/27/sPfknqYcBOL7INl.png" /></p><h2 id="fishers-exact-test">Fisher's Exact Test</h2><blockquote><p>参考:<a href="https://youtu.be/udyAvvaMjfM">Fisher's Exact Test</a></p></blockquote><h2 id="chi-square-test">Chi-Square Test</h2><p>这是一种先假设癌症与基因变异之间没有关系的方法。 首先算出正常人患癌症的概率为：29/356 = 0.08.</p><p>有基因突变的为140人，如果按照正常人患癌症的概率，那么有基因突变的人中应该是 140*0.08=11.2 人有癌症，剩下 140-11.2=128.8 人无癌症。</p><p>同样的对于没有基因突变的人，患癌症的人为 216*0.08 = 17.3, 剩下 216-17.3 = 198.7人无癌症。</p><p>最后对比两个表，就可以算出p-vlue，如果你不知道具体如何算，可以参考别的文章。</p><p><img src="https://i.loli.net/2019/12/27/W5op2s8JqCfcawF.png" /></p><h2 id="the-wald-test">The Wald Test</h2><blockquote><p>todo.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天开始准备对机器学习相关概念做个总结，part1会包括以下概念：Cross Validation、Confusion Matrix、Sensitivity 与 Specificity、Bias 与 Variance、ROC 与 AUC、Odds Ratios 与 Log(Odds Ratios)。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据科学" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="机器学习" scheme="https://scottzhang.pro/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
