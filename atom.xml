<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2022-05-15T13:50:32.274Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 协程与生成器</title>
    <link href="https://scottzhang.pro/article/d7273f24.html"/>
    <id>https://scottzhang.pro/article/d7273f24.html</id>
    <published>2022-05-14T04:41:02.000Z</published>
    <updated>2022-05-15T13:50:32.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的出现，就是为了解决回调编写难的问题。</p></blockquote><span id="more"></span><h1 id="协程">协程</h1><p>比如，回调模式编码复杂度高、同步编程的并发性不高，多线程编程需要线程间同步，有 Lock 的限制。</p><p>那么能不能采用同步的方式去编写异步的代码呢？</p><p>一个办法是使用单线程去切换任务，这样就不需要操作系统切换线程，也不需要锁，而且实现了并发性很高（但需要程序员自己去调度任务）类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_part1</span>(<span class="params">arg</span>):</span></span><br><span class="line">    <span class="comment"># job B 为 IO 操作，会阻塞</span></span><br><span class="line">    <span class="comment"># 我们希望在执行到 A 的时候，可以跳出去</span></span><br><span class="line">    <span class="comment"># 继续执行耗费 CPU 的部分</span></span><br><span class="line">    a = do_job_A(arg)</span><br><span class="line">    b = do_job_B(a)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_all_job</span>():</span></span><br><span class="line">    p1 = do_part1(<span class="number">1</span>)</span><br><span class="line">    result = do_part2(p1)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>说白了，我们需要一个这样的函数，即它可以暂停，并且在适当的时候恢复。</p><h1 id="生成器进阶">生成器进阶</h1><h2 id="send">send</h2><p>生成器不只是可以产出值，还可以接收值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    addr = <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">addr = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="comment"># send 的值，将函数赋值给内部的 addr</span></span><br><span class="line">after_send = g.send(<span class="string">&quot;apple.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里第一次需要调用 next 方法，否则会报 TypeError, 如果不调用 next，也可以在开始的时候 send 一个 None.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    addr = <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">g.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># send 的值，将函数赋值给内部的 addr</span></span><br><span class="line">after_send = g.send(<span class="string">&quot;apple.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是因为在调用 send 发送非 None 值之前，我们必须启动一次生成器。</p><p>有两种方式：</p><ol type="1"><li>使用 next</li><li>或调用生成器对象的 send 方法传入 None 值</li></ol><p>另外生成器，还有一个 close 方法，可以将生成器关闭。</p><p>如果一个生成器会 yield 三次，如果在第一次的时候 close 了，那么在第二次的时候调用 next 就会报 GeneratorExit 错误。</p><h2 id="throw">throw</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="comment"># 为什么不是 try microsoft</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;google.com&quot;</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Pass Test Error&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;microsoft.com&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;scottzhang.pro&quot;</span></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">g.throw(Exception, <span class="string">&quot;TestError&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure><h2 id="yield-from">yield from</h2><blockquote><p>Python 3.3 新语法。</p></blockquote><p>yield from 可以理解为 yiled 的简化，比如下面这两种写法差不多是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> v1 <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">for</span> v2 <span class="keyword">in</span> v1:</span><br><span class="line">            <span class="keyword">yield</span> v2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_chain</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> v1 <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> v1</span><br></pre></td></tr></table></figure><p>yield from 还有另外一个功能，先看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_gen</span>(<span class="params">gen</span>):</span></span><br><span class="line">    <span class="comment"># gen 是一个可迭代对象</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> gen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    g = my_gen()</span><br><span class="line">    g.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这里有几个概念需要区分清楚：</p><ul><li>main 叫做调用者</li><li>my_gen 叫做委托生成器</li><li>gen 叫做子生成器</li></ul><p><code>yield from</code> 的另外一个特性就是能在调用者和子生成器之间建立一个通道，而且是双向的。</p><p>一个基于上面的模式编程的例子，要求是统计一个字典中值的个数， 并将值重新赋值为(num, [values]) 的形式，即值变为个数与值的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果字典</span></span><br><span class="line">final_result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sales_sum</span>(<span class="params">pro_name</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(pro_name+<span class="string">&quot;销量: &quot;</span>, x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">        nums.append(x)</span><br><span class="line">    <span class="keyword">return</span> total, nums</span><br><span class="line"></span><br><span class="line"><span class="comment"># 委托生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middle</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        final_result[key] = <span class="keyword">yield</span> <span class="keyword">from</span> sales_sum(key)</span><br><span class="line">        <span class="built_in">print</span>(key + <span class="string">&quot;销量统计完成！！.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 产品销量字典</span></span><br><span class="line">    data_sets = &#123;</span><br><span class="line">        <span class="string">&quot;产品A&quot;</span>: [<span class="number">1200</span>, <span class="number">1500</span>, <span class="number">3000</span>],</span><br><span class="line">        <span class="string">&quot;产品B&quot;</span>: [<span class="number">28</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">108</span> ],</span><br><span class="line">        <span class="string">&quot;产品C&quot;</span>: [<span class="number">280</span>,<span class="number">560</span>,<span class="number">778</span>,<span class="number">70</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, data_set <span class="keyword">in</span> data_sets.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start key:&quot;</span>, key)</span><br><span class="line">        m = middle(key)</span><br><span class="line">        m.send(<span class="literal">None</span>) <span class="comment"># 预激 middle 协程</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> data_set:</span><br><span class="line">            m.send(value)   <span class="comment"># 给协程传递每一组的值</span></span><br><span class="line">        m.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;final_result:&quot;</span>, final_result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>可能你会有疑问为什么这里不把子生成器和委托生成器合二为一，这样直接使用 yield 也可以实现。</p><p>但这样你就得在生成器快结束的时候，自己处理生成器对象的异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">my_gen.send(last_value)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        my_gen.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        result = e.value</span><br></pre></td></tr></table></figure><p>而 yield from 会帮我们自动处理这些逻辑，但还不止这些。</p><p>我们来看下 yield from 背后源码的原理, 看源码之前，我们先认识下所用到的变量。</p><blockquote><p>PEP380</p></blockquote><ul><li>_i：子生成器，同时也是一个迭代器</li><li>_y：子生成器生产的值</li><li>_r：yield from 表达式最终的值</li><li>_s：调用方通过send()发送的值</li><li>_e：异常对象</li></ul><p>摘录一段简单的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_i = <span class="built_in">iter</span>(EXPR)      <span class="comment"># EXPR是一个可迭代对象，_i其实是子生成器；</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = <span class="built_in">next</span>(_i)   <span class="comment"># 预激子生成器，把产出的第一个值存在_y中；</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value   <span class="comment"># 如果抛出了`StopIteration`异常，那么就将异常对象的`value`属性保存到_r，这是最简单的情况的返回值；</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:    <span class="comment"># 尝试执行这个循环，委托生成器会阻塞；</span></span><br><span class="line">        _s = <span class="keyword">yield</span> _y   <span class="comment"># 生产子生成器的值，等待调用方`send()`值，发送过来的值将保存在_s中；</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _y = _i.send(_s)    <span class="comment"># 转发_s，并且尝试向下执行；</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">            _r = _e.value       <span class="comment"># 如果子生成器抛出异常，那么就获取异常对象的`value`属性存到_r，退出循环，恢复委托生成器的运行；</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">RESULT = _r     <span class="comment"># _r就是整个yield from表达式返回的值。</span></span><br></pre></td></tr></table></figure><p>此外，yield from 还需要处理这些逻辑：</p><ol type="1"><li>子生成器可能只是一个迭代器，并不是一个作为协程的生成器，所以它不支持.throw()和.close()方法；</li><li>如果子生成器支持.throw()和.close()方法，但是在子生成器内部，这两个方法都会抛出异常；</li><li>调用方让子生成器自己抛出异常</li><li>当调用方使用next()或者.send(None)时，都要在子生成器上调用next()函数，当调用方使用.send()发送非 None 值时，才调用子生成器的.send()方法；</li></ol><p>总结一下：</p><p>总结一下关键点：</p><ol type="1"><li>子生成器生产的值，都是直接传给调用方的；调用方通过.send()发送的值都是直接传递给子生成器的；如果发送的是 None，会调用子生成器的__next__()方法，如果不是 None，会调用子生成器的.send()方法；</li><li>子生成器退出的时候，最后的return EXPR，会触发一个StopIteration(EXPR)异常；</li><li>yield from表达式的值，是子生成器终止时，传递给StopIteration异常的第一个参数；</li><li>如果调用的时候出现StopIteration异常，委托生成器会恢复运行，同时其他的异常会向上 "冒泡"；</li><li>传入委托生成器的异常里，除了GeneratorExit之外，其他的所有异常全部传递给子生成器的.throw()方法；如果调用.throw()的时候出现了StopIteration异常，那么就恢复委托生成器的运行，其他的异常全部向上 "冒泡"；</li><li>如果在委托生成器上调用.close()或传入GeneratorExit异常，会调用子生成器的.close()方法，没有的话就不调用。如果在调用.close()的时候抛出了异常，那么就向上 "冒泡"，否则的话委托生成器会抛出GeneratorExit异常。</li></ol><h1 id="async-和-await">async 和 await</h1><p>Python 3.5+ 后，引入了 async 和 await 两个关键字，定义了原生的协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Fake Result&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="comment"># 将任务交给子协程完成</span></span><br><span class="line">    <span class="comment"># await 后面跟的是 collections.Awaittable 对象</span></span><br><span class="line">    <span class="comment"># 也可以实现 __await__ 魔法方法来支持</span></span><br><span class="line">    <span class="comment"># await 可以理解为 yield from</span></span><br><span class="line">    result = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    coro = download_url(<span class="string">&quot;www.scottzhang.pro&quot;</span>)</span><br><span class="line">    coro.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>注意生成器是不可以直接传给 await，下面的代码会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Fake Result&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    result = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    coro = download_url(<span class="string">&quot;www.scottzhang.pro&quot;</span>)</span><br><span class="line">    coro.send(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>解决办法是，加一个装饰器, 这个装饰器会将这个函数实现 <code>__await__</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="meta">@types.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Fake Result&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;协程的出现，就是为了解决回调编写难的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="协程" scheme="https://scottzhang.pro/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="生成器" scheme="https://scottzhang.pro/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程和异步IO</title>
    <link href="https://scottzhang.pro/article/4bf14380.html"/>
    <id>https://scottzhang.pro/article/4bf14380.html</id>
    <published>2022-05-11T03:40:41.000Z</published>
    <updated>2022-05-14T04:42:10.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍了一些异步IO的基本概念与 Select 即回调函数的使用。</p></blockquote><span id="more"></span><h1 id="一些基本概念">一些基本概念</h1><p>在学习协程之前，建议先复习一下 socket 编程和多线程的知识。</p><p><strong>并发与并行</strong></p><p>并发：一个时间段、有几个程序在同一个 CPU 上运行，任意时刻只有一个程序在CPU上运行。</p><p>并行：任意时刻，有多个程序运行在多个 CPU 上。</p><p><strong>同步和异步</strong></p><blockquote><p>是一种消息通信机制，把操作看成消息在不同线程、协程中发送，然后得到 Future进行后续操作。</p></blockquote><p>同步：代码调用IO操作时，必须等待IO操作完成菜返回的调用方式。</p><p>异步：代码调用IO操作时，不必等操作完成就返回的调用方式。</p><p><strong>阻塞和非阻塞</strong></p><blockquote><p>是一种函数调用的机制。</p></blockquote><p>阻塞：调用函数是当前线程被挂起。</p><p>非阻塞：调用函数时，当前线程不会被挂起，而是立即返回。</p><h1 id="什么是-c10k-问题">什么是 C10K 问题？</h1><p><a href="https://en.wikipedia.org/wiki/C10k_problem">C10K</a>，一个1999 年提出来的技术挑战，即我们如何在1颗 1GHz CPU，2G 内存，1gbps 网络环境下，让单台服务器同时为1万个客户端提供FTP服务。</p><h1 id="io-多路复用">IO 多路复用</h1><p>Unix 下的五种 I/O 模型:</p><ul><li>阻塞 I/O</li><li>非阻塞 I/O</li><li>多路复用 I/O</li><li>信号驱动是 I/O</li><li>异步I/O (POSIX 的 aio_系列函数)</li></ul><p>以 socket 中的连接建立为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 阻塞 I/O</span></span><br><span class="line"><span class="comment"># 基础的用的最多的，socket.connect 连接成功后再返回，这时候产生阻塞</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((host, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---  非阻塞 I/O</span></span><br><span class="line"><span class="comment"># 发出 socket.connect 后马上返回（不阻塞，但没有结果）</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.setblocking(<span class="literal">False</span>)</span><br><span class="line">client.connect((host, <span class="number">80</span>))</span><br><span class="line"><span class="comment"># 随后不停询问服务端连接是否，成功后才可以发送消息</span></span><br><span class="line"><span class="comment"># 不过此时，也可以直接就开始干别的事情</span></span><br><span class="line"><span class="keyword">while</span> (client connected):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">client.send(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---多路复用 I/O</span></span><br><span class="line"><span class="comment"># 调用操作系统的 select 方法，操作系统会告诉我们哪些 socket 的端口</span></span><br><span class="line"><span class="comment"># 和文件句柄已经准备好了，它支持监听多个文件和 socket（select 本质上也是阻塞方法)</span></span><br><span class="line"><span class="comment"># 比如我们可以监听100个端口，只要其中某个端口可用，我们就可以立即处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---信号驱动式 I/O</span></span><br><span class="line"><span class="comment"># 应用较少，暂时不做介绍</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---异步 I/O</span></span><br><span class="line"><span class="comment"># aio_read 真正的异步</span></span><br></pre></td></tr></table></figure><p>select,poll,epoll 都是 I/0 多路复用的机制。I/0 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><p>但select,poll, epoll 本质上都是同步 I/0，因为他们都需要在读写事件就绪后自己负责 进行读写，也就是说这个读写过程是阻塞的，而异步V/0则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。</p><h2 id="select">Select</h2><p>select 函数监视的文件描述符分3类，分别是 writefds、readfds, 和 exceptfds。</p><p>调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指指定等待时间，如果立即返回设为null即可），函数返回。</p><p>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p><p>select的一个缺点在于，单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><h2 id="poll">Poll</h2><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。</p><p>polfd结构包含了要监视的event和发生的event，不再使用select "参数-值" 传递的方式。</p><p>同时，pollfd并没有最大数量限制（ 但是数量过大后性能也是会下降）。和select西数一样，pol返回后需要轮询polfd来获取就绪的描述符。从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取 已经就绪的socket。</p><p>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态 ，因此随着监视的描述符数量的增长，其效率也会线性下降</p><h2 id="epoll">Epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和pol的增强版本。</p><p>相对于select和poll来说，epol更加灵活，没有描述符限制。epoll使用-一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><p>epoll 实现使用了红黑树。</p><h2 id="对比">对比</h2><p>在并发高的情况下，连接活跃度不是很高，epoll 比 selelct 好；</p><p>并发不高，连接很活跃的时候，select 比 epoll 好；</p><h1 id="实例非阻塞io">实例：非阻塞I/O</h1><p>先看一段使用非阻塞IO完成 socket 请求与接受的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用非阻塞io完成http请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立socket连接</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((host, <span class="number">80</span>)) <span class="comment">#阻塞不会消耗cpu</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不停的询问连接是否建立好， 需要while循环不停的去检查状态</span></span><br><span class="line">    <span class="comment"># 做计算任务或者再次发起其他的连接请求</span></span><br><span class="line"></span><br><span class="line">    send_to = <span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(path, host).encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client.send(send_to)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    data = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    data = data.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    html_data = data.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    get_url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实例select-回调">实例：Select 回调</h1><p>下面这个是使用 Select 的版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需处理系统兼容性问题</span></span><br><span class="line"><span class="comment"># 如 Windows 和 Linux 不一样, 推荐使用 selectors</span></span><br><span class="line"><span class="comment"># import select</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()</span><br><span class="line"><span class="comment"># 使用select完成http请求</span></span><br><span class="line"><span class="comment"># 一个线程发出url请求后即可不管，操作系统 select</span></span><br><span class="line"><span class="comment"># 会自动使用可用的 socket 处理，对比多线程中一个线程对应一个 url</span></span><br><span class="line"><span class="comment"># 省去了线程切换的开销，以及其占用的内存</span></span><br><span class="line">urls = []</span><br><span class="line">stop = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        selector.unregister(key.fd)</span><br><span class="line">        self.client.send(<span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(self.path, self.host).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        selector.register(self.client.fileno(), EVENT_READ, self.readable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readable</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        d = self.client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            self.data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selector.unregister(key.fd)</span><br><span class="line">            data = self.data.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">            html_data = data.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(html_data)</span><br><span class="line">            self.client.close()</span><br><span class="line">            urls.remove(self.spider_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> urls:</span><br><span class="line">                <span class="keyword">global</span> stop</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.spider_url = url</span><br><span class="line">        url = urlparse(url)</span><br><span class="line">        self.host = url.netloc</span><br><span class="line">        self.path = url.path</span><br><span class="line">        self.data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            self.path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立socket连接</span></span><br><span class="line">        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.client.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.client.connect((self.host, <span class="number">80</span>))  <span class="comment"># 阻塞不会消耗cpu</span></span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#注册</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    <span class="comment">#事件循环，不停的请求socket的状态并调用对应的回调函数</span></span><br><span class="line">    <span class="comment"># 1. select本身是不支持register模式</span></span><br><span class="line">    <span class="comment"># 2. socket状态变化以后的回调是由程序员完成的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop:</span><br><span class="line">        ready = selector.select()</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> ready:</span><br><span class="line">            call_back = key.data</span><br><span class="line">            call_back(key)</span><br><span class="line">    <span class="comment"># 回调+事件循环+select(poll\epoll)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    fetcher = Fetcher()</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">&quot;http://shop.projectsedu.com/goods/&#123;&#125;/&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">        urls.append(url)</span><br><span class="line">        fetcher = Fetcher()</span><br><span class="line">        fetcher.get_url(url)</span><br><span class="line">    loop()</span><br><span class="line">    <span class="built_in">print</span>(time.time()-start_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="回调的问题">回调的问题</h1><p>使用回调虽然可以带来效率上的提升，但是也会有一些问题，包括：</p><ul><li>回调函数执行不正常怎么办？</li><li>回调函数里还要嵌套回调怎么办？嵌套多层怎么办？</li><li>多层嵌套中，某个环节出错了怎么办？</li><li>有个数据，需要每个回调函数都处理怎么办？</li><li>怎么使用当前函数中的局部变量？</li></ul><p>归纳来看，可以说回调的问题在于：</p><ol type="1"><li>代码可读性变差</li><li>共享状态的管理困难</li><li>处理异常比较麻烦</li></ol><p>要处理这个问题，这时候就轮到协程出场了。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍了一些异步IO的基本概念与 Select 即回调函数的使用。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="socket" scheme="https://scottzhang.pro/tags/socket/"/>
    
    <category term="select" scheme="https://scottzhang.pro/tags/select/"/>
    
    <category term="poll" scheme="https://scottzhang.pro/tags/poll/"/>
    
    <category term="epoll" scheme="https://scottzhang.pro/tags/epoll/"/>
    
    <category term="回调函数" scheme="https://scottzhang.pro/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 多进程</title>
    <link href="https://scottzhang.pro/article/4300f84b.html"/>
    <id>https://scottzhang.pro/article/4300f84b.html</id>
    <published>2022-05-11T03:23:35.000Z</published>
    <updated>2022-05-11T03:25:47.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python 多进程编程参考，适合 CPU 密集型操作。</p></blockquote><span id="more"></span><h1 id="多进程">多进程</h1><p>在 Python 中，对于IO密集型操作，可以考虑多线程。而 CPU 密集型操作则应考虑多进程。</p><p>在 Linux 中, <code>os.fork()</code> 子进程会将父进程中所有数据拷贝过来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi, This is Scott!&quot;</span>)</span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位于子进程: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;父进程为: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位于父进程: <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里的运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hi, This is Scott!</span><br><span class="line">位于父进程: 3021</span><br><span class="line">Hi, This is Scott!</span><br><span class="line">位于子进程: 3021</span><br><span class="line">父进程为: 3020</span><br></pre></td></tr></table></figure><h1 id="multiprocessing">Multiprocessing</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do something in sub_progress&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    progress = multiprocessing.Process(</span><br><span class="line">        target=do_something,</span><br><span class="line">        args=(<span class="number">2</span>,)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;progress pid: <span class="subst">&#123;progress.pid&#125;</span>&quot;</span>)</span><br><span class="line">    progress.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;progress pid: <span class="subst">&#123;progress.pid&#125;</span>&quot;</span>)</span><br><span class="line">    progress.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;main progress finished&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">progress pid: None</span><br><span class="line">progress pid: 3391</span><br><span class="line">do something in sub_progress</span><br><span class="line">main progress finished</span><br></pre></td></tr></table></figure><p>当然也可以使用继承的方式，重写内部的 run 方法，这部分和多线程中的代码类似。</p><h1 id="进程池">进程池</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do something in sub_progress&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># using a pool to manage process</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    result = pool.apply_async(do_something, args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># waiting all tasks finished</span></span><br><span class="line">    <span class="comment"># must close a pool before join it, for new task added to pool</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="built_in">print</span>(result.get())</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ python multiprocessing_test.py</span><br><span class="line">do something in sub_progress</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>pool 中还有 <code>imap</code> 方法，类似线程中 <code>excuter.map</code> 方法，result 为每个函数的返回值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入顺序</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> pool.imap(do_something, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;do something in <span class="subst">&#123;result&#125;</span>s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成顺序</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> pool.imap_unordered(do_something, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;do something in <span class="subst">&#123;result&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ python multiprocessing_test.py</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 1s</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 3s</span><br><span class="line">do something in sub_progress</span><br><span class="line">do something in 5s</span><br></pre></td></tr></table></figure><h1 id="进程间通信">进程间通信</h1><p>多进程中，使用全局变量是无法共享数据的，因为进程间的数据是互相隔离的。</p><h2 id="使用-queue">使用 Queue</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="comment"># 下面的 queue 在多进程中无法使用</span></span><br><span class="line"><span class="comment"># from queue import Queue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line"></span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用进程池">使用进程池</h2><p>Pool 中的进程间通信，需要使用 manager 中的 queue.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># pool 中的 queue 需要使用 manager 中的</span></span><br><span class="line">    queue = Manager().Queue(<span class="number">10</span>)</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pool.apply_async(producer, args=(queue,))</span><br><span class="line">    pool.apply_async(consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>至此我们这里出现了三个 queue，注意区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line">queue = Manager().Queue</span><br></pre></td></tr></table></figure><h2 id="使用管道">使用管道</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe, Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&#x27;scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># pipe 只能适用于两个进程, 但更高效，相比 queue 它没那么多锁</span></span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line"></span><br><span class="line">    my_producer = Process(target=producer, args=(send_pipe,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用共享内存">使用共享内存</h2><p>Manager 中有一些支持共享内存的数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&#x27;scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    share_var = Manager().<span class="built_in">dict</span></span><br><span class="line">    share_var = Manager().Array</span><br><span class="line">    share_var = Manager().<span class="built_in">list</span></span><br><span class="line">    <span class="comment"># and more</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Python 多进程编程参考，适合 CPU 密集型操作。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Python 多进程" scheme="https://scottzhang.pro/tags/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="Multiprocessing" scheme="https://scottzhang.pro/tags/Multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>Python 多线程</title>
    <link href="https://scottzhang.pro/article/55e6fd87.html"/>
    <id>https://scottzhang.pro/article/55e6fd87.html</id>
    <published>2022-05-11T03:09:56.000Z</published>
    <updated>2022-05-11T03:23:08.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python 多线程编程参考。</p></blockquote><span id="more"></span><h1 id="关于线程">关于线程</h1><p>线程是操作系统的最小调度单位，属于进程。如果将操作系统比较工厂，那么进程就属于车间，而线程就是具体的工人。</p><h1 id="使用-tread-类">使用 Tread 类</h1><p>Python 中线程的模块是 treading, 我们先看一个简单的例子：</p><p>先导入包，定义好我们需要的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟爬取网页内容的操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get detail started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get detail end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟获取网页地址的操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get url started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get url end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>进行我们第一个测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义两个线程</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程可以并发，所以线程开始执行后无需等待执行结果即可继续执行打印时间的代码</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><p>查看执行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get detail started</span><br><span class="line">get url started</span><br><span class="line"><span class="number">0.0020024776458740234</span></span><br><span class="line">get detail end</span><br><span class="line">get url end</span><br></pre></td></tr></table></figure><p>设置守护线程可以让主线程结束后将子线程都 kill 掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义两个线程</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置守护线程</span></span><br><span class="line">    <span class="comment"># 主进程执行完毕后，子线程都 kill 掉，若其中只有某个</span></span><br><span class="line">    <span class="comment"># 子线程设置了守护线程，则等待另外一个</span></span><br><span class="line">    thread1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    thread2.setDaemon(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程可以并发，所以线程开始执行后无需等待执行结果即可继续执行打印时间的代码</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><p>主线程执行完毕后，其它子线程也将结束（在 jupyter 中不一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get detail started</span><br><span class="line">get url started</span><br><span class="line">0.0010001659393310547</span><br></pre></td></tr></table></figure><p>同时线程还有一个 join 方法，可以造成阻塞并等待前面的线程结束之后才运行后面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义两个线程</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">&quot;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程可以并发，所以线程开始执行后无需等待执行结果即可继续执行打印时间的代码</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 阻塞，等所有子线程运行完成才继续</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><h1 id="继承-tread-类">继承 Tread 类</h1><p>我们也可以继承 treading.Tread 类实现多线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailHtml</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟爬取网页内容的操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get detail started&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get detail end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailURL</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟获取网页地址的操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get url started&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get url end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread1 = GetDetailHtml()</span><br><span class="line">    thread2 = GetDetailURL()</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><h1 id="线程间通信">线程间通信</h1><p>前面提供了两个函数，一个是负责去抓 url，一个是去爬取 url 的内容，那么对于抓到的 url，你需要有一种方式传给爬取内容的函数，这就是线程之间需要通信的例子。</p><p>线程中通信有几种方案：</p><ul><li>使用全局变量</li><li>使用 Python 中的队列，即 queue</li></ul><h1 id="线程同步">线程同步</h1><p>在之前关于 GIL 的文章中，有一个多线程加减的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure><p>当我们查看上面代码的字节码的时候，可以看到大概的步骤如下：</p><ol type="1"><li>加载 total 到内存</li><li>加载 1</li><li>进行加法操作</li><li>赋值给 total （多线程状态下，赋值会出错）</li></ol><p>上述代码，每次的结果都不一样，就是因为在上面4个步骤的任意一个步骤中，GIL 都有可能被释放，然后加载的变量被其他的线程修改了。</p><p>这里就引出我们的线程的同步机制，即我们设置一种方法，让某一段代码执行完毕之后，才能切换到别的线程执行，这就保证了在修改数据的时候，不会出错。</p><h2 id="锁-lock">锁 Lock</h2><p>同步机制可以使用锁来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total is: <span class="subst">&#123;total&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># Total is: 0，可以看到结果正确了</span></span><br></pre></td></tr></table></figure><p>但是使用锁，也优缺点，第一个是性能上的损失，另外是容易引起死锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 没有 release 却重新申请导致死锁</span></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 竞争死锁</span></span><br><span class="line"><span class="comment"># A 任务需要 a，b，B 任务需要 b，a</span></span><br><span class="line"><span class="comment"># 那么 A 和 B 互相持有 a，b 容易导致死锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 子函数死锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">lock</span>):</span></span><br><span class="line">    lock.acquire()</span><br><span class="line"></span><br><span class="line">lock.acquire()</span><br><span class="line">do_something(lock)</span><br></pre></td></tr></table></figure><p>针对第三种情况，Python 有一种 RLock（可以重复申请的锁）, 可以让你连续申请锁，但是注意，申请和释放的次数要一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> RLock</span><br><span class="line"></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="comment"># pass</span></span><br><span class="line">lock.release()</span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><h2 id="条件变量-condition">条件变量 Condition</h2><p>假设有一个需求是，需要设计一个对话系统，让两个人可以互相对话，即他们说话的顺序需要是交互的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Condition</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># notify 和 wait，必须在 with 语句中</span></span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>, 1&quot;</span>) <span class="comment"># A先处理自己的逻辑</span></span><br><span class="line">            self.cond.notify()       <span class="comment"># 通知调用 wait 的方法启动</span></span><br><span class="line">            self.cond.wait()         <span class="comment"># 等待某个变量的通知</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>, 3&quot;</span>)</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># notify 和 wait，必须在 with 语句中</span></span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            self.cond.wait()        <span class="comment"># B顺序在后，所以先等待</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 2&quot;</span>) <span class="comment"># B再处理自己的逻辑</span></span><br><span class="line">            self.cond.notify()      <span class="comment"># 再通知 A</span></span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 4&quot;</span>)</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cond = Condition()</span><br><span class="line"></span><br><span class="line">    a = A(cond)</span><br><span class="line">    b = B(cond)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动顺序很重要，在这里如果 a 启动，那么 a 首先处理自己的代码</span></span><br><span class="line">    <span class="comment"># 随后发送 notify，但这个时候会出问题，因为 b 还没有启动起来</span></span><br><span class="line">    <span class="comment"># 所有正确的方式是先让 b 起来等待，再启动 a</span></span><br><span class="line">    b.start()</span><br><span class="line">    a.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么notify 和 wait，必须在 with 语句中呢？condition 内部有两把锁</p><ul><li>第一底层锁，控制 condition 的进入，即通过 with 或者 cond.acquire()。在这里 B 通过 with 语句进入 condition 内部后，它调用了 wait 方法，wait 内部首先会将底层锁释放，这样 a 才可以通过 wiht 语句进入 condition。</li><li>随后，在 wait 方法内，它还会申请一把新的锁放入condition的等待队列（双端队列）中，等待 notify 方法的唤醒</li></ul><p>了解了这个原理，上面的问题就很简单了，如果不先通过 with 语句，我们是无法进入到 condition 内部的。</p><p>Condition 也有类似锁的申请、释放的模式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.cond.acquire()</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">self.cond.release()</span><br></pre></td></tr></table></figure><h2 id="信号量-semaphore">信号量 Semaphore</h2><p>Semaphore 是用于控制进入数量的锁。</p><p>比如在文件的操作中，需要控制读写线程的数量。在爬虫的实现中，需要限制请求并发数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> c</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlSpider</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;HTML 爬取模拟器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        threading (Thread): 继承自线程类，每个 URL 有一个线程处理</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url, sem</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.url&#125;</span> finished.&quot;</span>)</span><br><span class="line">        <span class="comment"># 处理完成后，释放该锁</span></span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlMaker</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sem</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这里有 100 URL 需要处理，但是同时并发这么多请求会报错</span></span><br><span class="line">        <span class="comment"># 可以通过 semaphore 限制并发的数量来控制</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            <span class="comment"># 一把 sem 锁，最多进入10个线程</span></span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_sider = HtmlSpider(<span class="string">f&quot;http:/scottzhang.pro/<span class="subst">&#123;i&#125;</span>&quot;</span>, self.sem)</span><br><span class="line">            html_sider.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sem = threading.Semaphore(<span class="number">10</span>)  <span class="comment"># 控制并发数量为 10 个</span></span><br><span class="line">    url_maker = UrlMaker(sem)</span><br><span class="line">    url_maker.start()</span><br></pre></td></tr></table></figure><p>信号量内部实际上是使用 condition 实现的，而 condition 则是使用 queue 实现的。</p><h1 id="threadpoolexecutor-线程池">ThreadPoolExecutor 线程池</h1><h2 id="使用">使用</h2><p>线程池也可以实现 semaphore 的功能，即控制线程的数量。</p><p>但是线程池可以控制的东西更多，比如它可以获得某个线程的状态与返回值。</p><p>当一个线程完成的时候，主线程可以立即知道。</p><p>其次，futures 可以让多线程和多进程编码接口一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_function</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟某个函数的执行&quot;&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">&quot;Thread %s: starting&quot;</span>, name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    logging.info(<span class="string">&quot;Thread %s: finishing&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_thread_1</span>():</span></span><br><span class="line">    logging.info(<span class="string">&quot;# Start thread with method 1&quot;</span>)</span><br><span class="line">    executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">    task1 = executor.submit(thread_function, (<span class="string">&#x27;A thread&#x27;</span>))</span><br><span class="line">    task2 = executor.submit(thread_function, (<span class="string">&#x27;B thread&#x27;</span>))</span><br><span class="line">    task3 = executor.submit(thread_function, (<span class="string">&#x27;C thread&#x27;</span>))</span><br><span class="line">    <span class="comment"># 查看是否成功，返回结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task 1 status: <span class="subst">&#123;task1.done()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 取消某个任务(还未执行)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Cancel task 3: <span class="subst">&#123;task3.cancel()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_thread_2</span>(<span class="params">names</span>):</span></span><br><span class="line">    logging.info(<span class="string">&quot;# Start thread with method 2&quot;</span>)</span><br><span class="line">    executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    all_tasks = [</span><br><span class="line">        executor.submit(thread_function, (x)) <span class="keyword">for</span> x <span class="keyword">in</span> names</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 这里会直接进入到 as_completed 逻辑，并不会阻塞</span></span><br><span class="line">    <span class="comment"># as_completed 会将已经完成的 task yield</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_tasks):</span><br><span class="line">        data = future.result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_thread_3</span>(<span class="params">names</span>):</span></span><br><span class="line">    logging.info(<span class="string">&quot;# Start thread with method 3&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        data = executor.<span class="built_in">map</span>(thread_function, names)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">format</span> = <span class="string">&quot;%(asctime)s: %(message)s&quot;</span></span><br><span class="line">    logging.basicConfig(<span class="built_in">format</span>=<span class="built_in">format</span>, level=logging.INFO,</span><br><span class="line">                        datefmt=<span class="string">&quot;%H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">    names = [<span class="string">&#x27;A thread&#x27;</span>, <span class="string">&#x27;B thread&#x27;</span>, <span class="string">&#x27;C thread&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    start_thread_1()</span><br><span class="line">    start_thread_2(names)</span><br><span class="line">    start_thread_3(names)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">15:36:09: # Start thread with method 1</span><br><span class="line">15:36:09: Thread A thread: starting</span><br><span class="line">15:36:09: Thread B thread: starting</span><br><span class="line">Task 1 status: False</span><br><span class="line">Cancel task 3: True</span><br><span class="line">15:36:09: # Start thread with method 2</span><br><span class="line">15:36:09: Thread A thread: starting</span><br><span class="line">15:36:09: Thread B thread: starting</span><br><span class="line">15:36:09: Thread C thread: starting</span><br><span class="line">15:36:11: Thread B thread: finishing</span><br><span class="line">15:36:11: Thread A thread: finishing</span><br><span class="line">15:36:11: Thread C thread: finishing</span><br><span class="line">15:36:11: Thread A thread: finishing</span><br><span class="line">15:36:11: # Start thread with method 3</span><br><span class="line">15:36:11: Thread A thread: starting</span><br><span class="line">15:36:11: Thread B thread: starting</span><br><span class="line">15:36:11: Thread B thread: finishing</span><br><span class="line">15:36:13: Thread B thread: finishing</span><br><span class="line">15:36:13: Thread C thread: starting</span><br><span class="line">15:36:13: Thread A thread: finishing</span><br><span class="line">15:36:15: Thread C thread: finishing</span><br></pre></td></tr></table></figure><p>另外 <code>concurrent.futures</code> 中还有 wait 方法，可以用来阻塞。比如你想指定某个或者某些任务完成才继续:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> wait, FIRST_COMPLETED</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">all_tasks = [executor.submit(thread_function, (x)) <span class="keyword">for</span> x <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">wait(all_task)  <span class="comment"># 等所有 task 结束才完成</span></span><br><span class="line">wait(all_task, return_when=FIRST_COMPLETED)</span><br></pre></td></tr></table></figure><h2 id="理解-future-类">理解 Future 类</h2><p>当我们调用时:</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>task1 <span class="op">=</span> executor.submit(thread_function, (<span class="st">&#39;A thread&#39;</span>))</span></code></pre></div><p>task1 是一个 Future 类的实例，这个实例贯穿我们整个多线程的体系中。</p><p>因为 Python 为了提供系统的一致性，将多线程、多进程以及协程都采用了一样的设计模式。</p><p>仔细想一下，我们的 <code>thread_function</code> 函数并没有去访问任何 Future 实例，为什么它却可以拿到 函数的执行状态呢？</p><p>我们看一下 submit 的源码：</p><figure><img src="https://s2.loli.net/2022/05/10/kptihyjHsd4m9lO.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>其中 f 为 future 类实例；w 为 workitem 实例；workitem 负责了将 future 实例和我们的函数，以及其参数做绑定。</p><p>并将 w 放到队列中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Python 多线程编程参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="GIL" scheme="https://scottzhang.pro/tags/GIL/"/>
    
    <category term="线程" scheme="https://scottzhang.pro/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Thread" scheme="https://scottzhang.pro/tags/Thread/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://scottzhang.pro/tags/ThreadPoolExecutor/"/>
    
    <category term="Python Future" scheme="https://scottzhang.pro/tags/Python-Future/"/>
    
  </entry>
  
  <entry>
    <title>Spark-浅析API 与工具集P1</title>
    <link href="https://scottzhang.pro/article/28c39ad6.html"/>
    <id>https://scottzhang.pro/article/28c39ad6.html</id>
    <published>2022-03-21T13:20:08.000Z</published>
    <updated>2022-03-21T13:21:17.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spark 概述、浅析、工具集与结构化API。</p></blockquote><span id="more"></span><h2 id="spark-指南">Spark 指南</h2><h2 id="大数据与-spark-概述">大数据与 Spark 概述</h2><p><img src="https://s2.loli.net/2022/03/21/FrOiSsICP6Lhz51.png" /></p><h2 id="spark-浅析">Spark 浅析</h2><figure><img src="https://s2.loli.net/2022/03/21/eO2kihfLurdR96C.png" alt="spark浅析1, 基本架构、多语言、API 以及 SparkSession" /><figcaption aria-hidden="true">spark浅析1, 基本架构、多语言、API 以及 SparkSession</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/21/u2j5WVkyzgBhxdY.png" alt="spark 的主要架构" /><figcaption aria-hidden="true">spark 的主要架构</figcaption></figure><p>多语言支持中通过 spark 会话提交任务给执行器，具体如下图所示：</p><figure><img src="https://s2.loli.net/2022/03/21/AjqW67HLPRhaCTD.png" alt="多语言 API.png" /><figcaption aria-hidden="true">多语言 API.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/21/QmZVLvBwWj9xGFe.png" alt="spark浅析2,数据分区、转换操作、惰性评估、动作操作与用户接口" /><figcaption aria-hidden="true">spark浅析2,数据分区、转换操作、惰性评估、动作操作与用户接口</figcaption></figure><h2 id="spark-工具集介绍">Spark 工具集介绍</h2><figure><img src="https://s2.loli.net/2022/03/21/8lsOzB4ejMPy1X7.png" alt="Spark 工具集.png" /><figcaption aria-hidden="true">Spark 工具集.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/21/rojM52HmCB1wRge.png" alt="spark 工具集架构" /><figcaption aria-hidden="true">spark 工具集架构</figcaption></figure><h2 id="结构化-api">结构化 API</h2><figure><img src="https://s2.loli.net/2022/03/21/uvgWDohx7JceLrQ.png" alt="结构化 API" /><figcaption aria-hidden="true">结构化 API</figcaption></figure><p>结构化API指以下三种核心分布式集合类型的API： - Dataset类型。 - DataFrame类型。 - SQL表和视图。</p><p>结构化API是在编写大部分数据处理程序时会用到的基础抽象概念。</p><h3 id="结构化api的执行步骤">结构化API的执行步骤</h3><ul><li>编写DataFrame / Dataset / SQL代码。</li><li>如果代码能有效执行， Spark将其转换为一个逻辑执行计划（Logical Plan）。</li><li>Spark将此逻辑执行计划转化为一个物理执行计划（Physical Plan）， 检查可行的 优化策略，并在此过程中检查优化。</li><li>Spark在集群上执行该物理执行计划（RDD操作）。</li></ul><figure><img src="https://s2.loli.net/2022/03/21/GltsvRengH6C9QZ.png" alt="Catalyst优化器.png" /><figcaption aria-hidden="true">Catalyst优化器.png</figcaption></figure><blockquote><p>通过控制台提交给Spark，或者以一个Spark作业的形式提交。然后代码将交由Catalyst优化器决定如何执行， 并指定一个执行计划。 最后代码被运行， 得到的结果返回给用户。图4-1展示了整个过程。</p></blockquote><h3 id="逻辑计划">逻辑计划</h3><p><img src="https://s2.loli.net/2022/03/21/YEerSUfdGn7RLbx.png" /></p><blockquote><p>Spark使用catalog（所有表和DataFrame信息的存储库）在分析器中 解析列和表格。 如果目录中不存在所需的表或列名称， 分析器可能会拒绝该未解析的 逻辑计划。</p></blockquote><h3 id="物理计划">物理计划</h3><p><img src="https://s2.loli.net/2022/03/21/wlUpdFQYTNZ85oa.png" /></p><blockquote><p>在成功创建优化的逻辑计划后， Spark开始执行物理计划流程。物理规划产生一系列的RDD和转换操作。 这就是Spark被称为编译器的原因， 因为它 将对DataFrame、Dataset和SQL中的查询来作为你编译一系列RDD的转换操作。</p></blockquote><h3 id="执行">执行</h3><p>在选择一个物理计划时， Spark将所有代码运行在Spark的底层编程接口RDD上（第Ⅲ 部分将会介绍）。 Spark在运行时执行进一步优化， 生成可以在执行期间优化任务或 阶段的本地Java字节码，最终将结果返回给用户。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Spark 概述、浅析、工具集与结构化API。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Spark 权威指南" scheme="https://scottzhang.pro/categories/Spark-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="Spark" scheme="https://scottzhang.pro/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Linux 是如何工作的-管理设备</title>
    <link href="https://scottzhang.pro/article/d7967d77.html"/>
    <id>https://scottzhang.pro/article/d7967d77.html</id>
    <published>2022-03-20T15:11:55.000Z</published>
    <updated>2022-03-20T15:13:42.225Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Linux 的设备文件系统、系统设备路径与设备名、udev, SCSI 等内容。</p></blockquote><span id="more"></span><p>Linux 设备</p><h2 id="设备文件系统device-files">设备文件系统（Device files）</h2><p>操作系统负责帮我们管理设备，将其抽象成类似文件的形式放在磁盘上，所以当往设备中输出内容，就像我们往一个文件中写内容一样，这些设备文件存放于 <code>/dev</code> 中, 执行 <code>ls /dev</code> 可以看到这些设备。</p><p>Linux启动的时候，会动态的在/dev目录下创建好各种设备的设备文件节点（也就是说，系统启动后/dev目录下就有了各种设备的设备文件，直接就可使用了）。</p><p>除此之外，他还可以在设备卸载后自动的删除/dev下对应的设备文件节点（这对于一些热插拔设备很有用，插上的时候自动创建，拔掉的时候又自动删除）。</p><p>在我们编写设备驱动的时候，不必再去为设备指定主设备号，在设备注册时用0来动态的获取可用的主设备号，然后在驱动中来实现创建和销毁设备文件（一般在驱动模块加载和卸载函数中来实现）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">brw-rw----   1 root disk 8, 1 Sep  6 08:37 sda1</span><br><span class="line">crw-rw-rw-   1 root root 1, 3 Sep  6 08:37 null</span><br><span class="line">prw-r--r--   1 root root    0 Mar  3 19:17 fdata</span><br><span class="line">srw-rw-rw-   1 root root    0 Dec 18 07:43 log</span><br></pre></td></tr></table></figure><p>第一个字母，<code>b, c, p, s</code> 分别代表 block, character, pipe, and socket。</p><p>block 设备：Programs access data from a block device in fixed chunks，block device’s total size is fixed and easy to index, processes have quick random access to any block in the device with the help of the kernel.</p><p>character 设备：work with data streams，only character, don’t have a size. Like printer; kernel cannot back up and reexamine the data stream after it has passed data to a device or process.</p><p>Pipe device: like character device, work with IO process instead of kernel.</p><p>Socket device: special-purpose interfaces that are frequently used for interprocess communication. They’re often found outside of the /dev directory.</p><h2 id="系统设备路径">系统设备路径</h2><p>/dev 下面的名字所能告诉你的信息很有限，而且内核根据设备被发现的顺序来给设备命名，所以一旦计算机重启，这些设备的名字有可能会不一样。</p><p>Linux 根据设备的属性，提供了一个统一的视图来访问所有的设备，即： <code>/sys/devices</code>。</p><p>/dev 下的文件让用户进程可以与设备交互。/sys/devices 用来查看和管理设备。</p><p>sys 目录下还有一些分类，比如 <code>/sys/block</code> 下面都是块设备。</p><p>在 /dev 目录下，找到设备的路径上有点不容易，不过可以通过 <code>udevadm</code> 命令查看，我们将会在之后介绍更多关于这个命令的知识。</p><h2 id="dd-和-设备">dd 和 设备</h2><p><code>dd</code> 程序在与块设备与字符设备时非常方便，但它也是一个非常强大的命令，需要特别小心的使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从块数据中复制固定大小的数据</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=new_file bs=1024 count=1</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>if, 输入文件，默认是标准输入</li><li>of, 输出文件，默认是标准输出</li><li>bs, 块大小，可以使用 b 或者 k</li><li>count=num，块的个数，当使用大文件或者文件流，需要用 count 或下面的 skip 来控制大小</li><li>skip=num, 另外一个控制大小的选项</li></ul><h2 id="设备名">设备名</h2><h3 id="找到设备名">找到设备名</h3><p>找到设备名有时候很麻烦，这里提供了集中方式：</p><ol type="1"><li>使用 <code>udevadm</code></li><li>检查 /sys 目录</li><li>通过 <code>journalctl -k</code> 命令打印系统内核的消息、日志，猜测设备名</li><li>对于存储设备，可以通过 mount 命令查看</li><li>通过 <code>cat /proc/devices</code> 命令查看块设备和字符设备的驱动。</li></ol><p>其中只有第一种方式是最可靠的，建议主要还是用第一种方式，如果你的系统中实在是没有 <code>udevadm</code> 可以使用，可以再参考其他的方式。</p><p>下面的内容会例举出 Linux 中最常见的一些设备，以及它们的命名。</p><h3 id="存储设备-devsd">存储设备 /dev/sd*</h3><p>存储设备的命名一般以 sd 开头，即 SCSI disk 的简写, SCSI 的意思是：Small Computer System Interface。SCSI 是最早被开发用来在存储设备和外围设备之间进行通讯。</p><p><code>lsscsi</code> 命令可以用来检查设备中的存储设备，它的输出如下：</p><p><img src="https://s2.loli.net/2022/03/13/5Iuy2Kewt6jAJqX.png" /></p><p>其中 1 表示设备在系统中的位置；2 表示设备描述； 3 表示去哪里找到这个设备；</p><h3 id="虚拟存储-devxvd-devvd">虚拟存储 /dev/xvd*, /dev/vd*</h3><p>有的磁盘设备是为了虚拟机优化而存在的，例如 AWS 实例，Virtual-Box.</p><h3 id="non-volatile-memory-devices-devnvme">Non-Volatile Memory Devices: /dev/nvme*</h3><p>有一些系统现在使用 Non-Volatile memory，即 NVMe 接口与某些类型的固态存储通信。</p><p>可以用 <code>nvme list</code> 命令列出这些设备。</p><h3 id="device-mapper-devdm--devmapper">Device Mapper: /dev/dm-*, /dev/mapper/*</h3><p>Device Mapper 并不是一个文件系统（File System），而是 Linux 内核映射块设备的一种技术框架。提供的一种从逻辑设备（虚拟设备）到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。</p><p>使用了这种映射的名字一般以 <code>/dev/dm-</code> 或者 <code>/dev/mapper</code> 命名。</p><h3 id="cd-和-dvd-devsr">CD 和 DVD: /dev/sr*</h3><p>一般命名为 /dev/sr0, /dev/sr1，只读。如果是可以写的，可能会命名为：/dev/sg0.</p><h3 id="pata-hard-disks-devhd">PATA Hard Disks: /dev/hd*</h3><p>Older type of storage bus. <code>/dev/hda, /dev/hdb, /dev/hdc, and /dev/hdd</code> , 如果你发现你的 SATA 驱动被识别成上面的格式，则代表它工作在钱荣模式下，这会影响性能，你可以查看 BIOS 设置是否正确。</p><h3 id="终端devtty-devpts-and-devtty">终端：/dev/tty*, /dev/pts/*, and /dev/tty</h3><p>终端是一种设备，它在用户进程和 I/O 设备间传输字符。而且大部分终端属于伪设备，它不是一个真的硬件。</p><p>两个常见的终端设备是 /dev/tty1（第一个虚拟控制台）和 /dev/pts/0（第一个伪终端设备）。 /dev/pts 目录本身就是一个专用的文件系统。</p><p>显示模式和虚拟终端：</p><p>Linux 主要有两种显示模式，文本和图形。</p><p>Linux 系统传统上是在文本模式下启动的，现在分发的大部分的系统则会隐藏文本模式。</p><p>这里的控制台或终端都是计算机产生早期的遗留下来的概念。为了充分使用计算机提供的计算资源，早期很多计算机会连接若干终端控制台，这些终端控制台从硬件上构造很简单，只包括键盘和显示器，不执行计算的任务，只简单的把用户的输入发送到主计算机去处理，然后再把计算结果返回给用户。</p><h3 id="串行端口-devttys-devttyusb-devttyacm">串行端口: /dev/ttyS*, /dev/ttyUSB*, /dev/ttyACM*</h3><p>串行接口（Serial port），主要用于串行式逐位数据传输。按电气标准及协议来分包括RS-232-C、RS-422、RS485、USB等。 RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接外挂程式、电缆或协议。USB是近几年发展起来的新型接口标准，主要应用于高速数据传输领域。</p><p>可以使用 screen 来连接 usb 串口设备。</p><blockquote><p>参考<a href="https://cloud.tencent.com/developer/news/304629">命令行界面、终端、Shell、TTY 的区别</a></p></blockquote><h3 id="并行端口devlp0-and-devlp1">并行端口：/dev/lp0 and /dev/lp1</h3><p>计算机上数据以并行方式传递的端口，也就是说至少应该有两条连接线用于传递数据。 与只使用一根线传递数据（这里没有包括用于接地、控制等的连接线）的串行端口相比，并口在相同的数据传送速率下，并口可以更快地传输数据。所以在21世纪之前，在需要较大传输速度的地方，例如打印机，并口得到广泛使用。但是随着速度迅速提高，并且上导线之间数据同步成为一个很难处理的难题，导致并口在速度竞赛中逐渐被淘汰。USB等改进的串口逐渐代替了并口。</p><h3 id="音频设备devsnd-devdsp-devaudio-and-more">音频设备：/dev/snd/*, /dev/dsp, /dev/audio, and More</h3><p>Linux 有两种音频设备，ALSA 和 OSS。分别代表了 Advanced Linux Sound Architecture 和 Open Sound System.</p><p>The ALSA devices are in the /dev/snd directory, but it’s difficult to work with them directly. Linux systems that use ALSA support OSS backward-compatible devices if the OSS kernel support is currently loaded.</p><h3 id="创建设备文件">创建设备文件</h3><p>在绝大多数情况下，你不需要自己创建设备文件，它们会被 devtmpfs 和 udev 自动创建。但我们至少可以学习一下如何做。</p><p><code>mknod</code> 命令可以用来创建一个设备。你必须知道设备的名字，以及它的主要、次要版本号，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b 8 1, 指定了 block 设备，major 版本为8，minor 版本为1</span></span><br><span class="line">mknod /dev/dda1 b 8 1</span><br></pre></td></tr></table></figure><p>对于linux 来说管理如此多的设备以及版本是非常复杂的，特别是当linux系统在升级的时候，后来出现了 devfs，一个内核空间中的 /dev 的实现，它包括了所有现在内核支持的设备，可以指定设备号、所有者、用户空间等信息，devfs 运行在内核环境中，并有不少缺点：可能出现主/辅设备号不够，命名不灵活，不能指定设备名称等问题。</p><p>所以后人又开发了 udev 和 devtmpfs.</p><h2 id="udev">udev</h2><p>关于 udev 的相关介绍，可以参考这篇文章: <a href="https://www.pianshen.com/article/5062954066/">Linux 文件系统与设备文件系统 （一）—— udev 设备文件系统</a></p><h3 id="devtmpfs">devtmpfs</h3><p>The devtmpfs filesystem was developed in response to the problem of device availability during boot.</p><h3 id="udevd-操作和配置">udevd 操作和配置</h3><p>在 GNU/Linux 系统中，虽然设备的底层支持是在内核层面处理的，但是，它们相关的事件管理是在用户空间中通过 udev 来管理的。确切地说是由 udevd 守护进程来完成的。</p><p>Udevd 守护进程所作的操作如下：</p><ol type="1"><li>内核通过内部的网络连接向 udevd 发送一个名为 uevent 的通知事件</li><li>udevd 从 uevent 中加载所有的属性</li><li>udevd 从 rule 中提取、过滤或者是更新相关内容</li></ol><p>可以使用 <code>udevadm monitor --property</code> 得到一个 uevent 的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ACTION=change</span><br><span class="line">DEVNAME=sde</span><br><span class="line">DEVPATH=/devices/pci0000:00/0000:00:1a.0/usb1/1-1/1-1.2/1-1.2:1.0/host4/</span><br><span class="line">target4:0:0/4:0:0:3/block/sde</span><br><span class="line">DEVTYPE=disk</span><br><span class="line">DISK_MEDIA_CHANGE=1</span><br><span class="line">MAJOR=8</span><br><span class="line">MINOR=64</span><br><span class="line">SEQNUM=2752</span><br><span class="line">SUBSYSTEM=block</span><br><span class="line">UDEV_LOG=3</span><br></pre></td></tr></table></figure><p>udev 规则是定义在一个以 .rules 为扩展名的文件中。那些文件主要放在两个位置：/usr/lib/udev/rules.d，这个目录用于存放系统安装的规则；/etc/udev/rules.d/ 这个目录是保留给自定义规则的。</p><p>定义那些规则的文件的命名惯例是使用一个数字作为前缀（比如，50-udev-default.rules），并且以它们在目录中的词汇顺序进行处理的。在 /etc/udev/rules.d 中安装的文件，会覆盖安装在系统默认路径中的同名文件。</p><p>下面是 udevd 规则的行为逻辑：</p><ol type="1"><li>udevd reads rules from start to finish of a rules file.</li><li>After reading a rule and possibly executing its action, udevd continues reading the current rules file for more applicable rules.</li><li>There are directives (such as GOTO) to skip over parts of rules files if necessary. These are usually placed at the top of a rules file to skip over the entire file if it’s irrelevant to a particular device that udevd is configuring.</li></ol><p>我们来看一下一个 /dev/sda 下面的符号链接，它被定义在 <code>lib/udev/rules.d/60-persistent-storage.rules</code> 当中，这个文件中有几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ATA</span><br><span class="line">KERNEL==&quot;sd*[!0-9]|sr*&quot;, ENV&#123;ID_SERIAL&#125;!=&quot;?*&quot;, SUBSYSTEMS==&quot;scsi&quot;, ATTRS&#123;vendor&#125;==&quot;ATA&quot;, IMPORT&#123;program&#125;=&quot;ata_id --export $devnode&quot;</span><br><span class="line"></span><br><span class="line"># ATAPI devices (SPC-3 or later)</span><br><span class="line">KERNEL==&quot;sd*[!0-9]|sr*&quot;, ENV&#123;ID_SERIAL&#125;!=&quot;?*&quot;, SUBSYSTEMS==&quot;scsi&quot;, ATTRS&#123;type&#125;==&quot;5&quot;,ATTRS&#123;scsi_level&#125;==&quot;[6-9]*&quot;, IMPORT&#123;program&#125;=&quot;ata_id --export $devnode&quot;</span><br></pre></td></tr></table></figure><p>通过内核的 SCSI 子系统，这些规则会与 AKA 硬盘以及 optical media 设备匹配，一般是通过文本的模式来匹配，比如 <code>"sd*[!0-9]|sr*"</code>.</p><blockquote><p>ATA 是一个广为使用的 IDE 和 EIDE设备相关的标准，意思是高级技术附件规格。ATA的硬盘分为 PATA 和 SATA，其中 P 代表的是并行、S代表的串行。目前 SATA 使用广泛，它的速度比 PATA 快太多，而且体积小、散热也更好。</p></blockquote><p>更多关于编写 udev 的规则，可参考这篇文章:&gt; <a href="https://linux.cn/article-9365-1.html">在 Linux 中如何编写基本的 udev 规则</a></p><h3 id="udev管理工具udevadm">udev管理工具：udevadm</h3><p>Udevadm 程序是 udev 的一个管理工具。你可以重新加载 udev 的规则，触发事件，最重要的一个特性是，你可以查找和探索系统的设备，或者是监控内核发出的 uevents 事件。</p><p>我们首先来看看怎么使用 udevadm 检查系统设备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info --query=all --name=/dev/sda </span><br></pre></td></tr></table></figure><p>下面是这条命令在我电脑上的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@scott-pc:/mnt/c/Users/Scott# udevadm info --query=all --name=/dev/sda</span><br><span class="line">P: /devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:0/block/sda</span><br><span class="line">N: sda</span><br><span class="line">L: 0</span><br><span class="line">E: DEVPATH=/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:0/block/sda</span><br><span class="line">E: DEVNAME=/dev/sda</span><br><span class="line">E: DEVTYPE=disk</span><br><span class="line">E: MAJOR=8</span><br><span class="line">E: MINOR=0</span><br><span class="line">E: SUBSYSTEM=block</span><br></pre></td></tr></table></figure><p>其中每一行代表了一个设备的属性，在上面的例子中：</p><ul><li>P: 最开始的那行，是 sysfs 设备路径</li><li>N: 设备节点，也就是给 /dev 下面文件的名字</li><li>S: 表明了设备节点的符号链接</li><li>E： 从 udevd 规则中找到的附加的信息</li></ul><h3 id="使用-udevadm-监控设备">使用 udevadm 监控设备</h3><p>你可以使用 <code>udevadm monitor</code> 来监控电脑上的设备，下面是它的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">KERNEL[658299.569485] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2 (usb)</span><br><span class="line">KERNEL[658299.569667] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0 (usb)</span><br><span class="line">KERNEL[658299.570614] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/host15 </span><br><span class="line">(scsi)</span><br><span class="line">KERNEL[658299.570645] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/ </span><br><span class="line">host15/scsi_host/host15 (scsi_host)</span><br><span class="line">UDEV [658299.622579] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2 (usb)</span><br><span class="line">UDEV [658299.623014] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0 (usb)</span><br><span class="line">UDEV [658299.623673] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/host15 </span><br><span class="line">(scsi)</span><br><span class="line">UDEV [658299.623690] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/</span><br><span class="line">host15/scsi_host/host15 (scsi_host)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure><p>这里有重复的输出，因为默认会输出来自内核的消息，以及 udevd 处理的消息，可以指定 --kernel 选项只查看内核的消息，--udev 查看 udevd处理的消息，以及--property 则可以让你查看整个 uevent, 包括属性。</p><p>你也可以通过 subsystem 来 filter 这些消息,比如你只想要看到 SCSI 子系统的 kernel 的消息，可执行下面的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ udevadm monitor --kernel --subsystem-match=scsi</span><br></pre></td></tr></table></figure><p>关于更多 Udevadm 的使用，可以查看 udevadm(8) 的操作手册。udev 本身还有很多其他的知识，例如有一个守护进程叫做 udisksd, 它会监听事件，当有新的磁盘接入的时候，会自动向进程发送消息。</p><h2 id="深入理解scsi-和-linux-内核">深入理解：SCSI 和 Linux 内核</h2><p>这一小节我们会探讨 Linux 内核对于 SCSI 的支持，以增加对 Linux 内核架构的理解。如果是为了学习如何使用磁盘，你无需学习本小节中的内容。</p><p>我们先讲一个小背景，传统的SCSi硬件配置是一个主机适配器通过 SCSI总线连接了一系列的设备，如下图所示:</p><p><img src="https://s2.loli.net/2022/03/17/hYZJzEHWNAUKQXp.png" /></p><p>其中的电脑通过 SCSI Host Adapter 来与其他的 Disk 通信，每一个 Disk 都有唯一的 ID，对于每一个单独的 Disk，他们之间可以通过 SCSI 命令进行点对点的通信。</p><p>新版本的 SCSI，也就是 Serial Attached SCSI （SAS）提供了更好的性能，但在大部分机器上，也许找不到任何真正意义上的 SCSI 设备。</p><p>SATA 磁盘在你的系统上，也已 SCSI 设备的形式出现，但是它们还是有一点不同的，因为它们中大部分都是通过 libata 库 中的翻译层通信。</p><p>这些说明了什么呢？假设我们查看系统上的设备，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lsscsi</span><br><span class="line">[0:0:0:0]   disk    ATA       WDC WD3200AAJS-2  01.0  /dev/sda</span><br><span class="line">[1:0:0:0]   cd/dvd  Slimtype  DVD A DS8A5SH     XA15  /dev/sr0</span><br><span class="line">[2:0:0:0]   disk    USB2.0    CardReader CF     0100  /dev/sdb</span><br><span class="line">[2:0:0:1]   disk    USB2.0    CardReader SM XD  0100  /dev/sdc</span><br><span class="line">[2:0:0:2]   disk    USB2.0    CardReader MS     0100  /dev/sdd</span><br><span class="line">[2:0:0:3]   disk    USB2.0    CardReader SD     0100  /dev/sde</span><br><span class="line">[3:0:0:0]   disk    FLASH     Drive UT_USB20    0.00  /dev/sdf</span><br></pre></td></tr></table></figure><p>先看方括号中的内容，从左至右分别是 SCSI 适配器号，SCSI 总线号，设备的 SCSI ID，以及 LUN（Logical Unit Number）逻辑快号。</p><p>上面的例子中，可以看到有四个适配器(scsi0-3)，每一个都有一个总线（号码都从0开始），每一个总线上，也只有一个设备。USB 读卡器在 2:0:0 上有四个逻辑单元，通过LUN 编号可以很容易看出这一点，即内核给每个逻辑单元都分配了一个 device file.</p><p>Figure 3-2 是内核中的驱动与接口的结构：</p><figure><img src="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png" alt="Figure 3-2" /><figcaption aria-hidden="true">Figure 3-2</figcaption></figure><ul><li>图中上面的层负责处理设备集的操作，比如 sd(SCSI Disk) 在这层；它知道如何翻译来自内核块设备接口的命令，将它变成磁盘特定的、SCSI 协议的指令</li><li>中间层，连接顶层和底层，传输 SCSI 消息，track 所有的SCSI总线，以及插入到系统上的设备</li><li>执行特定的硬件操作。</li></ul><blockquote><p>The top and bottom layers contain many different drivers, but it’s important to remember that, for any given device file on your system, the kernel (nearly always) uses one top-layer driver and one lower-layer driver. For the disk at /dev/sda in our example, the kernel uses the sd top-layer driver and the ATA bridge lower-layer driver.</p></blockquote><h3 id="usb-存储-and-scsi">USB 存储 and SCSI</h3><p>为了使 SCSI 子系统与常见的 USB 存储硬件通信，如图 3-2 所示，内核需要的不仅仅是一个较低层的 SCSI 驱动程序。 以 /dev/sdf 为代表的 USB 闪存驱动器可以理解 SCSI 命令，但要真正与驱动器通信，内核需要知道如何通过 USB 系统进行通信。</p><p>从抽象结构上来看，USB 和 SCSI 很像，它们都有 device classes, buses, host controller。 所以 Linux 在内核中一个 USB Subsystem.</p><p>就像 SCSI 子系统在其组件之间传递 SCSI 命令一样，USB 子系统在其组件之间传递 USB 消息。 甚至还有一个类似于 lsscsi 的 lsusb 命令。</p><p>这里有趣的在于，USB 子系统在一头使用的是 USB 命令，而另外一头则使用的是 SCSI 命令。</p><p>在结构上，USB 子系统和 SCSI 子系统是分开的，因为两个子系统不应该共享同一个驱动，为了让它们可以通信，在 SCSI 子系统中，还有一个 lower-layer 的 SCSI bridge.</p><h3 id="scsi-和-ata">SCSI 和 ATA</h3><p>SATA 硬盘和其他的CD/DVD设备都使用了 SATA 接口。为了连接内核中 SATA 专用的驱动与 SCSI 子系统，内核利用了一个 bridge driver, 内核使用了一个桥接驱动程序，就像 USB 驱动器一样，但具有不同的机制和额外的复杂性。 光驱使用 ATAPI，一种以 ATA 协议编码的 SCSI 命令版本。 但是，硬盘不使用 ATAPI，也不编码任何 SCSI 命令！</p><p>Linux 内核使用名为 libata 的库的一部分来协调 SATA（和 ATA）驱动器与 SCSI 子系统。</p><h3 id="通用-scsi-设备">通用 SCSI 设备</h3><p>当用户空间进程与 SCSI 子系统通信时，它通常通过块设备层和/或位于 SCSI 设备类驱动程序（如 sd 或 sr）之上的另一个其他内核服务来进行。 换句话说，大多数用户进程从不需要知道关于 SCSI 设备或其命令的任何信息。</p><p>但是，用户进程可以绕过设备类驱动程序,直接向设备提供 SCSI 协议命令。 例如可以在 lsscsi 命令后添加 -g 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lsscsi -g</span><br><span class="line">[0:0:0:0]   disk    ATA       WDC WD3200AAJS-2  01.0  /dev/sda 1/dev/sg0</span><br><span class="line">[1:0:0:0]   cd/dvd  Slimtype  DVD A DS8A5SH     XA15  /dev/sr0   /dev/sg1</span><br><span class="line">[2:0:0:0]   disk    USB2.0    CardReader CF     0100  /dev/sdb   /dev/sg2</span><br><span class="line">[2:0:0:1]   disk    USB2.0    CardReader SM XD  0100  /dev/sdc   /dev/sg3</span><br><span class="line">[2:0:0:2]   disk    USB2.0    CardReader MS     0100  /dev/sdd   /dev/sg4</span><br><span class="line">[2:0:0:3]   disk    USB2.0    CardReader SD     0100  /dev/sde   /dev/sg5</span><br><span class="line">[3:0:0:0]   disk    FLASH     Drive UT_USB20    0.00  /dev/sdf   /dev/sg6</span><br></pre></td></tr></table></figure><p>为什么要使用通用设备？ 答案与内核中代码的复杂性有关。 随着任务变得越来越复杂，最好将它们排除在内核之外。 考虑 CD/DVD 写入和读取。 读取光盘是一个相当简单的操作，并且有一个专门的内核驱动程序。</p><p>然而，写入光盘比读取要困难得多，并且没有关键的系统服务依赖于写入的动作。 没有理由用这个活动来增加内核空间。 因此，要在 Linux 中写入光盘，您需要运行一个与通用 SCSI 设备（例如 /dev/sg1）对话的用户空间程序。 这个程序可能比内核驱动程序效率低一点，但它更容易构建和维护。</p><h3 id="单个设备的多种访问方法">单个设备的多种访问方法</h3><p>图 3-3 显示了 Linux SCSI 子系统从用户空间访问光驱的两个方法（sr 和 sg）（省略了 SCSI 底层以下的任何驱动程序）。</p><p>进程 A 使用 sr 驱动程序从驱动器读取，进程 B 使用 sg 驱动程序写入驱动器。 但是，像这样的进程通常不会同时运行以访问同一设备。</p><figure><img src="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png" alt="3-3" /><figcaption aria-hidden="true">3-3</figcaption></figure><p>在图 3-3 中，进程 A 从块设备中读取数据。 但是用户进程真的以这种方式读取数据吗？ 通常，答案是否定的。这种访问不是直接的，因为在块设备之上还有更多的层，甚至更多的硬盘访问点，我们将在下一章中学习。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Linux 的设备文件系统、系统设备路径与设备名、udev, SCSI 等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="How Linux Works" scheme="https://scottzhang.pro/categories/How-Linux-Works/"/>
    
    
    <category term="Linux" scheme="https://scottzhang.pro/tags/Linux/"/>
    
    <category term="Operating System" scheme="https://scottzhang.pro/tags/Operating-System/"/>
    
    <category term="udev" scheme="https://scottzhang.pro/tags/udev/"/>
    
    <category term="SCSI" scheme="https://scottzhang.pro/tags/SCSI/"/>
    
  </entry>
  
  <entry>
    <title>设计数据密集型应用-数据系统 P2</title>
    <link href="https://scottzhang.pro/article/ec2d337d.html"/>
    <id>https://scottzhang.pro/article/ec2d337d.html</id>
    <published>2022-03-20T15:07:08.000Z</published>
    <updated>2022-03-20T15:10:33.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「设计数据密集型应用」书中第三、四章内容的思维导图。包括：存储与检索、编码数据等内容。</p></blockquote><span id="more"></span><h1 id="存储与检索">3. 存储与检索</h1><h2 id="驱动数据库的数据结构">驱动数据库的数据结构</h2><figure><img src="https://s2.loli.net/2022/03/19/e2KTmgGZcw9th57.png" alt="驱动数据库的数据结构" /><figcaption aria-hidden="true">驱动数据库的数据结构</figcaption></figure><h3 id="散列索引">散列索引</h3><figure><img src="https://s2.loli.net/2022/03/19/k1KDrNagqEcGRtl.png" alt="以类 CSV 格式存储键值对的日志，并使用内存散列映射进行索引" /><figcaption aria-hidden="true">以类 CSV 格式存储键值对的日志，并使用内存散列映射进行索引</figcaption></figure><h3 id="sstable">SSTable</h3><figure><img src="https://s2.loli.net/2022/03/19/EVPSAbnZQypHuks.png" alt="驱动数据库的数据结构" /><figcaption aria-hidden="true">驱动数据库的数据结构</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/19/R9mu5kEyvLtP3d2.png" alt="键值更新日志压缩" /><figcaption aria-hidden="true">键值更新日志压缩</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/19/LZ4NIC9WTB2t3bJ.png" alt="同时执行压缩和分段合并" /><figcaption aria-hidden="true">同时执行压缩和分段合并</figcaption></figure><p>SSTable 的优势</p><ol type="1"><li>即使文件大于可用内存，合并段的操作仍然是简单而高效的。</li><li>为了在文件中找到一个特定的键，你不再需要在内存中保存所有键的索引。</li><li>由于读取请求无论如何都需要扫描所请求范围内的多个键值对，因此可以将这些记录分组为块（block），并在将其写入硬盘之前对其进行压缩</li></ol><h2 id="事务处理还是存储分析">3.2 事务处理还是存储分析</h2><figure><img src="https://s2.loli.net/2022/03/19/m6WxNfZC5PpsOhk.png" alt="事务处理分析" /><figcaption aria-hidden="true">事务处理分析</figcaption></figure><h3 id="olap-vs-oltp">OLAP vs OLTP</h3><table><thead><tr class="header"><th>属性</th><th>事务处理系统 OLTP</th><th>分析系统 OLAP</th></tr></thead><tbody><tr class="odd"><td>主要读取模式</td><td>查询少量记录，按键读取</td><td>在大批量记录上聚合</td></tr><tr class="even"><td>主要写入模式</td><td>随机访问，写入要求低延时</td><td>批量导入（ETL）或者事件流</td></tr><tr class="odd"><td>主要用户</td><td>终端用户，通过 Web 应用</td><td>内部数据分析师，用于决策支持</td></tr><tr class="even"><td>处理的数据</td><td>数据的最新状态（当前时间点）</td><td>随时间推移的历史事件</td></tr><tr class="odd"><td>数据集尺寸</td><td>GB ~ TB</td><td>TB ~ PB</td></tr></tbody></table><h3 id="数据仓库">数据仓库</h3><p>OLTP 系统往往对业务运作至关重要，因而通常会要求 高可用 与 低延迟。所以 DBA 会密切关注他们的 OLTP 数据库，他们通常不愿意让业务分析人员在 OLTP 数据库上运行临时的分析查询，因为这些查询通常开销巨大，会扫描大部分数据集，这会损害同时在执行的事务的性能。</p><p>从 OLTP 数据库中提取数据（使用定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中。将数据存入仓库的过程称为 “抽取 - 转换 - 加载（ETL）”。</p><figure><img src="https://s2.loli.net/2022/03/19/1q2SbhHmzZoeA3i.png" alt="事务处理分析-数据仓库" /><figcaption aria-hidden="true">事务处理分析-数据仓库</figcaption></figure><h3 id="列式存储">列式存储</h3><figure><img src="https://s2.loli.net/2022/03/19/29WjEJDOoRHq5lp.png" alt="列式存储" /><figcaption aria-hidden="true">列式存储</figcaption></figure><h1 id="编码与演化">4. 编码与演化</h1><h2 id="编码数据的格式">编码数据的格式</h2><figure><img src="https://s2.loli.net/2022/03/20/OMzifUsVo5aNhdj.png" alt="编码与演化-格式1" /><figcaption aria-hidden="true">编码与演化-格式1</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/20/WHOUvbmGMj4wnks.png" alt="编码与演化-格式2" /><figcaption aria-hidden="true">编码与演化-格式2</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/20/Wmj9cRuQgToqLyz.png" alt="编码与演化-模式" /><figcaption aria-hidden="true">编码与演化-模式</figcaption></figure><h2 id="数据流的类型">数据流的类型</h2><figure><img src="https://s2.loli.net/2022/03/20/cpGuNimlo9SZ6zK.png" alt="数据流" /><figcaption aria-hidden="true">数据流</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;「设计数据密集型应用」书中第三、四章内容的思维导图。包括：存储与检索、编码数据等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计数据密集型应用" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="database" scheme="https://scottzhang.pro/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>设计数据密集型应用-数据系统 P1</title>
    <link href="https://scottzhang.pro/article/752462c7.html"/>
    <id>https://scottzhang.pro/article/752462c7.html</id>
    <published>2022-03-18T13:44:15.000Z</published>
    <updated>2022-03-18T13:47:06.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「设计数据密集型应用」书中第一二章内容的思维导图。包括：第一章关于可靠性、可伸缩性、可维护性以及第二章介绍的数据模型与查询语言。</p></blockquote><span id="more"></span><p>设计数据密集型应用-数据系统</p><h1 id="可靠性可伸缩性可维护性">1. 可靠性、可伸缩性、可维护性</h1><h2 id="可靠性">1.1 可靠性</h2><figure><img src="https://s2.loli.net/2022/03/18/oMFv6ndUyYaERgm.png" alt="1-1" /><figcaption aria-hidden="true">1-1</figcaption></figure><h2 id="可伸缩性">1.2 可伸缩性</h2><figure><img src="https://s2.loli.net/2022/03/18/MZfmFU98SGbJHe2.png" alt="1-2" /><figcaption aria-hidden="true">1-2</figcaption></figure><h2 id="可维护性">1.3 可维护性</h2><figure><img src="https://s2.loli.net/2022/03/18/SO3gwFKtd8U7iaL.png" alt="1-3" /><figcaption aria-hidden="true">1-3</figcaption></figure><h1 id="数据模型与查询语言">2. 数据模型与查询语言</h1><h2 id="关系模型与文档模型">2.1 关系模型与文档模型</h2><figure><img src="https://s2.loli.net/2022/03/18/an5Gom1VSOcqBp6.png" alt="关系模型与文档模型2-1.png" /><figcaption aria-hidden="true">关系模型与文档模型2-1.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/18/rS9UTdP7OC1YJqv.png" alt="关系模型与文档模型2-2.png" /><figcaption aria-hidden="true">关系模型与文档模型2-2.png</figcaption></figure><h2 id="数据查询语言">2.2 数据查询语言</h2><figure><img src="https://s2.loli.net/2022/03/18/Gf6BhxwE3jTVDcr.png" alt="数据查询语言2-3.png" /><figcaption aria-hidden="true">数据查询语言2-3.png</figcaption></figure><h2 id="图数据模型">2.3 图数据模型</h2><figure><img src="https://s2.loli.net/2022/03/18/7rQefncS3tWBLd6.png" alt="图数据示例2-3-1.png" /><figcaption aria-hidden="true">图数据示例2-3-1.png</figcaption></figure><p>一个图数据模型示例。可以从社交网络或系谱数据库中获得：它显示了两个人，来自爱达荷州的 Lucy 和来自法国 Beaune 的 Alain。他们已婚，住在伦敦。</p><figure><img src="https://s2.loli.net/2022/03/18/uFSEp4mULksXdYo.png" alt="图数据模型2-3-2.png" /><figcaption aria-hidden="true">图数据模型2-3-2.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/18/ajBF7HSo9ZT8AOR.png" alt="图数据模型2-3-3.png" /><figcaption aria-hidden="true">图数据模型2-3-3.png</figcaption></figure><p>在历史上，数据最开始被表示为一棵大树（层次数据模型），但是这不利于表示多对多的关系，所以发明了关系模型来解决这个问题。最近，开发人员发现一些应用程序也不适合采用关系模型。新的非关系型 “NoSQL” 数据存储在两个主要方向上存在分歧：</p><p>文档数据库 的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。 图形数据库 用于相反的场景：任意事物都可能与任何事物相关联。 这三种模型（文档，关系和图形）在今天都被广泛使用，并且在各自的领域都发挥很好。一个模型可以用另一个模型来模拟 — 例如，图数据可以在关系数据库中表示 — 但结果往往是糟糕的。这就是为什么我们有着针对不同目的的不同系统，而不是一个单一的万能解决方案。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;「设计数据密集型应用」书中第一二章内容的思维导图。包括：第一章关于可靠性、可伸缩性、可维护性以及第二章介绍的数据模型与查询语言。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计数据密集型应用" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="database" scheme="https://scottzhang.pro/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Linux-基本命令与目录结构</title>
    <link href="https://scottzhang.pro/article/fa8d7a03.html"/>
    <id>https://scottzhang.pro/article/fa8d7a03.html</id>
    <published>2022-03-02T07:06:53.000Z</published>
    <updated>2022-03-02T07:19:54.660Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章涵盖了Linux中关于基本命令、环境变量、特殊符号、Shell 编辑工具、帮助文档查询、标准输入输出、符号链接、解压缩、超级用户以及目录的结构介绍等内容。</p></blockquote><span id="more"></span><h2 id="关于-unix-和-linux">关于 Unix 和 Linux</h2><p>Linux is a Unix flavor at heart. You’ll see the word Unix in this chapter more than Linux because you can take what you learn straight over to BSD and other Unix-flavored systems.</p><h2 id="bourne-shell-binsh">Bourne Shell: /bin/sh</h2><p>A shell is a program that runs commands.</p><p>现在有很多的 Shell，但大部分的都是起源于 Bourne shell (/bin/sh)，这是贝尔实验室早期开发给 Unix 用的。</p><p>Linux 也有一个优化过的 Shell 叫 <code>bash</code>，全称是 bourne again shell.</p><h2 id="基本命令">基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">cp</span><br><span class="line">mv</span><br><span class="line">rm</span><br><span class="line">touch</span><br><span class="line">mkdir</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">grep</span><br><span class="line">less</span><br><span class="line">more</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">diff 对比两个文件不同</span><br><span class="line">file 查看一个文件的格式</span><br><span class="line">find</span><br><span class="line">head</span><br><span class="line">tail</span><br><span class="line">sort</span><br><span class="line">passwd 改密码</span><br></pre></td></tr></table></figure><h2 id="环境和-shell-变量">环境和 Shell 变量</h2><p>Shell 环境下可以保存一些变量:</p><p><img src="https://s2.loli.net/2022/03/01/U13k84fPnlTDwYp.png" /></p><p>如果希望当 shell 启动的时候就将一些变量存起来，则可通过环境变量。</p><p>The main difference between environment and shell variables is that the operating system passes all of your shell’s environment variables to programs that the shell runs, whereas shell variables cannot be accessed in the commands that you run.</p><h2 id="命令地址">命令地址</h2><p><code>Path</code> 是一个特殊的环境变量，我们输入的指令 shell 会去这些路径中寻找程序，例如这是我的电脑上 <code>Path</code> 的值：</p><p><img src="https://s2.loli.net/2022/03/01/6Z1ztSubRsA3vlP.png" /></p><p>这个地址中的可以编辑，添加。</p><h2 id="特殊符号">特殊符号</h2><table><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 66%" /></colgroup><thead><tr class="header"><th>符号</th><th>符号名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>*</td><td>star, asterisk</td><td>Regular expression, glob character</td></tr><tr class="even"><td>.</td><td>dot</td><td>Current directory, file/hostname delimiter</td></tr><tr class="odd"><td>!</td><td>bang</td><td>Negation, command history</td></tr><tr class="even"><td>|</td><td>pipe</td><td>Command pipes</td></tr><tr class="odd"><td>/</td><td>(forward) slash</td><td>Directory delimiter, search command</td></tr><tr class="even"><td>\</td><td>backslash</td><td>Literals, macros (never directories)</td></tr><tr class="odd"><td>$</td><td>dollar</td><td>Variables, end of line</td></tr><tr class="even"><td>'</td><td>tick, (single) quote</td><td>Literal strings</td></tr><tr class="odd"><td>`</td><td>backtick, backquote</td><td>Command substitution</td></tr><tr class="even"><td>"</td><td>double quote</td><td>Semi-literal strings</td></tr><tr class="odd"><td>^</td><td>caret</td><td>Negation, beginning of line</td></tr><tr class="even"><td>~</td><td>tilde, squiggle</td><td>Negation, directory shortcut</td></tr><tr class="odd"><td>#</td><td>hash, sharp, pound</td><td>Comments, preprocessor, substitutions</td></tr><tr class="even"><td>[ ]</td><td>(square) brackets</td><td>Ranges</td></tr><tr class="odd"><td>{ }</td><td>braces, (curly) brackets</td><td>Statement blocks, ranges</td></tr><tr class="even"><td>_</td><td>underscore, under</td><td>Cheap substitute for a space used when spaces aren’t wanted or allowed, or when autocomplete algorithms get confused</td></tr></tbody></table><h2 id="shell-中编辑">Shell 中编辑</h2><table><thead><tr class="header"><th>快捷键</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CTRL-B</td><td>Move the cursor left</td></tr><tr class="even"><td>CTRL-F</td><td>Move the cursor right</td></tr><tr class="odd"><td>CTRL-P</td><td>View the previous command (or move the cursor up)</td></tr><tr class="even"><td>CTRL-N</td><td>View the next command (or move the cursor down)</td></tr><tr class="odd"><td>CTRL-A</td><td>Move the cursor to the beginning of the line</td></tr><tr class="even"><td>CTRL-E</td><td>Move the cursor to the end of the line</td></tr><tr class="odd"><td>CTRL-W</td><td>Erase the preceding word</td></tr><tr class="even"><td>CTRL-U</td><td>Erase from cursor to beginning of line</td></tr><tr class="odd"><td>CTRL-K</td><td>Erase from cursor to end of line</td></tr><tr class="even"><td>CTRL-Y</td><td>Paste erased text (for example, from CTRL-U)</td></tr></tbody></table><h2 id="查询帮助文档">查询帮助文档</h2><p><code>man ls</code> 查询 ls 的帮助；<code>man -k kerword</code> 查询有 keyword 关键字的帮助，结果你会发现有些数字，这些数字是告诉你这个命令在哪个分类下出现，数字对应的分类信息如下</p><table><thead><tr class="header"><th>Section</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>1</td><td>User commands</td></tr><tr class="even"><td>2</td><td>Kernel system calls</td></tr><tr class="odd"><td>3</td><td>Higher-level Unix programming library documentation</td></tr><tr class="even"><td>4</td><td>Device interface and driver information</td></tr><tr class="odd"><td>5</td><td>File descriptions (system configuration files)</td></tr><tr class="even"><td>6</td><td>Games</td></tr><tr class="odd"><td>7</td><td>File formats, conventions, and encodings (ASCII, suffixes, and so on)</td></tr><tr class="even"><td>8</td><td>System commands and servers</td></tr></tbody></table><h2 id="标准输入输出和错误">标准输入输出和错误</h2><ul><li><code>command &gt; file</code> # 命令的输出存到 file</li><li><code>command &gt;&gt; file</code> # 命令的输出追加到 file</li><li><code>command1 | command2</code> # 命令1 的输出作为命令2 的输入</li><li><code>head &lt; /proc/cpuinfo#</code> 文件内容到输出</li></ul><p>如果执行一个命令会报错，但希望将报错的内容单独保存到其他文件中，可使用下图的命令，The number <code>2</code> specifies the stream ID that the shell modifies. Stream ID 1 is standard output (the default), and 2 is standard error. <code>&gt;&amp;</code> notation will send both standard output and standard error to the file named f</p><p><img src="https://s2.loli.net/2022/03/01/utf8BAJgk43Fnbz.png" /></p><h2 id="管理进程">管理进程</h2><h3 id="列出进程">列出进程</h3><p>在系统中，每个进程都有一个 PID 作为标识进程的唯一 ID，在 Linux 可以使用 <code>ps</code> 命令直接查看所有进程的情况:</p><p><img src="https://s2.loli.net/2022/03/02/X3bOYeqWzfl9Ex4.png" /></p><ul><li>PID, The process ID.</li><li>TTY, The terminal device where the process is running. More about this later.</li><li>STAT, what the process is doing and where its memory resides. For example, S means sleeping and R means running. (See the ps(1) manual page for a description of all the symbols.)</li><li>TIME, the total amount of time that the process has spent running instructions on the processor. Remember that because processes don’t run constantly, this is different from the time since the process started (or “wall-clock time”).</li><li>COMMAND, This one might seem obvious as the command used to run the program, but be aware that a process can change this field from its original value. Furthermore, the shell can perform glob expansion, and this field will reflect the expanded command instead of what you enter at the prompt.</li></ul><blockquote><p>Mac 下没有 STAT 这列</p></blockquote><p>Ps 还有一些选项可以指定，方便我们定义输出：</p><ul><li><code>ps x</code> Show all of your running processes.</li><li><code>ps ax</code> Show all processes on the system, not just the ones you own.</li><li><code>ps u</code> Include more detailed information on processes.</li><li><code>ps w</code> Show full command names, not just what fits on one line.</li></ul><h3 id="杀死进程">杀死进程</h3><p>杀死一个进程使用 kill 指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill pid, 让内核向进程发送一个 TERM 信号（默认），停止该进程</span><br><span class="line">kill -STOP pid, 发送 STOP 信号， 冻结该进程，冻结的进程还会存在于内存</span><br><span class="line">kill -CONT pid, 恢复一个冻结的进程</span><br></pre></td></tr></table></figure><p>发送上面的指令可能你还会看到进程存在，因为操作系统会给进程机会去处理现场，进程也可能直接忽略你发送的信号，这时候你可以强制杀死一个进程，不给其任何机会</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -KILL pid</span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><h3 id="作业管理">作业管理</h3><p>作业管理，allows you to suspend and switch between programs you’re using。</p><p>For example, you can send a TSTP signal with CTRL-Z and then start the process again by entering fg (bring to foreground) or bg (move to background; see the next section).</p><p>可使用 <code>jobs</code> 查看是否有什么作业正在运行。</p><p>用 <code>screen</code> 或者 <code>tmux</code> 来管理作业是一个更好的选择。</p><h3 id="进程放到后台使用">进程放到后台使用</h3><p>如果你有一个解压大量文件的需求，当你运行的时候，只有当全部任务结束你才会看到输出，这时候你也没办法做什么，但你可以将这个任务放到后台去做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip file.gz &amp;</span><br></pre></td></tr></table></figure><p>这会给你一个 PID 告诉你正在处理这个任务的进程。</p><p>如果这个后台运行的进程需要标准输入，那么它会进入冻结状态，可以使用 <code>fg</code> 将其带入前台，如果这个后台进程报错了，那你会收到报错的信息（即便你当时正在忙别的事情😂），如果不想被打扰，最好将其错误信息重定向到其他地方（前面介绍过）.</p><h2 id="文件模式和权限">文件模式和权限</h2><p>所有 Unix 文件都有一组权限来决定你是否可以读或者写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 juser somegroup 7041  Mar 26 19:34  endnotes.html</span><br></pre></td></tr></table></figure><p>最开始的 <code>-rw-r--r--</code> 表明了该文件的权限，其含义如下:</p><p><img src="https://s2.loli.net/2022/03/02/GIVpzYK9hBNSUxC.png" /></p><p>第一个 - 往后开始，三个一组为权限组，其中各个字母的意思如下：</p><ul><li>r means that the file is readable.</li><li>w means that the file is writable.</li><li>x means that the file is executable (you can run it as a program).</li><li>- means “nothing” (more specifically, the permission for that slot in the set has not been granted).</li><li>有些会是s，用来表示用户执行这个程序时，将以这个程序所有者的身份执行，可以直接设置s权限，而无需先有x，但是有可能未生效（将以大S表示）</li><li>Mac OS X文件系统还有一个的附加属性@.</li></ul><h2 id="权限修改">权限修改</h2><p>使用 <code>chmod</code> 来修改权限，如对 group 和 others 增加写权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod g+r file</span><br><span class="line">chmod o+r file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者通过一条命令</span></span><br><span class="line">chmod go+r file</span><br></pre></td></tr></table></figure><p>你可能会看到通过数字来指定权限的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sets all permission bits at once</span></span><br><span class="line">chmod 644 file</span><br></pre></td></tr></table></figure><p>无需记住所有数字的意思，常用的权限可以参考下表：</p><table style="width:100%;"><colgroup><col style="width: 14%" /><col style="width: 57%" /><col style="width: 28%" /></colgroup><thead><tr class="header"><th>Mode</th><th>Meaning</th><th>Used for</th></tr></thead><tbody><tr class="odd"><td>644</td><td>user: read/write; group, other: read</td><td>files</td></tr><tr class="even"><td>600</td><td>user: read/write; group, other: none</td><td>files</td></tr><tr class="odd"><td>755</td><td>user: read/write/execute; group, other: read/execute</td><td>directories, programs</td></tr><tr class="even"><td>700</td><td>user: read/write/execute; group, other: none</td><td>directories, programs</td></tr><tr class="odd"><td>711</td><td>user: read/write/execute; group, other: execute</td><td>directories</td></tr></tbody></table><p>关于目录的权限：</p><ul><li>You can list the contents of a directory if it’s readable, but you can only access a file in a directory if the directory is executable.</li><li>You need both in most cases;</li></ul><p><code>unmask</code> 命令:</p><ul><li>ou can specify a set of default permissions with the umask shell command, which applies a predefined set of permissions to any new file you create.</li><li>use umask 022 if you want everyone to be able to see all of the files and directories that you create, and use umask 077 if you don’t.</li></ul><h2 id="符号链接">符号链接</h2><p>symbolic link is a file that points to another file or a directory, effectively creating an alias (like a shortcut in Windows). Symbolic links offer quick access to obscure directory paths.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 ruser users  11 Feb 27 13:52  somedir -&gt; /home/origdir</span><br></pre></td></tr></table></figure><p>若符号链接代表的文件不存在，则依赖该文件的命令会出错，除了 <code>ls file</code>。</p><p>通过符号链接，你无法知道指向的文件或者文件夹的特征，你必须访问该路径去看了才知道，而且一个符号链接可以指向另外一个符号链接，这种被称为 chained symbolic links.</p><p>创建一个符号链接可以通过下面的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -s 指定为软链接，若没有则是硬链接</span><br><span class="line">ln -s target linkname</span><br></pre></td></tr></table></figure><blockquote><p>注意不要将 target 和 linkname 搞反了，否则会发生的事情就是：creates a link named target inside linkname, and the link will point to itself unless linkname is a full path.</p></blockquote><p>符号链接可能还有一个问题是，你以为你编辑的是一个文件（可以编辑），但其实它是一个符号链接。</p><p>符号链接本质上是创建一个新的文件，这个文件保存的是目标文件的地址，而硬链接则是指向文件系统中底层的数据。</p><ul><li>当对一个文件创建了硬链接，如果对硬链接修改，那么原始文件也会被修改</li><li>当原始文件被删除，访问硬链接还可以看到原始文件内容，因为底层的文件数据存在硬链接这个引用，并未被真的删除；访问软链接则会提示原始文件已经不见。</li><li>原始文件被删除后，当向硬链接追加内容，硬链接文件内容会有原始内容和新内容；软连接则会创建一个新文件，并将新内容写入。</li></ul><h2 id="解压缩">解压缩</h2><ul><li><code>gzip</code>, The program gzip (GNU Zip) is one of the current standard Unix compression programs. 但无法压缩多个文件.</li><li><code>tar</code>, 可压缩多个文件，细节如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 压缩</span><br><span class="line"># c, create mode</span><br><span class="line"># v, 显示输入，两个v则显示更多细节</span><br><span class="line"># f, 指定要压缩的文件</span><br><span class="line">tar cvf archive.tar file1 file2 ...</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar xvf archive.tar</span><br><span class="line"># x, 解压模式</span><br></pre></td></tr></table></figure><p>在解压一个文件之前，先查看压缩文件内有哪些东西是有必要的，可以通过 <code>t</code> 模式来实现。</p><p>解压时的权限控制： consider using the p option to preserve permissions. Use this in extract mode to override your umask and get the exact permissions specified in the archive.</p><p>压缩文件有时候会有多重压缩的情况，比如你可能看到一个这样的文件: <code>file.tar.gz</code>，解压这种文件需要从右往左使用对应工具解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunzip file.tar.gz</span><br><span class="line">tar xvf file.tar</span><br></pre></td></tr></table></figure><p>但分别解压是比较慢的，需要两次磁盘读写和io时间，可以利用管道来处理:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat file.tar.gz | tar xvf -</span><br></pre></td></tr></table></figure><p><code>zcat</code> 相当于 <code>gunzip -dc</code>, 其中 d 的意思是解压，c 的意思是将结果放到标准输出。</p><p><code>zcat</code> 使用非常频繁, 所以 tar 将其放在内置参数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar ztvf file.tar.gz</span><br></pre></td></tr></table></figure><p>其他的解压工具还有 <code>xz</code> 和 <code>bzip2</code>.</p><h2 id="linux-目录结构">Linux 目录结构</h2><p>目录结构一般如下图所示：</p><p><img src="https://s2.loli.net/2022/03/02/vRuS1hNDzWUI2Hl.png" /></p><hr /><p><strong>一般的目录文件夹介绍：</strong></p><ul><li>/bin Contains ready-to-run programs (also known as executables), including most of the basic Unix commands such as ls and cp. Most of the programs in /bin are in binary format, having been created by a C compiler, but some are shell scripts in modern systems.</li><li>/dev Contains device files. You’ll learn more about these in Chapter 3.</li><li>/etc This core system configuration directory (pronounced EHT-see) contains the user password, boot, device, networking, and other setup files.</li><li>/home Holds home (personal) directories for regular users. Most Unix installations conform to this standard.</li><li>/lib An abbreviation for library, this directory holds library files containing code that executables can use. There are two types of libraries: static and shared. The /lib directory should contain only shared libraries, but other lib directories, such as /usr/lib, contain both varieties as well as other auxiliary files. (We’ll discuss shared libraries in more detail in Chapter 15.)</li><li>/proc Provides system statistics through a browsable directory-and-file interface. Much of the /proc subdirectory structure on Linux is unique, but many other Unix variants have similar features. The /proc directory contains information about currently running processes as well as some kernel parameters.</li><li>/run Contains runtime data specific to the system, including certain process IDs, socket files, status records, and, in many cases, system logging. This is a relatively recent addition to the root directory; in older systems, you can find it in /var/run. On newer systems, /var/run is a symbolic link to /run.</li><li>/sys This directory is similar to /proc in that it provides a device and system interface. You’ll read more about /sys in Chapter 3.</li><li>/sbin The place for system executables. Programs in /sbin directories relate to system management, so regular users usually do not have /sbin components in their command paths. Many of the utilities found here don’t work if not run as root.</li><li>/tmp A storage area for smaller, temporary files that you don’t care much about. Any user may read to and write from /tmp, but the user may not have permission to access another user’s files there. Many programs use this directory as a workspace. If something is extremely important, don’t put it in /tmp because most distributions clear /tmp when the machine boots and some even remove its old files periodically. Also, don’t let /tmp fill up with garbage because its space is usually shared with something critical (the rest of /, for example).</li><li>/usr Although pronounced “user,” this subdirectory has no user files. Instead, it contains a large directory hierarchy, including the bulk of the Linux system. Many of the directory names in /usr are the same as those in the root directory (like /usr/bin and /usr/lib), and they hold the same type of files. (The reason that the root directory does not contain the complete system is primarily historic—in the past, it was to keep space requirements low for the root.)</li><li>/var The variable subdirectory, where programs record information that can change over the course of time. System logging, user tracking, caches, and other files that system programs create and manage are here. (You’ll notice a /var/tmp directory here, but the system doesn’t wipe it on boot.)</li></ul><p><strong>其他 root 目录下的子文件夹：</strong></p><ul><li>/boot Contains kernel boot loader files. These files pertain only to the very first stage of the Linux startup procedure, so you won’t find information about how Linux starts up its services in this directory. See Chapter 5 for more about this.</li><li>/media A base attachment point for removable media such as flash drives that is found in many distributions.</li><li>/opt This may contain additional third-party software. Many systems don’t use /opt.</li></ul><p><strong>其他用户目录下存在的子文件夹：</strong></p><ul><li>/include Holds header files used by the C compiler.</li><li>/local Is where administrators can install their own software. Its structure should look like that of / and /usr.</li><li>/man Contains manual pages.</li><li>/share Contains files that should work on other kinds of Unix machines with no loss of functionality. These are usually auxiliary data files that programs and libraries read as necessary. In the past, networks of machines would share this directory from a file server, but today a share directory used in this manner is rare because there are no realistic space restraints for these kinds of files on contemporary systems. Instead, on Linux distributions, you’ll find /man, /info, and many other subdirectories here because it is an easily understood convention.</li></ul><p><strong>内核路径</strong></p><p>在 Linux 中，内核一般放在 /vmlinuz or /boot/vmlinuz，在系统启动的时候，boot loader 会启动内核。关于 boot loader 会在之后的文章中介绍。</p><h2 id="以超级用户执行命令">以超级用户执行命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vipw</span><br></pre></td></tr></table></figure><p>可通过 <code>/etc/sudoers</code> 文件配置谁可以使用 sudo 命令执行，是否需要密码等。</p><p>下面的配置表明，user1 和 user2 可以直接使用 sudo 命令，而不需要输入密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># defines an ADMINS user alias with the two users</span><br><span class="line">User_Alias ADMINS = user1, user2</span><br><span class="line"></span><br><span class="line"># users in the ADMINS alias can use sudo to execute commands as root</span><br><span class="line"># The second ALL means “any command.” The first ALL means “any host.” </span><br><span class="line">ADMINS ALL = NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line"># superuser may also use sudo to run any command on any host.</span><br><span class="line"># extra (ALL) means that the superuser may also run commands as any other user.</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"># 上面的这句，可以扩展为</span><br><span class="line">ADMINS ALL = (ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>visudo</code> 命令来编辑上面这个文件，它会检查你的语法。</p></blockquote><p>要查看 sudo 命令的历史记录，可使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl SYSLOG_IDENTIFIER=sudo</span><br></pre></td></tr></table></figure><p>来启用，对于老一点的系统，可能需要在 <code>/var/log</code> 查看, 比如 <code>/var/log/auth.log.</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章涵盖了Linux中关于基本命令、环境变量、特殊符号、Shell 编辑工具、帮助文档查询、标准输入输出、符号链接、解压缩、超级用户以及目录的结构介绍等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="How Linux Works" scheme="https://scottzhang.pro/categories/How-Linux-Works/"/>
    
    
    <category term="Linux" scheme="https://scottzhang.pro/tags/Linux/"/>
    
    <category term="Operating-System" scheme="https://scottzhang.pro/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Linux 是如何工作的- Big Picture</title>
    <link href="https://scottzhang.pro/article/74b16f02.html"/>
    <id>https://scottzhang.pro/article/74b16f02.html</id>
    <published>2022-03-01T09:48:07.000Z</published>
    <updated>2022-03-01T09:51:34.008Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《How Linux Works》 阅读笔记。</p></blockquote><span id="more"></span><h1 id="big-picture">Big Picture</h1><p>理解操作系统如何工作的关键是学会抽象，我们会将 Linux 系统抽象成不同的层：</p><p><img src="https://s2.loli.net/2022/03/01/4fLjqxBO3KyPS65.png" /></p><p>内核和用户进程有不同的运行态：</p><ul><li>the kernel runs in kernel mode, and the user processes run in user mode.</li><li>Code running in kernel mode has unrestricted access to the processor and main memory.</li><li>User mode restricts access to a (usually quite small) subset of memory and safe CPU operations.</li></ul><h2 id="理解内存">理解内存</h2><ul><li>main memory is just a big storage area for a bunch of 0s and 1s.</li><li>where the running kernel and processes reside</li></ul><h2 id="内核">内核</h2><ul><li>管理进程，决定哪个进程可以使用 CPU</li><li>Memory, 追踪、分配所有内存，如何多进程间共享内存</li><li>设备，提供硬件与软件的接口</li><li>系统调用和其他功能</li></ul><h3 id="管理进程">管理进程</h3><p>首先，进程是的运行是 “simultaneously” 的，同一时刻在一个CPU核心上，只能有一个进程可以使用 CPU，每个进程在 CPU 上运行一小段时间，内核需要管理不同进程在 CPU 上的切换。</p><blockquote><p>切换意味着程序所在的环境（变量值、内存地址等）需要记录下来，当再次运行的时候，需要重新恢复，这是通过 CPU 的寄存器实现的。同时每一个进程自己也有许多种状态，如就绪态、运行态、阻塞态等，这些状态的切换也需要内核来实现，一个进程属于哪个状态，就需要将其放到该状态的队列中去。不过状态之间的切换，有时候可能是进程自己来请求的，方法是通过系统调用。</p></blockquote><h3 id="管理内存">管理内存</h3><ul><li>内核在内存中，必须有一段常驻的区域，它是无法被用户进程访问的</li><li>每个用户进程需要有自己的内存区域与其他进程隔离</li><li>用户进程之间需要共享内存</li><li>用户进程的内存需要是只读的</li><li>系统可以通过将内存区域的数据放到磁盘，支持大于物理内存的数据放入内存中</li></ul><h3 id="管理设备与驱动">管理设备与驱动</h3><p>只有内核可以控制设备的访问，这是为了简化和抽象底层的硬件，防止用户进程直接访问硬件（比如直接关闭电源）。</p><h3 id="系统调用">系统调用</h3><ul><li>system calls (or syscalls) perform specific tasks that a user process alone cannot do well or at all.</li><li>Two system calls, fork() and exec(), are important to understanding how processes start：<ul><li>When a process calls <code>fork()</code>, the kernel creates a nearly identical copy of the process.</li><li>When a process calls <code>exec(program)</code>, the kernel loads and starts program, replacing the current process.</li></ul></li><li>系统调用的过程，可以参考看下图:</li></ul><p><img src="https://s2.loli.net/2022/03/01/2tKeHglsfwEPRTu.png" /></p><h2 id="用户空间">用户空间</h2><ul><li>内核分配给用户进程的，在内存中的空间称为用户空间。</li><li>Most of the real action on a Linux system happens in user space.</li></ul><figure><img src="https://s2.loli.net/2022/03/01/g1OikwaPRIKl4F5.png" alt="Example set of components fit together and interact on a Linux system" /><figcaption aria-hidden="true">Example set of components fit together and interact on a Linux system</figcaption></figure><h2 id="用户">用户</h2><ul><li>用户的定义：A user is an entity that can run processes and own files.</li><li>内核通过用户 ID 而不是用户名来管理用户。kernel does not manage the usernames; instead, it identifies users by simple numeric identifiers called user IDs.</li><li>Linux 通过用户主要是来管理 permissions and boundaries，每个用户空间都属于某个用户，进程也一样，用户只能对自己的进程、空间、文件有权限。</li><li>现实 Linux 系统中会有一系列的用户，其中有一个 root 用户被称为超级用户，他可以访问其他用户的进程与空间</li><li>还有一个群组的概念，即一组用户</li></ul><blockquote><p>下一章请参考：基本命令与目录结构。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《How Linux Works》 阅读笔记。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="How Linux Works" scheme="https://scottzhang.pro/categories/How-Linux-Works/"/>
    
    
    <category term="Linux" scheme="https://scottzhang.pro/tags/Linux/"/>
    
    <category term="Operating System" scheme="https://scottzhang.pro/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>记录开源 BI 工具 Metabase 的部署</title>
    <link href="https://scottzhang.pro/article/75e7492b.html"/>
    <id>https://scottzhang.pro/article/75e7492b.html</id>
    <published>2022-02-15T12:58:36.000Z</published>
    <updated>2022-02-22T03:46:16.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用最简单、快速的方式让你们公司的每一位拥有商业智能与分析。</p></blockquote><span id="more"></span><h1 id="metabase-介绍">Metabase 介绍</h1><p>Metabase 有两个版本，开源版和企业版，有两种方式将它们部署到生成环境：</p><ol type="1"><li>Metabase 云，有钱不想自己折腾的选择，但数据访问比较受限制</li><li>自己托管，在自己的机器上或者是云服务商的主机上</li></ol><p>对于 Metabase 云，他们会帮你搞定设置，备份，升级，你只需要专注在使用上，而不需要管如何部署等等。</p><p>对于自己托管的方案，我们需要准备两个东西：</p><ol type="1"><li>一台服务器运行 Metabase 应用</li><li>一个应用的服务器，用来存储 Metabase 运行期间产生的数据</li></ol><p>对于部署方式，用户是感觉不到任何差别的，实际上 Metabase 文档也写了，在底层即便是使用 Docker，Metabase 也是使用 Metabase JAR 的方式运行。</p><p>另外对于这一点的选择，也与 team 内部成员的技术储备有关，如果你的 team 成员比较懂 Docker，比如 服务器、网络等技术，则选择 Docker，否则选择 JAR；如果你的 taem 成员对两者都是差不多的懂，则选择 JAR，因为它需要学习的内容相对较少。</p><p>对于数据库，建议使用 PostgreSQL，MySQL，或者 MariaDb。</p><p>如果你使用云主机，则它们会自动帮你处理备份，否则你就需要自己备份。</p><h1 id="使用-docker-部署">使用 docker 部署</h1><p>使用 docker 部署 metabase 非常简单，打开 Metabase 官方的 docker image <a href="https://hub.docker.com/r/metabase/metabase">页面</a>。</p><p>复制下面的语句，将 docker image 拉取下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull metabase/metabase</span><br></pre></td></tr></table></figure><p>然后，直接启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我 windows 机器上，3000 端口无法打开，所以将其设置为 8889</span></span><br><span class="line"><span class="comment"># docker -p 中，顺序是 宿主机端口:docker内端口</span></span><br><span class="line">docker run -d -p 8889:3000 --name metabase metabase/metabase</span><br></pre></td></tr></table></figure><p>然后访问本机的 8889 端口就可以看到欢迎界面了。</p><figure><img src="https://s2.loli.net/2022/02/15/BGpNfu5T7RVQXiE.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>但是在添加数据库的界面中，是没有 Oracle 的，对我来说这是刚需，没办法得配置一下。</p><p>需要我们去 Oracle 下载 JDBC Driver JAR 文件，并放到容器内的 plugins 文件夹。</p><ol type="1"><li>访问 Oracle JDBC <a href="https://www.oracle.com/database/technologies/appdev/jdbc-ucp-19-13-c-downloads.html">下载页面</a>，这里是文档内推荐的版本</li><li>往下面找到 ojdbc8.jar</li><li>使用 docker cp 命令从宿主机拷贝该包到容器内</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp C:\Users\Scott\Downloads\ojdbc8.jar 614bccac20ce:/plugins/</span><br></pre></td></tr></table></figure><p>然后打开 metabase ，添加数据库连接，即可看到 Oracle 也出现在列表中了。</p><p><img src="https://s2.loli.net/2022/02/15/5dOZYaUimMJfKVe.png" /></p><p>至此，使用 Docker 对于 Meta 的部署就结束了。</p><p>还有一些高级的内容，比如如何将应用的数据存储在 docker 外部，或者是存储在 postgres 数据库中，可以参考官网的<a href="https://www.metabase.com/docs/latest/operations-guide/running-metabase-on-docker.html">文档</a>。</p><h1 id="配置邮箱">配置邮箱</h1><p>一开始使用 Metabase 设置邮箱，参考 Metabase 的<a href="https://www.metabase.com/docs/latest/administration-guide/02-setting-up-email.html">官网文档</a>(2022-2-21)并没有 outlook 的设置教程, 但设置的过程和参数应该是差不多的。</p><p>于是搜索 smtp outlook 的设置文档，找到了微软的帮助文档: <em><a href="https://support.microsoft.com/en-us/office/pop-imap-and-smtp-settings-8361e398-8af4-4e97-b147-6c6c4ac95353">POP, IMAP, and SMTP settings</a></em></p><p>按照微软的教程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMTP: smtp.office365.com</span><br><span class="line">SMTP: 587</span><br></pre></td></tr></table></figure><p>取决于你公司的配置，你可能直接配置成功，或者也有可能像我一样遇到无法连接到 smtp 服务器的情况。</p><p>这时候需要你检查你公司的smtp邮件服务器地址，然后将端口换成25再试试。</p><blockquote><p>可使用 telnet 命令来测试与邮件服务器的连接，如: <code>telnet smtp.office365.com 25</code> 是测试到该网址的25端口连接情况。</p></blockquote><p>如果你公司的地址是 google.com，那么你公司的邮件服务器地址有可能是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">google.mail.protection.outlook.com</span><br><span class="line"># 或者</span><br><span class="line">google-com.mail.protection.outlook.com</span><br></pre></td></tr></table></figure><figure><img src="https://s2.loli.net/2022/02/22/w9MZhjNbYV3f8XU.png" alt="metabase 邮箱配置" /><figcaption aria-hidden="true">metabase 邮箱配置</figcaption></figure><h1 id="参考">参考</h1><ul><li><a href="https://juejin.cn/post/6844903760867622920">数据可视化分析平台开源方案集锦</a></li><li><a href="https://juejin.cn/post/6844904200728641550">开源 BI，我最终选择了 Metabase</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;用最简单、快速的方式让你们公司的每一位拥有商业智能与分析。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Metabase" scheme="https://scottzhang.pro/tags/Metabase/"/>
    
    <category term="Docker" scheme="https://scottzhang.pro/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>记录开源 BI 工具 Superset 的部署</title>
    <link href="https://scottzhang.pro/article/35c1cbc9.html"/>
    <id>https://scottzhang.pro/article/35c1cbc9.html</id>
    <published>2022-02-15T09:51:50.000Z</published>
    <updated>2022-02-15T09:58:11.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apache Superset 是一个开源的数据探查与可视化平台，该工具在可视化、易用性和交互性上非常有特色，用户可以轻松对数据进行可视化分析。</p></blockquote><span id="more"></span><h1 id="使用-docker-安装-superset">使用 Docker 安装 Superset</h1><ol type="1"><li>第一步需要安装 Docker Engine 和 Docker Compose，在 Mac 上，可以使用 Docker Desktop，其中包括了 Docker Engine 和 Docker Compose。安装好 Docker 后，需要进入 Docker 设置将默认的内存设置为 6 GB</li><li>克隆 Superset 的仓库到本地:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/superset.git</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>将仓库拷贝到本地后，执行下面两条语句：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-non-dev.yml pull</span><br><span class="line">docker-compose -f docker-compose-non-dev.yml up</span><br></pre></td></tr></table></figure><p>关于 <code>docker compose</code> 的 CLI 命令参数与相关的解释，参考 <a href="https://docs.docker.com/compose/reference/#command-options-overview-and-help">Overview of docker-compose CLI</a>.</p><p>如果需要指定版本的 superset，需要在这一步指定，方法是在前面加上 tag 参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 1.4.0</span><br><span class="line">TAG=1.4.0 docker-compose -f docker-compose-non-dev.yml pull</span><br><span class="line">TAG=1.4.0 docker-compose -f docker-compose-non-dev.yml up</span><br></pre></td></tr></table></figure><p>在启动日志中，可能会看到检测到默认的 secret string，提示我们使用自己生成的字符，还贴心的给了我们生成示例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -base64 42</span><br></pre></td></tr></table></figure><p>其次，superset_worker 提示我们在使用超级用户启动 worker, 并提示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">You&#x27;re running the worker with superuser privileges: </span><br><span class="line">this is absolutely not recommended!&quot;</span><br><span class="line"></span><br><span class="line">Please specify a different user using the --uid option.</span><br><span class="line">User information: uid=0 euid=0 gid=0 egid=0</span><br></pre></td></tr></table></figure><p>我们之后再来看这个问题。</p><p>同时在 superset_init 中，我们还看到它的初始化配置文件地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/app/docker/pythonpath_dev/superset_config.py</span><br></pre></td></tr></table></figure><p>此时，我们其实已经可以打开 <code>http://0.0.0.0:8088</code> 访问 superset 的服务了, 默认的用户名和密码都是 <code>admin</code>。</p><h1 id="windows-使用-wsl-安装">Windows 使用 WSL 安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install build-essential libssl-dev libffi-dev python-dev python-pip libsasl2-dev libldap2-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 python 和 pip 后，安装虚拟环境</span></span><br><span class="line">pip install virtualenv</span><br><span class="line">python3 -m venv venv</span><br><span class="line">. venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 superset</span></span><br><span class="line">pip install apache-superset</span><br><span class="line"><span class="comment"># 初始化 db</span></span><br><span class="line">superset db upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置管理员账号</span></span><br><span class="line"><span class="built_in">export</span> FLASK_APP=superset</span><br><span class="line">superset fab create-admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载例子，可选</span></span><br><span class="line">superset load_examples</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">superset init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接启动</span></span><br><span class="line">superset run -p 8088 --with-threads --reload --debugger</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 wsgi 服务</span></span><br><span class="line"><span class="comment"># 安装相关服务</span></span><br><span class="line">pip install gunicorn</span><br><span class="line">pip install gevent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 wsgi 服务启动</span></span><br><span class="line">gunicorn  -w 10 -k gevent --timeout 120 -b 0.0.0.0:7668 --limit-request-line 0 --limit-request-field_size 0 <span class="string">&quot;superset.app:create_app()&quot;</span></span><br></pre></td></tr></table></figure><h1 id="配置-superset">配置 Superset</h1><p>配置 superset 需要使用一个配置文件，即上面我们日志中看到过的那个文件，它需要被添加到你的 PYTHONPATH 中。</p><p>看一下这个文件中的内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in superset_config.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Superset specific config</span></span><br><span class="line">ROW_LIMIT = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">SUPERSET_WEBSERVER_PORT = <span class="number">8088</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask App Builder configuration</span></span><br><span class="line"><span class="comment"># Your App secret key</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;\2\1thisismyscretkey\1\2\e\y\y\h&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The SQLAlchemy connection string to your database backend</span></span><br><span class="line"><span class="comment"># This connection defines the path to the database that stores your</span></span><br><span class="line"><span class="comment"># superset metadata (slices, connections, tables, dashboards, ...).</span></span><br><span class="line"><span class="comment"># Note that the connection information to connect to the datasources</span></span><br><span class="line"><span class="comment"># you want to explore are managed directly in the web UI</span></span><br><span class="line">SQLALCHEMY_DATABASE_URI = <span class="string">&#x27;sqlite:////path/to/superset.db&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask-WTF flag for CSRF</span></span><br><span class="line">WTF_CSRF_ENABLED = <span class="literal">True</span></span><br><span class="line"><span class="comment"># Add endpoints that need to be exempt from CSRF protection</span></span><br><span class="line">WTF_CSRF_EXEMPT_LIST = []</span><br><span class="line"><span class="comment"># A CSRF token that expires in 1 year</span></span><br><span class="line">WTF_CSRF_TIME_LIMIT = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set this API key to enable Mapbox visualizations</span></span><br><span class="line">MAPBOX_API_KEY = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>你可以在<a href="https://github.com/apache/superset/blob/master/superset/config.py">这里</a>找到所有可选的配置添加到配置文件中。</p><h1 id="连接数据库">连接数据库</h1><p>由于我需要测试的数据库是 Oracle，而 superset 安装后内部并不会带有数据库驱动，我们需要手动安装，方法是在仓库内部的 docker 目录下面，新建 <code>requirements-local.txt</code> 文件，并填入包的名字，如对于 oracle 是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx_Oracle</span><br></pre></td></tr></table></figure><p>然后关掉 superset 服务，重新生成镜像再启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build --force-rm</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>连接 oracle，只安装 cx_Oracle 是不够的，可能还需要有 instantclient 客户端。</p><p>在 web 界面添加数据库可能会看到这个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot locate a 64-bit Oracle Client library: &quot;libclntsh.so: cannot open shared object file: No such file or directory&quot;. See https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html for help</span><br><span class="line">(Background on this error at: http://sqlalche.me/e/13/4xp6)</span><br></pre></td></tr></table></figure><p>原因是没有配置 Oracle 的 instant client，需要在环境中安装才可以连接 Oracle。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 成功启动后，还需要安装 cx_Oracle 和 instant client 才可以连接 oracle</span><br><span class="line"># 首先需要下载 instant client, 这里不再赘述，去 Oracle 官网下载对应版本即可，我下载的版本是 instantclient-basic-linux.x64-12.2.0.1.0.zip</span><br><span class="line"></span><br><span class="line">apt-get update &amp;&amp; apt-get install -y libaio1       # 装依赖</span><br><span class="line">Unzip instantclient-basic-linux.x64-12.2.0.1.0.zip # 解压</span><br><span class="line"></span><br><span class="line"># 删除不需要的文件</span><br><span class="line">cd /opt/oracle/instantclient* \</span><br><span class="line">rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \</span><br><span class="line">echo /instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf \</span><br><span class="line"></span><br><span class="line"># 配置 tnsnames</span><br><span class="line">&amp;&amp; ldconfig \</span><br><span class="line">&amp;&amp; mkdir -p instantclient_12_2/network/admin \</span><br><span class="line">&amp;&amp; cp tnsnames.ora instantclient_12_2/network/admin/ \</span><br><span class="line">&amp;&amp; cp /sqlnet.ora instantclient_12_2/network/admin/</span><br></pre></td></tr></table></figure><p>另外，如果使用 tnsnames, tnsnames.ora 文件中的数据库地址配置可能在 wsl 中无法连接，这里折腾了一会，在宿主机上 ping 该地址得到了一个 domain.org 形式的地址，重新填入解决了。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Apache Superset 是一个开源的数据探查与可视化平台，该工具在可视化、易用性和交互性上非常有特色，用户可以轻松对数据进行可视化分析。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="superset" scheme="https://scottzhang.pro/tags/superset/"/>
    
    <category term="cx_oracle" scheme="https://scottzhang.pro/tags/cx-oracle/"/>
    
  </entry>
  
  <entry>
    <title>优先队列与堆</title>
    <link href="https://scottzhang.pro/article/c172b52c.html"/>
    <id>https://scottzhang.pro/article/c172b52c.html</id>
    <published>2022-02-09T13:42:44.000Z</published>
    <updated>2022-02-15T09:50:15.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>优先队列 Priority Queue (PQ) 是一个抽象的数据结构，堆（heap）是一个具体的数据结构，可以说是优先队列的一个实现。</p></blockquote><span id="more"></span><h1 id="优先队列">优先队列</h1><p>优先队列至少需要有以下这些操作：</p><ul><li>is_empty, 队列是否为空</li><li>add_element, 增加元素</li><li>pop_element, 弹出元素</li></ul><p>Python 有一个优先队列的实现，即堆（heapq），其中最小的元素拥有最高的优先级。它的每个父节点的值都只会小于或等于所有孩子节点（的值）; 最小的元素总是在根结点：heap[0]</p><p>Python heapq 模块和一般的堆数据结构，在设计时不允许查找除最小元素之外的任何元素。对于按大小检索任何元素，更好的选择是二叉搜索树。</p><p>堆使用了完全二叉树来实现优先队列，这意味着树的深度等于2为底，元素个数的对数。堆中每个父节点的值都小于或等于其任何子节点，这一点与二叉搜索树不一样（子节点中左节点小于右节点）</p><p><img src="https://files.realpython.com/media/heap-tree.4b4413ff133c.png" /></p><p>优先队列在编程中应用广泛，特别是那些需要在一些元素中查找极端值的情况，比如：</p><ul><li>根据点击量，查找博客中最受欢迎的5篇文章</li><li>找出从 a 点到 b 点最快的路径</li><li>你有发送邮件的一些任务，其中一些邮件需要每5分钟发一次，另外的一些需要每4分钟发一次</li></ul><h1 id="在-heapq-模块中作为列表的堆">在 heapq 模块中作为列表的堆</h1><p>堆是一个完全二叉树，我们可以使用列表来表示（<a href="%5B最小堆排序_Python_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV1ph411r7A6?from=search&amp;seid=14588240802172044798)">下图</a>表示的为最大堆）：</p><figure><img src="https://s2.loli.net/2022/02/08/ftlG2QF6pxjYuhe.png" alt="数组表示堆" /><figcaption aria-hidden="true">数组表示堆</figcaption></figure><ul><li>用 i 来表示索引值（也有用 k）</li><li>作为父节点，它的第一个子节点的数组下标为 2*i + 1.</li><li>作为父节点，它的第二个子节点数组下标为 2*i + 2.</li><li>作为子节点，它的父节点为 (i - 1) // 2.</li></ul><p>Python 中最小堆的一个特性，即子节点都要大于父节点，可以表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[i] &lt;= h[2*i + 1] and h[i] &lt;= h[2*i + 2]</span><br></pre></td></tr></table></figure><h1 id="操作堆">操作堆</h1><p>Python 中堆的实现是依赖于 list 的，它没有使用自定义的类。</p><p>可以从一个空堆开始初始化数据，但是如果你已经有一个list需要将其中的元素放到堆中，则可通过 heaptify() 来把一个 list 转成堆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">a = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># heapify() 修改列表，但不对它进行排序。</span></span><br><span class="line">heapq.heapify(a)</span><br><span class="line">a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>可以通过堆来实现优先级任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h = []</span><br><span class="line">heappush(h, (<span class="number">5</span>, <span class="string">&#x27;write code&#x27;</span>))</span><br><span class="line">heappush(h, (<span class="number">7</span>, <span class="string">&#x27;release product&#x27;</span>))</span><br><span class="line">heappush(h, (<span class="number">1</span>, <span class="string">&#x27;write spec&#x27;</span>))</span><br><span class="line">heappush(h, (<span class="number">3</span>, <span class="string">&#x27;create tests&#x27;</span>))</span><br><span class="line">heappop(h)</span><br></pre></td></tr></table></figure><p>再来看一个前面提到的发送 email 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">email</span>(<span class="params">frequency, details</span>):</span></span><br><span class="line">    current = datetime.datetime.now()</span><br><span class="line">    <span class="comment"># 产生一个无限循环的生成器</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        current += frequency</span><br><span class="line">        <span class="keyword">yield</span> current.strftime(<span class="string">&quot;%Y/%m/%d %H:%M&quot;</span>) , details</span><br><span class="line"></span><br><span class="line">fast_email = email(datetime.timedelta(minutes=<span class="number">15</span>), <span class="string">&quot;fast email&quot;</span>)</span><br><span class="line">slow_email = email(datetime.timedelta(minutes=<span class="number">40</span>), <span class="string">&quot;slow email&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将两个生成器在 heapq 中 merge</span></span><br><span class="line">unified = heapq.merge(fast_email, slow_email)</span><br></pre></td></tr></table></figure><p>我们调用结合后的生成器 10 次看看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(unified))</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;2022/02/08 17:40&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 17:55&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:05&#x27;, &#x27;slow email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:10&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:25&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:40&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:45&#x27;, &#x27;slow email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 18:55&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 19:10&#x27;, &#x27;fast email&#x27;)</span><br><span class="line">(&#x27;2022/02/08 19:25&#x27;, &#x27;fast email&#x27;)</span><br></pre></td></tr></table></figure><p>可以看到 fast email 是间隔 15 分钟每次发送，而 slow email 则是40 分钟一次，它们完美的交错成一个任务列表。</p><p>merge 并不会一次性将所有输入全部读取，所以即使我们传入的无限重复的生成器，它也非常快且不占用很多内存。</p><h1 id="使用堆的其他场景">使用堆的其他场景</h1><p>堆还擅长解决统计最大或者最小的问题，比如下面这个统计得奖次数得例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">results=<span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">Christania Williams      11.80</span></span><br><span class="line"><span class="string">Marie-Josee Ta Lou       10.86</span></span><br><span class="line"><span class="string">Elaine Thompson          10.71</span></span><br><span class="line"><span class="string">Tori Bowie               10.83</span></span><br><span class="line"><span class="string">Shelly-Ann Fraser-Pryce  10.86</span></span><br><span class="line"><span class="string">English Gardner          10.94</span></span><br><span class="line"><span class="string">Michelle-Lee Ahye        10.92</span></span><br><span class="line"><span class="string">Dafne Schippers          10.90</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">top_3 = heapq.nsmallest(</span><br><span class="line">    <span class="number">3</span>,                                  <span class="comment"># 指示返回多少个元素</span></span><br><span class="line">    results.splitlines(),               <span class="comment"># 分割成数组，要比较的元素或数据集</span></span><br><span class="line">    key=<span class="keyword">lambda</span> x: <span class="built_in">float</span>(x.split()[-<span class="number">1</span>])  <span class="comment"># 确定如何比较元素的可调用函数</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(top_3))</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Elaine Thompson          10.71</span><br><span class="line">Tori Bowie               10.83</span><br><span class="line">Marie-Josee Ta Lou       10.86</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;优先队列 Priority Queue (PQ) 是一个抽象的数据结构，堆（heap）是一个具体的数据结构，可以说是优先队列的一个实现。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="heapq" scheme="https://scottzhang.pro/tags/heapq/"/>
    
    <category term="queue" scheme="https://scottzhang.pro/tags/queue/"/>
    
    <category term="PQ" scheme="https://scottzhang.pro/tags/PQ/"/>
    
    <category term="heap" scheme="https://scottzhang.pro/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Python 什么是GIL锁</title>
    <link href="https://scottzhang.pro/article/eefff7f1.html"/>
    <id>https://scottzhang.pro/article/eefff7f1.html</id>
    <published>2022-01-17T12:54:03.000Z</published>
    <updated>2022-02-15T09:50:15.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>理解 Python 中的 GIL 锁对于想要了解 Python 多线程是非常重要的。</p></blockquote><span id="more"></span><h1 id="什么是-gil">什么是 GIL</h1><p>Python 全局解释器锁或 GIL(Global Interpreter Lock)，简单来说，是一个互斥体（或锁），它只允许一个线程持有 Python 解释器的控制权。</p><p>这意味着，在同一时刻，只有一个线程可以在 CPU 上可以执行字节码，即便是在拥有多核 CPU 的情况下，这也是 Python 被诟病的一个点。</p><h1 id="gil-解决了什么问题">GIL 解决了什么问题？</h1><p>既然 GIL 会带来性能利用上的问题，那为什么还要这样设计呢？</p><p>在谈这个问题之前，先来说说 Python 中的内存管理，Python 使用引用计数来实现内存管理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">a = []</span><br><span class="line">b = a</span><br><span class="line">sys.getrefcount(a)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>当一个对象的引用计数为0的时候，也就是没有变量指向它的时候，它就会被销毁。</p><p>这种引用计数的机制需要一个保护机制，以确保当多个线程同时对同一个对象进行操作时，不会发生错误（比如 A 线程对 X 加一百万次，B 线程对 X 减一百万次），如果放任不管，可能会造成内存泄漏（内存永远无法释放），或者是错误释放了还存在引用的内存。</p><p>如果给在不同线程之间共享的数据结构的引用计数加一把锁，这样它们就不会被不一致地修改。</p><p>但是给每一个对象（或者是一组对象）都加锁可能会导致死锁，而且在多把锁的情况下，对于锁的申请与释放又会导致性能下降。</p><p>GIL 规定执行任何 Python 字节码都需要先获得解释器锁, 这就避免了死锁和性能大幅下降的情况，坏处是 Python 程序只能以单线程的形式运行。</p><h1 id="为什么选择-gil-作为解决方案">为什么选择 GIL 作为解决方案？</h1><p>那么，为什么在 Python 中使用了一种看似如此笨拙的方法呢？ Python 的开发人员做出了一个错误的决定吗？毕竟现在动不动给就是 8 核 CPU。</p><p>在 <a href="https://www.youtube.com/watch?v=KVKufdTphKs&amp;t=731s">Larry Hastings</a> 关于 GIL 的演讲中，他说：“选择 GIl 的这个决定正是让 Python 如此流行的原因”</p><p>在操作系统出现线程这个概念以前，Python就存在。Python 被设计的易于使用，以使得开发更快。早期的 Python 依赖许多 C 的库，为了避免问题的产生，这些 C 程序需要一个线程安全的内存管理，而 GIL 让这成为了可能。可以说 GIL 是 CPython 开发人员在 Python 早期面临的难题的一个实用的解决方案。</p><h1 id="什么是-cpython">什么是 CPython</h1><p>Cpython 是用 C 写的一个解释器。</p><p>PYthon 有很多个解释器，如 CPython, Jython, IronPython 以及 PyPy, 分别使用 C, Java, C# 和 Python 实现。</p><p>我们知道 C 并不是一门面向对象的编程语言。你可能听说过在 Python 中一切皆对象（比如 int, str)，这在 CPython 层面的实现也是一样的，在 CPython 中，有一个 struct 叫做 PyObject，CPython 中的每一个对象都使用它。</p><blockquote><p>Note: A struct, or structure, in C is a custom data type that groups together different data types. To compare to object-oriented languages, it’s like a class with attributes and no methods.</p></blockquote><p>PyObject，也就是所有 Python 对象的爷爷，包含了两个东西:</p><ul><li><code>ob_refcnt</code>, 引用计数，实现垃圾回收机制</li><li><code>ob_type</code>, 指针指向另一个结构体，结构体中保存了实际的对象类型</li></ul><p>关于 CPython 的内存管理，可以参考 RealPython 的<a href="https://realpython.com/python-memory-management/#garbage-collection">这篇</a>文章。</p><h1 id="gil-的影响">GIL 的影响</h1><p>Python 中，如果你使用线程来同时对一个变量进行加减操作，会发现结果是不一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次的结果都不一样</span></span><br><span class="line"><span class="comment"># GIL 并不是上面某个函数一直占有，而是在某个函数转化成字节码后</span></span><br><span class="line"><span class="comment"># 执行一段长度的字节码后，会释放 GIL 码，然后给其他线程执行</span></span><br><span class="line"><span class="built_in">print</span>(total)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GIL 让你在同一时刻只能利用到一个线程，对于 CPU 密集型程序，使用单线程和多线程，其执行效率是一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># single_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">countdown(COUNT)</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所需时间(秒) -&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>在四核的机器上，它需要的时间是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python single_threaded.py</span><br><span class="line">所需时间(秒) - 6.20024037361145</span><br></pre></td></tr></table></figure><p>现在使用两个线程编写一个一样的程序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># multi_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line">t2 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所需时间(秒) -&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>运行查看结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python multi_threaded.py</span><br><span class="line">所需时间(秒) - <span class="number">6.924342632293701</span></span><br></pre></td></tr></table></figure><p>可以看到使用多线程和不适用多线程花的时间是差不多的。</p><p>GIL 对于 CPU 密集型的程序有限制的，对于 IO 密集型的则没有很大影响。</p><p>如果你编写了使用线程去处理图象中的每一个部分，那么甚至会让你的运行时间增加，这是因为申请和释放锁还需要额外的开销。</p><p>在 Python 3 更新的时候，许多人都希望将 GIL 移除，确实也有很多人做过尝试，但发现这么做除了导致很多的 C 语言库不支持意外，还让单线程下的 Python 相比较 Python2 更慢。</p><p>所以 Python 的创始人在谈及 GIL 时说：</p><blockquote><p>“I’d welcome a set of patches into Py3k only if the performance for a single-threaded program (and for a multi-threaded but I/O-bound program) does not decrease”.</p></blockquote><p>但 Python3 对 GIl 有过一次升级，即将 IO 密集型的线程申请锁的优先级降低。</p><p>Python 的 GIL 会饿死 I/O 密集型线程，因为它们不给它们从 CPU 密集型线程获取 GIL 的机会。</p><p>这是因为 Python 内置了一种机制，该机制强制线程在固定的连续使用间隔后释放 GIL，如果没有其他人获得 GIL，同一个线程可以继续使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># The interval is set to 100 instructions:</span></span><br><span class="line">sys.getcheckinterval()</span><br></pre></td></tr></table></figure><p>这种机制的问题在于，大多数情况下，CPU 密集型线程会在其他线程获取 GIL 之前重新获取 GIL，在 2009 年的时候，这个 bug 在 Python 3.2 中由 Antoine Pitrou 修复了，他设计了一种机制去查看其他线程申请锁但被拒绝的次数，目的就是防止 CPU 密集型线程长期占用 GIL 锁。</p><h1 id="如何解决-gil-带来的问题">如何解决 GIL 带来的问题</h1><p>如果确定 GIL 是你程序的瓶颈，可以有几个优化的方向：</p><p><strong>使用多进程</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(processes=<span class="number">2</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    r1 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    r2 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所需时间(秒)&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>使用多进程，所需时间只需要 4 秒。在进程中，每个进程都有自己的 GIL 锁用于内部线程的控制，所以互不影响。</p><blockquote><p>参考阮一峰关于: <a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">进程与线程的一个简单解释</a>。</p></blockquote><p><strong>更换解释器</strong></p><p>GIL 的问题，只存在于最开始的 CPython 中。</p><p>这篇文章对 Python 的 GIL 做了一个简单的介绍，如果你还想了解 GIL 更底层的东西，可以看一下 David Beazley 关于 GIL 的讲座: <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s">Understanding the Python GIL</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;理解 Python 中的 GIL 锁对于想要了解 Python 多线程是非常重要的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="GIL" scheme="https://scottzhang.pro/tags/GIL/"/>
    
  </entry>
  
  <entry>
    <title>了解 Python Magic Method</title>
    <link href="https://scottzhang.pro/article/23c3a2e1.html"/>
    <id>https://scottzhang.pro/article/23c3a2e1.html</id>
    <published>2022-01-16T14:07:47.000Z</published>
    <updated>2022-02-15T09:50:15.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了魔法方法，并带你使用魔法方法实现自定义的序列。</p></blockquote><span id="more"></span><h1 id="魔法方法">魔法方法</h1><p>魔法方法是为了增强某个类的特性，它有约定俗成的名字，你只需要实现这个方法即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, employee_list</span>):</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让此类的实例，支持被 for 循环访问内部 employee</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line">company = Company([<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;MicroSoft&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持 for 循环</span></span><br><span class="line"><span class="keyword">for</span> company_name <span class="keyword">in</span> company:</span><br><span class="line">    <span class="built_in">print</span>(company_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持切片</span></span><br><span class="line">company[:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h1 id="有哪些魔法方法">有哪些魔法方法</h1><p>首先可以分为非数学运算与数学相关。</p><p>非数学运算中又有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 字符串表示，__repr__, __str__</span><br><span class="line">- 集合序列相关，__len__, __get/set/delitem__, __contains__</span><br><span class="line">- 迭代相关, __iter__, __next__</span><br><span class="line">- 可调用, __call__</span><br><span class="line">- with 上下文管理器, __enter__, __exit__</span><br><span class="line">- 数值转换，__abs__, __int/float/bool/...__, __hash__</span><br><span class="line">- 元类相关, __new__, __init__</span><br><span class="line">- 属性相关，__get/setattr__, __get/setattribute__. __dir__</span><br><span class="line">- 属性描述符, __get__, __set__, __delete__</span><br><span class="line">- 协程, __await__, __aiter__, __anext__, __aenter__, __aexit__</span><br></pre></td></tr></table></figure><p>数学运算则有一元、二元运算符，算数运算符，位运算符等等，暂时不做过多介绍。</p><p>在 Python 中，len 方法有其特殊性。当 len 作用在内置类型如 set, list, dict 上的时候，因为这些结构都是用 C 语言实现的，性能非常高，当 len 计算这些数据结构的长度的时候，会直接读取这个数据结构的长度值（C 会维护一个长度值），而不会遍历该树结构。</p><h1 id="应用自定义序列">应用：自定义序列</h1><h2 id="序列类型">序列类型</h2><p>在了解如何自定义序列类之前，我们先看 python 有哪些内置的序列类，我们将其中分为这几类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个容器，可以往里面放东西</span></span><br><span class="line">- 容器序列：<span class="built_in">list</span>, <span class="built_in">tuple</span>, deque</span><br><span class="line"><span class="comment"># 非容器</span></span><br><span class="line">- 扁平序列：<span class="built_in">str</span>, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>, array.array</span><br><span class="line"><span class="comment"># 序列内部元素可以变化</span></span><br><span class="line">- 可变序列： <span class="built_in">list</span>, deque, <span class="built_in">bytearray</span>, array</span><br><span class="line"><span class="comment"># 序列内部元素不可变化</span></span><br><span class="line">- 不可变：<span class="built_in">str</span>, <span class="built_in">tuple</span>, <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><p>上面这些序列类，你都可以通过 for 循环去访问其内部的元素。</p><p>要想实现序列类，则需要实现序列的协议。</p><p>可以通过 <code>_collections_abc</code> 了解要实现序列协议所需要的函数。</p><p>在序列中，一般都支持 <code>+ += extend</code> 方法，但你知道他们的区别吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化列表</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># +, c = [1, 2, 3, 4]</span></span><br><span class="line">c = a + [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># +=, a = [1, 2, 3, 4]</span></span><br><span class="line">a += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将 += 后面换成元组呢？</span></span><br><span class="line"><span class="comment"># 结果是一样的</span></span><br><span class="line">a += (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是 + 呢？</span></span><br><span class="line"><span class="comment"># 会报错</span></span><br><span class="line">c = a + (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>+=</code> 支持任意序列类型，其背后原理是调用一个魔法函数 <code>__iadd__</code>, 其中又是依赖 <code>__extend__</code> 方法，内部使用的是 for 循环对元素取值并相加，所以只要是可以迭代的类型，都支持用 <code>+=</code> 操作。</p></blockquote><p>另外要注意 list 的 <code>append</code> 和 <code>extend</code> 方法的区别，extend 是将数组内的值一个一个放入另一个数组，而 append 是将整个数组放入另一个数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">arr.extend([<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">arr.append([<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line">arr.append((<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># [1, 2, (3, 4)]</span></span><br></pre></td></tr></table></figure><h2 id="实现可切片对象">实现可切片对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DCGroup</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dpt, industry, staff</span>):</span></span><br><span class="line">        self.dpt = dpt</span><br><span class="line">        self.industry = industry</span><br><span class="line">        self.staff = staff</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现序列协议需要的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.staff.reverse()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个是实现切片的关键，若没有，切片操作会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># 若这样返回，则直接叫切片操作交给了内置的 list 操作</span></span><br><span class="line">        <span class="comment"># return self.staff[item]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 但如果你想要返回的东西是一个 Group 对象呢？</span></span><br><span class="line">        <span class="comment"># 这样你就可以一直切片</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这就需要理解 传入的 item（本质上是一个 slice 对象）</span></span><br><span class="line">        <span class="comment"># 如果是根据 index 访问，则是 int 值</span></span><br><span class="line"></span><br><span class="line">        cls = <span class="built_in">type</span>(self)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">slice</span>):</span><br><span class="line">            <span class="keyword">return</span> cls(</span><br><span class="line">                dpt=self.dpt,</span><br><span class="line">                industry=self.industry,</span><br><span class="line">                staff=self.staff[item]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(item, numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> cls(</span><br><span class="line">                dpt=self.dpt,</span><br><span class="line">                industry=self.industry,</span><br><span class="line">                staff=[self.staff[item]]</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.staff)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.staff)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> self.staff:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">dc = DCGroup(dpt=<span class="string">&#x27;DC&#x27;</span>, industry=<span class="string">&#x27;IMF&#x27;</span>, staff=[<span class="string">&#x27;Scott&#x27;</span>, <span class="string">&#x27;Austin&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">dc[:<span class="number">1</span>].staff  <span class="comment"># [&#x27;Scott&#x27;]</span></span><br><span class="line"><span class="string">&#x27;Scott&#x27;</span> <span class="keyword">in</span> dc <span class="comment"># True</span></span><br><span class="line"><span class="built_in">len</span>(dc)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> dc:</span><br><span class="line">    <span class="built_in">print</span>(user)</span><br><span class="line"></span><br><span class="line"><span class="built_in">reversed</span>(dc)</span><br></pre></td></tr></table></figure><h2 id="拓展维护已排序序列">拓展：维护已排序序列</h2><p><code>bisect</code> 是用来处理已排序的升序序列的包，使用的是二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="comment"># insort 插入</span></span><br><span class="line">int_list = []</span><br><span class="line">bisect.insort(int_list, <span class="number">3</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">2</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">1</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">5</span>)</span><br><span class="line">bisect.insort(int_list, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(int_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找插入的位置会是什么下标</span></span><br><span class="line"><span class="built_in">print</span>(bisect.bisect(int_list, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bisect.bisect_left(int_list, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(bisect.bisect_right(int_list, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 5, 9]</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>Python 中还有其他的数据结构，比如 array, deque.</p><p>list 相当于容器，可以存放任意类型，而array 只能存放指定数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># array 非常快，list 很灵活</span></span><br><span class="line">my_array = array.array(<span class="string">&quot;i&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了魔法方法，并带你使用魔法方法实现自定义的序列。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="魔法函数" scheme="https://scottzhang.pro/tags/%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/"/>
    
    <category term="magic method" scheme="https://scottzhang.pro/tags/magic-method/"/>
    
    <category term="dunder method" scheme="https://scottzhang.pro/tags/dunder-method/"/>
    
  </entry>
  
  <entry>
    <title>Python 深入理解类与对象</title>
    <link href="https://scottzhang.pro/article/4bcdc7f7.html"/>
    <id>https://scottzhang.pro/article/4bcdc7f7.html</id>
    <published>2022-01-16T13:54:41.000Z</published>
    <updated>2022-02-15T09:50:15.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>深入理解 Python 中的类与对象。</p></blockquote><span id="more"></span><h1 id="类和对象">类和对象</h1><p>对象是一个有着相应行为的数据的集合，比如苹果和橘子可以说都是对象。</p><p>假设我们在编写一个农场游戏，苹果会放到篮子里，橘子会放到桶中，那么现在就有四个对象。</p><p>对象和类有什么不同呢？类描述了对象，它们就像是创建对象的模板。</p><h1 id="静态方法与类方法">静态方法与类方法</h1><p>理解方法是怎么工作的，Python 中的静态方法、类方法以及抽象方法，可以参考之前设计模式系列文章-<a href="https://scottzhang.pro/article/18dbdeeb.html">单例模式及其实现原理</a>。</p><h1 id="type-object-和-class-的关系">type, object 和 class 的关系</h1><p>type 有两种用法：一个是生成一个类；另外一个是查看某个对象的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="number">1</span>)   <span class="comment"># class int</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">int</span>) <span class="comment"># class type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -&gt; int -&gt;1</span></span><br><span class="line"><span class="comment"># type -&gt; class -&gt; obj</span></span><br></pre></td></tr></table></figure><p>object 是所有类的基类，object 的基类是空， object 是 type 生成的。</p><p>但 type 本身也是一个类，同时 type 也是一个对象，type 的基类又是 object。</p><p>为了理解其中的关系，可以参考下图：</p><figure><img src="https://s2.loli.net/2022/01/09/NrGE3UmuzJpbdIk.png" alt="object, type and class" /><figcaption aria-hidden="true">object, type and class</figcaption></figure><ul><li>虚线描述的是实例关系，实线描述的是继承关系</li><li>type 创建了所有的对象；type 继承自 object，而 object 又是 type 的一个实例；type 还是自己的实例（连自己都不放过）；</li></ul><p>举例：list 继承自 object，"abc" 继承自 str, str 又继承自 object；list类继承自 object 类，同时 list 也是 type 的一个实例对象，所以其实 list 既是类也是实例，即 python 中一切皆对象的一个理解。</p><p>为什么 list 是一个 class的同时，也要是一个对象，因为如果它变成一个对象，就可以动态的修改。而在静态语言中，类一旦创建放到内存中，修改起来就很麻烦了。而 python 中将其变成对象，就很简单了。</p><h1 id="鸭子类型和多态">鸭子类型和多态</h1><p>当你看见一只鸟走起来像鸭子、游泳像鸭子、叫起来也像鸭子，那么这只鸟就是鸭子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am a dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am a Duck&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> [Dog, Duck]:</span><br><span class="line">    obj().say()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="抽象基类">抽象基类</h1><p>抽象基类，其他类可以继承此类，并必须要实现其规定的方法，抽象基类本身无法实例化出任何对象。</p><p>在 Python 中，检查某个类是否有某个方法，可以通过 hasattr 方法检查，比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, employee_list</span>):</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.employee)</span><br><span class="line"></span><br><span class="line">com = Company([<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 hasattr 检查类是否有某个方法</span></span><br><span class="line"><span class="built_in">hasattr</span>(com, <span class="string">&quot;__len__&quot;</span>)</span><br></pre></td></tr></table></figure><p>其结果与下面代码一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sized</span><br><span class="line"><span class="comment"># 问题：com 没有继承自 Sized，为何可以使用 isinstance 判断？</span></span><br><span class="line"><span class="comment"># Sized 内部有一个 __subclasshot 方法，其中会直接判断 com 有没有 len 方法</span></span><br><span class="line"><span class="built_in">isinstance</span>(com, Sized)</span><br></pre></td></tr></table></figure><p>其中 Sized 是一个抽象基类。背后的逻辑是，com 实现了 <code>__len__</code> 方法，所以它继承了 Sized 抽象基类，所以判断为真。</p><p>另外一种抽象基类的应用是限制子类必须实现某些方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抽象基类：限制子类必须实现某个方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheBase</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个 RedisCache 类，继承自 CacheBase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>(<span class="params">CacheBase</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 RedisCache</span></span><br><span class="line"><span class="comment"># 下面这步不会报错</span></span><br><span class="line">redis_cache = RedisCache()</span><br><span class="line"><span class="comment"># 调用 get 或者 set 的时候才会报错</span></span><br><span class="line">redis_cache.get(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你希望在 RedisCache 初始化的时候就报错，则需要使用 abc 抽象基类模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheBaseABC</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处会报错</span></span><br><span class="line">redis_cache_abc = CacheBaseABC()</span><br></pre></td></tr></table></figure><blockquote><p>Python 中，abc 模块，有系统全局的abc，也有 collections.abc</p></blockquote><p>在平时的编码实践中，注意不要过度依赖 abc 模块，容易导致过度设计, 可以考虑使用 mixin 的方式。</p><h1 id="isinstance-和-type">isinstance 和 type</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印两个都是 true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, B))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, A))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b) <span class="keyword">is</span> B)</span><br><span class="line"><span class="comment"># 也是 True</span></span><br><span class="line"><span class="comment"># 注意 is 和 == 的区别</span></span><br><span class="line"><span class="comment"># is 的意思是，判断两个对象是不是同一个对象，即 id() 返回的值是不是一样</span></span><br><span class="line"><span class="comment"># == 的意思是，判断值是否相等</span></span><br></pre></td></tr></table></figure><h1 id="类变量与实例变量">类变量与实例变量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例会向上查找找不到的值，比如这里的z</span></span><br><span class="line"><span class="built_in">print</span>(a.z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类自然也可以找到属于自己的值</span></span><br><span class="line"><span class="built_in">print</span>(A.z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类无法找到属于实例的值, 此处报错</span></span><br><span class="line"><span class="built_in">print</span>(a.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改实例的值，并不会修改类中的值</span></span><br><span class="line">a.z = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(a.z)  <span class="comment"># 99</span></span><br><span class="line"><span class="built_in">print</span>(A.z)     <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例创建之前，修改类内部的值，实例的值也会变化</span></span><br><span class="line">A.z = <span class="number">100</span></span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a.z  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure><h1 id="属性和查找顺序">属性和查找顺序</h1><p>属性分为类属性、实例属性。在上面的例子中，我们看到实例不存在的属性，在类中若可以找到则会被返回，这个查找顺序是怎样的呢？</p><p>简单的情况下，很容易理解，如果没有实例的 name 会使用类的 name，即 A。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">&quot;A&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;obj&quot;</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.name <span class="comment"># obj</span></span><br></pre></td></tr></table></figure><p>但如果是多继承是什么样的呢？比如下面的例子，A 是B, C, D, E的父类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D     E</span><br><span class="line">|     |</span><br><span class="line">B     C</span><br><span class="line"> \   /</span><br><span class="line">   A</span><br><span class="line"></span><br><span class="line"># DFS 的搜索顺序</span><br><span class="line">Deep First Search(DFS): A -&gt; B -&gt; D -&gt; C -&gt; E</span><br><span class="line"></span><br><span class="line">   D</span><br><span class="line"> /   \</span><br><span class="line">B     C</span><br><span class="line"> \   /</span><br><span class="line">   A</span><br><span class="line"></span><br><span class="line"># DFS 存在的问题</span><br><span class="line">这里的搜索顺序是A -&gt; B -&gt; D -&gt; C</span><br><span class="line">C 中有一个函数是重载 D 的，会导致无法重载</span><br><span class="line"></span><br><span class="line"># 引入广度优先算法</span><br><span class="line">对于图2，BFS: A -&gt; B -&gt; C -&gt; D</span><br><span class="line">对于图2，又有了新问题，假设 B，C，D 都有一个 get 方法</span><br><span class="line">那么如果 B 找不到，广度优先会去 C 中找，C 的 get 就会覆盖 D 的</span><br><span class="line">按理说应该 B 和 D 是一块</span><br><span class="line"></span><br><span class="line"># 引入 C3 算法</span><br><span class="line"># todo</span><br><span class="line"></span><br><span class="line">在 python 中，可以通过 class.__mro__ 查看查找顺序</span><br></pre></td></tr></table></figure><h1 id="多继承">多继承</h1><p>Python 也支持多线程，不过更推荐使用 Mixin 的模式。</p><p>本质上说就是让你的类继承自各种单一功能的类。可以简单理解为 java 中的函数，设计模式中的组合模式。</p><p>在设计 mixin 类的时候，尽量让它功能单一；不要让它和基类关联，这样就可以和任意基类组合；其次在 mixin 中，不要使用 super 这种用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># minxin.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListDirMixin</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListFileMixin</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> minxin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params">mixin.ListDirMixin, mixin.ListFileMixin</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="上下文管理器">上下文管理器</h1><p>首先通过两段代码来看 try except 在 Python 中的工作机制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个捕捉异常的例子</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> KeyError</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;KeyError&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try 还可以有其他的逻辑分支：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 raise 的 Error 和 except 的不一样则无法捕捉</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> IndexError</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;KeyError&quot;</span>)</span><br><span class="line"><span class="comment"># else，try 内没有 raise error，才会执行</span></span><br><span class="line"><span class="comment"># 这里永远不会运行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Other Error&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># finally 永远都会运行</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Always run&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果你用 python 打开一个文件，最后不管如何都需要关闭这个文件，你可能会在 try 中打开并读取文件， 然后在 finally 中关闭该文件。</p><p>这里有个问题是，如果你在 try 中打开文件之前报错了，那么在 finally 中则会无法关闭该文件，因为文件对象 还没来得及创建。</p><p>再来一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_test</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么返回 4 ？</span></span><br><span class="line"><span class="comment"># 如果有 finally 语句，就会返回 finally 中的值，即 4</span></span><br><span class="line"><span class="comment"># 如果没有，则返回之前 return 返回的值，即 2</span></span><br><span class="line">try_test()</span><br></pre></td></tr></table></figure><p>with 语句的出现，可以简化我们的 try, finally 的使用。而 with 语句本身属于上下文管理器的一种实现，本质上来说，它遵从了一种类协议（实现了 2 个魔法函数).</p><p>这里涉及了两个魔法函数, <code>__enter__</code>, <code>__exit__</code>。（魔法函数将会在接下来的文章更新）</p><p>如果你实现了某个类的这两个函数，即实现了上下文管理器协议，你就可以使用 with 语句调用你的类，比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>:</span></span><br><span class="line">    <span class="comment"># 进入 with 的时候，先调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 跳出 with 语句后会自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;doing something&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Sample() <span class="keyword">as</span> sample:</span><br><span class="line">    sample.do_something()</span><br></pre></td></tr></table></figure><p>你还可以通过 contextlib 进一步简化上下文管理器，这是 python 提供的内置模块, 它可以将一个 函数变成上下文管理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_open</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;open a file&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> &#123;&#125;  <span class="comment"># 必须使用生成器</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exit logic&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> file_open(<span class="string">&quot;file.txt&quot;</span>) <span class="keyword">as</span> f_opend:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;processing...&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;深入理解 Python 中的类与对象。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>理解 Python 一切皆对象</title>
    <link href="https://scottzhang.pro/article/7cdaf89.html"/>
    <id>https://scottzhang.pro/article/7cdaf89.html</id>
    <published>2022-01-16T13:14:17.000Z</published>
    <updated>2022-02-15T09:50:15.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是对象？Python 中的对象又与其他编程语言中的对象有何不同？</p></blockquote><span id="more"></span><h1 id="什么是对象">什么是对象？</h1><p>一般来说，对象指的是拥有数据（或属性）和操作数据的方法的一个实体。</p><p>不同的编程语言对它的定义不一样，有的编程语言规定对象必须有属性和方法，有的编程语言则规定对象必须是subclassable 的（暂时没想到中文），Python 的定义则比较宽松，因为 Python 中不要求对象一定要有数据或方法，也不要求对象是 subclassable 的。</p><h1 id="一切皆对象">一切皆对象</h1><p>在其他的静态语言中，有对象和类，对象是类的一个实例，但是在 Python 中，这两者都是对象。</p><p>“Python 中一切皆对象”这句话，它的意思暗示了在 Python 中，所有元素都是对象，string, list, 函数、类甚至是模块都是对象，属于 Python 的一等公民，这意味着它可以：</p><ul><li>被赋值给一个变量</li><li>可以添加到集合对象中</li><li>可以作为参数传递给函数</li><li>可以当作函数的返回值</li></ul><p>这就提供了一种动态性，你可以在运行的时候修改它。</p><blockquote><p>对象的三个特征：身份(内存中的地址)、类型（1 是 int 类型）、值（a=1 中的1）。</p></blockquote><h1 id="以-list-为例">以 list 为例</h1><p>对象有数据和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 是一个对象</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type 可以告诉我们变量属于什么对象</span></span><br><span class="line"><span class="comment"># output: int</span></span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 x 对象的一个属性</span></span><br><span class="line"><span class="comment"># 对于 Int 类型，它有 Real and imaginary part of the value</span></span><br><span class="line"><span class="comment"># if viewed as a complex number</span></span><br><span class="line"><span class="built_in">print</span>(x.real)</span><br><span class="line"><span class="built_in">print</span>(x.imag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 x 对象的一个方法</span></span><br><span class="line"><span class="built_in">print</span>(x.is_integer())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说一切皆对象，真的就是所有都是对象</span></span><br><span class="line"><span class="comment"># 比如 x.is_interger 这个方法本身，也是对象</span></span><br><span class="line"><span class="comment"># output: builtin_function_or_method</span></span><br><span class="line"><span class="built_in">type</span>(x.is_interger)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="以函数为例">以函数为例</h1><p>如果你定义了一个函数，你也可以将它赋值给一个新的变量，新的变量将拥有对这个函数的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数赋值给新的变量</span></span><br><span class="line">my_add = add</span><br><span class="line">my_add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数作为参数返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_number_creator</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_number</span>(<span class="params">a</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a+ number</span><br><span class="line">    <span class="keyword">return</span> add_number</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://www.codingninjas.com/blog/2020/08/27/how-everything-in-python-is-an-object/">How everything in Python is an Object?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是对象？Python 中的对象又与其他编程语言中的对象有何不同？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python Socket 入门</title>
    <link href="https://scottzhang.pro/article/4317dd1.html"/>
    <id>https://scottzhang.pro/article/4317dd1.html</id>
    <published>2022-01-15T13:43:59.000Z</published>
    <updated>2022-02-15T09:50:15.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章带你了解如何建立 Python Socket 服务端与客户端，编写一个简单的多用户聊天程序，以及如何使用 Socket 模拟 http 请求。</p></blockquote><span id="more"></span><h1 id="理论介绍">理论介绍</h1><p>计算机网络基础知识，推荐一本书《TCP/IP 详解》。</p><p>HTTP，Socket，TCP 的区别，HTTP 是应用层的协议。Socket可理解为操作系统提供的应用层与传输层打交道的插座。而 TCP 属于传输层。 通过 Socket 编程，我们可以自己与传输层打交道，定义自己的协议进行通信。</p><p>Client 端涉及的操作：</p><figure><img src="https://s2.loli.net/2022/01/15/sXuIOz8T12n5DfB.png" alt="Socket编程" /><figcaption aria-hidden="true">Socket编程</figcaption></figure><p>服务端：</p><ul><li>socket：socket 是应用层和传输层之间的接口，传输层有 tcp 和 udp；</li><li>bind(协议，地址，端口)：地址可在本机 IP，也可以指定；每一个应用程序只能占用一个端口，网络 来的数据，操作系统会转发给相应的端口。</li><li>listen(监听客户端 socket 请求)</li><li>accept()</li><li>阻塞等待连续请求（新套接字）</li><li>recv()</li><li>send(), socket 建立了连接后，可以一直发送数据；http 则不行。</li><li>close()</li></ul><p>客户端：</p><ul><li>socket</li><li>connect()</li><li>send()</li><li>recv()</li><li>close()</li></ul><h1 id="socket-实现聊天">Socket 实现聊天</h1><p>来看一个 socket 实现聊天的例子，第一个是服务端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Socket Server</span></span><br><span class="line"><span class="comment"># 先启动 Server，否则 Client 会无法连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”.  &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    response_str = <span class="string">&quot;From Server, Admin:&quot;</span> + response_str</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen()</span><br><span class="line">sock_client, addr = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 这里才是用户拿到的 sock，上面的 server 则是用来监听的</span></span><br><span class="line">    data = sock_client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    respond(sock_client)</span><br></pre></td></tr></table></figure><p>然后是客户端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># Client, 第一次会尝试连接 Server Say Hi</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">client.send(<span class="string">f&quot;From Client, Scott: Hi!&quot;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 客户端，先发信息</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    client_id = <span class="string">&quot;From Client, Scott:&quot;</span></span><br><span class="line">    client_new_msg = client_id + <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    client.send(client_new_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>当客户端起来之后，服务端会收到一条消息，来看看他们的对话吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 服务端</span><br><span class="line">From Client, Scott: Hi!</span><br><span class="line">New msg:Hi Scott!</span><br><span class="line">From Client, Scott:Are you admin from the server?</span><br><span class="line">New msg:Yes, i am.</span><br><span class="line">From Client, Scott:Nice to meet you!!!</span><br><span class="line">New msg:Me too. How can i help you?</span><br><span class="line">From Client, Scott:Just test the connection, bye~</span><br><span class="line">New msg:Ok, Have a great day!</span><br><span class="line">From Client, Scott:You too!</span><br><span class="line"></span><br><span class="line"># 客户端</span><br><span class="line">From Server, Admin:Hi Scott!</span><br><span class="line">New msg:Are you admin from the server?</span><br><span class="line">From Server, Admin:Yes, i am.</span><br><span class="line">New msg:Nice to meet you!!!</span><br><span class="line">From Server, Admin:Me too. How can i help you?</span><br><span class="line">New msg:Just test the connection, bye~</span><br><span class="line">From Server, Admin:Ok, Have a great day!</span><br><span class="line">New msg:You too!</span><br></pre></td></tr></table></figure><h1 id="socket-实现多用户聊天">Socket 实现多用户聊天</h1><p>上面的 server 只支持一个用户，如何支持多个用户呢？可以使用线程来实现，背后的思想是，每当遇到一个新的连接 请求，就让一个线程去处理, 也就是这一段 <code>sock_client, addr = server.accept()</code> 交给一个新的线程去处理。</p><p>这是一个多线程的 server，客户端的代码是一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Socket Server</span></span><br><span class="line"><span class="comment"># 先启动 Server，否则 Client 会无法连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”.  &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    response_str = <span class="string">&quot;From Server, Admin:&quot;</span> + response_str</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_sock</span>(<span class="params">sock_client, addr</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 这里才是用户拿到的 sock，上面的 server 则是用来监听的</span></span><br><span class="line">        data = sock_client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        respond(sock_client)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">    server.listen()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sock_client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 用线程处理新来的用户</span></span><br><span class="line">        client_thread = threading.Thread(</span><br><span class="line">            target=handle_sock,</span><br><span class="line">            args=(sock_client, addr)</span><br><span class="line">        )</span><br><span class="line">        client_thread.start()</span><br></pre></td></tr></table></figure><p>来看服务端与不同客户端的通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">From Client 1, Scott: Hi!</span><br><span class="line">New msg:Hi Scott!</span><br><span class="line">From Client 2, The Weeknd: Hi!</span><br><span class="line">New msg:Hi The Weeknd!</span><br><span class="line">From Client 1, Scott:I really like the weeknd!</span><br><span class="line">New msg:Me too!</span><br><span class="line">From Client 2, The Weeknd:I just adds three tracks to my new album: Dawn FM.</span><br><span class="line">New msg:Great!</span><br></pre></td></tr></table></figure><h1 id="socket-模拟-http-请求">Socket 模拟 http 请求</h1><p>你应该听说过 Python 中 request 这个包，它其实底层是依赖 urllib 实现的，而 urllib 又是依赖于 socket。</p><p>既然是模拟 http 请求，还是需要做 url 解析，我们将会用到 urllib 中的部分函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 解析 url</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc   <span class="comment"># host</span></span><br><span class="line">    path = url.path     <span class="comment"># 子路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:      <span class="comment"># 子路径为空</span></span><br><span class="line">        path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立 socket 连接, 一般网站都使用 8000 端口</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造请求内容，并开始发送请求</span></span><br><span class="line">    <span class="comment"># 关于请求的内容，可以通过 Chrome 的调试工具打开目标网站</span></span><br><span class="line">    <span class="comment"># 再查看 Headers，具体某个网站必须构造哪些请求内容，各有不同</span></span><br><span class="line">    <span class="comment"># 比如百度必须有: host, connection,</span></span><br><span class="line">    client.send(</span><br><span class="line">        <span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            path, host</span><br><span class="line">    ).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回的数据不一定是 1024， 有可能是 &gt; 1024 的</span></span><br><span class="line">    <span class="comment"># client.recv(1024), 这样写会出问题，特殊处理一下</span></span><br><span class="line">    data = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 先接受 1024 个数据</span></span><br><span class="line">        d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    data = data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章带你了解如何建立 Python Socket 服务端与客户端，编写一个简单的多用户聊天程序，以及如何使用 Socket 模拟 http 请求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 浅拷贝与深拷贝</title>
    <link href="https://scottzhang.pro/article/c5dc05db.html"/>
    <id>https://scottzhang.pro/article/c5dc05db.html</id>
    <published>2022-01-15T13:38:58.000Z</published>
    <updated>2022-02-15T09:50:15.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章以 list，dict，class 为例，带你了解 Python 中的浅拷贝与深拷贝。</p></blockquote><span id="more"></span><h1 id="变量与指针">变量与指针</h1><p>在理解下面的例子之前，我们需要对 Python 中的变量有一个基本的理解。</p><p>对变量赋值，在其他语言中，我们可能理解为开辟一个区域（理解为容器、或者是一个篮子），再将值放进去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言：在内存中开辟一个区域，将值放进去</span></span><br><span class="line"><span class="keyword">int</span> x <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>在 Python 中，写法是一样的，但是最好的理解是将一个指针指向了这个区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python：定义了一个指针 x，指向了内存中</span></span><br><span class="line"><span class="comment"># 这个包含 4 的容器的地方</span></span><br><span class="line">x = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>因为 Python 变量相当于一个指针，指向这个内存区域，所以无需提前声明好变量是什么类型，指针中间也可以指向别的值，这也是人们说的 Python 的动态类型。</p><p>所以你可以这么做:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>         <span class="comment"># x is an integer</span></span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>   <span class="comment"># now x is a string</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># now x is a list</span></span><br></pre></td></tr></table></figure><p>但是动态类型也有缺点，那就是如果两个变量名指向同一个数据，那么一个变量所做的修改，另一个变量所指向的值也会发生变化。</p><p>下面来看具体的例子：</p><h1 id="以-list-为例">以 list 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------- 浅拷贝 ------------------ #</span></span><br><span class="line"><span class="comment"># 构造一个列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- New List XS, YS&quot;</span>)</span><br><span class="line">xs = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">ys = <span class="built_in">list</span>(xs)  <span class="comment"># Make a shallow copy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 添加元素: 不会影响 ys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Append Element To XS&quot;</span>)</span><br><span class="line">xs.append([<span class="string">&#x27;I am new&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 修改元素：两者都会影响</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To XS&quot;</span>)</span><br><span class="line">xs[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 yx 修改元素：两者会影响</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To YS&quot;</span>)</span><br><span class="line">ys[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;y&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- Deep Copy --------------- #</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">zs = copy.deepcopy(xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Deep Copy ZS from XS&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span>, xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 zs 修改元素，不会影响 xz</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To ZS&quot;</span>)</span><br><span class="line">zs[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 修改元素，也不会影响 xs</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To XS&quot;</span>)</span><br><span class="line">xs[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span>, xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------- New List XS, YS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">--------- Append Element To XS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">--------- Modified To XS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9]]</span><br><span class="line">--------- Modified To YS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">--------- Deep Copy ZS from XS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">--------- Modified To ZS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [&#x27;z&#x27;, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">--------- Modified To XS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, &#x27;z&#x27;, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [&#x27;z&#x27;, 8, 9], [&#x27;I am new&#x27;]]</span><br></pre></td></tr></table></figure><h1 id="以-dict-为例">以 dict 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个 dict，用来演示深拷贝与浅拷贝</span></span><br><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&#x27;name1&#x27;</span>: &#123;<span class="string">&quot;scott zhang&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;name2&#x27;</span>: &#123;<span class="string">&quot;the weeknd&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A new dict:&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 d 中 name1 的 id</span></span><br><span class="line">d_id = <span class="built_in">id</span>(d[<span class="string">&#x27;name1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(d_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝，更详细的说是</span></span><br><span class="line"><span class="comment"># 将 d[&#x27;name1&#x27;] 所在内存区域的地址绑定给 d_copy1</span></span><br><span class="line"><span class="comment"># 摘自 realpython：</span></span><br><span class="line"><span class="comment"># (Assignment statements in Python do not create copies of objects</span></span><br><span class="line"><span class="comment"># they only bind names to an object.)</span></span><br><span class="line"><span class="comment"># 浅拷贝内部值只是指针, 所以对 d_copy1 内部 name1 字典内的修改，会将 d 中的值也修改</span></span><br><span class="line">d_copy1 = d.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示</span></span><br><span class="line"><span class="comment"># 对 copy 过来的 dict 修改，再打印原来的数据</span></span><br><span class="line">d_copy1[<span class="string">&#x27;name1&#x27;</span>][<span class="string">&#x27;scott zhang&#x27;</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么？</span></span><br><span class="line"><span class="comment"># 因为其实内部指向的是同一个 dict</span></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">id</span>(d_copy1[<span class="string">&#x27;name1&#x27;</span>]) == <span class="built_in">id</span>(d[<span class="string">&#x27;name1&#x27;</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要指向同一个 dict?</span></span><br><span class="line"><span class="comment"># 因为浅拷贝指向的是指针，深拷贝会将数据重新赋值，非常耗费系统资源。</span></span><br></pre></td></tr></table></figure><p>上面代码的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A new dict: &#123;&#x27;name1&#x27;: &#123;&#x27;scott zhang&#x27;: 1&#125;, &#x27;name2&#x27;: &#123;&#x27;the weeknd&#x27;: 2&#125;&#125;</span><br><span class="line">1901449775104</span><br><span class="line">&#123;&#x27;name1&#x27;: &#123;&#x27;scott zhang&#x27;: 0&#125;, &#x27;name2&#x27;: &#123;&#x27;the weeknd&#x27;: 2&#125;&#125;</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h1 id="以-class-为例">以 class 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Point(<span class="subst">&#123;self.x!r&#125;</span>, <span class="subst">&#123;self.y!r&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># A Rectagle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, topleft, bottomright</span>):</span></span><br><span class="line">        self.topleft = topleft</span><br><span class="line">        self.bottomright = bottomright</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&#x27;Rectangle(<span class="subst">&#123;self.topleft!r&#125;</span>, &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;<span class="subst">&#123;self.bottomright!r&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Make a point and it copy obj</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Point&quot;</span>)</span><br><span class="line">    point = Point(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    point_copy = copy.copy(point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point:&quot;</span>, point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point copy:&quot;</span>, point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># point is point_copy?</span></span><br><span class="line">    <span class="comment"># no, because class Point using int in x and y</span></span><br><span class="line">    <span class="comment"># int is immutable type in python</span></span><br><span class="line">    <span class="comment"># so there is no difference between deep/shallow copy for Point class</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point is point copy？&quot;</span>, point <span class="keyword">is</span> point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># modified point</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified Point&quot;</span>)</span><br><span class="line">    point.x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point:&quot;</span>, point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point copy:&quot;</span>, point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是 Rectangle 内部的 Pointer 呢?</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Rectangle&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># new rectangle and a copy from it</span></span><br><span class="line">    rect = Rectangle(topleft=Point(<span class="number">0</span>, <span class="number">1</span>), bottomright=Point(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    rect_copy = copy.copy(rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect:&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy:&quot;</span>, rect_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># rect is rect_copy?</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect_copy is rect?&quot;</span>, rect_copy <span class="keyword">is</span> rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified rect&quot;</span>)</span><br><span class="line">    rect.topleft.x = <span class="number">999</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect:&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy:&quot;</span>, rect_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># using deep copy</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- New Deep Copy Rect&quot;</span>)</span><br><span class="line">    rect_copy_deep = copy.deepcopy(rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy deep:&quot;</span>, rect_copy_deep)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># modified a deep copy obj</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified Deep Copy Rect&quot;</span>)</span><br><span class="line">    rect.bottomright.x = <span class="number">666</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy deep:&quot;</span>, rect_copy_deep)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---- Point</span><br><span class="line">point: Point(0, 0)</span><br><span class="line">point copy: Point(0, 0)</span><br><span class="line">point is point copy？ False</span><br><span class="line">---- Modified Point</span><br><span class="line">point: Point(1, 0)</span><br><span class="line">point copy: Point(0, 0)</span><br><span class="line"></span><br><span class="line">---- Rectangle</span><br><span class="line">rect: Rectangle(Point(0, 1), Point(1, 0))</span><br><span class="line">rect copy: Rectangle(Point(0, 1), Point(1, 0))</span><br><span class="line">rect_copy is rect? False</span><br><span class="line">---- Modified rect</span><br><span class="line">rect: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">rect copy: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">---- New Deep Copy Rect</span><br><span class="line">rect Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">rect copy deep: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">---- Modified Deep Copy Rect</span><br><span class="line">rect Rectangle(Point(999, 1), Point(666, 0))</span><br><span class="line">rect copy deep: Rectangle(Point(999, 1), Point(1, 0))</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><ul><li>浅拷贝（shallow copy）并不会克隆对象中的子对象，因此原对象和对象中，被拷贝的内部对象不是独立两份，而是同一份。</li><li>深拷贝（Deep copy）会递归的拷贝所有子对象，这保证了内部对象的独立性，但是这样速度很慢。</li><li>你可以使用 copy 模块拷贝任意对象（包括你自定义的类），你还可以通过实现 <code>__copy()__</code> 或 <code>__deepcopy()__</code> 来自定义拷贝的过程。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章以 list，dict，class 为例，带你了解 Python 中的浅拷贝与深拷贝。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P3</title>
    <link href="https://scottzhang.pro/article/4074d0e9.html"/>
    <id>https://scottzhang.pro/article/4074d0e9.html</id>
    <published>2021-12-20T09:13:01.000Z</published>
    <updated>2021-12-20T09:19:39.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.</p></blockquote><span id="more"></span><h1 id="方法">方法</h1><p>Go 没有类。不过你可以为结构体类型定义方法，Go 中方法是带特殊的 {接收者} 参数的函数（方法其实就是函数，只是带了个接收者）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------后续代码将省略上面的部分------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 位于 func 关键字和方法名之间</span></span><br><span class="line"><span class="comment">// 在下面的例子中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：方法相当于函数，所以下面的写法功能是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是在使用的时候，不再是 v.Abs(), 而是 Abs(v)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非结构体也是可以声明方法的，比如对于 float：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 为 (f MyFloat)，方法名为 Abs, 返回 float64</span></span><br><span class="line"><span class="comment">// 没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">f := MyFloat(<span class="number">-1</span>)</span><br><span class="line">f.Abs()</span><br></pre></td></tr></table></figure><p>但是，你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。</p><p>上面的接收者为值接收者，实际上接收者还有一种叫做指针接收者，因为使用指针接收者，你可以在方法内部修改值，所以指针接收者比值接收者更常用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值接收者 (v Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取值、计算</span></span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者 (v *Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析输出</span></span><br><span class="line"><span class="comment">// 如果是指针接收者:</span></span><br><span class="line"><span class="comment">// Scale: 3*10 = 30; 4*10 = 40</span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果将指针接收者改为值接收者</span></span><br><span class="line"><span class="comment">// 即 (v *Vertex) -&gt; (v Vertex)</span></span><br><span class="line"><span class="comment">// Scale: 3 ; 4 </span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法和指针重定向; 在函数中，如果要求的参数是指针，传值会报错；如果使用指针接收者，则既可以传值，也可以传指针；反之如果要求的参数是值，在函数中传指针也会出错，指针接收者则也可以避免这种情况。</p><p>使用指针接收者的好处是：</p><ol type="1"><li>指针能够修改传进来的值</li><li>因为传的是指针，避免了值的复制，更高效</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 因为参数指定为指针，直接传值会出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="comment">// 下面这两种方式都可以工作</span></span><br><span class="line"><span class="comment">// v.Scale(10), (&amp;v).scale(10)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口">接口</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个几何形状的接口，拥有面积和</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形和圆的结构体</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 rect 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 circle 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// measure 函数，基于 geometory 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">    c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    measure(r)</span><br><span class="line">    measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接口的另一个例子, 首先是完整的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们逐一来看，方便研究，首先是直接将变量赋值给接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">a = f</span><br><span class="line"></span><br><span class="line">fmt.Println(f.Abs()) <span class="comment">// 为 MyFload 实现了 Abs 方法, 即</span></span><br><span class="line">fmt.Println(a.Abs()) <span class="comment">// MyFloat 实现了 Abser</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是将结构体赋值给接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line"></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它们不同的地方在于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件</span></span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义不同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;  <span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同</span></span><br><span class="line">a = f  <span class="comment">// a.Abs(), work; a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a.Abs(), work; a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">a = v </span><br><span class="line"><span class="comment">// a.Abs(), Error; Vertex does not implement Abser; 如果将</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() float64 改为</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() 则可以正常运行</span></span><br></pre></td></tr></table></figure><p>接口的隐式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事</span></span><br><span class="line"><span class="comment">// 直接将 func 的名字设置成 接口中的名字即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也是值，所以可以像值一样传递。可以用作参数和函数的返回值。</p><p>接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组 <code>(value, type)</code>, 接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 接口 I，其中规定了需要实现 M() 方法</span></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体 T，其中有 string 类型的 S</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为结构体 T 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (t *T) 为指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 float64 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (f F) 为值接收者</span></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印函数，参数为接口 I</span></span><br><span class="line"><span class="comment">// %v：值的 value</span></span><br><span class="line"><span class="comment">// %T: 值的 type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复习</span></span><br><span class="line"><span class="comment">// &amp; 符号的意思是对变量取地址，如：变量a的地址是&amp;a</span></span><br><span class="line"><span class="comment">// * 符号的意思是对指针取值，如:*&amp;a，就是a变量所在地址的值，当然也就是a的值了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I        <span class="comment">// 声明接口 i</span></span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125; <span class="comment">// 定了结构体 -&gt; 取该结构体的地址 -&gt; 给 i</span></span><br><span class="line">describe(i)     <span class="comment">// 打印结构体地址的值，以及 type</span></span><br><span class="line">i.M()           <span class="comment">// 结构体增加了 M() 方法，运行成功</span></span><br><span class="line"></span><br><span class="line">i = F(math.Pi)  <span class="comment">// F 是自定义的 float64，初始化值为 math.pi -&gt; 给 i</span></span><br><span class="line">describe(i)        <span class="comment">// 打印 i 的值和地址</span></span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层值为 nil 的接口值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I     <span class="comment">// 声明接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T    <span class="comment">// 初始化一个结构体指针 t，零值为 nil</span></span><br><span class="line">i = t       <span class="comment">// 隐式实现了接口，使得 i 有了 M() 方法</span></span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, *main.T)</span></span><br><span class="line"><span class="comment">&lt;nil&gt;</span></span><br><span class="line"><span class="comment">(&amp;&#123;hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>空接口, 它没有规定接口的方法，空接口可保存任何类型的值； 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 指定了零个方法的接口值</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于类型断言，它提供了访问接口值底层值的具体方式，并可以进行检测断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型选择，可以按顺序从接口值中选择值的类型，文法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个类型选择的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 类型选择中的 case 为类型（而非值</span></span><br><span class="line"><span class="comment">// 类型选择中的声明与类型断言 i.(T) 的语法相同</span></span><br><span class="line"><span class="comment">// 只是具体类型 T 被替换成了关键字 type</span></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Twice 21 is 42</span></span><br><span class="line"><span class="comment">&quot;hello&quot; is 5 bytes long</span></span><br><span class="line"><span class="comment">I don&#x27;t know about type bool!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面介绍一个普遍使用的接口，即 fmt 包中的 Stringer。一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">fmt.Println(a.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关于 Go 中的错误处理:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rror 为 nil 时表示成功；非 nil 的 error 表示失败。</span></span><br><span class="line">i, err := strconv.Atoi(<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure><p>关于文件读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line">        <span class="comment">// 在遇到数据流的结尾时，它会返回一个 io.EOF 错误</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于图像处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;image&quot;</span>  <span class="comment">// image 包定义了 Image 接口</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">// Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明</span></span><br><span class="line">fmt.Println(m.Bounds())</span><br><span class="line">fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并发">并发</h1><p>说到并发，首先介绍Go 中的 Go 程（goroutine），它是由 Go 运行时管理的轻量级线程。当你写 <code>go f(x, y, z)</code> 会启动一个新的 Go 程并执行 <code>f(x, y, z)</code>。</p><p>在 Go 程的运行过程中，f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p></blockquote><p>关于信道，在 Go 中，实质上是带有类型的管道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>信道操作符有 <code>-&gt;</code>, <code>&lt;-</code>，箭头的方向预示着数据流的方向。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收值并赋予 v。</span></span><br></pre></td></tr></table></figure><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于带缓冲的信道, 使用 make 创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br><span class="line"><span class="comment">// ch &lt;- 3</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于使用信道来说，还有两个基本的操作，即关闭信道，或者是检查一个信道是否关闭了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个求斐波拉契数列的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)  <span class="comment">// 使用 close 关闭信道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// 循环 for i := range c 会不断从信道接收值，直到它被关闭</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>注意：只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p></li><li><p>信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。</p></li></ul><p>关于 Go 总的 Select 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go&#x27;s _select_ lets you wait on multiple channel</span></span><br><span class="line"><span class="comment">// operations. Combining goroutines and channels with</span></span><br><span class="line"><span class="comment">// select is a powerful feature of Go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For our example we&#x27;ll select across two channels.</span></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each channel will receive a value after some amount</span></span><br><span class="line"><span class="comment">// of time, to simulate e.g. blocking RPC operations</span></span><br><span class="line"><span class="comment">// executing in concurrent goroutines.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// We&#x27;ll use `select` to await both of these values</span></span><br><span class="line"><span class="comment">// simultaneously, printing each one as it arrives.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中信道非常适合在不同的 Go 程中进行通信。但如果我们不需要通信呢？若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这个概念叫互斥，Go 中有一个专门的数据结构来提供这一功能，互斥锁 Mutex，<code>sync.Mutex</code>.</p><p><code>sync.Mutex</code> 中有两个方法，Lock 和 Ulock。</p><p>我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行</p><p>我们也可以用 defer 语句来保证互斥锁一定会被解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
</feed>
