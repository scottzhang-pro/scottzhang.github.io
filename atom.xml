<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2022-06-27T13:19:14.024Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法题:N叉树的最近公共祖先</title>
    <link href="https://scottzhang.pro/article/b217f3dd.html"/>
    <id>https://scottzhang.pro/article/b217f3dd.html</id>
    <published>2022-06-27T13:07:42.000Z</published>
    <updated>2022-06-27T13:19:14.024Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个树（非二叉树）, 找到该树中两个指定节点的最近公共祖先。（树使用key为子级，value为父级的字典结构存储。</p></blockquote><span id="more"></span><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><img src="https://s2.loli.net/2022/06/27/wsz6JFT2ondHSNy.png" /></p><p>tree 定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tree = &#123;<span class="number">1</span>:<span class="literal">None</span>, <span class="number">2</span>:<span class="number">1</span>, <span class="number">3</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">2</span>,<span class="number">5</span>:<span class="number">2</span>,<span class="number">6</span>:<span class="number">2</span>,<span class="number">7</span>:<span class="number">3</span>,<span class="number">8</span>:<span class="number">3</span>,<span class="number">9</span>:<span class="number">4</span>,<span class="number">10</span>:<span class="number">4</span>,<span class="number">11</span>:<span class="number">7</span>&#125;</span><br><span class="line"><span class="comment"># 输入</span></span><br><span class="line">p = <span class="number">5</span></span><br><span class="line">q = <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"><span class="comment"># 解释：节点 5 和节点 1 的最近公共祖先是节点 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line">p = <span class="number">9</span></span><br><span class="line">q = <span class="number">6</span></span><br><span class="line"><span class="comment"># 输出：2</span></span><br><span class="line"><span class="comment"># 解释：9 的祖先是4，不是6的祖先，往上走，2则是</span></span><br></pre></td></tr></table></figure><p>递归解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_common_ancestor</span>(<span class="params">tree, p, q</span>):</span></span><br><span class="line">    <span class="comment"># if it&#x27;s a empty tree, or givin nodes not in dict</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tree <span class="keyword">or</span> p <span class="keyword">not</span> <span class="keyword">in</span> tree <span class="keyword">or</span> q <span class="keyword">not</span> <span class="keyword">in</span> tree: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># root node</span></span><br><span class="line">    root = [k <span class="keyword">for</span> k,v <span class="keyword">in</span> tree.items() <span class="keyword">if</span> v <span class="keyword">is</span> <span class="literal">None</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if any givin nodes is root node</span></span><br><span class="line">    <span class="keyword">if</span> tree.get(p) <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> tree.get(q) <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="comment"># recursive helper function</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive</span>(<span class="params">tree, rp, rq</span>):</span></span><br><span class="line">        <span class="keyword">if</span> rp == tree.get(rq): <span class="keyword">return</span> rp  <span class="comment"># p is children of q</span></span><br><span class="line">        <span class="keyword">if</span> rq == tree.get(rp): <span class="keyword">return</span> rq  <span class="comment"># q is children of p</span></span><br><span class="line">        <span class="keyword">if</span> rq == p: <span class="keyword">return</span> p              <span class="comment"># q move up, equal p then p</span></span><br><span class="line">        <span class="keyword">if</span> rp == q: <span class="keyword">return</span> q              <span class="comment"># p move up, equal q then q</span></span><br><span class="line">        <span class="keyword">if</span> tree.get(rp) == tree.get(rq):  <span class="comment"># p,q moved to root</span></span><br><span class="line">            <span class="keyword">return</span> tree.get(rp)</span><br><span class="line">        <span class="keyword">return</span> recursive(tree, tree.get(rp), tree.get(rq))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(tree, p, q)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;给定一个树（非二叉树）, 找到该树中两个指定节点的最近公共祖先。（树使用key为子级，value为父级的字典结构存储。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="N叉数" scheme="https://scottzhang.pro/tags/N%E5%8F%89%E6%95%B0/"/>
    
    <category term="递归" scheme="https://scottzhang.pro/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>算法题:二叉搜索树的最近公共祖先</title>
    <link href="https://scottzhang.pro/article/5914e90d.html"/>
    <id>https://scottzhang.pro/article/5914e90d.html</id>
    <published>2022-06-18T07:35:47.000Z</published>
    <updated>2022-06-27T13:17:29.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">📌</a> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><span id="more"></span><p>二叉搜索树的定义：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>在此题目中，会提供 p, q 2个节点，我们需要确定这两个节点的公共祖先。</p><p>首先我们知道，根节点肯定是所有节点的祖先，其次根据二叉搜索树的特性，当我们将 p 和 q 分别与根节点做对比的时候，可以排除掉一半的值，因为左边的节点肯定小于右边的节点，当 p 大于根节点，那我们需要找的那个公共祖先肯定在右半部分子树。</p><p>还有一种特殊情况需要考虑，那就是 p 或者 q 于根节点是相等的，这时候公共祖先其实就是根节点了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 如果两个节点都在左边，将当前指针往左边移动</span></span><br><span class="line">            <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 如果两个节点都在右边，将当前指针往右边移动</span></span><br><span class="line">            <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="comment"># 两种情况都不是，则说明两个节点分叉，当前节点即为结果</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/&quot;&gt;📌&lt;/a&gt; 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="二叉树" scheme="https://scottzhang.pro/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://scottzhang.pro/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法题:二叉树的最近公共祖先</title>
    <link href="https://scottzhang.pro/article/465ce338.html"/>
    <id>https://scottzhang.pro/article/465ce338.html</id>
    <published>2022-06-18T07:19:52.000Z</published>
    <updated>2022-06-27T13:18:40.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">📌</a> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><span id="more"></span><p>对于树的遍历：</p><ul><li>使用递归是一种高效、简便的方式，不要怕使用递归。</li><li>对于二叉树的递归又分为三种不同的形式，分别是前序、中序、后序。</li><li>如果面试要求不使用递归，则可以使用循环解法。</li></ul><p>各种顺序的节点遍历顺序：</p><ul><li>前序：根左右</li><li>中序：左根右</li><li>后序：左右根</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: TreeNode, p: TreeNode, q: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 如果 root 为空或者</span></span><br><span class="line">        <span class="comment"># 如果 p 和 q 中某一个等于 root（其本身为最近公共祖先）</span></span><br><span class="line">        <span class="comment"># 直接返回 root 为结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行先序遍历，根左右</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/&quot;&gt;📌&lt;/a&gt; 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="二叉树" scheme="https://scottzhang.pro/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Python Asyncio 并发编程</title>
    <link href="https://scottzhang.pro/article/8fe84c4f.html"/>
    <id>https://scottzhang.pro/article/8fe84c4f.html</id>
    <published>2022-05-17T05:19:57.000Z</published>
    <updated>2022-05-19T14:24:06.619Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个 Python 内置的异步IO并发编程模块。</p></blockquote><span id="more"></span><p>asyncio 包含不同系统下实现的事件循环，如 Windows 下的 Select，Linux 下的 epoll.</p><p>它还对 TCP UDP 等传输协议做了抽象，支持SSL、子进程、延时调用。</p><p>模仿 futures 模块但适用于事件循环使用的 future 类。 模仿 threading 模块中的同步原语，可以在单线程内的协程之间。</p><p>基于 yield from 的协议和任务，让你可以用顺序的方式编写并发代码。</p><p>必须使用一个将产生阻塞IO的调用时，有接口可以把这个事件转移到线程池。</p><p>它主要的功能是为了做协程调度，但也可以让我们把多线程、多进程融合进来。</p><h1 id="asyncio-介绍">Asyncio 介绍</h1><p>Python 用于解决异步 I/O 编程的一整套解决方案，其应用有:</p><ul><li>Tornado</li><li>Gevent</li><li>Twisted (scrapy, Django channels)</li></ul><p>Tornado 底层也是使用协程和事件循环的方式完成高并发，另外它还实现了 Web 服务器。</p><p>对于 django 或者 flask 是不提供 web 服务器的，不会去做很多 socket 编码的事情，只是完成了基本的功能让你可以调试应用。</p><p>所以 django 和 flask，他们还需要一个实现高并发 socket 接口的框架，如 uwsgi, gunicorn，可能再加一个 nginx。</p><p>参考: <a href="https://www.v2ex.com/t/766445">理解 asyncio 来构建高性能 Python 网络程序</a></p><blockquote><p>Tornado 不能简单的使用平时使用的阻塞数据库驱动。</p></blockquote><h1 id="基本使用与事件循环">基本使用与事件循环</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">table</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep started&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(get_data(<span class="string">&quot;test_db&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ python async_play.py</span><br><span class="line">sleep started</span><br><span class="line">sleep finished</span><br></pre></td></tr></table></figure><p>注意这个函数的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">table</span>):</span></span><br><span class="line">    <span class="comment"># 正确写法</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 如果我们不小心将 sleep 换成了 time, 则会报错 TypeError</span></span><br><span class="line">    <span class="comment"># 因为 await后面必须跟一个 awaitable 的对象，这里返回 None 显然不是</span></span><br><span class="line">    <span class="keyword">await</span> time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 如果不加 await, 就会变成顺序的执行过程了</span></span><br><span class="line">    <span class="comment"># 因 time.sleep() 是同步的操作，而 asyncio.sleep() 则会</span></span><br><span class="line">    <span class="comment"># 立即返回一个 future 对象</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我们看到这里 time.sleep 是不支持 asyncio 的，需要将其换成 asyncio.sleep。同理，对于我们其他的 I/O 操作，比如和数据库交互，请求网页，我们也需要一个支持 asyncio 的框架，才可以配合一起工作。</p><p>下面来看一段完整的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">table</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep started&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_data(<span class="string">&quot;test_db&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time()-start_time)</span><br></pre></td></tr></table></figure><p>现在让我们给这段代码加上回调函数，比如在数据库数据拿到之后，就去调用一个回调函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">table</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep started&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback_send_email</span>(<span class="params">url, future</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send email to bobby&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这种方式也是可以的，基本上等价于下面的 create_task</span></span><br><span class="line">    <span class="comment"># get_future = asyncio.ensure_future(get_data(&quot;test_db&quot;))</span></span><br><span class="line">    task = loop.create_task(get_data(<span class="string">&quot;test_db&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># partial 将你的函数包装成一个新的函数，可以将参数放进去</span></span><br><span class="line">    <span class="comment"># 要使用它，需要确保将你的函数要传入的参数放在前面</span></span><br><span class="line">    task.add_done_callback(</span><br><span class="line">        partial(callback_send_email, <span class="string">&quot;test_db&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(task.result())</span><br></pre></td></tr></table></figure><p>另外 asyncio 还支持 wait 和 gather 函数，可以对任务进行精细化控制:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">table</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep started&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_data(<span class="string">&quot;test_db1&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># loop.run_until_complete(asyncio.gather(*tasks))</span></span><br><span class="line">    <span class="comment"># print(time.time()-start_time)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># gather和wait的区别</span></span><br><span class="line">    <span class="comment"># gather更加high-level</span></span><br><span class="line">    group1 = [get_data(<span class="string">&quot;test_db2&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_data(<span class="string">&quot;test_db1&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">    group1 = asyncio.gather(*group1)</span><br><span class="line">    group2 = asyncio.gather(*group2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gather 支持批量取消</span></span><br><span class="line">    group2.cancel()</span><br><span class="line">    loop.run_until_complete(asyncio.gather(group1, group2))</span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br></pre></td></tr></table></figure><h1 id="task-取消和子协程调用原理">Task 取消和子协程调用原理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># run_forever 回一直运行</span></span><br><span class="line">loop.run_forever()</span><br><span class="line"><span class="comment"># 会在运行到指定的协程后停止，这是如何做到的呢？</span></span><br><span class="line">loop.run_until_complete()</span><br></pre></td></tr></table></figure><p>在 <code>run_until_complete</code> 内部，会将传递进来指定的 future 对象增加一个 <code>add_done_callback</code> 方法。</p><p>在指定的 future 执行完成之后，就会调用 <code>_run_until_complete_cb</code> 方法，而 <code>_run_until_complete_cb</code> 内部就会调用 loop 即事件循环 的 stop。</p><p>在理解了上面这两个函数之后，我们就知道如何去启动一个永不停止的函数。</p><p>那么如何去停止它呢？</p><p>loop 实际上，会被放到 future中，(future 中也有 loop 😅)，它内部的实现比较绕，我们通过一个实际例子来看如何取消 loop 的运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">sleep_times</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;waiting&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_times)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;done after &#123;&#125;s&quot;</span>.<span class="built_in">format</span>(sleep_times))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    task1 = get_html(<span class="number">2</span>)</span><br><span class="line">    task2 = get_html(<span class="number">3</span>)</span><br><span class="line">    task3 = get_html(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [task1, task2, task3]</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 这里是如何后续到上面 loop 中的所有 task 的？它完全都没有访问 loop</span></span><br><span class="line">        <span class="comment"># 因为在单线程中，很多变量都是共享的，当直接调用 asyncio.Task.all_tasks()</span></span><br><span class="line">        <span class="comment"># 的时候，它内部会去直接拿 loop，若没有则会创建一个新的</span></span><br><span class="line">        all_tasks = asyncio.Task.all_tasks()</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> all_tasks:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;cancel task&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(task.cancel())</span><br><span class="line">        <span class="comment"># stop 只是标记 stoping 为 True</span></span><br><span class="line">        <span class="comment"># close 则会清空 ready，schedule 队列清空，关闭进程和线程池</span></span><br><span class="line">        <span class="comment"># stop 后一定要调用 run_forever 方法才不会报错</span></span><br><span class="line">        loop.stop()</span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure><h1 id="协程嵌套协程">协程嵌套协程</h1><p>参考官方文档的一个例子（最新文档已被移除）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Compute %s + %s ...&quot;</span> % (x, y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s + %s = %s&quot;</span> % (x, y, result))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>以及它的一个时间顺序图：</p><p><img src="https://s2.loli.net/2022/05/18/9motcaCPZ58rFGi.png" /></p><h1 id="asyncio-其他函数">asyncio 其他函数</h1><p>这里的其他函数指的是，在进行 task 管理的时候，你希望一些 task 可以尽快或者马上运行。</p><p>先定义 call back 和 stop 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">sleep_times, loop</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;回调函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;success time &#123;&#125;&quot;</span>.<span class="built_in">format</span>(loop.time()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span>(<span class="params">loop</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;停止loop&quot;&quot;&quot;</span></span><br><span class="line">    loop.stop()</span><br></pre></td></tr></table></figure><h2 id="call_soon">call_soon</h2><p>指定马上（在队列中）运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.call_soon(callback, <span class="number">4</span>, loop)</span><br><span class="line">    loop.call_soon(stoploop, loop)</span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure><h2 id="call_later">call_later</h2><p>指定一个时间后运行, 多个时间会排序，比 call_soon 慢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    now = loop.time()</span><br><span class="line">    loop.call_later(<span class="number">2</span>, callback, <span class="number">2</span> )</span><br><span class="line">    loop.call_later(<span class="number">1</span>, callback, <span class="number">1</span>)</span><br><span class="line">    loop.call_later(<span class="number">3</span>, callback, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 这个 call_soon 会先运行</span></span><br><span class="line">    loop.call_soon(callback, <span class="number">4</span>)</span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure><h2 id="call_at">call_at</h2><p>指定一个确切的时间（如当前时间加多少秒）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    now = loop.time()</span><br><span class="line">    loop.call_at(now+<span class="number">2</span>, callback, <span class="number">2</span>, loop)</span><br><span class="line">    loop.call_at(now+<span class="number">1</span>, callback, <span class="number">1</span>, loop)</span><br><span class="line">    loop.call_at(now+<span class="number">3</span>, callback, <span class="number">3</span>, loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="call_soon_threadsafe">call_soon_threadsafe</h2><p>线程安全的方法。</p><p>比如 callabck 中的变量，可能在其他的方法中会改动，那么这时候使用 call_soon_threadsafe 才比较安全。</p><h1 id="线程池与-asyncio">线程池与 asyncio</h1><p>asyncio 为什么要和线程池结合呢？asyncio 我们说这是一个异步 IO 框架，它其实支持多线程和多进程的，也包括协程。</p><p>我们要将一个阻塞的接口（比如访问DB）和 asyncio 结合起来的话，要怎么用呢？</p><p>像上面的情况，都是需要特定的函数的（如 asyncio.sleep）？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用多线程：在协程中集成阻塞io</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 通过socket请求html</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">&quot;http://shop.projectsedu.com/goods/&#123;&#125;/&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">        task = loop.run_in_executor(executor, get_url, url)</span><br><span class="line">        tasks.append(task)</span><br><span class="line"></span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;last time:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(time.time()-start_time))</span><br></pre></td></tr></table></figure><h1 id="asyncio-模拟-http-请求">asyncio 模拟 http 请求</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio 没有提供http协议的接口 aiohttp</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立socket连接，比较费事，使用 await</span></span><br><span class="line">    <span class="comment"># asyncio.open_connection 会自动帮我们注册</span></span><br><span class="line">    reader, writer = <span class="keyword">await</span> asyncio.open_connection(host,<span class="number">80</span>)</span><br><span class="line">    writer.write(<span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(path, host).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过 async for 读取数据</span></span><br><span class="line">    <span class="comment"># reader 内部实现了 anext 魔法方法</span></span><br><span class="line">    all_lines = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> raw_line <span class="keyword">in</span> reader:</span><br><span class="line">        data = raw_line.decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">        all_lines.append(data)</span><br><span class="line">    html = <span class="string">&quot;\n&quot;</span>.join(all_lines)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">&quot;http://shop.projectsedu.com/goods/&#123;&#125;/&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">        tasks.append(</span><br><span class="line">            <span class="comment"># append 是 futrue</span></span><br><span class="line">             asyncio.ensure_future(get_url(url))</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;last time:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time()-start_time))</span><br></pre></td></tr></table></figure><h1 id="future-和-task">Future 和 Task</h1><p>我们知道 Future 是一个任务结果容器，Asyncio 也有自己的 Future，它和线程池中的 Future 几乎是一致的。</p><p>当结果容器完成后，就会去运行 callback。</p><p>Task 是 Future 的子类。是协程和 Future 之间的桥梁。</p><h1 id="asyncio-同步和通信">asyncio 同步和通信</h1><p>一般来说，在单线程模式下是不需要锁的，下面的代码打印 total 最终为0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">desc</span>():</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> asyncio</span><br><span class="line">    tasks = [add(), desc()]</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    <span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个 Python 内置的异步IO并发编程模块。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="asyncio" scheme="https://scottzhang.pro/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 Dash 应用</title>
    <link href="https://scottzhang.pro/article/49672c93.html"/>
    <id>https://scottzhang.pro/article/49672c93.html</id>
    <published>2022-05-17T04:54:26.000Z</published>
    <updated>2022-05-17T05:04:10.156Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/dash_app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up Oracle</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">    /opt/oracle</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y libaio1 wget unzip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /app/dash_app/oracle_configs/instantclient-basic-linux.x64-12.2.0.1.0.zip . \</span></span><br><span class="line"><span class="bash">    &amp;&amp; unzip instantclient-basic-linux.x64-12.2.0.1.0.zip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f instantclient-basic-linux.x64-12.2.0.1.0.zip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> /opt/oracle/instantclient* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> /opt/oracle/instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ldconfig \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /opt/oracle/instantclient_12_2/network/admin \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /app/dash_app/oracle_configs/tnsnames.ora /opt/oracle/instantclient_12_2/network/admin/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /app/dash_app/oracle_configs/sqlnet.ora /opt/oracle/instantclient_12_2/network/admin/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set work dir</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="string">&quot;/app/dash_app&quot;</span></span></span><br><span class="line"><span class="comment"># Install python packages</span></span><br><span class="line"><span class="comment"># RUN pip install -r /app/dash_app/requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /app/dash_app/requirements.txt</span></span><br><span class="line"><span class="comment"># Expose port</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8050</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;gunicorn&quot;</span>,<span class="string">&quot;run:server&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;./gunicorn.conf.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>Dash 应用还需要一个 WSGI 服务，这里使用 gunicorn，它需要一个配置文件 <code>gunicorn.conf.py</code> ，其文件内容参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workers = <span class="number">5</span></span><br><span class="line">workers_class = <span class="string">&quot;gevent&quot;</span></span><br><span class="line">bind = <span class="string">&quot;0.0.0.0:8050&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;

&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://scottzhang.pro/categories/Docker/"/>
    
    
    <category term="Dash" scheme="https://scottzhang.pro/tags/Dash/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 Streamlit 应用</title>
    <link href="https://scottzhang.pro/article/fc2204a7.html"/>
    <id>https://scottzhang.pro/article/fc2204a7.html</id>
    <published>2022-05-17T04:46:17.000Z</published>
    <updated>2022-05-17T05:04:10.156Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 Docker 部署 Streamlit 并设置 Oracle 数据库连接。</p></blockquote><span id="more"></span><p>Streamlit 的部署其实很简单，只需要拉取 Python 基础包，装好你需要的包即可。</p><p>我的 dockerfile 中，因为还需要让 strealit 连接 oracle, 所以有 set up Oracle 的步骤。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>.<span class="number">13</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> MAINTAINER=<span class="string">&quot;scottzhang.pro&quot;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/streamlit_app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up Oracle</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">    /opt/oracle</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y libaio1 wget unzip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /app/streamlit_app/instantclient/oracle_configs/instantclient-basic-linux.x64-12.2.0.1.0.zip . \</span></span><br><span class="line"><span class="bash">    &amp;&amp; unzip instantclient-basic-linux.x64-12.2.0.1.0.zip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f instantclient-basic-linux.x64-12.2.0.1.0.zip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> /opt/oracle/instantclient* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> /opt/oracle/instantclient* &gt; /etc/ld.so.conf.d/oracle-instantclient.conf \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ldconfig \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /opt/oracle/instantclient_12_2/network/admin \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /app/streamlit_app/instantclient/oracle_configs/tnsnames.ora /opt/oracle/instantclient_12_2/network/admin/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /app/streamlit_app/instantclient/oracle_configs/sqlnet.ora /opt/oracle/instantclient_12_2/network/admin/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set work dir</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="string">&quot;/app/streamlit_app&quot;</span></span></span><br><span class="line"><span class="comment"># Install python packages</span></span><br><span class="line"><span class="comment"># RUN pip install -r /app/streamlit_app/requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="comment"># query_helper and fc_auto is a package I developed, that is used as a Git submodule</span></span><br><span class="line"><span class="comment"># when i pull all code to local (include this docker file), these submodules also will download to local</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /app/streamlit_app/requirements.txt \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip install -e query_helper \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip install -e fc_auto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Expose port</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;streamlit&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>最后将 streamlit 暴露在 80 端口，就可以访问了。</p><p>Enjoy!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用 Docker 部署 Streamlit 并设置 Oracle 数据库连接。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://scottzhang.pro/categories/Docker/"/>
    
    
    <category term="Streamlit" scheme="https://scottzhang.pro/tags/Streamlit/"/>
    
  </entry>
  
  <entry>
    <title>Python 测试驱动开发介绍</title>
    <link href="https://scottzhang.pro/article/52faaad0.html"/>
    <id>https://scottzhang.pro/article/52faaad0.html</id>
    <published>2022-05-17T03:59:30.000Z</published>
    <updated>2022-05-17T04:00:54.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍了 Python 中各种测试方法与场景。</p></blockquote><span id="more"></span><h1 id="test-runner">Test runner</h1><p>一个特别设计的应用，用来跑测试，检查输出，调试和诊断你的代码。</p><p>Python 有几种测试工具:</p><ul><li>unittest</li><li>nose or nose2</li><li>pytest</li></ul><h2 id="unittest">unittest</h2><p>unittest 要求：</p><ol type="1"><li>把你的测试代码写进 class 或者方法</li><li>在 unittest.TestClass 类中使用一系列特殊断言</li></ol><p>一个简单的测试例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), <span class="number">6</span>, <span class="string">&quot;Should be 6&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_tuple</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="built_in">sum</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)), <span class="number">6</span>, <span class="string">&quot;Should be 6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><h2 id="nose">nose</h2><p>nose 兼容其他测试框架写的代码，nose 会在你的目录寻找所有 <code>py</code> 文件和测试用例进行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install nose2</span><br><span class="line">$ python -m nose2</span><br></pre></td></tr></table></figure><h2 id="pytest">pytest</h2><p>也支持 unitters，它的测试用例是以 <code>test_</code> 开头的一些函数。 pytest 的优点是：</p><ul><li>支持内置的 <code>assert</code> 命令</li><li>可以 filter 测试用例</li><li>支持从上次失败的测试重新开始</li><li>生态系统丰富，支持很多插件</li></ul><p>一个 pytest 的测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_sum():</span><br><span class="line">    assert sum([1, 2, 3]) == 6, &quot;Should be 6&quot;</span><br><span class="line"></span><br><span class="line">def test_sum_tuple():</span><br><span class="line">    assert sum((1, 2, 2)) == 6, &quot;Should be 6&quot; </span><br></pre></td></tr></table></figure><h1 id="编写测试">编写测试</h1><p>一个简单的测试项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">│</span><br><span class="line">├── my_sum/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">|</span><br><span class="line">└── test.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">arg</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> arg:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">    </span><br><span class="line"><span class="comment"># test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> my_sum <span class="keyword">import</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_list_int</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Test that it can sum a list of integers</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        result = <span class="built_in">sum</span>(data)</span><br><span class="line">        self.assertEqual(result, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>断言是你的测试条件，比如你预期，可以通过 <code>.assert*()</code> 编写你的断言，比如 <code>.assertEqual(a, b)</code>，它和 <code>a==b</code> 其实是相等的。</p><p>类似的函数还有：</p><ul><li>assertTrue(x)</li><li>assertFalse(x)</li><li>assertIs(a, b)</li></ul><h1 id="执行测试">执行测试</h1><p>一般通过执行 <code>test.py</code> 文件来测试，在这个文件中你会调用 <code>unittest.main()</code> 函数。</p><p>或者也可以通过命令行的 <code>python -m unittest test</code> 来执行测试。</p><p>通过 <code>python -m unittest -v test</code> 来执行测试并输出每一个测试的内容。</p><p>通过 <code>python -m unittest discover</code> 让其自动发现目前目录戏的 <code>test*.py</code> 文件进行测试，此命名还支持子包的路径: <code>python -m unittest discover -s tests -t src</code>, 其中 src 是子目录名。</p><p>在 PyCharm 中，你可以执行 Run 'Unittests in ..' 来执行测试，在 VS Code 中，进入命令模式，输入 test 即可以看到相关指令。</p><h1 id="web-框架测试">Web 框架测试</h1><blockquote><p>Django, Flask</p></blockquote><p>这类测试很不一样，因为它们内置了一些诸如路由、视图、模型等必要的模块，在启动的时候需要导入，这就好像你要测试一辆车，则需要先将电脑准备好。</p><p>但这类框架也提供了测试工具，比如 Django 在你执行 <code>startapp</code> 的时候，会自动创建 <code>test.py</code> 文件。</p><p>如果你的 Django 项目中没有的话，也可以自己创建，与前面的例子不一样的是，你需要将你的测试类继承自 <code>django.test.TestCase</code>,而不是 <code>unittest.TestCase</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="comment"># Your test methods</span></span><br></pre></td></tr></table></figure><p>在执行的时候，也需要换成 <code>python manage.py test</code>.</p><p>如果你有多个测试文件，则创建一个 test 文件夹，将你的测试文件名更改为 test_*.py，django 会自动发现并执行这些测试。</p><blockquote><p>更多 Django 测试的内容可以参考<a href="https://docs.djangoproject.com/en/2.1/topics/testing/overview/">这里</a></p></blockquote><p>对于 Flask 则又有一些不同，需要设置应用的模式为 test, 然后你可以是实例化一个测试客户端，根据路由去做一些测试。</p><p>实例化的配置都在 setup 方法中，参考下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_app</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        my_app.app.testing = <span class="literal">True</span></span><br><span class="line">        self.app = my_app.app.test_client()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_home</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.app.get(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="comment"># Make your assertions</span></span><br></pre></td></tr></table></figure><p>配置好后，可以直接使用 <code>-m unittest discover</code> 进行测试。</p><blockquote><p>更多 Flask 测试的内容可以参考 <a href="https://flask.palletsprojects.com/en/0.12.x/testing/">Flask Documentation Website</a></p></blockquote><h1 id="高级测试场景">高级测试场景</h1><p>基本的测试步骤：</p><ol type="1"><li>创建你的输入</li><li>执行代码，捕捉输出</li><li>对比输出和预期的结果</li></ol><p>这里输入又叫 fixture， 一般创建后可以重复使用。</p><p>如果你跑一个测试多次，但使用不同的参数，并预期结果是一样的，这叫 parameterization。</p><h1 id="集成测试">集成测试</h1><p>集成测试，顾名思义，会集成多个测试用来检查其每个模块是否都工作，它会站在用户的角度去测试你的软件。</p><p>通常集成测试的代码会和单元测试的分开，因为集成测试需要跑更多的模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">│</span><br><span class="line">├── my_app/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">│</span><br><span class="line">└── tests/</span><br><span class="line">    |</span><br><span class="line">    ├── unit/</span><br><span class="line">    |   ├── __init__.py</span><br><span class="line">    |   └── test_sum.py</span><br><span class="line">    |</span><br><span class="line">    └── integration/</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── test_integration.py</span><br></pre></td></tr></table></figure><p>使用 unitters, 你可以通过 -s 来指定只包含某个部分的代码来进行测试。</p><p><code>python -m unittest discover -s tests/integration</code></p><p>如果你的测试依赖一些文件，可以新建fixtures文件夹，将数据放到里面。</p><h1 id="环境测试">环境测试</h1><p>你想知道你的代码放在不同版本的 python 中是否工作，可以使用 Tox.</p><p>Tox 使用需要配置，它有一个配置文件，里面包括：</p><ul><li>测试需要执行的代码</li><li>执行测试需要的包</li><li>目标环境版本</li></ul><p>你可以执行 <code>tox-quickstart</code> 来启动快速配置脚本，回答问题即可生成 <code>tox.ini</code> 配置文件。</p><h1 id="自动测试">自动测试</h1><p>自动化测试工具，又被称为 CI/CD 工具，意思是 持续集成持续部署(Continuous Integration/Continuous Deployment)。</p><p>Travis CI 是在 Python 下不错的 CI 工具，并且对于所有 Github，GitLab 上开源的项目都免费，它会创建一个 <code>.travis.yml</code> 配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;2.7&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.txt</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">unittest</span> <span class="string">discover</span></span><br></pre></td></tr></table></figure><p>这个配置会测试代码在 python 2.7, 3.7 中是否工作，安装你配置文件中的包，并执行所有自动发现的单元测试。</p><p>当你配置好之后，Travis CI 会在你每次 push 后自动测试你的代码。</p><h1 id="其他测试相关内容">其他测试相关内容</h1><ul><li>使用 Linters， 比如 flake8</li><li>保持干净的测试代码，遵循 DRY( Don’t Repeat Yourself) 原则</li><li>使用 timeit 或是 pytest-benchmark 模块，查看测试性能</li><li>使用 bandit 测试你的包的安全问题.</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍了 Python 中各种测试方法与场景。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python 高级系列" scheme="https://scottzhang.pro/categories/Python-%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="unittest" scheme="https://scottzhang.pro/tags/unittest/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 基本信息速查</title>
    <link href="https://scottzhang.pro/article/96143e16.html"/>
    <id>https://scottzhang.pro/article/96143e16.html</id>
    <published>2022-05-17T03:55:06.000Z</published>
    <updated>2022-05-17T03:56:08.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些关于 Oracle 基本信息查询的常用 sql。</p></blockquote><span id="more"></span><h2 id="数据库信息">数据库信息</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库版本</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v$version;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前数据库名</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> v$database;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前数据库实例名</span></span><br><span class="line"><span class="keyword">select</span> instance_name <span class="keyword">from</span> v$instance;</span><br></pre></td></tr></table></figure><h2 id="表空间">表空间</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表空间信息</span></span><br><span class="line"><span class="comment">-- 参考: https://techgoeasy.com/how-to-check-tablespace-in-oracle-database/</span></span><br><span class="line"><span class="comment">-- 查看表空间</span></span><br><span class="line"><span class="keyword">SELECT</span> TABLESPACE_NAME &quot;TABLESPACE&quot;, EXTENT_MANAGEMENT,FORCE_LOGGING,</span><br><span class="line">BLOCK_SIZE,</span><br><span class="line">SEGMENT_SPACE_MANAGEMENT</span><br><span class="line"><span class="keyword">FROM</span> DBA_TABLESPACES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表空间文件地址</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">FILE_NAME, </span><br><span class="line">BLOCKS, </span><br><span class="line">TABLESPACE_NAME</span><br><span class="line"><span class="keyword">FROM</span> DBA_DATA_FILES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查表空间文件大小，输入表空间名字</span></span><br><span class="line"><span class="comment">-- 结果为 MB</span></span><br><span class="line"><span class="keyword">Select</span> (<span class="built_in">sum</span>(bytes)<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>) Space_allocated</span><br><span class="line"><span class="keyword">from</span> dba_data_files</span><br><span class="line"><span class="keyword">where</span> tablespace_name<span class="operator">=</span><span class="built_in">upper</span>(<span class="string">&#x27;&amp;tname&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="schema-与用户">Schema 与用户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Schema 与用户的区别</span></span><br><span class="line"><span class="comment">-- A schema is a collection of database objects (used by a user.). </span></span><br><span class="line"><span class="comment">-- Schema objects are the logical structures that directly refer to the database’s data.</span></span><br><span class="line"><span class="comment">-- A user is a name defined in the database that can connect to and access objects. </span></span><br><span class="line"><span class="comment">-- Schemas and users help database administrators manage database security.</span></span><br><span class="line"><span class="comment">-- 一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。</span></span><br><span class="line"><span class="comment">-- 查用户信息，包括 schema</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dba_users;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有用户</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_users; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_users; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看用户或角色系统权限</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_sys_privs; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_sys_privs; (查看当前用户所拥有的权限)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/hellojesson/p/3398268.html">如何查询Oracle中所有用户信息</a></p></blockquote><h1 id="查索引">查索引</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- user index</span></span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, TABLE_OWNER, TABLE_NAME, UNIQUENESS <span class="keyword">from</span> USER_INDEXES</span><br><span class="line"></span><br><span class="line"><span class="comment">-- all index</span></span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, TABLE_OWNER, TABLE_NAME, UNIQUENESS <span class="keyword">from</span> ALL_INDEXES</span><br><span class="line"></span><br><span class="line"><span class="comment">-- all index filter by table name</span></span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, TABLE_OWNER, TABLE_NAME, UNIQUENESS <span class="keyword">from</span> ALL_INDEXES</span><br><span class="line"><span class="keyword">where</span> table_owner <span class="keyword">like</span> <span class="string">&#x27;%DC%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- all index group by table owner</span></span><br><span class="line"><span class="keyword">select</span> table_owner, <span class="built_in">COUNT</span>(TABLE_OWNER) <span class="keyword">from</span> ALL_INDEXES</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> table_owner;</span><br></pre></td></tr></table></figure><h1 id="表与视图">表与视图</h1><h2 id="有哪些表和视图">有哪些表和视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- list all user&#x27;s table</span></span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> all_tables <span class="keyword">order</span> <span class="keyword">by</span> table_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list all views</span></span><br><span class="line"><span class="keyword">select</span> view_name <span class="keyword">from</span> all_views <span class="keyword">where</span> view_name <span class="keyword">like</span> <span class="string">&#x27;GRA%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> view_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- check table length</span></span><br><span class="line"><span class="keyword">select</span> table_name, num_rows <span class="keyword">from</span> all_tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- create table from another view or table</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> prs7.t_gra_stores_mapping_dc <span class="keyword">as</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> prs4.GRA_STORE_MAPPING_INFO_DC);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查表占用空间">检查表占用空间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">segment_name,</span><br><span class="line">sum(bytes)/1024/1024/1024 GB </span><br><span class="line">from user_segments </span><br><span class="line">where segment_type=&#x27;TABLE&#x27; and segment_name=upper(&#x27;&amp;TABLE_NAME&#x27;) group by segment_name;</span><br></pre></td></tr></table></figure><h1 id="查看执行计划">查看执行计划</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> a, b, c</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">TABLE</span>(dbms_xplan.display);</span><br></pre></td></tr></table></figure><h1 id="oracle-文档阅读">Oracle 文档阅读</h1><ul><li><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/introduction-to-oracle-database.html#GUID-A42A6EF0-20F8-4F4B-AFF7-09C100AE581E">Introduction to Oracle Database</a></li><li><a href="https://oracle-base.com/articles/misc/naming-conventions#EntitiesTables">Oracle Naming Conventions</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些关于 Oracle 基本信息查询的常用 sql。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="oracle" scheme="https://scottzhang.pro/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 数据处理技巧</title>
    <link href="https://scottzhang.pro/article/23f82ff0.html"/>
    <id>https://scottzhang.pro/article/23f82ff0.html</id>
    <published>2022-05-17T03:31:37.000Z</published>
    <updated>2022-05-17T03:45:44.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些数据处理小技巧，不成体系。</p></blockquote><span id="more"></span><h3 id="了解文件">了解文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 读取数据</span></span><br><span class="line"><span class="comment"># csv, excel, txt, etc...</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">sndata = pd.read_csv(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看数据结构和类型</span></span><br><span class="line">sndata.dtypes</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看index</span></span><br><span class="line">sndata.index</span><br><span class="line">&gt; index是可以定义的，默认是<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,也可以是a,b,c</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看列名</span></span><br><span class="line">sndata.columns</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看缺失的数据</span></span><br><span class="line">sndata.isnull()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 转换成DataFrame</span></span><br><span class="line">pd.DataFrame(sndata)</span><br><span class="line">&gt; The resulting DataFrame will have its index assigned automatically <span class="keyword">as</span> <span class="keyword">with</span> Series, <span class="keyword">and</span></span><br><span class="line">the columns are placed <span class="keyword">in</span> <span class="built_in">sorted</span> order:</span><br><span class="line"></span><br><span class="line"><span class="comment">## 去重复</span></span><br><span class="line">sndata.duplicated([<span class="string">&#x27;MonitorFA&#x27;</span>])</span><br><span class="line">sndata[sndata.duplicated([<span class="string">&#x27;ComputerSN&#x27;</span>],keep = <span class="literal">False</span>)]</span><br><span class="line">Drop_duplicates当中的参数keep=<span class="literal">False</span>，意为重复项全部删除，它还有keep=<span class="string">&quot;first&quot;</span>与keep=<span class="string">&quot;last&quot;</span>，分别对应在有多项重复时，保留第一项（或最后一项）</span><br><span class="line"></span><br><span class="line"><span class="comment">## 找出两个表不一样的地方</span></span><br><span class="line">c=a.append(b)</span><br><span class="line">c.drop_duplicates(keep=<span class="literal">False</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">c.reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除 NA</span></span><br><span class="line">df.dropna(axis=‘columns’,how=‘<span class="built_in">all</span>’)</span><br></pre></td></tr></table></figure><h3 id="检测文件是否有-header">检测文件是否有 Header</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">path = <span class="string">r&#x27;C:\Users\scott\Documents\Test_Data\distribution\myfile.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    dialect = csv.Sniffer().has_header(csvfile.read(<span class="number">1024</span>))</span><br><span class="line"><span class="built_in">print</span>(dialect)</span><br></pre></td></tr></table></figure><h3 id="大数据集处理">大数据集处理</h3><ol type="1"><li>回收垃圾</li><li>提前设置好 dtype</li><li>选择有限的行，列</li><li>使用 chunk 分批导入、处理</li><li>Tips 查看内存消耗: <code>train.memory_usage(deep=True) * 1e-6</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import some file</span></span><br><span class="line">temp = pd.read_csv(<span class="string">&#x27;../input/train_sample.csv&#x27;</span>)</span><br><span class="line"><span class="comment">#do something to the file</span></span><br><span class="line">temp[<span class="string">&#x27;os&#x27;</span>] = temp[<span class="string">&#x27;os&#x27;</span>].astype(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"><span class="comment">#delete when no longer needed</span></span><br><span class="line"><span class="keyword">del</span> temp</span><br><span class="line"><span class="comment">#collect residual garbage</span></span><br><span class="line">gc.collect()</span><br></pre></td></tr></table></figure><p>参考：https://www.kaggle.com/rohanrao/tutorial-on-reading-large-datasets#Large-datasets</p><h3 id="tidy-data-原则">Tidy Data 原则</h3><ol type="1"><li>Columns represent separate variables</li><li>Raws represent individual observations</li><li>Observational units from tables</li></ol><h3 id="cut-方法">Cut 方法</h3><p>用于检测数据的分类，比如19,20,35 对应人员年龄的分层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.cut(a,b)</span><br><span class="line"></span><br><span class="line">a: data</span><br><span class="line">b:category info</span><br></pre></td></tr></table></figure><h3 id="时间日期处理">时间日期处理</h3><blockquote><p>内容太多，只记录了个人的笔记。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间切片</span></span><br><span class="line">ts = pd.to_datetime(<span class="string">&#x27;///&#x27;</span>)</span><br><span class="line">ufo.loc([ufo.time &gt;= ts],:)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 星期、年、等计算</span></span><br><span class="line">ufo.time.dt.dayofyear.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最新时间、计算</span></span><br><span class="line">ufo.time.<span class="built_in">max</span>() - ufo.time.<span class="built_in">min</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期转换时间段</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> monthrange</span><br><span class="line"></span><br><span class="line">start = datetime.strptime(<span class="string">&#x27;20201402&#x27;</span>,<span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">_,days = monthrange(start.year, start.month)</span><br><span class="line">end_str = <span class="string">f&#x27;<span class="subst">&#123;start.year&#125;</span>-<span class="subst">&#123;start.month&#125;</span>-<span class="subst">&#123;days&#125;</span>&#x27;</span></span><br><span class="line">end = datetime.strptime(end_str,<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="category-datatype">Category Datatype</h3><ul><li>object 通常是 string，这个object指向本来的python 的list或者dict对象</li><li>memory usage xxx+ KB, +的意思是最少需要这么多空间去存储这些引用</li><li>drinks.info(memory_usage='deep') ： 查看真实的空间需求</li><li>每一列需要的空间: drinks.memory_usage(deep=True)</li></ul><h3 id="append-和-concat">append 和 concat</h3><p>对于Series：</p><ul><li>append会将index直接加上去，索引还是以前的，如果按照索引去选择，可能会返回多个数据, 最好在 append 后加上 resetindex</li><li>concat默认会重设索引，也可以使用ignore_index保留索引</li></ul><p>对于DataFrame：</p><ul><li>append：如果列名字一样，直接在后面添加，如果不一样，增加相应的列，填充空值。</li><li>concat：指定axis=0，则效果和append一样，axis=1，会合并值一样的行</li></ul><p>append和concat操作中 index的变化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># concat直接将两份数据合并到一起</span></span><br><span class="line"><span class="comment"># 如果你的两份数据分别是13年和14年的，你想要添加索引将其分开，可以使用：</span></span><br><span class="line">rain1314 = pd.concat([rain2013, rain2014], keys=[<span class="number">2013</span>, <span class="number">2014</span>], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样是以row名来分类，当然也可以用column名来分类：</span></span><br><span class="line">rain1314 = pd.concat([rain2013, rain2014], keys=[<span class="number">2013</span>, <span class="number">2014</span>], axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个dataframe不仅可以从数组中构造，也可以从dict中</span></span><br><span class="line"><span class="comment"># 这样就不必后期指定key的值了：</span></span><br><span class="line">rain_dict = &#123;<span class="number">2013</span>: rain2013, <span class="number">2014</span>: rain2014&#125; </span><br><span class="line">rain1314 = pd.concat(rain_dict, axis=<span class="string">&#x27;columns&#x27;</span>) </span><br></pre></td></tr></table></figure><p>对于 join:</p><ul><li>inner join, 把不同表中，索引名字一样的行的列合并，如果某些列没有的，则过滤掉这一行。</li><li>outer join, 把两个表合并，所有索引都合并，如果某些列没有值的，填充值为nanaxis = 1或者0, 对列或者行操作</li></ul><h3 id="merge">Merge</h3><p>merge默认指定的列来合并两个表的其他列，默认根据 index。</p><p>如果类似多索引的两个表，索引部分的值无法一一对应，那么就需要指定根据哪一列来merge，如果只指定了一列，那么肯定会有两个表都对应同一列数据的情况出现，可以用suffixes参数，来对这些列进行区分（一般是根据表名），当然也可以直接指定多个列来merge。</p><p>一般默认会使用index去merge，但更多的是使用lefton和righton参数来指定左右两个表中的列来merge。</p><h3 id="从多标签中切分值">从多标签中切分值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx = pd.IndexSlice</span><br><span class="line">slice_2_8 = february.loc[<span class="string">&#x27;2015-2-2&#x27;</span>:<span class="string">&#x27;2015-2-8&#x27;</span>, idx[:, <span class="string">&#x27;Company&#x27;</span>]]</span><br></pre></td></tr></table></figure><h3 id="多列操作">多列操作</h3><p>从多列创建日期</p><p><img src="https://s2.loli.net/2022/05/17/mxKPnu3bCTiINlq.png" /></p><p>批量转换列的数据类型</p><p><img src="https://s2.loli.net/2022/05/17/6aNR4GMCXSbZiWg.png" /></p><p>批量对列使用聚合函数</p><p><img src="https://s2.loli.net/2022/05/17/LauhgMiFtOXPjrU.png" /></p><p>批量重命名列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns = &#123;<span class="string">&#x27;oldname&#x27;</span>:<span class="string">&#x27;new_name&#x27;</span>&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="避免赋值出现-warning">避免赋值出现 warning</h3><p><img src="https://s2.loli.net/2022/05/17/GTyqipAekfHo2wP.png" /></p><h3 id="关闭科学记数法">关闭科学记数法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/21137150/format-suppress-scientific-notation-from-python-pandas-aggregation-results</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.3f&#x27;</span> % x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置千分符</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x:<span class="string">&#x27;&#123;:,.0f&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br></pre></td></tr></table></figure><h3 id="by-行修改值">By 行修改值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/23330654/update-a-dataframe-in-pandas-while-iterating-row-by-row</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">    <span class="keyword">if</span> &lt;something&gt;:</span><br><span class="line">        df.at[row.Index, <span class="string">&#x27;ifor&#x27;</span>] = x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        df.at[row.Index, <span class="string">&#x27;ifor&#x27;</span>] = x</span><br><span class="line">df.loc[row.Index, <span class="string">&#x27;ifor&#x27;</span>] = x</span><br></pre></td></tr></table></figure><h3 id="pd.iterrows-的限制">pd.iterrows 的限制</h3><blockquote><p>pd.DataFrame.iterrows you are iterating through rows as Series. But these are not the Series that the data frame is storing and so they are new Series that are created for you while you iterate.</p></blockquote><p>Refer <a href="https://stackoverflow.com/questions/23330654/update-a-dataframe-in-pandas-while-iterating-row-by-row">this</a></p><h3 id="pd.xs-方法">pd.xs 方法</h3><p>多个 index 取值，但不能用来设置值，默认它返回原数据中的一份 copy。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># by default, returns a new dataframe with a copy of the data</span></span><br><span class="line">df.xs(<span class="string">&#x27;C&#x27;</span>) </span><br></pre></td></tr></table></figure><p>Refer <a href="https://stackoverflow.com/questions/13842088/set-value-for-particular-cell-in-pandas-dataframe-using-index">this</a></p><h3 id="理解-pandas-的-axis">理解 Pandas 的 Axis</h3><p>对于 Dataframe</p><ul><li>“axis 0” represents rows direction and “axis 1” represents columns direction</li><li>可以使用 “index” 与 “row” 代表 0； “column” 代表 1</li><li>Sum 应用到 “axis 0”，意味着 sum 每列的结果</li><li>Sum 应用到 “axis 1”，意味着 sum 每行的结果</li></ul><p><img src="https://s2.loli.net/2022/05/17/MPx9yEOuhASFN2C.png" /></p><blockquote><p>dropna 可以默认是丢弃有 na 值的行，如果你需要丢弃有 na 值的列，将 axis 设置为 1 即可。</p></blockquote><p>对于 Series</p><blockquote><p>Series and DataFrame share the same direction for “axis 0”</p></blockquote><p><img src="https://s2.loli.net/2022/05/17/u7imoNkQeMXAsaB.png" /></p><h3 id="提高-dataframe-遍历速度">提高 Dataframe 遍历速度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For 循环，iloc 访问 df : 2.65 秒</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_for</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df)):</span><br><span class="line">        temp += df[<span class="string">&#x27;A&#x27;</span>].iloc[index] + df[<span class="string">&#x27;B&#x27;</span>].iloc[index]</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># For 循环，df.iterrows 访问 df：12.4 秒, 会花费大量时间在</span></span><br><span class="line"><span class="comment"># 创建 series 对象（且不会保留 dtype，如果需要建议使用 itertuples）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_iterrows</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">            temp += row.A + row.B</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="comment"># For 循环，df.itertuples 访问 df：136 毫秒，终于来到毫秒级别</span></span><br><span class="line"><span class="comment"># 但它还是会创建 namedtuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_itertuples</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row_tuple <span class="keyword">in</span> df.itertuples():</span><br><span class="line">        temp += row_tuple.A + row_tuple.B</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，我们可以自己实现，避免创建 nameduple,使用 zip 函数</span></span><br><span class="line"><span class="comment"># For 循环，zip 函数访问，30 毫秒，这里的改进来自于避免创建 namedtuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_with_zip</span>(<span class="params">df</span>):</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(df[<span class="string">&#x27;A&#x27;</span>], df[<span class="string">&#x27;B&#x27;</span>]):</span><br><span class="line">        temp += a + b</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pandas 自带的 apply 函数</span></span><br><span class="line"><span class="comment"># 3.28 秒，看起来和普通的 for 循环差不多</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_apply</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> df.apply(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;A&#x27;</span>] + x[<span class="string">&#x27;B&#x27;</span>], axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pandas 自带的 add 函数</span></span><br><span class="line"><span class="comment"># 849 µs，pandas 自带的这种函数运行效率非常高</span></span><br><span class="line"><span class="comment"># 如果你的操作可以分解成这种就优先使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_add</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (df[<span class="string">&#x27;A&#x27;</span>]+df[<span class="string">&#x27;B&#x27;</span>]).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你还是很在乎性能，可以使用 numpy</span></span><br><span class="line"><span class="comment"># 将数据转化成 numpy 的 array</span></span><br><span class="line"><span class="comment"># 186 µs，提升八倍</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_numpy_builtin</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (df[<span class="string">&#x27;A&#x27;</span>].values + df[<span class="string">&#x27;B&#x27;</span>].values).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同大小的数据，对结果会有影响，如果是大数据集，结果差距会非常明显，附图：</span></span><br><span class="line"><span class="comment"># iterrows 是效率最差的,其次是 apply，和 普通的 for 循环，两者差不多</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一定要用 apply 怎么办呢？</span></span><br><span class="line"><span class="comment"># 可以使用如下的第二种方式, * here is to unpack all values in list </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_apply</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> df.apply(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;A&#x27;</span>] + x[<span class="string">&#x27;B&#x27;</span>] + x[<span class="string">&#x27;C&#x27;</span>] + x[<span class="string">&#x27;D&#x27;</span>], axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using_apply_unpack</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]].apply(<span class="keyword">lambda</span> x: <span class="built_in">sum</span>([*x]), axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>速度测试对比：</p><p><img src="https://s2.loli.net/2022/05/17/4Ej1WL9nxTOyXPC.png" /></p><h3 id="测试你代码的速度">测试你代码的速度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 自带</span></span><br><span class="line">%timeit using_numpy_builtin(df)</span><br><span class="line"><span class="comment"># notebook 自带</span></span><br><span class="line">%prun -l <span class="number">4</span> loop_with_iterrows(df)</span><br></pre></td></tr></table></figure><h3 id="使用-pd.wide_to_long">使用 pd.wide_to_long</h3><p>wide_to_long allows us to set stub names that can group columns.</p><p>Remember that wide_to_long() function takes the main arguments: i to set the unique row index, j to set the new variable name, and stubnames to extract the start of the wide columns.</p><p>needed to specify the separating elements. When you didn't do that, pandas didn't recognize the column names and returned an empty DataFrame.</p><p>Also, wide_to_long() always assumes that suffixes are numeric, so don't forget to specify if they are not!</p><h3 id="使用-pd.apply">使用 pd.apply</h3><p>创建列 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Discounted_Price&#x27;</span>] = df.apply(</span><br><span class="line">    <span class="keyword">lambda</span> row: row.Cost - (row.Cost * <span class="number">0.1</span>),</span><br><span class="line">    axis = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Print the DataFrame after addition of new column</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></p><p>对比 map</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># apply 返回 dataframe，增加两列</span></span><br><span class="line">a = p.apply(<span class="keyword">lambda</span> x: pd.Series([x,x+<span class="number">1</span>,x+<span class="number">2</span>]))</span><br><span class="line"><span class="comment"># map，返回3个 Series</span></span><br><span class="line">a,b,c = p.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: pd.Series([x,x+<span class="number">1</span>,x+<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><h3 id="pivot-和-pivottable">Pivot 和 Pivottable</h3><p>When the .pivot() method finds two rows with the same index and column, but different values for the values, it doesn't know how to handle it.</p><h3 id="dataframe-增加总和grand-total">Dataframe 增加总和（Grand Total）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/21752399/pandas-dataframe-total-row</span></span><br><span class="line">df.loc[<span class="string">&#x27;Column_Total&#x27;</span>]= df.<span class="built_in">sum</span>(numeric_only=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">df.loc[:,<span class="string">&#x27;Row_Total&#x27;</span>] = df.<span class="built_in">sum</span>(numeric_only=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="pandas-求众数">Pandas 求众数</h3><p>两种方法都可以，性能差异不大：</p><p><img src="https://s2.loli.net/2022/05/17/uz2aefXxApK1VvO.png" /></p><h3 id="根据条件对列赋值">根据条件对列赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Numpy Where 方法</span></span><br><span class="line">df[<span class="string">&#x27;hasimage&#x27;</span>] = np.where(df[<span class="string">&#x27;photos&#x27;</span>]!= <span class="string">&#x27;[]&#x27;</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Numpy Select 方法</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># read data</span></span><br><span class="line">all_ = pd.read_excel(<span class="string">&#x27;./scott.xlsx&#x27;</span>,sheet_name=<span class="string">&#x27;ALL&#x27;</span>)</span><br><span class="line">enc_ = pd.read_excel(<span class="string">&#x27;./scott.xlsx&#x27;</span>,sheet_name=<span class="string">&#x27;ENC&#x27;</span>)</span><br><span class="line">result = pd.read_excel(<span class="string">&#x27;./scott.xlsx&#x27;</span>,sheet_name=<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enc store list unique array</span></span><br><span class="line">enc_store_list = enc_.STORECODE.unique()</span><br><span class="line"></span><br><span class="line">conditions = [</span><br><span class="line">    all_.STORECODE.isin(enc_store_list),</span><br><span class="line">    ~all_.STORECODE.isin(enc_store_list)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PVAL_OLD values</span></span><br><span class="line">pval_new_values = [</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    all_[conditions[<span class="number">1</span>]].PVAL.values</span><br><span class="line">]</span><br><span class="line">pvol_new_values = [</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    all_[conditions[<span class="number">1</span>]].PVOL.values</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">all_[<span class="string">&#x27;PVOL_NEW&#x27;</span>] = np.select(conditions,pvol_new_values)</span><br><span class="line">all_[<span class="string">&#x27;PVAL_NEW&#x27;</span>] = np.select(conditions,pval_new_values)</span><br><span class="line"></span><br><span class="line">all_.rename(columns=&#123;<span class="string">&#x27;PVOL&#x27;</span>:<span class="string">&#x27;PVOL_OLD&#x27;</span>,<span class="string">&#x27;PVAL&#x27;</span>:<span class="string">&#x27;PVAL_OLD&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用多进程提高数据处理速度">使用多进程提高数据处理速度</h3><p>我们知道 Python 因为 GIL 的关系，对于 CPU 密集操作无法有效利用多核处理器，我们可以使用多进程来打破这个限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有以下代码</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span>  Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_features</span>(<span class="params">df</span>):</span></span><br><span class="line">    df[<span class="string">&#x27;question_text&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> x:<span class="built_in">str</span>(x))</span><br><span class="line">    df[<span class="string">&quot;lower_question_text&quot;</span>] = df[<span class="string">&quot;question_text&quot;</span>].apply(<span class="keyword">lambda</span> x: x.lower())</span><br><span class="line">    df[<span class="string">&#x27;total_length&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="built_in">len</span>)</span><br><span class="line">    df[<span class="string">&#x27;capitals&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> c <span class="keyword">in</span> comment <span class="keyword">if</span> c.isupper()))</span><br><span class="line">    df[<span class="string">&#x27;caps_vs_length&#x27;</span>] = df.apply(<span class="keyword">lambda</span> row: <span class="built_in">float</span>(row[<span class="string">&#x27;capitals&#x27;</span>])/<span class="built_in">float</span>(row[<span class="string">&#x27;total_length&#x27;</span>]),</span><br><span class="line">                                axis=<span class="number">1</span>)</span><br><span class="line">    df[<span class="string">&#x27;num_words&#x27;</span>] = df.question_text.<span class="built_in">str</span>.count(<span class="string">&#x27;\S+&#x27;</span>)</span><br><span class="line">    df[<span class="string">&#x27;num_unique_words&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">len</span>(<span class="built_in">set</span>(w <span class="keyword">for</span> w <span class="keyword">in</span> comment.split())))</span><br><span class="line">    df[<span class="string">&#x27;words_vs_unique&#x27;</span>] = df[<span class="string">&#x27;num_unique_words&#x27;</span>] / df[<span class="string">&#x27;num_words&#x27;</span>] </span><br><span class="line">    df[<span class="string">&#x27;num_exclamation_marks&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: comment.count(<span class="string">&#x27;!&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_question_marks&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: comment.count(<span class="string">&#x27;?&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_punctuation&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> <span class="string">&#x27;.,;:&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_symbols&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> <span class="string">&#x27;*&amp;$%&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;num_smilies&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> (<span class="string">&#x27;:-)&#x27;</span>, <span class="string">&#x27;:)&#x27;</span>, <span class="string">&#x27;;-)&#x27;</span>, <span class="string">&#x27;;)&#x27;</span>)))</span><br><span class="line">    df[<span class="string">&#x27;num_sad&#x27;</span>] = df[<span class="string">&#x27;question_text&#x27;</span>].apply(<span class="keyword">lambda</span> comment: <span class="built_in">sum</span>(comment.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> (<span class="string">&#x27;:-&lt;&#x27;</span>, <span class="string">&#x27;:()&#x27;</span>, <span class="string">&#x27;;-()&#x27;</span>, <span class="string">&#x27;;(&#x27;</span>)))</span><br><span class="line">    df[<span class="string">&quot;mean_word_len&quot;</span>] = df[<span class="string">&quot;question_text&quot;</span>].apply(<span class="keyword">lambda</span> x: np.mean([<span class="built_in">len</span>(w) <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">str</span>(x).split()]))</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallelize_dataframe</span>(<span class="params">df, func, n_cores=<span class="number">4</span></span>):</span></span><br><span class="line">    df_split = np.array_split(df, n_cores)</span><br><span class="line">    pool = Pool(n_cores)</span><br><span class="line">    df = pd.concat(pool.<span class="built_in">map</span>(func, df_split))</span><br><span class="line">    <span class="comment"># 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">train = parallelize_dataframe(train_df, add_features)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于多进程，可以<a href="https://scottzhang.pro/article/4300f84b.html">点击</a>了解更多。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些数据处理小技巧，不成体系。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 基础操作</title>
    <link href="https://scottzhang.pro/article/706b7b04.html"/>
    <id>https://scottzhang.pro/article/706b7b04.html</id>
    <published>2022-05-17T01:59:34.000Z</published>
    <updated>2022-05-17T03:45:39.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍了 Pandas 中的 Index，Series, Dataframe 及其基本操作。</p></blockquote><span id="more"></span><h1 id="概念介绍">概念介绍</h1><h2 id="index">Index</h2><p>Index 对象主要保存了关于轴的信息，index 对象类似数组，可以被切片，可以根据下标访问，但是不可以被修改;</p><p>可以通过 pd.Index 构造 index 对象，index 对象可以拥有重复的值。</p><p>index 比较常用的方法:</p><p><img src="https://i.loli.net/2021/03/22/fca94zqHgxJ7Ey8.jpg" /></p><h2 id="series">Series</h2><p>Series 可以直接从数组初始化，如果没有指定 index，则会默认分配数字作为 index，也可以指定 index，但要求其长度与 values 一致。</p><p>当指定了 index 后，可直接通过 index 的名字访问 value，比如 <code>obj['a']</code> 或者 <code>obj[['a','b','c']]</code>，可以通过 <code>obj[obj &gt; 0]</code> 的方式 filter其元素，或者进行运算：<code>'a' in obj</code>， <code>obj * 2</code>;</p><p>可以通过 dict 初始化 Series，结果的顺序与和 dict 中的 key 排序后的一样，如果像自定义顺序，可以在初始化函数中单独指定 index，需要保证传入的 index 在 dict 中的 key 中存在，否则会将值设为空。</p><p>多个 Series 在参与计算的时候，会自动对齐 index，有点类似 database 中的 join。</p><p>Series 对象本身和它的index 都有一个叫 name 的属性, index 可以被其它的值替代。</p><h2 id="dataframe">DataFrame</h2><p>可以理解为 dict 中 value 为 Series，构造 dataframe 的方式也可以直接通过 dict，DataFrame 的 index 也和 Series 一样，会自动指定，column 的顺序也会重新排序，你也可以指定指定列的顺序，就像 Series 一样: <code>pd.DataFrame(data, columns=[...])</code>，如果你传的 columns 数组中，有 data 中没有的值，则会将该列添加到 DataFrame 中，值全部置空。</p><p>DataFrame 中的列，可以通过 <code>df['a']</code> 或者 <code>df.a</code> 两种方式访问，将会返回一个 Series，第一种方式在任何情况下都可以使用，第二种方式则需要 column name 满足 python 对于变量名字的要求。从 DataFrame 拿到的 Series，将会拥有和 DataFrame 一样的 index，它的 name 属性也已经被自动设定。</p><p>DaFrame 中的行，也可以通过位置和名字访问，例如 loc 方法（之后介绍）。</p><p>给 Column 赋的值，可以是一个值，也可以是一个数组，或者 Series 对象。如果是数组，数组长度要与 dataframe 一致；如果是 Series，将按照 index label 赋值给 DataFrame; 给不存在的 column 赋值，会创建一个新的 column (只可以通过 ['column'] 的方式创建);</p><p>删除列，通过 <code>del df['col']</code> 操作，但这种写法不鼓励，可以通过 <code>df.drop(columns=['B', 'C'])</code>。</p><p>DataFrame 的 column 和 index 都可以有 name, <code>df.index.name = 'idx'</code>, <code>df.columns.name = 'col'</code>, df.values 会返回一个 DataFrame 的值的二维数组。</p><h1 id="essential-functionality">Essential Functionality</h1><h2 id="reindexing">Reindexing</h2><p>reindex 是 pandas 里实现数据对齐的基本方法, 沿着指定轴，让现有数据匹配一组新标签，并重新排序。</p><p>可以在无数据但有标签的位置插入缺失值。</p><p>编写注重性能的代码时，最好花些时间深入理解 reindex：预对齐数据后，操作会更快。两个未对齐的 DataFrame 相加，后台操作会执行 reindex。</p><p>提取一个对象，并用另一个具有相同标签的对象 reindex 该对象的轴。这种操作的语法虽然简单，但未免有些啰嗦。这时，最好用 reindex_like() 方法，这是一种既有效，又简单的方式。</p><p>align() 方法是对齐两个对象最快的方式，该方法支持 join 参数,比如你想要根据 df2的列的顺序排序 df1 的列顺序 <code>df1.align(df2, join='left'), axis=1</code>。</p><p>可以直接调用 Series <code>s.rename(str.upper)</code> 来操作 index 上的 string 格式; 也可以操作 df 的 index 和 columns, <code>df.rename(&#123;'one': 'foo', 'two': 'bar'&#125;, axis='columns')</code>。</p><p>reindex，ffill 与 bfill，在 reindex 时候产生的值用前、后的值去取代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">219</span>]: rng = pd.date_range(<span class="string">&#x27;1/3/2000&#x27;</span>, periods=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: ts = pd.Series(np.random.randn(<span class="number">8</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">221</span>]: ts2 = ts[[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: ts</span><br><span class="line">Out[<span class="number">222</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.400528</span></span><br><span class="line"><span class="number">2000</span>-01-05   -<span class="number">0.015083</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">1.414806</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.118428</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>   -<span class="number">0.936077</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">223</span>]: ts2</span><br><span class="line">Out[<span class="number">223</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: ts2.reindex(ts.index)</span><br><span class="line">Out[<span class="number">224</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04         NaN</span><br><span class="line"><span class="number">2000</span>-01-05         NaN</span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07         NaN</span><br><span class="line"><span class="number">2000</span>-01-08         NaN</span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>         NaN</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">225</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line">Out[<span class="number">226</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>         NaN</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>上面的做法亦可通过 <code>ts2.reindex(ts.index).fillna(method='ffill')</code> 实现, 如果索引不是按递增或递减排序，reindex() 会触发 ValueError 错误。fillna() 与 interpolate() 则不检查索引的排序。limit 与 tolerance 参数可以控制 reindex 的填充操作。limit 限定了连续匹配的最大数量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">229</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;ffill&#x27;</span>, limit=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05         NaN</span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08         NaN</span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>tolerance 限定了索引与索引器值之间的最大距离：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">230</span>]: ts2.reindex(ts.index, method=<span class="string">&#x27;ffill&#x27;</span>, tolerance=<span class="string">&#x27;1 day&#x27;</span>)</span><br><span class="line">Out[<span class="number">230</span>]: </span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">0.183051</span></span><br><span class="line"><span class="number">2000</span>-01-05         NaN</span><br><span class="line"><span class="number">2000</span>-01-06    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">2.395489</span></span><br><span class="line"><span class="number">2000</span>-01-08         NaN</span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">0.733639</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.733639</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><blockquote><p>索引为 DatetimeIndex、TimedeltaIndex 或 PeriodIndex 时，tolerance 会尽可能将这些索引强制转换为 Timedelta，这里要求用户用恰当的字符串设定 tolerance 参数。</p></blockquote><h2 id="dropping-entries-from-an-axis">Dropping Entries from an Axis</h2><p>如果有了 index，可以直接 index 名字删除某行 <code>new_obj = obj.drop('c')</code>, 或者同时删除多行 <code>data.drop(['Colorado', 'Ohio'])</code>,<code>axis=1</code> 删除列，0 删除行。</p><h1 id="代码示例">代码示例</h1><h2 id="indexing-value">Indexing value</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用中括号</span></span><br><span class="line">df[<span class="string">&quot;eggs&quot;</span>][<span class="string">&#x27;May&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列名</span></span><br><span class="line">df.eggs[<span class="string">&#x27;May&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 loc</span></span><br><span class="line">df.loc[<span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>]</span><br><span class="line">df.loc[<span class="string">&#x27;May&#x27;</span>][<span class="string">&#x27;eggs&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 iloc</span></span><br><span class="line">df.iloc[<span class="number">4</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="slicing-dataframes">Slicing DataFrames</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eggs 列中的某些值</span></span><br><span class="line">df[<span class="string">&#x27;eggs&#x27;</span>][<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># eggs 列中的某个值</span></span><br><span class="line">df[<span class="string">&#x27;eggs&#x27;</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某些列中的所有行</span></span><br><span class="line">df.loc[:, <span class="string">&#x27;eggs&#x27;</span>:<span class="string">&#x27;salt&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某些行中所有列</span></span><br><span class="line">df.loc[<span class="string">&#x27;Jan&#x27;</span>:<span class="string">&#x27;Feb&#x27;</span>, :]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某些行中某些列</span></span><br><span class="line">df.loc[<span class="string">&#x27;Jan&#x27;</span>:<span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>:<span class="string">&#x27;salt&#x27;</span>]</span><br><span class="line">df.loc[<span class="string">&#x27;Jan&#x27;</span>:<span class="string">&#x27;Mar&#x27;</span>, [<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;salt&#x27;</span>]]  <span class="comment"># 使用列表删选行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 iloc 选择</span></span><br><span class="line">df.iloc[<span class="number">2</span>:<span class="number">5</span>, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># df[&#x27;eggs&#x27;]  -&gt; pandas.core.series.Series</span></span><br><span class="line"><span class="comment"># df[[&#x27;eggs]] -&gt; pandas.core.frame.DataFrame</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="filtering">Filtering</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, df.<span class="built_in">all</span>()]           <span class="comment"># 所有非0值</span></span><br><span class="line">df.loc[:, df.<span class="built_in">any</span>()]           <span class="comment"># 0值行</span></span><br><span class="line">df.loc[:, df.isnull().<span class="built_in">any</span>()]  <span class="comment"># 任何 na 行</span></span><br><span class="line">df.loc[:, df.notnull().<span class="built_in">any</span>()] <span class="comment"># 任何 na 行</span></span><br><span class="line">df.dropna(how=<span class="string">&#x27;any&#x27;</span>)</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="understand-dataframe-index">Understand Dataframe index</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Series</span></span><br><span class="line">prices = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1.5</span>, <span class="number">4</span>, <span class="number">4.5</span>]</span><br><span class="line">shares = pd.Series(prices)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Series，从数组指定索引值</span></span><br><span class="line">days = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thur&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>]</span><br><span class="line">shares = pd.Series(prices, index=days)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可使用下标访问索引值，也可以切片</span></span><br><span class="line">shares.index[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给索引起名</span></span><br><span class="line">shares.name = <span class="string">&quot;Share&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给索引赋值会出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重索引访问索引名</span></span><br><span class="line"><span class="comment"># df.index.name  -&gt; None</span></span><br><span class="line"><span class="comment"># df.index.names -&gt; [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引排序</span></span><br><span class="line">df.sort_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引的顺序进行排序</span></span><br><span class="line">df.reindex([<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照另外一个dataframe index 的顺序排序</span></span><br><span class="line">df2 = pd.DataFrame()</span><br><span class="line">df.reindex(df2.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重索引选择，使用元组</span></span><br><span class="line">df.loc[(<span class="string">&#x27;idx1&#x27;</span>,<span class="string">&#x27;idx2&#x27;</span>), <span class="string">&#x27;col_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只选择单个索引，会返回该索引内部得值（包括子索引）</span></span><br><span class="line">df.loc[<span class="string">&#x27;idx1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 slice 函数，对第一层不设条件，返回第二层 ab 结果</span></span><br><span class="line">df.loc[<span class="built_in">slice</span>(<span class="literal">None</span>), <span class="built_in">slice</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)]</span><br></pre></td></tr></table></figure><h2 id="manipulating">Manipulating</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.eggs[df.salt &gt; <span class="number">55</span>] += <span class="number">5</span>   <span class="comment"># 加</span></span><br><span class="line">df.floordiv(<span class="number">12</span>)              <span class="comment"># 类似 dataframe // other，支持fill_value</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="melt">Melt</h3><ul><li>Melt：适用于列中存在值，需要整理到行中的情况</li><li>Pivoting: 与Melt 相反，将1列中唯一的值放到不同的列上</li></ul><h3 id="pivot">Pivot</h3><ul><li>Pivot 根据列值 Reshape 数据，有重复值会出错</li><li>PivotTable 根据列值 Reshape 数据，有重复值可指定 aggregate 函数(sum, count, etc.)</li><li>都可以指定多个 index 或者 columns</li></ul><h3 id="stack-和-unstack">Stack 和 Unstack</h3><ul><li>UnStack 将行上的多 index 中的某一个放到 column 上，需要指定参数 level= '' ，即index 中的某个值；传给 level 的也可以是一个数字比如 0,1 等，取决于 index 的层数</li><li>Stack 将 column 上的 index 放到行上</li><li>多索引中，可使用 swaplevel 方式交换两个索引的顺序</li></ul><h3 id="group-by">Group by</h3><p>Groupby 一般有几个步骤：</p><ul><li>根据某些列按其值分割成不同的组</li><li>对每个组，指定内部的某些列进行操作</li><li>将这些操作后的结果组合起来</li></ul><p>Groupby 有一些特殊操作方便我们使用：</p><ul><li>第一个分割组的操作，可以传入自定义的 Series, 不限定于列名</li><li>groupby 的时候，使用 category 类型的数据会加快速度</li><li>组合组内部的操作，一般使用 mean, sum, max 等，但也可以一次指定多个函数，如 <code>df.groupby(['a','b']).agg('a':'sum')</code>, 也可以指定自定义的函数</li></ul><p>Groupby 可以和 transformation 结合使用，看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zscore</span>(<span class="params">series</span>):</span></span><br><span class="line">    <span class="string">&quot;对 Series 中的值，每一个都减去其平均值，再除以标准差&quot;</span></span><br><span class="line">   <span class="keyword">return</span> (series - series.mean()) / series.std()</span><br></pre></td></tr></table></figure><p>使用的时候，直接传入 dataframe 的某列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore(df[<span class="string">&#x27;mpg&#x27;</span>]).head()</span><br></pre></td></tr></table></figure><p>所以，我们也可以接 group 去使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;yr&#x27;</span>)[<span class="string">&#x27;mpg&#x27;</span>].transform(zscore).head()</span><br></pre></td></tr></table></figure><p>进一步的，可以把一些操作组合起来放到一个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zscore_with_year_and_name</span>(<span class="params">group</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;针对每一个 group，只取其中的某些列（mpg, year, name）做一些操作并组合成新的 dataframe</span></span><br><span class="line"><span class="string">       对于操作：mpg，算 zscore; yr 重命名为 year; name 不操作.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    df = pd.DataFrame(&#123;</span><br><span class="line">            <span class="string">&#x27;mpg&#x27;</span>: zscore(group[<span class="string">&#x27;mpg&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;year&#x27;</span>: group[<span class="string">&#x27;yr&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: group[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">df.groupby(<span class="string">&#x27;yr&#x27;</span>).apply(zscore_with_year_and_name).head()</span><br></pre></td></tr></table></figure><p>有时候你分组操作后，需要再进行 filter 操作，这需要拿到 groupby 之后的对象进行遍历操作。</p><p>首先我们来看看 groupby 操作后得到的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">splitting = auto.groupby(<span class="string">&#x27;yr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(splitting)</span><br><span class="line"><span class="comment"># pandas.core.groupby.DataFrameGroupBy</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(splitting.groups)</span><br><span class="line"><span class="comment"># dict</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(splitting.groups.keys())</span><br><span class="line"><span class="comment"># dict_keys([70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82])</span></span><br></pre></td></tr></table></figure><p>你可以对 group 对象进行遍历:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> groupname, group <span class="keyword">in</span> splitting:</span><br><span class="line">   avg = group[<span class="string">&#x27;mpg&#x27;</span>].mean()</span><br><span class="line">   <span class="built_in">print</span>(group_name, avg)</span><br></pre></td></tr></table></figure><p>对于一个 group 对象，你也可以对其使用 loc 操作，所以在内部我们可以进行 filter:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 group filter，只找出 name 包含 chevrolet 的组，取出其 mpg 列求 mean</span></span><br><span class="line"><span class="comment"># 返回的是单个值</span></span><br><span class="line">group.loc[group[<span class="string">&#x27;name&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;chevrolet&#x27;</span>), <span class="string">&#x27;mpg&#x27;</span>].mean()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结合操作，得到一个 Series</span></span><br><span class="line">chevy_means = &#123;</span><br><span class="line">    year: group.loc[group[<span class="string">&#x27;name&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;chevrolet&#x27;</span>),<span class="string">&#x27;mpg&#x27;</span>].mean()</span><br><span class="line">    <span class="keyword">for</span> year, group <span class="keyword">in</span> splitting</span><br><span class="line">&#125;</span><br><span class="line">pd.Series(chevy_means)</span><br></pre></td></tr></table></figure><p>一组条件，也可以当作 groupby 的列，如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chevy 一组 True, False，其值反映了df name列中包含 chevrolet 的行</span></span><br><span class="line">chevy = df[<span class="string">&#x27;name&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;chevrolet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 chevy 作为 groupby 条件</span></span><br><span class="line">df.groupby([<span class="string">&#x27;yr&#x27;</span>, chevy])[<span class="string">&#x27;mpg&#x27;</span>].mean()</span><br></pre></td></tr></table></figure><h3 id="concat">Concat</h3><ul><li>Concat 时可以指定 index，如 <code>pd.concat([rain2013, rain2014], keys=[2013, 2014], axis=0)</code>，如果两个 df 本来就有 index，则会产生多 index</li><li>index 也可以在 column 上，如 <code>pd.concat([rain2013, rain2014], keys=[2013, 2014], axis='columns')</code></li><li>可以将两个数组左右拼接到一起，可以使用 <code>np.hstack([B, A])</code> 或者 <code>np.concatenate([B, A], axis=1)</code></li></ul><h3 id="merge">Merge</h3><ul><li>merge 时，指定 suffixis 参数来区分来自不同 dataframe 的列</li><li>对于特殊的 merge，可以了解 <code>pandas.merge_asof</code> 和 <code>pandas.merge_ordered</code> 方法</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍了 Pandas 中的 Index，Series, Dataframe 及其基本操作。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 数据导入</title>
    <link href="https://scottzhang.pro/article/973c6fd9.html"/>
    <id>https://scottzhang.pro/article/973c6fd9.html</id>
    <published>2022-05-17T01:56:08.000Z</published>
    <updated>2022-05-17T01:58:46.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些常用数据导入的代码示例与技巧。</p></blockquote><span id="more"></span><h3 id="从网络">从网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign url of file: url</span></span><br><span class="line">url = <span class="string">&#x27;https://you_url/you_file.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save file locally</span></span><br><span class="line">urlretrieve(url,<span class="string">&#x27;you_file.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read file into a DataFrame and print its head</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;you_file.csv&#x27;</span>, sep=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><h3 id="直接用pd读取">直接用PD读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import packages</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign url of file: url</span></span><br><span class="line">url = <span class="string">&#x27;https://s3.amazonaws.com/assets.datacamp.com/production/course_1606/datasets/winequality-red.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read file into a DataFrame: df</span></span><br><span class="line">df = pd.read_csv(url,sep=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of the DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot first column of df</span></span><br><span class="line">pd.DataFrame.hist(df.ix[:, <span class="number">0</span>:<span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;fixed acidity (g(tartaric acid)/dm$^3$)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="网络读取excel文件">网络读取excel文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign url of file: url</span></span><br><span class="line">url = <span class="string">&#x27;http://s3.amazonaws.com/assets.datacamp.com/course/importing_data_into_r/latitude.xls&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in all sheets of Excel file: xl</span></span><br><span class="line">xl = pd.read_excel(url,sheetname = <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the sheetnames to the shell</span></span><br><span class="line"><span class="built_in">print</span>(xl.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of the first sheet (using its name, NOT its index)</span></span><br><span class="line"><span class="built_in">print</span>(xl[<span class="string">&#x27;1700&#x27;</span>].head())</span><br></pre></td></tr></table></figure><h3 id="从-json文件">从 Json文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load JSON: json_data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a_movie.json&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json_data = json.load(json_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print each key-value pair in json_data</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> json_data.keys():</span><br><span class="line">    <span class="built_in">print</span>(k + <span class="string">&#x27;: &#x27;</span>, json_data[k])</span><br></pre></td></tr></table></figure><h3 id="从-api-请求-json">从 api 请求 json</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign URL to variable: url</span></span><br><span class="line">url = <span class="string">&#x27;http://www.omdbapi.com/?apikey=72bc447a&amp;t=social+network&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Package the request, send the request and catch the response: r</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decode the JSON data into a dictionary: json_data</span></span><br><span class="line">json_data = r.json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print each key-value pair in json_data</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> json_data.keys():</span><br><span class="line">    <span class="built_in">print</span>(k + <span class="string">&#x27;: &#x27;</span>, json_data[k])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从-api-如维基百科">从 API 如:维基百科</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign URL to variable: url</span></span><br><span class="line">url = <span class="string">&#x27;https://en.wikipedia.org/w/api.php?action=query&amp;prop=extracts&amp;format=json&amp;exintro=&amp;titles=pizza&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Package the request, send the request and catch the response: r</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decode the JSON data into a dictionary: json_data</span></span><br><span class="line">json_data = r.json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the Wikipedia page extract</span></span><br><span class="line">pizza_extract = json_data[<span class="string">&#x27;query&#x27;</span>][<span class="string">&#x27;pages&#x27;</span>][<span class="string">&#x27;24768&#x27;</span>][<span class="string">&#x27;extract&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(pizza_extract)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从-api-如-推特">从 API 如: 推特</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> tweepy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store OAuth authentication credentials in relevant variables</span></span><br><span class="line">access_token = <span class="string">&quot;&quot;</span></span><br><span class="line">access_token_secret = <span class="string">&quot;&quot;</span></span><br><span class="line">consumer_key = <span class="string">&quot;&quot;</span></span><br><span class="line">consumer_secret = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pass OAuth details to tweepy&#x27;s OAuth handler</span></span><br><span class="line">auth = tweepy.OAuthHandler(consumer_key, consumer_secret)</span><br><span class="line">auth.set_access_token(access_token,access_token_secret)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="条件导入">条件导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过第一行，至需要第一和第三列</span></span><br><span class="line">data = np.loadtxt(file, delimiter=<span class="string">&#x27;\t&#x27;</span>, skiprows=<span class="number">1</span>, usecols=[<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># delimiter分隔符</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&#x27;titanic.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, names=<span class="literal">True</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># nrows，只需要前面5行，header只可以等于None，而不是Bool</span></span><br><span class="line">pd.read_csv(file,nrows=<span class="number">5</span>, header=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="获取文件列表">获取文件列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">wd = os.getcwd()</span><br><span class="line">os.listdir(wd)</span><br></pre></td></tr></table></figure><h3 id="从-excel">从 excel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assign spreadsheet filename: file</span></span><br><span class="line">file = <span class="string">&#x27;battledeath.xlsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load spreadsheet: xl</span></span><br><span class="line">xl = pd.ExcelFile(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print sheet names</span></span><br><span class="line"><span class="built_in">print</span>(xl.sheet_names)</span><br></pre></td></tr></table></figure><h3 id="从-sas-文件">从 SAS 文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From sas7bdat <span class="keyword">import</span> SAS7BDAT</span><br><span class="line"></span><br><span class="line">Data = pd.read_stata(<span class="string">&#x27;urbanpop.dta&#x27;</span>)</span><br><span class="line"><span class="comment"># sas文件变成dataframe</span></span><br><span class="line"><span class="keyword">with</span> SAS7BDAT(<span class="string">&#x27;sales.sas7bdat&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    df_sas = file.to_data_frame()</span><br></pre></td></tr></table></figure><h3 id="从-mat文件">从 mat文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import package</span></span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load MATLAB file: mat</span></span><br><span class="line">mat = scipy.io.loadmat(<span class="string">&#x27;albeck_gene_expression.mat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the datatype type of mat</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(mat))</span><br></pre></td></tr></table></figure><h3 id="从数据库">从数据库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import packages</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create engine: engine</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;sqlite:///Chinook.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open engine connection: con</span></span><br><span class="line">con = engine.connect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perform query: rs</span></span><br><span class="line">rs = con.execute(<span class="string">&#x27;select * from Album&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save results of the query to DataFrame: df</span></span><br><span class="line">df = pd.DataFrame(rs.fetchall())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close connection</span></span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print head of DataFrame df</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line">从DB导入指定条数据，重命名列名:</span><br><span class="line"><span class="keyword">with</span> engine.connect() <span class="keyword">as</span> con:</span><br><span class="line">    rs = con.execute(<span class="string">&#x27;SELECT LastName, Title FROM Employee&#x27;</span>)</span><br><span class="line">    df = pd.DataFrame(rs.fetchmany(size=<span class="number">3</span>))</span><br><span class="line">    df.columns = rs.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the length of the DataFrame df</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(df))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the head of the DataFrame df</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="提高数据导入速度">提高数据导入速度</h3><ul><li><a href="https://www.kaggle.com/c/home-credit-default-risk/discussion/59575">Faster data loading with Pandas</a></li><li><a href="https://medium.com/@bobhaffner/gist-to-medium-test-db3d51b8ba7b">DataFrame IO Performance with Pandas, dask, fastparquet and HDF5</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些常用数据导入的代码示例与技巧。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 安装</title>
    <link href="https://scottzhang.pro/article/6f1b3942.html"/>
    <id>https://scottzhang.pro/article/6f1b3942.html</id>
    <published>2022-05-17T00:07:25.000Z</published>
    <updated>2022-05-17T03:45:13.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章将带你安装 Python 环境以使用 Pandas。</p></blockquote><span id="more"></span><h1 id="环境配置">环境配置</h1><h2 id="检查是否已安装-python">检查是否已安装 Python</h2><p>检查你的 Python 版本:</p><ul><li><code>python --version</code></li><li><code>python -V</code></li></ul><p>检查你的 Python 安装路径(用户):</p><ul><li><code>where.exe python</code></li></ul><p>小技巧: 打开你的 PowerShell:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 敲击电脑上的 Win 键.</span><br><span class="line">2. 键入 PowerShell.</span><br><span class="line">3. 敲击回车 (Enter)键.</span><br></pre></td></tr></table></figure><blockquote><p>你也可以使用 cmd.exe 或者是 <a href="https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab">Windows Terminal</a>.</p></blockquote><h2 id="windows-安装-python-的几种方式">Windows 安装 Python 的几种方式</h2><ul><li>微软官方商店, 微软公司提供的,主要面向学生与 python 初学者, 公司环境下无法从微软商店下载软件.</li><li>Windows Subsystem for Linux (WSL), 让你在 Windows 上可以直接运行 Linux, 公司环境下无法配置</li><li>Python 完整安装包, 推荐.(<a href="https://www.python.org/downloads/windows/">下载地址</a>)</li><li>Anaconda, 一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项, 推荐.</li></ul><p>推荐使用 Anaconda.</p><h2 id="如何安装-anaconda">如何安装 Anaconda</h2><ol type="1"><li>打开安装包</li></ol><p><img src="https://docs.anaconda.com/_images/win-install-destination.png" /></p><ol start="2" type="1"><li>添加到环境变量</li></ol><p><img src="https://docs.anaconda.com/_images/win-install-options.png" /></p><p>关于安装选项:</p><ul><li>add Anaconda3 to my PATH environment variable, 会影响其他依赖 python 的软件,根据自己的需要选择</li><li>Register Anaconda3 as my default Python x, 根据自己的需要选择</li></ul><p>关于安装版本, 32 还是 64? 这取决于你机器的处理器的配置, 记住64位机器可以处理32位程序,反之则不行.</p><p>Anaconda <a href="https://docs.anaconda.com/anaconda/install/windows/">Windows 官方安装指南</a></p><h2 id="如何管理-python-运行环境">如何管理 Python 运行环境</h2><h3 id="为什么要管理环境">为什么要管理环境</h3><ul><li>场景 1: 你的同事给你一份代码, Ta 基于 Python 3.6 写的, Pandas 1.0.1 版本, 你的版本过低或者过高导致无法运行</li><li>场景2: 你看到一个不错的 Python 包, 但是安装它会讲你目前的 Pandas 降级, 但是降级又会影响你平时的工作环境</li><li>场景3: 你需要部署你的工具,你想创建一个完全干净的环境来测试部署流程, 测试程序依赖的包是否可以工作</li></ul><h3 id="管理环境的工具">管理环境的工具</h3><table><colgroup><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /></colgroup><thead><tr class="header"><th></th><th>Python Version</th><th>Dependency Management</th><th>Virtual Environment</th><th>Environment Reproducibility</th></tr></thead><tbody><tr class="odd"><td>pyenv</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr class="even"><td>venv + pip</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td></tr><tr class="odd"><td>venv + pip-tools</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr class="even"><td>Poetry</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr class="odd"><td>Pipenv</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr class="even"><td>Docker</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td></tr><tr class="odd"><td>Conda</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr></tbody></table><h3 id="使用-conda">使用 Conda</h3><p>对于开发者来说, 电脑上有时候需要有多个 python 环境, 可以使用 Conda 进行来管理 Python 的环境与包, Conda 可以帮你创建、复制、克隆、管理一个全新隔离的环境, 同时也可以用来安装包, 它既具有pip的包管理能力，同时也具有vitualenv的环境管理功能 ，因此在功能上Conda可以看作是pip 和 vitualenv 的组合。</p><p>参考 <a href="https://docs.conda.io/projects/conda/en/4.6.0/_downloads/52a95608c49671267e40c689e0bc00ca/conda-cheatsheet.pdf">Conda CheatSheet</a></p><h2 id="如何安装-python-包">如何安装 Python 包</h2><h3 id="python-装包的选择">Python 装包的选择</h3><ul><li>pip</li><li>conda</li><li>其他略过</li></ul><h3 id="区别是什么">区别是什么?</h3><ul><li>包仓库不同, pip 可以找到, conda 不一定有</li><li>Pip安装Python包，而conda安装包可能包含用任何语言编写的软件的包</li><li>conda 会帮你解决包之间的依赖冲突</li><li>从使用角度来说, conda 比较慢 (可以考虑 <a href="https://mamba.readthedocs.io/en/latest/">Mamba</a>, 一个旨在替代 Conda 的工具)</li></ul><h3 id="使用-conda-1">使用 Conda</h3><ul><li>搜索包: <code>conda search PACKAGENAME</code></li><li>安装包: <code>conda install PACKAGENAME</code></li><li>更新包: <code>conda update PACKAGENAME</code></li><li>查看已安装的包: <code>conda list</code></li><li>卸载包: <code>conda remove PACKAGENAME</code></li></ul><h3 id="使用-pip">使用 Pip</h3><ul><li>搜索包: <code>pip search</code>, currently disabled</li><li>安装包: <code>pip install PACKAGENAME</code></li><li>更新包: <code>pip install --upgrade PACKAGENAME</code></li><li>查看已安装包: <code>pip list</code></li><li>卸载包: <code>pip uninstall PACKAGENAME</code></li></ul><h3 id="在-nielseniq-装包">在 NielsenIQ 装包</h3><ul><li>因为众所周知的原因, 国内外网经常抽风,而 pip 和 conda 下载包默认都是从国外的服务器下载</li><li>为了解决这个问题,国内有一些高等院校和知名企业免费托管了很多包资源,只需要将下载服务器更改为国内地址即可加速包的下载</li><li>可以使用清华大学开源软件镜像站来加速, 你也可以使用其他的镜像站<ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">pip</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">anaconda</a></li></ul></li></ul><h2 id="在哪里编写代码">在哪里编写代码?</h2><h3 id="ides-还是代码编辑器">IDEs 还是代码编辑器?</h3><p>IDE (or Integrated Development Environment) 是一个专注于软件开发的程序, 它通常包含了许多软件开发的工具集, 例如:</p><ul><li>处理代码的编辑器(如高亮代码, 自动补全)</li><li>编译、执行, debug 工具</li><li>或有版本控制的工具</li><li>大部分IDE支持多种语言, 或是拥有更多的功能(也有专门为某种语言开发的IDE, 如针对 Golang 的 Goland, Python 的 Pycharm)</li></ul><p>代码编辑器或者说文本编辑器, 大部分都有代码高亮、格式化的功能, 一些优秀的代码编辑器还可以通过插件实现版本控制、多种语言的支持.</p><h3 id="常用-ides-和代码编辑器">常用 IDEs 和代码编辑器</h3><p>IDEs: - Visual Studio, 微软开发的 IDEs, 特性丰富 - Eclipse + PyDev, 知名 java 编辑器 Eclipse 针对 Python 出的版本</p><p>代码编辑器: - Sublime Text, Google 工程师开发的梦想中的编辑器 - Visual Studio Code - Atom, 全平台支持的代码编辑器 - GNU Emacs, Vi / Vim</p><p>针对 Python 的 IDEs:</p><ul><li>PyCharm, 最优秀的 Python IDE 之一, 有付费版和社区免费版</li><li>Spyder, 为 data science 工作流程优化的 IDE, Anaconda 附带.</li><li>Thonny, 为初学者准备的 IDE</li></ul><h3 id="使用-vs-code">使用 VS Code</h3><ul><li>微软为 VS Code 提供了官方的 Python 工具包</li><li>VS Code 也支持编辑 Jupyter-Notebook</li><li>丰富的插件，让你可以许多可定制化的功能，如支持 Git 版本控制、远程编辑服务器上的文件、Debug Jupyter-Notebook 的代码等</li></ul><h3 id="使用-jupyter-notebook-lab">使用 Jupyter Notebook &amp; Lab</h3><p>介绍：</p><ul><li>Jupyter Notebook 交互式笔记本，支持运行40 多种编程语言，代码基于 Cell 组织，按 Cell 运行，所见即所得，主要用户是数据科学家</li><li>Jupiter lab 在 Notebook 的基础上，拥有更灵活的布局、可拖动的 Cell、跨 Notebook 之间的编辑，集成终端等丰富的功能</li></ul><p>启动：</p><ul><li>直接通过应用程序中的 jupyter notebook 打开，默认工作目录是 <code>用户主目录/</code></li><li>若需指定工作目录，可以打开 Powershell，切换到你的目标工作目录，再输入 jupyter-notebook 并回车（jupyter-lab 同理）</li><li>若提示 port error，需指定端口，如 <code>jupyter-notebook --port 8889</code></li><li>Jupyter 的工作环境可以在你使用 Conda 创建的环境中切换</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章将带你安装 Python 环境以使用 Pandas。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pandas 系列" scheme="https://scottzhang.pro/categories/Pandas-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Pandas" scheme="https://scottzhang.pro/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 两数之和与三数之和</title>
    <link href="https://scottzhang.pro/article/347c867a.html"/>
    <id>https://scottzhang.pro/article/347c867a.html</id>
    <published>2022-05-16T14:51:09.000Z</published>
    <updated>2022-05-17T01:40:59.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/">📌</a> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p></blockquote><span id="more"></span><h3 id="两数之和">两数之和</h3><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>():</span></span><br><span class="line">    hashtable = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">            <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">        hashtable[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="三数之和">三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><a href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">算法流程</a>：</p><ol type="1"><li>特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。</li><li>对数组进行排序。</li><li>遍历排序后数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 若 nums[i] &gt; 0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</span><br><span class="line">- 对于重复元素：跳过，避免出现重复解</span><br><span class="line">- 令左指针 L=i+1，右指针 R=n−1，当 L&lt;R 时，执行循环：</span><br><span class="line">    - 当 nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</span><br><span class="line">    - 若和大于 0，说明 nums[R] 太大，R 左移</span><br><span class="line">    - 若和小于 0，说明 nums[L] 太小，L 右移</span><br></pre></td></tr></table></figure><p>简单演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-1, 0, 1, 2, -1, -4]</span><br><span class="line">[ I, L, 1, 2, -1,  R]</span><br><span class="line">[ I, 0, L, 2, -1,  R]</span><br><span class="line">[ I, 0, L, 2,  R, -4]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># null, 长度 &lt; 3, 返回 []</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> nums <span class="keyword">or</span> n &lt; <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 排序方便操作</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 连续两个重复值，前面已经尝试过所有组合，所以跳过    </span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># L 从 i+1 开始，R 从数组长度 -1 开始</span></span><br><span class="line">        L = i+<span class="number">1</span></span><br><span class="line">        R = n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(L &lt; R):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[L]+nums[R] == <span class="number">0</span>):</span><br><span class="line">                res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                <span class="keyword">while</span>(L &lt; R <span class="keyword">and</span> nums[L] == nums[L+<span class="number">1</span>]):</span><br><span class="line">                    L = L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span>(L &lt; R <span class="keyword">and</span> nums[R] == nums[R-<span class="number">1</span>]):</span><br><span class="line">                    R = R-<span class="number">1</span></span><br><span class="line">                L = L+<span class="number">1</span></span><br><span class="line">                R = R-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span>(nums[i]+nums[L]+nums[R] &gt; <span class="number">0</span>):</span><br><span class="line">                R = R-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = L+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">threeSum(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle/&quot;&gt;📌&lt;/a&gt; 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 字母异位词分组</title>
    <link href="https://scottzhang.pro/article/2239a89.html"/>
    <id>https://scottzhang.pro/article/2239a89.html</id>
    <published>2022-05-16T14:50:37.000Z</published>
    <updated>2022-05-17T01:36:29.592Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/group-anagrams/">📌</a> 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。Leetcode</p></blockquote><span id="more"></span><h3 id="思考">思考</h3><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>使用题目"有效的字母异位词"思路判断异位词。</p><p>对数组中的每一个元素进行组合执行上面的判断， 需要将所有的异位词放到一个数组，所以需要构建另外一个数组。</p><p>如果找到了一个新的形式，需要将新的放到这个数组，比对的对象可以是第一个，因为所有异位词之间应该都是相等的关系， 那么可以使用第一个遇到的词语作为键和值，后续找到的新的放到值中。</p><h3 id="解法">解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">strs: <span class="built_in">list</span></span>):</span></span><br><span class="line">    angram_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">            is_angram = isAnagramCounter(strs[i], strs[j])</span><br><span class="line">            <span class="keyword">if</span> is_angram:</span><br><span class="line">                <span class="keyword">if</span> strs[i] <span class="keyword">in</span> angram_dict:</span><br><span class="line">                    angram_dict[strs[i]].append(strs[j])</span><br><span class="line">                <span class="keyword">elif</span> strs[i] <span class="keyword">in</span> angram_dict.values():</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    angram_dict[strs[i]] = []</span><br><span class="line">                    angram_dict[strs[i]].append(strs[j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> angram_dict</span><br><span class="line"></span><br><span class="line">groupAnagrams(strs)</span><br></pre></td></tr></table></figure><p>上面的双重循环增加了很多复杂度，可以直接借鉴排序的优秀解法，其中 tuple(sorted(w)) 也可以换成 ''.join(sorted(w))。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记住 d.get(key, []) + [w]</span></span><br><span class="line">strs = [<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>,<span class="string">&quot;tan&quot;</span>,<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;bat&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">strs</span>):</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">sorted</span>(strs):</span><br><span class="line">        key = <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(w))</span><br><span class="line">        d[key] = d.get(key, []) + [w]</span><br><span class="line">    <span class="keyword">return</span> d.values()</span><br><span class="line"></span><br><span class="line">groupAnagrams(strs)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/group-anagrams/&quot;&gt;📌&lt;/a&gt; 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。Leetcode&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字典" scheme="https://scottzhang.pro/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 有效的字母异位词</title>
    <link href="https://scottzhang.pro/article/f2f7dffe.html"/>
    <id>https://scottzhang.pro/article/f2f7dffe.html</id>
    <published>2022-05-16T14:50:24.000Z</published>
    <updated>2022-05-17T01:36:39.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/valid-anagram/">📌</a> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p></blockquote><span id="more"></span><p>直接排序，异位词的顺序不同出现的次数一样，所以使用 sort 方法排序后的值应该相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagramSort</span>(<span class="params">s, t</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    s_sorted = <span class="built_in">sorted</span>(s)</span><br><span class="line">    t_sorted = <span class="built_in">sorted</span>(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s_sorted == t_sorted:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">isAnagramSort(a, b)</span><br></pre></td></tr></table></figure><p>使用 collection 中的 Counter。</p><p>Counter 支持比较运算符 ==, !=, &lt;, &lt;=, &gt;, &gt;=.</p><p>需要注意对于个数为 0的，不算入比较的范围，如 Counter(a=1) == Counter(a=1, b=0) 返回 true.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagramCounter</span>(<span class="params">s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">return</span> collections.Counter(s) == collections.Counter(t)</span><br></pre></td></tr></table></figure><p>链接：</p><ul><li><a href="https://leetcode.com/problems/valid-anagram/">英文站</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-anagram/&quot;&gt;📌&lt;/a&gt; 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://scottzhang.pro/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="collections" scheme="https://scottzhang.pro/tags/collections/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 用队列实现栈</title>
    <link href="https://scottzhang.pro/article/5a9968.html"/>
    <id>https://scottzhang.pro/article/5a9968.html</id>
    <published>2022-05-16T14:45:32.000Z</published>
    <updated>2022-05-17T01:37:20.384Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">📌</a> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）</p></blockquote><span id="more"></span><p>实现 MyStack 类：</p><ul><li>void push(int x) 将元素 x 压入栈顶。</li><li>int pop() 移除并返回栈顶元素。</li><li>int top() 返回栈顶元素。</li><li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。  </li></ul><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue1 = []</span><br><span class="line">        self.queue2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.queue1.append(x)</span><br><span class="line">        self.queue2 = <span class="built_in">list</span>(<span class="built_in">reversed</span>(self.queue1))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue2.pop()</span><br><span class="line">        <span class="keyword">del</span> self.queue1[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue1) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mystack = MyStack()</span><br><span class="line">mystack.push(<span class="number">1</span>)</span><br><span class="line">mystack.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">mystack.queue2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-stack-using-queues/&quot;&gt;📌&lt;/a&gt; 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://scottzhang.pro/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 最小栈问题</title>
    <link href="https://scottzhang.pro/article/302a7493.html"/>
    <id>https://scottzhang.pro/article/302a7493.html</id>
    <published>2022-05-16T14:45:17.000Z</published>
    <updated>2022-05-17T01:36:36.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/min-stack/">📌</a> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p></blockquote><span id="more"></span><p>实现 MinStack 类:</p><ul><li>MinStack() 初始化堆栈对象。</li><li>void push(int val) 将元素val推入堆栈。</li><li>void pop() 删除堆栈顶部的元素。</li><li>int top() 获取堆栈顶部的元素。</li><li>int getMin() 获取堆栈中的最小元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack2Arr</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;内部使用了两个栈（一个辅助栈）&quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/min-stack/&quot;&gt;📌&lt;/a&gt; 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 有效的括号</title>
    <link href="https://scottzhang.pro/article/6d4e3bea.html"/>
    <id>https://scottzhang.pro/article/6d4e3bea.html</id>
    <published>2022-05-16T14:45:03.000Z</published>
    <updated>2022-05-17T01:36:42.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/valid-parentheses/">📌</a> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p></blockquote><span id="more"></span><p>注意：有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。</p><p>左括号必须以正确的顺序闭合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;注意理解栈的原理&quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="built_in">dict</span> = &#123;<span class="string">&quot;]&quot;</span>:<span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>:<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;)&quot;</span>:<span class="string">&quot;(&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># 查 value，如果出现左括号，将其放到栈中</span></span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> <span class="built_in">dict</span>.values():</span><br><span class="line">            stack.append(char)</span><br><span class="line">        <span class="comment"># 如果是出现了右括号、若栈是空的或者</span></span><br><span class="line">        <span class="comment"># 根据右边括号找到对应的左括号不等于栈顶元素，返回 False</span></span><br><span class="line">        <span class="keyword">elif</span> char <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">            <span class="keyword">if</span> stack == [] <span class="keyword">or</span> <span class="built_in">dict</span>[char] != stack.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 其他情况，返回 False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> stack == []</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/valid-parentheses/&quot;&gt;📌&lt;/a&gt; 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="栈" scheme="https://scottzhang.pro/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 判断环形链表</title>
    <link href="https://scottzhang.pro/article/50c0087b.html"/>
    <id>https://scottzhang.pro/article/50c0087b.html</id>
    <published>2022-05-16T14:40:24.000Z</published>
    <updated>2022-05-17T01:36:24.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/">📌</a> 给你一个链表的头节点 head ，判断链表中是否有环。</p></blockquote><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_cycle_set</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用集合或者哈希表，记录访问过的节点，若再次出现则有环</span></span><br><span class="line"><span class="string">       1. 时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</span></span><br><span class="line"><span class="string">       2. 空间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seen.add(head)</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_cycle_fast_slow_pointer</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用两个指针，一快一慢遍历链表，如果链表存在环，则最终快指针肯定会与慢指针相遇</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果头节点为空或者头结点没有下一个结点，则不存在环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义两个快慢指针遍历，这里快指针比慢指针先出发</span></span><br><span class="line">    <span class="comment"># 不是同一个位置出发，这么写的原因是 while 的条件需要一开始</span></span><br><span class="line">    <span class="comment"># 处于不满足的情况</span></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        <span class="comment"># 如果 fast 为空或没有下一个结点，说明遍历到了链表尾部</span></span><br><span class="line">        <span class="comment"># 说明不存在环，有环的话会循环到前面的结点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动快慢指针</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># while 后的条件为 True，即 slow == fast, 说明存在环</span></span><br><span class="line">    <span class="comment"># 此时 slow 指向的结点 == fast 指向的结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>链表的访问是从第一个结点开始的，不要用数组的思维去理解链表</p><p>在链表操作中，通常会创建一个伪结点，又称 dummy 结点，使用 dummy 结点的好处是 1. 在链表初始化的时候，没有合适的结点可以使用，用一个伪结点开始初始化比较方便，但需要注意在返回的时候需要返回 dummy.next. 2. 可以使用 <code>while node</code> 或者是 <code>if node</code> ，来判断某个结点是否有 next</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle/&quot;&gt;📌&lt;/a&gt; 给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="链表" scheme="https://scottzhang.pro/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法题: 合并 K 个排序链表</title>
    <link href="https://scottzhang.pro/article/6b8b3431.html"/>
    <id>https://scottzhang.pro/article/6b8b3431.html</id>
    <published>2022-05-16T14:38:39.000Z</published>
    <updated>2022-05-17T01:36:26.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">📌</a> 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><span id="more"></span><h3 id="合并-k-个排序链表">合并 K 个排序链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</span><br><span class="line">输出：[1, 1, 2, 3, 4, 4, 5, 6]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;顺序合并，效率不是很高&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">        d = c = ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                c.<span class="built_in">next</span>, l1 = l1, l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c.<span class="built_in">next</span>, l2 = l2, l2.<span class="built_in">next</span></span><br><span class="line">            c = c.<span class="built_in">next</span></span><br><span class="line">        c.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> d.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        ans = merge(ans, i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">mergeKLists([l1, l2])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    p = dummy</span><br><span class="line">    head = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">        <span class="keyword">if</span> lists[i]:</span><br><span class="line">            heapq.heappush(head, (lists[i].val, i))</span><br><span class="line">            lists[i] = lists[i].<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        val, idx = heapq.heappop(head)</span><br><span class="line">        p.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> lists[idx]:</span><br><span class="line">            heapq.heappush(head, (lists[idx].val, idx))</span><br><span class="line">            lists[idx] = lists[idx].<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-k-sorted-lists/&quot;&gt;📌&lt;/a&gt; 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://scottzhang.pro/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="链表" scheme="https://scottzhang.pro/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
