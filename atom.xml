<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2021-12-20T09:19:39.461Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 语法概览 P3</title>
    <link href="https://scottzhang.pro/article/4074d0e9.html"/>
    <id>https://scottzhang.pro/article/4074d0e9.html</id>
    <published>2021-12-20T09:13:01.000Z</published>
    <updated>2021-12-20T09:19:39.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.</p></blockquote><span id="more"></span><h1 id="方法">方法</h1><p>Go 没有类。不过你可以为结构体类型定义方法，Go 中方法是带特殊的 {接收者} 参数的函数（方法其实就是函数，只是带了个接收者）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------后续代码将省略上面的部分------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 位于 func 关键字和方法名之间</span></span><br><span class="line"><span class="comment">// 在下面的例子中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：方法相当于函数，所以下面的写法功能是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是在使用的时候，不再是 v.Abs(), 而是 Abs(v)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非结构体也是可以声明方法的，比如对于 float：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 为 (f MyFloat)，方法名为 Abs, 返回 float64</span></span><br><span class="line"><span class="comment">// 没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">f := MyFloat(<span class="number">-1</span>)</span><br><span class="line">f.Abs()</span><br></pre></td></tr></table></figure><p>但是，你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。</p><p>上面的接收者为值接收者，实际上接收者还有一种叫做指针接收者，因为使用指针接收者，你可以在方法内部修改值，所以指针接收者比值接收者更常用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值接收者 (v Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取值、计算</span></span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者 (v *Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析输出</span></span><br><span class="line"><span class="comment">// 如果是指针接收者:</span></span><br><span class="line"><span class="comment">// Scale: 3*10 = 30; 4*10 = 40</span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果将指针接收者改为值接收者</span></span><br><span class="line"><span class="comment">// 即 (v *Vertex) -&gt; (v Vertex)</span></span><br><span class="line"><span class="comment">// Scale: 3 ; 4 </span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法和指针重定向; 在函数中，如果要求的参数是指针，传值会报错；如果使用指针接收者，则既可以传值，也可以传指针；反之如果要求的参数是值，在函数中传指针也会出错，指针接收者则也可以避免这种情况。</p><p>使用指针接收者的好处是：</p><ol type="1"><li>指针能够修改传进来的值</li><li>因为传的是指针，避免了值的复制，更高效</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 因为参数指定为指针，直接传值会出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="comment">// 下面这两种方式都可以工作</span></span><br><span class="line"><span class="comment">// v.Scale(10), (&amp;v).scale(10)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口">接口</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个几何形状的接口，拥有面积和</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形和圆的结构体</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 rect 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 circle 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// measure 函数，基于 geometory 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">    c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    measure(r)</span><br><span class="line">    measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接口的另一个例子, 首先是完整的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们逐一来看，方便研究，首先是直接将变量赋值给接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">a = f</span><br><span class="line"></span><br><span class="line">fmt.Println(f.Abs()) <span class="comment">// 为 MyFload 实现了 Abs 方法, 即</span></span><br><span class="line">fmt.Println(a.Abs()) <span class="comment">// MyFloat 实现了 Abser</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是将结构体赋值给接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line"></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它们不同的地方在于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件</span></span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义不同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;  <span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同</span></span><br><span class="line">a = f  <span class="comment">// a.Abs(), work; a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a.Abs(), work; a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">a = v </span><br><span class="line"><span class="comment">// a.Abs(), Error; Vertex does not implement Abser; 如果将</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() float64 改为</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() 则可以正常运行</span></span><br></pre></td></tr></table></figure><p>接口的隐式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事</span></span><br><span class="line"><span class="comment">// 直接将 func 的名字设置成 接口中的名字即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也是值，所以可以像值一样传递。可以用作参数和函数的返回值。</p><p>接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组 <code>(value, type)</code>, 接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 接口 I，其中规定了需要实现 M() 方法</span></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体 T，其中有 string 类型的 S</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为结构体 T 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (t *T) 为指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 float64 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (f F) 为值接收者</span></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印函数，参数为接口 I</span></span><br><span class="line"><span class="comment">// %v：值的 value</span></span><br><span class="line"><span class="comment">// %T: 值的 type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复习</span></span><br><span class="line"><span class="comment">// &amp; 符号的意思是对变量取地址，如：变量a的地址是&amp;a</span></span><br><span class="line"><span class="comment">// * 符号的意思是对指针取值，如:*&amp;a，就是a变量所在地址的值，当然也就是a的值了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I        <span class="comment">// 声明接口 i</span></span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125; <span class="comment">// 定了结构体 -&gt; 取该结构体的地址 -&gt; 给 i</span></span><br><span class="line">describe(i)     <span class="comment">// 打印结构体地址的值，以及 type</span></span><br><span class="line">i.M()           <span class="comment">// 结构体增加了 M() 方法，运行成功</span></span><br><span class="line"></span><br><span class="line">i = F(math.Pi)  <span class="comment">// F 是自定义的 float64，初始化值为 math.pi -&gt; 给 i</span></span><br><span class="line">describe(i)        <span class="comment">// 打印 i 的值和地址</span></span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层值为 nil 的接口值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I     <span class="comment">// 声明接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T    <span class="comment">// 初始化一个结构体指针 t，零值为 nil</span></span><br><span class="line">i = t       <span class="comment">// 隐式实现了接口，使得 i 有了 M() 方法</span></span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, *main.T)</span></span><br><span class="line"><span class="comment">&lt;nil&gt;</span></span><br><span class="line"><span class="comment">(&amp;&#123;hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>空接口, 它没有规定接口的方法，空接口可保存任何类型的值； 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 指定了零个方法的接口值</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于类型断言，它提供了访问接口值底层值的具体方式，并可以进行检测断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型选择，可以按顺序从接口值中选择值的类型，文法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个类型选择的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 类型选择中的 case 为类型（而非值</span></span><br><span class="line"><span class="comment">// 类型选择中的声明与类型断言 i.(T) 的语法相同</span></span><br><span class="line"><span class="comment">// 只是具体类型 T 被替换成了关键字 type</span></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Twice 21 is 42</span></span><br><span class="line"><span class="comment">&quot;hello&quot; is 5 bytes long</span></span><br><span class="line"><span class="comment">I don&#x27;t know about type bool!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面介绍一个普遍使用的接口，即 fmt 包中的 Stringer。一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">fmt.Println(a.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关于 Go 中的错误处理:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rror 为 nil 时表示成功；非 nil 的 error 表示失败。</span></span><br><span class="line">i, err := strconv.Atoi(<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure><p>关于文件读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line">        <span class="comment">// 在遇到数据流的结尾时，它会返回一个 io.EOF 错误</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于图像处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;image&quot;</span>  <span class="comment">// image 包定义了 Image 接口</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">// Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明</span></span><br><span class="line">fmt.Println(m.Bounds())</span><br><span class="line">fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并发">并发</h1><p>说到并发，首先介绍Go 中的 Go 程（goroutine），它是由 Go 运行时管理的轻量级线程。当你写 <code>go f(x, y, z)</code> 会启动一个新的 Go 程并执行 <code>f(x, y, z)</code>。</p><p>在 Go 程的运行过程中，f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p></blockquote><p>关于信道，在 Go 中，实质上是带有类型的管道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>信道操作符有 <code>-&gt;</code>, <code>&lt;-</code>，箭头的方向预示着数据流的方向。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收值并赋予 v。</span></span><br></pre></td></tr></table></figure><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于带缓冲的信道, 使用 make 创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br><span class="line"><span class="comment">// ch &lt;- 3</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于使用信道来说，还有两个基本的操作，即关闭信道，或者是检查一个信道是否关闭了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个求斐波拉契数列的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)  <span class="comment">// 使用 close 关闭信道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// 循环 for i := range c 会不断从信道接收值，直到它被关闭</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>注意：只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p></li><li><p>信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。</p></li></ul><p>关于 Go 总的 Select 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go&#x27;s _select_ lets you wait on multiple channel</span></span><br><span class="line"><span class="comment">// operations. Combining goroutines and channels with</span></span><br><span class="line"><span class="comment">// select is a powerful feature of Go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For our example we&#x27;ll select across two channels.</span></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each channel will receive a value after some amount</span></span><br><span class="line"><span class="comment">// of time, to simulate e.g. blocking RPC operations</span></span><br><span class="line"><span class="comment">// executing in concurrent goroutines.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// We&#x27;ll use `select` to await both of these values</span></span><br><span class="line"><span class="comment">// simultaneously, printing each one as it arrives.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中信道非常适合在不同的 Go 程中进行通信。但如果我们不需要通信呢？若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这个概念叫互斥，Go 中有一个专门的数据结构来提供这一功能，互斥锁 Mutex，<code>sync.Mutex</code>.</p><p><code>sync.Mutex</code> 中有两个方法，Lock 和 Ulock。</p><p>我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行</p><p>我们也可以用 defer 语句来保证互斥锁一定会被解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P2</title>
    <link href="https://scottzhang.pro/article/3773e07f.html"/>
    <id>https://scottzhang.pro/article/3773e07f.html</id>
    <published>2021-12-15T14:07:40.000Z</published>
    <updated>2021-12-20T09:19:09.900Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P2, 包括了指针、结构体、数组、切片、映射和闭包等内容。</p></blockquote><span id="more"></span><h1 id="指针">指针</h1><p>指针, 指针保存了值的地址:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针声明</span></span><br><span class="line"><span class="comment">// *int 是指向 int 类型的指针，其初始值（零值）为 nil</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp; 操作符会生成一个指向其操作数的指针</span></span><br><span class="line"><span class="comment">// 此处生成一个指向整数 42 的指针，赋值给 p</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取指针指向的值，操作也是 *</span></span><br><span class="line">fmt.Print(*p) <span class="comment">// 通过指针读取值</span></span><br><span class="line">*p = <span class="number">52</span>       <span class="comment">// 通过指针设置值</span></span><br></pre></td></tr></table></figure><h1 id="结构体">结构体</h1><p>结构体 struct，即一组字段 field:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">v = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 初始化赋值</span></span><br><span class="line">v.X = <span class="number">4</span>          <span class="comment">// 结构内元素赋值</span></span><br><span class="line">fmt.Print(v.X)   <span class="comment">// 取值</span></span><br><span class="line">fmt.Print(v.Y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的特殊文法：</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们第一次看到了 <code>type</code>，可以<a href="https://thenewstack.io/understanding-golang-type-system/">点击</a>这篇文章了解更多。</p><p>使用指针访问结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问结构体，需要结构提指针</span></span><br><span class="line"><span class="comment">// 还是以上面定义的结构体 Vertex 为例</span></span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结构体指针 p</span></span><br><span class="line"><span class="comment">// 赋值，本质是 (*p).X，为了避免繁琐，简化了操作（隐式间接调用）</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br><span class="line">fmt.Println(v)</span><br></pre></td></tr></table></figure><h1 id="数组">数组</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明形式 [n]T</span></span><br><span class="line"><span class="comment">// 数组的长度是其类型的一部分，因此数组不能改变大小</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问内容的文法与其它语言一致</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;Scott&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的同时设置初始值</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(primes)</span><br></pre></td></tr></table></figure><h1 id="切片">切片</h1><p>切片为数组提供动态大小, 在实践中，切片比数组更常用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片与 Python Pandas 中 iloc 的语法类似</span></span><br><span class="line"><span class="comment">// 语法为 []T, 包括第一个元素，排除最后一个元素</span></span><br><span class="line">a[low:high]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择下标1-3的元素</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个例子</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片只是提供一个视角，所以它并不存储数据</span></span><br><span class="line"><span class="comment">// 但是对切片的修改，会修改底层数据</span></span><br><span class="line">names := [<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;Scott&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sam&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片的文法与没有写数组长度的类似</span></span><br><span class="line">[<span class="number">3</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;  <span class="comment">// 数组文法</span></span><br><span class="line">[]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;   <span class="comment">// 切片文法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 numpy, pandas 类似，取同样的值有多种写法</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">a[:]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片本身有属性，如长度和容量</span></span><br><span class="line"><span class="comment">// 长度：包含的元素个数</span></span><br><span class="line"><span class="comment">// 容量: 从它的第一个元素开始数，到其底层数组元素末尾的个数（注意区别 numpy）</span></span><br><span class="line"><span class="comment">// 长度和容量可通过表达式 len(s) 和 cap(s) 来获取</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 拓展其长度</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 舍弃前两个值</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//nil 切片</span></span><br><span class="line"><span class="comment">// 切片的零值是 nil</span></span><br><span class="line"><span class="comment">// nil 切片的长度和容量为 0 且没有底层数组</span></span><br></pre></td></tr></table></figure><p>使用 make 创建切片, make 函数会分配一个元素为零值的数组并返回一个引用了它的切片, 这也是在 Go 中使用动态数组的方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 make</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分别打印 abcd</span></span><br><span class="line"><span class="comment">a len=5 cap=5 [0 0 0 0 0]</span></span><br><span class="line"><span class="comment">b len=0 cap=5 []</span></span><br><span class="line"><span class="comment">c len=2 cap=5 [0 0]</span></span><br><span class="line"><span class="comment">d len=3 cap=3 [0 0 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>切片的切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似操作 dataframe</span></span><br><span class="line">board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个下标设置值后得到改变后的图案</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X _ X</span></span><br><span class="line"><span class="comment">O _ X</span></span><br><span class="line"><span class="comment">_ _ O</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>向切片追加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>for 循环的 range 形式, 类似于 Python 中的 enumrate，但它是一个关键字而不是函数：</p><h1 id="映射">映射</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次迭代都会返回两个值</span></span><br><span class="line"><span class="comment">// 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</span></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">    fmt.Printf(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想忽略某个值，可以使用 _ </span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你只需要索引</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure><p>映射，类似 Python 中的字典，但需要规定 Key 和 Value 的类型，假设值是 struct，则需提前定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构体，用来存值</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明映射，键是 string，值是 struct</span></span><br><span class="line"><span class="comment">// 映射的零值为 nil 。nil 映射既没有键，也不能添加键。</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构体</span></span><br><span class="line"><span class="comment">// make 函数会返回给定类型的映射，并将其初始化备用</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">    <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 make 函数</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体内部，Vertex 可以省略</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取、编辑映射内部的值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除值</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双赋值检测, elem, ok = m[key]</span></span><br><span class="line"><span class="comment">// 若 key 在 m 中，ok 为 true ；否则，ok 为 false。</span></span><br><span class="line"><span class="comment">// 若 key 不在映射中，那么 elem 是该映射元素类型的零值。</span></span><br><span class="line"><span class="comment">// 同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</span></span><br><span class="line"><span class="comment">// 若 elem 或 ok 还未声明，你可以使用短变量声明：elem, ok := m[key]</span></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br></pre></td></tr></table></figure><h1 id="闭包">闭包</h1><p>函数值，Go 中函数也可以被传到另一个函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compute 函数接收另外一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute 接收了 hypot 作为参数</span></span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(compute(hypot))</span><br></pre></td></tr></table></figure><p>函数的闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><p>来一步一步理解 Go 中的闭包： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个普通的函数 send 并调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">&#125;</span><br><span class="line">send(<span class="string">&quot;hi, scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个匿名版本的 send 函数并立即调用</span></span><br><span class="line"><span class="comment">// 注意这个函数并没有函数名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">&#125;(<span class="string">&quot;hi, scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，返回一个函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func give_me_a_func() |func(string)| &lt;---- 这里规定了返回值</span></span><br><span class="line"><span class="comment">                                           即为一个接收 string 的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">give_me_a_func</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以把 give_me_a_func() 传给另外一个函数</span></span><br><span class="line">send_func := give_me_a_func()</span><br><span class="line">send_func(<span class="string">&quot;hi scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解了上面函数的工作方式后，我们来介绍闭包</span></span><br><span class="line"><span class="comment">// 先定义一个函数, 它返回一个函数(return int)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在定义另外一个变量来存储 incrementor 返回的函数</span></span><br><span class="line">next := incrementor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印每次调用 next() 返回的值</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 1</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 2</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="comment">// 这里 i 看起来应该无法工作的</span></span><br><span class="line">        <span class="comment">// 因为 i 是定义在 incrementor 中的</span></span><br><span class="line">        <span class="comment">// 但闭包拥有其被创建环境下的作用域</span></span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://thenewstack.io/understanding-golang-type-system/">Understanding Golang Type System</a></li><li><a href="https://medium.com/m/global-identity?redirectUrl=https%3A%2F%2Fbetterprogramming.pub%2Fclosures-made-simple-with-golang-69db3017cd7b">Closures Made Simple With Golang</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P2, 包括了指针、结构体、数组、切片、映射和闭包等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P1</title>
    <link href="https://scottzhang.pro/article/ae7ab1c5.html"/>
    <id>https://scottzhang.pro/article/ae7ab1c5.html</id>
    <published>2021-12-14T15:55:09.000Z</published>
    <updated>2021-12-20T09:19:01.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P1, 包含两大部分的语法介绍：一个是包、变量和函数，另外一个是流程控制语句，如 for, if-else, switch。</p></blockquote><span id="more"></span><h1 id="包变量和函数">包、变量和函数</h1><p>关于包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// 每个程序由包构成，从 main 开始</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span> </span><br><span class="line">    <span class="comment">// 在这个包中，肯定以 package rand 开始</span></span><br><span class="line">    <span class="comment">// 申明包的名字</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>关于导出名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(math.Pi) <span class="comment">//一个名字以大写字母开头，那么它就是已导出的</span></span><br><span class="line">fmt.Println(math.pi) <span class="comment">//未导出</span></span><br></pre></td></tr></table></figure><p>函数的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型相同的参数可以简写</span></span><br><span class="line">x <span class="keyword">int</span>, y <span class="keyword">int</span></span><br><span class="line">x,y <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以返回任意数量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接写 return 会返回函数中定义了的所有变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">    <span class="comment">// 返回 x 和 y, 此处是 7,10</span></span><br><span class="line">    <span class="comment">// 此处返回值会转成 int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span> <span class="comment">// 默认赋值为 false</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> <span class="comment">// 默认赋值为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始值</span></span><br><span class="line">vari, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span> <span class="comment">// 可以设置初始值</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&#x27;no!&#x27;</span> <span class="comment">// 不指定类型而直接指定初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量简单法，用 := 替代 var</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用语法块声明变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有给初始值，默认会赋值, 数值是0， 布尔 false，字符串是空字符</span></span><br></pre></td></tr></table></figure><p>类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int -&gt; float -&gt; uint</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f float = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的形式</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)</span><br><span class="line">u := <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>类型推导:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以准确推导的情况下，直接使用</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">j := i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能准确推导或者因为值运算的结果，需要改变精度</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">j := <span class="number">3.142</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> </span><br><span class="line"><span class="comment">// 注意: g = 0.867 + 0.5i 会报错</span></span><br></pre></td></tr></table></figure><p>常量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> Pi := <span class="number">3.14</span> <span class="comment">//syntax error: unexpected :=, expecting =</span></span><br></pre></td></tr></table></figure><p>数值常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line"><span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br></pre></td></tr></table></figure><h1 id="流程控制">流程控制</h1><p>Go 只有一种循环结构即 for 循环，分成三部分</p><ul><li><p>初始化语句：在第一次迭代前执行</p></li><li><p>条件表达式：在每次迭代前求值</p></li><li><p>后置语句：在每次迭代的结尾执行</p></li></ul><p>它有三种写法，for 后面没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的</p><ul><li><strong>for init; condition; post{}</strong></li><li><strong>for condition {}</strong></li><li><strong>for {}</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for init; condition; post&#123;&#125;</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for condition &#123;&#125;</span></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for &#123;&#125; 无限循环</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 If 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无(), 必须有 &#123;&#125;</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件表达式前可以执行一个简单的语句</span></span><br><span class="line"><span class="keyword">if</span> v := add(x, y); v &lt; <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else 语法</span></span><br><span class="line"><span class="keyword">if</span> v:= add(x, y) &#123;</span><br><span class="line">    <span class="comment">// do a</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处不可以使用 v 了</span></span><br></pre></td></tr></table></figure><p>关于 switch:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// freebsd, openbsd,</span></span><br><span class="line">        <span class="comment">// plan9, windows...</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Go 只运行选定的 case，而非之后所有的 case</span></span><br><span class="line"><span class="comment">// switch 的 case 无需为常量，且取值不必为整数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求值顺序从上到下，找到匹配成功</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> f(): <span class="comment">// f() 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有条件的 switch</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 defer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer 会将函数推迟到外层函数返回之后执行</span></span><br><span class="line"><span class="comment">// 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</span></span><br><span class="line"><span class="comment">// 下面的代码输出 hello \n world</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推迟的函数被压入栈，先进后出</span></span><br><span class="line"><span class="comment">// 所以下面的函数会以 987.. 的顺序打印</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P1, 包含两大部分的语法介绍：一个是包、变量和函数，另外一个是流程控制语句，如 for, if-else, switch。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 笔记: Module</title>
    <link href="https://scottzhang.pro/article/4b8d4d9.html"/>
    <id>https://scottzhang.pro/article/4b8d4d9.html</id>
    <published>2021-12-14T14:33:51.000Z</published>
    <updated>2021-12-20T09:11:58.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Understand Module in Golang.</p></blockquote><span id="more"></span><h1 id="code-example">Code example</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">quoteV3 <span class="string">&quot;rsc.io/quote/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> quoteV3.HelloV3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Proverb</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> quoteV3.Concurrency()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">want := <span class="string">&quot;Hello, world.&quot;</span></span><br><span class="line"><span class="keyword">if</span> got := Hello(); got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Hello() = %q, want %q&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProverb</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">want := <span class="string">&quot;Concurrency is not parallelism.&quot;</span></span><br><span class="line"><span class="keyword">if</span> got := Proverb(); got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Proverb() = %q, want %q&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go.mod</span></span><br><span class="line">module scottzhang.pro/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.17</span></span><br><span class="line"></span><br><span class="line">require rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="use-go-modules">Use Go Modules</h1><p>What is module?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module：a collection of Go packages</span><br><span class="line">  |</span><br><span class="line">go.mod:</span><br><span class="line">    - module&#x27;s module path</span><br><span class="line">    - dependency requirements</span><br></pre></td></tr></table></figure><p>The Running ENV for a module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. outside $GOPATH/src &lt;--</span><br><span class="line">2. inside any folder     |</span><br><span class="line">   with:                 |</span><br><span class="line">       - go.mod --------&gt;|</span><br></pre></td></tr></table></figure><p>How to creating a new module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. create you file.  // status: contains a package</span><br><span class="line">2. cmd: go mod init scottzhang.pro/hello  // make the current directory the root of a module</span><br><span class="line">3. cmd: go test  // test the module</span><br></pre></td></tr></table></figure><ul><li>Packages in subdirectories have import paths consisting of the module path plus the path to the subdirectory.</li><li>So you don't need to run <strong>go mod init</strong> in subdirectories.</li></ul><p>Understand go.mod content:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example.com/hello //main module</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c //an example of a pseudo-version</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.3.0</span><br><span class="line"></span><br><span class="line">// go <span class="built_in">command</span> maintains a file named go.sum</span><br><span class="line">// containing the expected cryptographic hashes of the content of specific module versions.</span><br><span class="line">// ensure that future downloads of these modules retrieve the same bits as the first download</span><br></pre></td></tr></table></figure><p>How to import dependencies module:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;rsc.io/quote&quot;</span></span><br><span class="line"><span class="comment">// to check  indirect dependencies</span></span><br><span class="line"><span class="comment">// cmd: go list -m all</span></span><br></pre></td></tr></table></figure><p>How to upgrading dependencies:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// here is a example to upgrade text and sampler</span><br><span class="line">cmd: go get golang.org/x/text</span><br><span class="line">cmd: go get rsc.io/sampler</span><br></pre></td></tr></table></figure><p>Now depends on both <strong>rsc.io/quote</strong> and <strong>rsc.io/quote/v3</strong>.</p><p>why here is V3?, because:</p><ul><li>Each different major version (v1, v2, and so on) of a Go module uses a different module path</li><li>v3 of rsc.io/quote = rsc.io/quote/v3, Know more visit <a href="https://research.swtch.com/vgo-import">here</a></li></ul><blockquote><p>You can have v1, v2, v3 in same module, but can't with v1.1 and v1.2</p></blockquote><p>To know what new changes in new version, type <strong>go doc rsc.io/quote/v3</strong>.</p><p>Remove no need module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go list -m all  # check</span><br><span class="line">go mod tidy  # cleans up these unused dependencies</span><br></pre></td></tr></table></figure><h1 id="conclusion">Conclusion</h1><ul><li><strong>go mod init</strong> creates a new module, initializing the go.mod file that describes it.</li><li><strong>go build</strong>, go test, and other package-building commands add new dependencies to go.mod as needed.</li><li><strong>go list -m all</strong> prints the current module’s dependencies.</li><li><strong>go get</strong> changes the required version of a dependency (or adds a new dependency).</li><li><strong>go mod tidy</strong> removes unused dependencies.</li></ul><h1 id="ref">Ref</h1><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-go-modules">How to Use Go Modules</a></li><li><a href="https://go.dev/blog/using-go-modules">Using Go Modules</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Understand Module in Golang.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-抽象工厂与组合模式</title>
    <link href="https://scottzhang.pro/article/72c6f483.html"/>
    <id>https://scottzhang.pro/article/72c6f483.html</id>
    <published>2021-11-28T13:44:50.000Z</published>
    <updated>2021-11-28T13:50:30.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="抽象工厂模式">抽象工厂模式</h1><p>想让你的系统根据配置或平台的问题有多个可能的实现，就可以利用抽象工厂模式。</p><p>你调用抽象工厂会返回一个对象，这个对象的实现会基于你的需求而变化。</p><ul><li>对于一个在线的商城，它对于不同的国家有不同的语言、货币以及税收的计算方式。</li><li>对于一套 GUI 工具，在 Windows 上可能返回的是 WinForm，在 Mac 上返回的则是 Cocoa 组件。</li><li>对于 Django，它会根据当前站点的配置而返回相关的对象以对不同数据库后端的支持。</li></ul><p>想象一个格式化日期与货币的需求，我们需要支持中英文两种情况下的货币和日期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaDateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot; &#123;&#125; 年 &#123;&#125; 月 &#123;&#125; 日 &quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USADateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27; 2021 年 01 月 01 日 &#x27;</span></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;27&#x27;</span>)  <span class="comment"># &#x27; 2021 年 11 月 27 日 &#x27;</span></span><br><span class="line"></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>) <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>再来定义两个处理货币的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaCurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¥ &#123;&#125;.&#123;&#125; 元&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USACurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;$ &#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChinaCurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;¥ 143,958,766,111,111.05 元&#x27;</span></span><br><span class="line">USACurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;$ 143,958,766,111,111.05&#x27;</span></span><br></pre></td></tr></table></figure><p>将上面的代码按照国家组织在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USAFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USADateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USACurrencyFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaDateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaCurrencyFormatter()</span><br></pre></td></tr></table></figure><p>在使用的时候，可以直接使用字典去找对应的抽象工厂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factory_map = &#123;</span><br><span class="line">    <span class="string">&#x27;US&#x27;</span>: USAFormatterFactory,</span><br><span class="line">    <span class="string">&#x27;China&#x27;</span>: ChinaFormatterFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置区域为中国：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = &#x27;China&#x27;</span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(&#x27;21&#x27;, &#x27;1&#x27;, &#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line"># &#x27; 2021 年 01 月 01 日 &#x27;</span><br></pre></td></tr></table></figure><p>设置区域为美国：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = <span class="string">&#x27;US&#x27;</span></span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>在实际的项目架构中，我们会有一个后端的模块来支持对不同国家提供服务，它的结构可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">localize/</span><br><span class="line">__init__.py</span><br><span class="line">backends/</span><br><span class="line">__init__.py</span><br><span class="line">USA.py</span><br><span class="line">China.py</span><br></pre></td></tr></table></figure><p>那么我们可以在 localize 下面的 <code>__init__.py</code> 文件中，动态的选择区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .backends <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> country_code == <span class="string">&#x27;China&#x27;</span>:</span><br><span class="line">current_backend = <span class="string">&#x27;China&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="组合模式">组合模式</h1><p>组合模式一般通过组建来构造复杂的树状结构，它在文件夹和文件夹树中的应用比较多。</p><p>文件目录中通常有两种类型的对象，文件和文件夹。首先来定义这两个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.children = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">sejlf</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把一些常用的方法抽象到基类中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compoment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      get_path 方法会在外部实现</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">        new_folder = get_path(new_path)</span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br><span class="line">        new_folder.children[self.name] = self</span><br><span class="line">        self.parent = new_folder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br></pre></td></tr></table></figure><p>这样 File 和 Folder 类就可以少去一些代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        child.parent = self</span><br><span class="line">        self.children[child.name] = child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这种方式，我们使用的时候，可以进行任意的组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root = Folder(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">folder1 = Folder(<span class="string">&#x27;F1&#x27;</span>)</span><br><span class="line">folder2 = Folder(<span class="string">&#x27;F2&#x27;</span>)</span><br><span class="line">hello_file = File(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line">folder2.add_child(hello_file)</span><br><span class="line">folder1.add_child(folder2)</span><br><span class="line">root.add_child(folder1)</span><br><span class="line"></span><br><span class="line">root.children[<span class="string">&#x27;F1&#x27;</span>].children[<span class="string">&#x27;F2&#x27;</span>].children[<span class="string">&#x27;hello&#x27;</span>].contents</span><br></pre></td></tr></table></figure><p>当你在编程的时候，遇到了树状结构的时候，可以想想是否可以应用组合模式。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-适配器与外观模式</title>
    <link href="https://scottzhang.pro/article/2b511f30.html"/>
    <id>https://scottzhang.pro/article/2b511f30.html</id>
    <published>2021-11-26T09:46:19.000Z</published>
    <updated>2021-11-28T13:50:12.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="适配器模式">适配器模式</h1><p>适配器模式，顾名思义就好像是电脑的转接头一样，目的就是让不同的系统之间可以协同工作。</p><p>比如现在已经存在一些代码了，但你不想对它做任何更改，因为这意味着你要修改大量的内容，这时候你可以写一个适配器，将输入转化成现有代码可以直接使用的，这就叫适配器。</p><p>举个例子，假设我们有一个奇怪的日期格式，它的年和月中间有一个14，现在有一个代码的逻辑是得到初始日期和结束日期中间的天数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysCalculator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        start = datetime.datetime.strptime(self.start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strptime(self.end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (end - start).days</span><br><span class="line"></span><br><span class="line">DaysCalculator(start=<span class="string">&#x27;20211403&#x27;</span>, end=<span class="string">&#x27;20211409&#x27;</span>).get_days()</span><br><span class="line"><span class="comment"># 输出 184</span></span><br></pre></td></tr></table></figure><p>现在你有一些方法需要依赖这段代码，你不得不也按照这个奇怪的格式工作，那么这时候你可以写一个适配器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysAdaptor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        start = datetime.datetime.strftime(start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strftime(end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        self.calculator = DaysCalculator(start, end)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.calculator.get_days()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造两个标准日期对象作为输入</span></span><br><span class="line">start = datetime.datetime.strptime(<span class="string">&#x27;2021/3&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line">end = datetime.datetime.strptime(<span class="string">&#x27;2021/9&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里传入的日期类的日期，但也可以正常工作</span></span><br><span class="line">DaysAdaptor(start, end).get_days()</span><br></pre></td></tr></table></figure><h1 id="外观模式">外观模式</h1><p>外观模式更关注外部的体验，为了用户体验的方便，它将复杂的内部代码封装起来，只暴露一个简单的方法接受参数供用户调用，从而实现不同的功能。</p><p>一个例子是，你想编写一个接受/发送邮件的客户端，对于用户而言，它只需关心：</p><ul><li>发件人地址</li><li>邮件内容</li><li>接受人地址</li></ul><p>所以我们可以编写一个简单的方法，只关心这几个参数，而其余的对于地址的处理、检查，对于用户密码的验证等等则隐藏在函数内部。</p><p>相信你已经在自己的代码中使用过外观模式，此处不在举例。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-享元与命令模式</title>
    <link href="https://scottzhang.pro/article/56f28bda.html"/>
    <id>https://scottzhang.pro/article/56f28bda.html</id>
    <published>2021-11-26T09:42:59.000Z</published>
    <updated>2021-11-28T13:50:17.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章讨论了享元模式与命令模式。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="享元模式">享元模式</h1><p>元、气之始，引申为元气。享元模式即共享最初的那部分，哪部分呢？</p><p>假设你有一个需求需要创建大量的类实例，利用享元模式，就可以保证<strong>共享同一状态的对象，可以同时使用该共享状态的内存。</strong></p><p>举个例子，之前聊过的汽车销售系统。对于每一辆车，我们可以加装不同的配置，比如有尊享版、豪华版等等。</p><p>不同版本之间，其实是大同小异。</p><p>如果对于每辆车我们都去统计它有什么功能，没有什么功能，则会产生巨大的浪费。</p><p>我们可以通过共享对象去存储那些与型号相关的特性列表。</p><p>享元在 Python 中的实现类似单例模式。</p><p>但单例模式返回的是一个类的实例，而享元模式则是根据指定的不同参数，返回对应的实例。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc  <span class="comment"># 垃圾回收器</span></span><br><span class="line"><span class="keyword">import</span> weakref <span class="comment"># 弱引用数据结构包</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarModel</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;弱引用的字典，内部的对象弱没有被引用，则会被回收。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _models = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, model_name, *avgs, **kvargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;这里对新实例的创建自定义，与单例模式有点类似</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        model = cls._models.get(model_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> model:</span><br><span class="line">            model = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">            cls._models[model_name] = model</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name, air=<span class="literal">False</span>, title=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 cruise_control=<span class="literal">False</span>, power_locks=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 allow_whells=<span class="literal">False</span>, use_charger=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例的初始化，在这里完成</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.model_name = model_name</span><br><span class="line">        self.air = air</span><br><span class="line">        self.title = title</span><br><span class="line">        self.cruise_control = cruise_control</span><br><span class="line">        self.power_locks = power_locks</span><br><span class="line">        self.allow_whells = allow_whells</span><br><span class="line">        self.use_charger = use_charger</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self, serial_number</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Sorry We are anble to check&quot;</span>,</span><br><span class="line">            <span class="string">&quot;the seria number &#123;0&#125; on the &#123;1&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;at this time&quot;</span>.<span class="built_in">format</span>(self.number, self.model_name)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model, color, serial</span>):</span></span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = color</span><br><span class="line">        self.serial = serial</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model.check_serial(self.serial)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>上面定义了两个类，一个是汽车模版，一个是汽车。我们来生产几辆车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dx = CarModel(<span class="string">&quot;FIT DX&quot;</span>)</span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产一些车</span></span><br><span class="line">car1 = Car(model=dx, color=<span class="string">&#x27;blue&#x27;</span>, serial=<span class="string">&#x27;DX001&#x27;</span>)</span><br><span class="line">car2 = Car(model=dx, color=<span class="string">&#x27;black&#x27;</span>, serial=<span class="string">&#x27;DX002&#x27;</span>)</span><br><span class="line">car3 = Car(model=lx, color=<span class="string">&quot;red&quot;</span>, serial=<span class="string">&quot;LX003&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在来观察他们的内存地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># display(id(lx)) -&gt; 4402294352</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 lx 和对它的引用，让垃圾回收器回收</span></span><br><span class="line"><span class="keyword">del</span> lx</span><br><span class="line"><span class="keyword">del</span> car3</span><br><span class="line">gc.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新创建一个新的 lx，其地址已经变了，因为生成了新的 lx</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个其它版本的 lx，没有 air 和其他的选项，发现返回的还是第二遍创建的</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br></pre></td></tr></table></figure><p>享元模式使用起来比普通的类实现更负责，但如果你有成百上千的类实例需要创建的时候，享元模式可以极大的节省你的内存，可以说享元模式是专为节省内存而设计的。</p><h1 id="命令模式">命令模式</h1><p>命令模式在<strong>必须被完成的行为</strong>和<strong>调用这些动作的对象</strong>之间添加了一个抽象层，这句话可能比较难理解，我们看一个例子。</p><p>这个模式在图形窗口中的操作中应用的比较多。</p><p>我们实现一个窗口程序，它有退出和保存的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_name</span>):</span></span><br><span class="line">        self.file_name = file_name</span><br><span class="line">        self.content = <span class="string">&quot;This file can not be modified&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToolBarButton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, iconname</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.iconname = iconname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, menu_name, manu_itemname</span>):</span></span><br><span class="line">        self.manu_name = menu_name</span><br><span class="line">        self.menu_itemname = manu_itemname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyboardShortCut</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, modifier</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.modifier = modifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keypress</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExitCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个窗口</span></span><br><span class="line">window = Window()</span><br><span class="line"><span class="comment"># 新建一个文档</span></span><br><span class="line">document = Document(<span class="string">&quot;A Great Document!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建两个指令，需要传入文档</span></span><br><span class="line">save_command = SaveCommand(document)</span><br><span class="line">exit_command = ExitCommand(document)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定操作</span></span><br><span class="line"><span class="comment"># 举例：当 ToolBarButton 内部的 click 被调用</span></span><br><span class="line"><span class="comment"># click -&gt; save_command.execute（内部引用了document） -&gt; document.save</span></span><br><span class="line">save_button = ToolBarButton(<span class="string">&#x27;save&#x27;</span>, <span class="string">&#x27;save.png&#x27;</span>)</span><br><span class="line">save_button.command = save_command</span><br><span class="line"></span><br><span class="line">save_keystroke = KeyboardShortCut(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;ctrl&#x27;</span>)</span><br><span class="line">save_keystroke.command = save_command</span><br><span class="line"></span><br><span class="line">exit_menu = MenuItem(<span class="string">&#x27;File&#x27;</span>, <span class="string">&#x27;Exit&#x27;</span>)</span><br><span class="line">exit_menu.command = exit_command</span><br></pre></td></tr></table></figure><p>还有一种更简洁、更 Python 的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command()</span><br><span class="line"></span><br><span class="line">window = Window()</span><br><span class="line">menu_item = MenuItem()</span><br><span class="line">menu_item.command = window.exit</span><br></pre></td></tr></table></figure><p>或者直接调用类，只需实现 <code>__call__</code> 方法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;实现了 call 方法的类可以直接被调用&quot;&quot;&quot;</span></span><br><span class="line">        self.document.save()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章讨论了享元模式与命令模式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记录 Airflow 的部署</title>
    <link href="https://scottzhang.pro/article/c6a5215a.html"/>
    <id>https://scottzhang.pro/article/c6a5215a.html</id>
    <published>2021-11-26T07:06:25.000Z</published>
    <updated>2021-11-27T08:28:31.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个 Python 编写的调度工具，在此记录它的部署过程。</p></blockquote><span id="more"></span><h1 id="部署">部署</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy new server</span></span><br><span class="line">From vultr</span><br><span class="line"></span><br><span class="line"><span class="comment"># win10 generate ssh key</span></span><br><span class="line">ssh-keygen</span><br><span class="line">cat | Users/YourUserName/.ssh/id_rsa.pub | set-clibboard</span><br><span class="line"></span><br><span class="line">使用 Docker 配置 Airflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull puckel/docker-airflow</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -d -p 8080:8080 puckel/docker-airflow webserver</span><br><span class="line"><span class="comment"># 进入启动的容器并启动 shell</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置登录密码</span></span><br><span class="line"><span class="comment">## 创建 py 文件</span></span><br><span class="line">vim set_password.py</span><br><span class="line"></span><br><span class="line"><span class="comment">## 贴入代码</span></span><br><span class="line">import airflow</span><br><span class="line">from airflow import models, settings</span><br><span class="line">from airflow.contrib.auth.backends.password_auth import PasswordUser</span><br><span class="line"></span><br><span class="line">user = PasswordUser(models.User())</span><br><span class="line">user.username = <span class="string">&#x27;new_user_name&#x27;</span></span><br><span class="line">user.email = <span class="string">&#x27;new_user_email@example.com&#x27;</span></span><br><span class="line">user.password = <span class="string">&#x27;set_the_password&#x27;</span></span><br><span class="line">session = settings.Session()</span><br><span class="line">session.add(user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件，将配置文件拷贝出来用vim修改</span></span><br><span class="line">sudo docker cp a3a3dc6b79fe:/usr/<span class="built_in">local</span>/airflow/airflow.cfg .</span><br><span class="line">vim airflow.cfg . <span class="comment"># 修改</span></span><br><span class="line">sudo docker cp airflow.cfg  dc8b159da311:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 py 文件拷贝到容器</span></span><br><span class="line">sudo docker cp set_password.py  1291e03f85fc:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f85fc bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码</span></span><br><span class="line">python set_password.py <span class="comment"># 提示缺少包 flask_bcrypt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 flask_bcrypt 包</span></span><br><span class="line">pip intall flask_bcrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码, 重启</span></span><br><span class="line">python set_password.py</span><br><span class="line">docker container restart 1291e03f85fc</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"><span class="comment"># list dags</span></span><br><span class="line"></span><br><span class="line">airflow list_dags</span><br><span class="line"></span><br><span class="line">Filling up the DagBag from /home/repl/workspace/dags , 加粗部分为 dags 所在文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置文件</span></span><br><span class="line">cat ~/airflow/airflow.cfg</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line"><span class="comment"># 容器启动失败查看日志</span></span><br><span class="line">sudo docker logs <span class="variable">$&#123;container_id&#125;</span></span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://notbe.cn/2019/05/12/1557726443776.html">airflow 使用心得，从环境到部署上线</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个 Python 编写的调度工具，在此记录它的部署过程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="docker" scheme="https://scottzhang.pro/tags/docker/"/>
    
    <category term="airflow" scheme="https://scottzhang.pro/tags/airflow/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-模版模式</title>
    <link href="https://scottzhang.pro/article/ebf9c4b3.html"/>
    <id>https://scottzhang.pro/article/ebf9c4b3.html</id>
    <published>2021-11-21T07:51:22.000Z</published>
    <updated>2021-11-28T13:50:07.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><p>模版模式有助于去除重复代码，并满足了”DRY-不要重复自己“原则。</p><p>平时遇到数据处理的需求，我们需要执行一些常见的任务，如：</p><ol type="1"><li>去数据库取数，并将某些结果打印至控制台</li><li>去数据库取数，简单处理后，将结果保存到 csv 文件</li></ol><p>在这两个步骤中，有些子步骤是一样的，比如连接数据库，发出查询请求，执行 query 语句等。</p><p>可以将这部分功能集成到基类中，而其他特殊的功能可以放到子类中。</p><p>我们举例来说明，首先准备一个数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;CREATE TABLE sales&quot;</span></span><br><span class="line">    <span class="string">&quot;(&quot;</span></span><br><span class="line">    <span class="string">&quot;salespersion txt,&quot;</span></span><br><span class="line">    <span class="string">&quot;amt currency,&quot;</span></span><br><span class="line">    <span class="string">&quot;year integer,&quot;</span></span><br><span class="line">    <span class="string">&quot;model text,&quot;</span></span><br><span class="line">    <span class="string">&quot;new boolen&quot;</span></span><br><span class="line">    <span class="string">&quot;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入一些假数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete all rows from db before any new rows insert into table</span></span><br><span class="line">conn.execute(<span class="string">&quot;delete from sales&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert rows</span></span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Scott&#x27;, 1400, 2007, &#x27;Toyota&#x27;, &#x27;false&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Desmond&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Burney&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Austin&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cursor = conn.execute(<span class="string">&quot;select * from sales&quot;</span>)</span><br><span class="line">cursor.fetchall()</span><br></pre></td></tr></table></figure><p>查询结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&#x27;Scott&#x27;</span>, 1400, 2007, <span class="string">&#x27;Toyota&#x27;</span>, <span class="string">&#x27;false&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Desmond&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Burney&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Austin&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>现在我们设计一个 query 的模版类，想想它需要有哪些功能？</p><p>一个可能的基类是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_format</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;暴露给外部调用的方法，用来保证每个方法按照顺序执行。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.connect()</span><br><span class="line">        self.construct_query()</span><br><span class="line">        self.do_query()</span><br><span class="line">        self.format_results()</span><br><span class="line">        self.output_results()</span><br></pre></td></tr></table></figure><p>基类定义了我们需要有哪些功能，现在根据我们的需求，将其中一些可以共用的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个类提供了连接数据库、执行 query，格式化结果的功能</span></span><br><span class="line"><span class="string">       而对于构造 query、导出结果的功能，则抽象成接口交给子类去实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.conn.execute(self.query)  <span class="comment"># query 待 construct_query 实现</span></span><br><span class="line">        self.result = result.fetchall()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> self.result:</span><br><span class="line">            row = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> row]</span><br><span class="line">            output.append(row)</span><br><span class="line">        self.formated_result = <span class="string">&#x27;\n&#x27;</span>.join(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>现在实现我们自己的需求就很容易了，因为我们只需要将精力放在构造 query 和 输出结果这两个方法上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewVehiclesQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.query = <span class="string">&quot;select * from sales where new = &#x27;true&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.format_result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.do_query = <span class="string">&quot;select * from sales&quot;</span>  <span class="comment"># do what you want to do</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        file_name = <span class="string">&quot;output_file.csv&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span> (file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.formated_result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-单例模式及其实现原理</title>
    <link href="https://scottzhang.pro/article/18dbdeeb.html"/>
    <id>https://scottzhang.pro/article/18dbdeeb.html</id>
    <published>2021-11-18T13:25:00.000Z</published>
    <updated>2021-11-28T13:50:00.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="面向对象">面向对象</h1><h2 id="方法是怎么工作的">方法是怎么工作的？</h2><p>方法是绑定在类中的函数。你可以像下面这样声明一个 pizza 类以及它的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接访问类的 get_size 方法，会告诉你这个方法未绑定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 中不会提示</span></span><br><span class="line">Pizza.get_size</span><br><span class="line">&lt;unbound method Pizza.get_size&gt;</span><br></pre></td></tr></table></figure><p>我们无法调用这个方法，因为它没有绑定给任何 Pizza 的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 会直接报错</span></span><br><span class="line">Pizza.get_size()</span><br><span class="line">TypeError: unbound method get_size() must be called <span class="keyword">with</span> Pizza instance <span class="keyword">as</span> first argument (got nothing instead)</span><br></pre></td></tr></table></figure><p>它提示你第一个参数必须是 Pizza 的实例，那我们将它的 Pizza 的实例传进去看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 方法，同时传入实例，正常</span></span><br><span class="line">Pizza.get_size(Pizza(<span class="number">42</span>))</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>成功了! 不过这样使用也太麻烦了，好在 Python 会帮我们自动实现这些繁琐的工作。它会自动将 Pizza 中所有的方法绑定给任何 Pizza 的实例，当我们定义类方法的时候，其中写的 self 就等于类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = Pizza(<span class="number">42</span>).get_size</span><br><span class="line">m()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>如果你想知道方法被绑定给了那个对象，可以通过 <code>m.__self__</code> 来查看方法被绑定到了哪个对象。</p><h2 id="静态方法">静态方法</h2><p>静态方法不需要提供 self 或 cls 等参数，因为声明为静态方法后，它不会绑定给任何实例或者类, 这减少了类实例创建时候的开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mix_ingredients</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mix_ingredients(self.cheese, self.vegetables)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到两个实例的方法是不想等的，而静态方法的对于实例和类都是相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pizza().cook <span class="keyword">is</span> Pizza().cook</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza.mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza().mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="类方法">类方法</h2><p>类方法的概念和实例方法类似，不同的是它会被绑定给类本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    radius = <span class="number">42</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">cls</span>):</span>  <span class="comment"># cls 为类</span></span><br><span class="line">        <span class="keyword">return</span> cls.radius</span><br></pre></td></tr></table></figure><p>对于类方法来说，不管你通过类还是类的实例调用，它引用的也都是同一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pizza.get_radius</span><br><span class="line">&lt;bound method <span class="built_in">type</span>.get_radius of &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">type</span>.<span class="title">get_radius</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span> == <span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span>()</span></span><br><span class="line"><span class="class">42</span></span><br></pre></td></tr></table></figure><p>什么时候使用类方法呢？</p><p>第一种情况是工厂模式中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ingredients</span>):</span></span><br><span class="line">        self.ingredients = ingredients</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_fridge</span>(<span class="params">cls, fridge</span>):</span></span><br><span class="line">        <span class="comment"># 会返回一个新的类的实例，这允许你在类的实例被初始化之前做一些事情，</span></span><br><span class="line">        <span class="comment"># 它的初始化参数来自于fridge 的两个方法 get_cheese() + get_vegetables()</span></span><br><span class="line">        <span class="keyword">return</span> cls(fridge.get_cheese() + fridge.get_vegetables())</span><br></pre></td></tr></table></figure><p>这样写的好处是，你可以通过 <code>Pizza.from_fridge(...)</code> 的方式生成实例。</p><p>第二种情况是调用静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius, height</span>):</span></span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.height = height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span>(<span class="params">radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> math.pi * (radius ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_volume</span>(<span class="params">cls, height, radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> height * cls.compute_area(radius)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_volume</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.compute_volume(self.height, self.radius)</span><br></pre></td></tr></table></figure><p>这里的 cls 可以写成 Pizza, 但通过 cls 的方式避免将 Pizza 类写死在类中。</p><h2 id="抽象方法">抽象方法</h2><p>抽象方法（Abstract methods）是定义在基类中的，未实现的方法，它有点类似于 java 中的接口。它规定了一种方法的形式，任何继承基类的子类都必须实现此方法才可以工作。</p><p>一个简单的抽象方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>根据这个定义，任何继承了 Pizza 类的子类，都必须实现并重写 get_redius 方法，如果你忘记实现，实例调用 get_radius 就会出错。</p><p>如果你想要让这种错误发生的更早一点，比如发生在实例刚创建的时候，那么可以设置 Pizza 的 metaclass 为 abc 模块中的 ABCMeta。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="string">&quot;&quot;&quot;Method that should do something.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这里继承自 BasePizza 的类中，必须实现 get_radius 方法。BasePizza 对实现的细节并不关心，可以是类方法，实例方法，或者是静态方法。同样它也不关心返回的结果。</p><blockquote><p>参考: <a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">The definitive guide on how to use static, class or abstract methods in Python.</a></p></blockquote><h2 id="super-类">super 类</h2><p>是的，这标题没有错！super 是一个类，实例化之后得到的是一个代理的对象，而不是得到了父类，我们使用这个代理对象来调用父类或者兄弟类的方法。</p><p>但是当继承的父类比较多时，去哪个父类中调用方法就是个问题。对于子类的实例来说，可以通过 <code>obj.__mro__</code> 或者是 <code>cls.mro()</code> 访问父类的列表，python 通过它用管理类的继承顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问一个实例的 MRO 列表</span></span><br><span class="line"><span class="built_in">type</span>(B()).__mro__</span><br><span class="line">(__main__.B, __main__.A, <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>如果你提供一个 MRO 列表以及一个 MRO 中的类 C 给 super()，它将返回一个从 MRO 列表中 C 之后的类中查找到的方法的对象。</p><p>假设有个MRO列表为 [A, B, C, D, E, object]，执行 super(C, A).foo() 它只会从 C 之后查找，即: 只会在 D 或 E 或 object 中查找 foo 方法。</p><p>super() 它有几种使用方法：</p><ul><li>super() -&gt; same as super(<strong>class</strong>, <first argument>)</li><li>super(type) -&gt; unbound super object</li><li>super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</li><li>super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</li></ul><p>举个 super(type, obj) 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Base&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 super 的 func</span></span><br><span class="line"><span class="built_in">super</span>(A, C()).func()  <span class="comment"># 输出 &#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么是 B 呢？首先看一下 MRO 列表，Python 会根据第二个参数来计算 MRO，也就是这里提供的 C() 产生的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C.mro()</span><br><span class="line">[__main__.C, __main__.A, __main__.B, __main__.Base, <span class="built_in">object</span>]</span><br></pre></td></tr></table></figure><p>super 会计算出来的 mro 列表中，跳过参数A，从后面开始找父类的 func 方法，所以这里会执行 B 的 func。</p><p>然后再来说说 super(type, obj) 和 super(type, type2)的区别，他们的区别是第二个参数，super的第二个参数传递的是类，得到的是函数，super的第二个参数传递的是对象，得到的是绑定方法。</p><blockquote><p>理解绑定方法，有兴趣的再可以深入了解<a href="(https://docs.python.org/zh-cn/3.7/howto/descriptor.html)">描述器</a>的介绍。</p></blockquote><h1 id="单例模式">单例模式</h1><p>掌握了面向对象的知识和 super 的使用，就可以介绍单例模式了。单例模式是一种确保一个类只有一个实例会被创建出来的模式。</p><p>在其他语言中，单例通过构造函数私有化实现，Python 中没有私有构造函数，但可以通过类方法 <code>__new__</code> 实现。</p><p>我们知道 <code>__init__</code> 函数，但 <code>__init__</code> 是对创建好的实例初始化，而 <code>__new__</code> 才创建实例。</p><p>摘录网上一段关于这两个方法的解释：</p><ul><li>new (cls[, ...]) 是在一个对象实例化的时候所调用的第一个方法，在调用 init 初始化前，先调用new 。</li><li>new 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给 init 。</li><li>new 对当前类进行了实例化，并将实例返回，传给 init 的self。但是，执行了new ，并不一定会进入 init ，只有new 返回了，当前类cls的实例，当前类的 init 才会进入。</li><li>若new 没有正确返回当前类cls的实例，那 init 是不会被调用的，即使是父类的实例也不行，将没有 init 被调用。</li><li>new 方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径。</li></ul><blockquote><p>为 markdown 渲染方便，这里的 new 即 <code>__new__</code>, init 即 <code>__init__</code></p></blockquote><p>来看一个实现了这两个方法的类的调用顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Scott&quot;</span>, <span class="number">25</span>)</span><br><span class="line">__new__</span><br><span class="line">__init__</span><br></pre></td></tr></table></figure><p>可以看到先调用了 <code>__new__</code>, 才是 <code>__init__</code>，利用 new 的特性，我们可以用它来实现单例模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span>:</span></span><br><span class="line">    _singleton = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># super(OnlyOne, cls) 即上面的 super(type, type2) 模式</span></span><br><span class="line">        <span class="comment"># 这里相当于根据 cls 找 MRO 列表中，OnlyOne后的父类</span></span><br><span class="line">        <span class="comment"># 使用它的 __new__ 方法创建一个 cls（即本类）的实例</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._singleton:</span><br><span class="line">            cls._singleton = <span class="built_in">super</span>(</span><br><span class="line">                OnlyOne, cls</span><br><span class="line">            ).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._singleton</span><br></pre></td></tr></table></figure><p>我们首先检查这个单件的实例是否被创建出来，如果没有，我们用 super 函数来创建它。因此，每当我们调用 OnlyOne 的时候，总是可以得到完全相同的实例。</p><p>单例模式还有其他的实现，比如装饰器、MetaClass，感兴趣的可以看<a href="https://zhuanlan.zhihu.com/p/37534850">这篇</a>文章。</p><p>单例的这种思想，可以用在模块中。比如对于我们前面状态模式中的例子，状态模式中对于不同的状态，我们都有对应的类会初始化作为对状态的记录（如 First tag, Open tag）。</p><p>其实我们可以将状态设置为变量，这就避免了每次都初始化状态类产生一个新的实例，同时在每一个状态类内部，不再对解析器做引用，具体的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildNode</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remaining_str, parser</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        parser.state = child_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">child_node = ChildNode()</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>单例模式设计的内容还是挺多的，如装饰器、静态方法、类方法、继承、多态、MRO、装饰器、super 方法等。为了理解单例模式，我也是花了不少时间复习这块的内容，希望整理的这些笔记可以帮到你，如果要彻底理解这些内容，重要的还是要多去练习、多动手写代码。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/37534850">Python单例模式 Singleton 的N种实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/261579683">python魔法方法，详解 new 和 init 方法</a></li><li><a href="https://www.cnblogs.com/maple-shaw/p/9288018.html">你会使用super()吗？你确定你了解它吗？</a></li><li><a href="https://docs.python.org/zh-cn/3.7/howto/descriptor.html">实现描述器</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="OOP" scheme="https://scottzhang.pro/tags/OOP/"/>
    
    <category term="singleton" scheme="https://scottzhang.pro/tags/singleton/"/>
    
    <category term="super" scheme="https://scottzhang.pro/tags/super/"/>
    
    <category term="staticmethod" scheme="https://scottzhang.pro/tags/staticmethod/"/>
    
    <category term="classmethod" scheme="https://scottzhang.pro/tags/classmethod/"/>
    
    <category term="Abstract methods" scheme="https://scottzhang.pro/tags/Abstract-methods/"/>
    
    <category term="abc" scheme="https://scottzhang.pro/tags/abc/"/>
    
    <category term="MRO" scheme="https://scottzhang.pro/tags/MRO/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-策略与状态模式</title>
    <link href="https://scottzhang.pro/article/8a706eb8.html"/>
    <id>https://scottzhang.pro/article/8a706eb8.html</id>
    <published>2021-11-16T13:32:21.000Z</published>
    <updated>2021-11-28T13:49:55.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="策略模式">策略模式</h1><p>策略模式是一种面向对象编程中的抽象模式。针对同样的问题，它实现了不同的解决方案，你的代码可以在运行的时候自由选择最恰当的方案。</p><p>策略模式的一个应用是排序，比如你要实现一个排序算法，它可以自动选择排序方法来对输入的数组进行排序，排序的方法是自动选择的，而结果是不变的。</p><p>还有一个例子是设置电脑的墙纸，当你设置墙纸的时候，你的电脑会自动帮你设置很多事情：</p><ol type="1"><li>根据屏幕的分辨率，自动将图片缩放到合适的大小</li><li>自动处理图片与系统组件之间的缩放、虚化关系</li><li>图片与背景色的结合</li></ol><p>你可以定义不同的对象，它们接受的 input 是一样的（目标图片，屏幕分辨率），不管怎样，这些对象都都能达到设置屏幕壁纸的目的。</p><p>有人说我通过 if 判断也可以达到同样的目的，但是这意味着你需要将你的代码放到一个巨大的方法中，随着新的策略的增加，你的函数将变得非常笨重。</p><p>这里略过策略模式的实例。</p><h1 id="状态模式">状态模式</h1><p>状态模式的目的是实现“状态切换”，对象的状态可以被外面知道，并且可能会被一些活动改变。来一个例子，需求是要对一个 <a href="https://www.w3.org/XML/">xml 文件</a>进行解析，一个简单的 xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>welcome to scott&#x27;s blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想把这样的文件解析出来，结果是我可以通过 node.attr 的方式访问 xml 文件的内容。比如 xml_file.body 作为一个节点。该节点有一个属性叫子节点，我可以通过 xml_file.body.children 的方式拿到，对于 title 中的内容，我已通过 xml_file.body.title.text 的方式拿到。</p><p>首先需要一个节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点类，记录节点的名字，文本，节点之间有上下级关系，所以它</span></span><br><span class="line"><span class="string">       还需要一个指向父节点的指针。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tagname, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.parent=parent</span><br><span class="line">        self.tagname = tagname</span><br><span class="line">        <span class="comment"># text 和 children 都由其他组件操作</span></span><br><span class="line">        self.children = []</span><br><span class="line">        self.text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.text:</span><br><span class="line">            <span class="keyword">return</span> self.tagname + <span class="string">&#x27;:&#x27;</span> + self.text</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.tagname</span><br></pre></td></tr></table></figure><p>有了节点后，我们还需要一个解析器，解析器会一层一层的解析字符串，我们可以定义解析器有几种状态，即处于：</p><ul><li>开始节点</li><li>子节点</li><li>结束节点</li></ul><p>如何根据解析器的状态判断是否还可以深入一步呢？可以这么定义：</p><ul><li>开始节点</li><li>子节点</li><li>打开的节点</li><li>结束节点</li><li>文本节点（最底层无子节点的节点）</li></ul><p>来看代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parser 是一个解析器。它会负责去切换状态，下图的状态之间会互相转换。</span></span><br><span class="line"><span class="string">       第一个状态是 First Tag，它永远将切换至子节点，再由子节点来决定切换到其他哪个状态。</span></span><br><span class="line"><span class="string">       每一个状态都会用自己的方法处理收到的剩余字符，然后将状态再设置为 Children Node，告诉解析器来处理剩下的部分。</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">        |                     .-------------.                      |</span></span><br><span class="line"><span class="string">        |                    (   First Tag   )                     |</span></span><br><span class="line"><span class="string">        |                     `-------------&#x27;                      |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                     .------v------.                      |</span></span><br><span class="line"><span class="string">        |         +---------&gt;( Children Node )&lt;----------+         |</span></span><br><span class="line"><span class="string">        |         |           `-------------&#x27;            |         |</span></span><br><span class="line"><span class="string">        |         |                  ^                   |         |</span></span><br><span class="line"><span class="string">        |         v                  v                   v         |</span></span><br><span class="line"><span class="string">        |  .-------------.    .-------------.     .-------------.  |</span></span><br><span class="line"><span class="string">        | (   Open tag    )  (  Closed tag   )   (     Text      ) |</span></span><br><span class="line"><span class="string">        |  `-------------&#x27;    `-------------&#x27;     `-------------&#x27;  |</span></span><br><span class="line"><span class="string">        |                                                          |</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parse_str</span>):</span></span><br><span class="line">        self.parse_str = parse_str</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.current_node = <span class="literal">None</span></span><br><span class="line">        self.state = FirstTag()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str</span>):</span></span><br><span class="line">        remainning = self.state.process(remain_str, self)</span><br><span class="line">        <span class="keyword">if</span> remainning:</span><br><span class="line">            self.process(remainning)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.process(self.parse_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理剩余的字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str (string): 剩余需要解析的字符</span></span><br><span class="line"><span class="string">            parser (Parser): parser 即上面定义的的 Parser，它会被闯进来修改它的属性，如current_node, root, state</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 剩余需要解析的字符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line"></span><br><span class="line">        root = Node(tag_name)</span><br><span class="line">        parser.root = parser.current_node = root</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;同样只需要一个 process 方法来处理字符串。</span></span><br><span class="line"><span class="string">           作为 ChildrenNode，它需要根据字符来判断需要使用什么样的类状态器，</span></span><br><span class="line"><span class="string">           类状态器的 process 方法将会完成对剩余字符的处理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str ([type]): [description]</span></span><br><span class="line"><span class="string">            parser ([type]): [description]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        striped = remain_str.strip()</span><br><span class="line">        <span class="keyword">if</span> striped.startswith(<span class="string">&#x27;&lt;&#x27;</span>):</span><br><span class="line">            parser.state = OpenTag()</span><br><span class="line">        <span class="keyword">elif</span> striped.startswith(<span class="string">&#x27;&gt;&#x27;</span>):</span><br><span class="line">            parser.state = CloseTag()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parser.state = TextNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line">        <span class="comment"># parser.current_node 未被更改还是上一层节点，将其设为父节点</span></span><br><span class="line">        node = Node(tag_name, parser.current_node)</span><br><span class="line">        parser.current_node.children.append(node)</span><br><span class="line">        parser.current_node = node</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        <span class="comment"># assert 断言中</span></span><br><span class="line">        <span class="comment"># 第一个确保 &lt; 后是/，如 &lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 第二个确保以同一个tag名开始结束，如 &lt;h1&gt;Hi&lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 以及因当前是结束tag，重置parser当前节点为其父节点</span></span><br><span class="line">        <span class="keyword">assert</span> remain_str[i_start_tag+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        tagname = remain_str[i_end_tag+<span class="number">2</span>:i_end_tag]</span><br><span class="line">        <span class="keyword">assert</span> tagname == parser.current_node.tagname</span><br><span class="line">        parser.current_node = parser.current_node.parent</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:].strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">         i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">         text = remain_str[:i_start_tag]</span><br><span class="line">         parser.current_node.text = text</span><br><span class="line">         parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> remain_str[i_start_tag:]</span><br></pre></td></tr></table></figure><p>启动代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.xml&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        p = Parser(file.read())</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">        nodes = [p.root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            nodes = node.children + nodes</span><br></pre></td></tr></table></figure><p>将会产生下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">title:welcome to scott&#x27;s blog</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-装饰器与观察者模式</title>
    <link href="https://scottzhang.pro/article/140cd416.html"/>
    <id>https://scottzhang.pro/article/140cd416.html</id>
    <published>2021-11-15T12:50:18.000Z</published>
    <updated>2021-11-28T13:50:21.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="装饰器模式">装饰器模式</h1><p>装饰器可以将一个提供核心功能的对象，和其他可以改变这个功能的对象“包裹”在一起使用。</p><p>它主要有两种用途：</p><ul><li>增强一个组件给另一个组件发送数据时的<strong>响应能力</strong></li><li>支持<strong>多种可选的行为</strong>（适当的代替多重继承）</li></ul><h2 id="装饰器">装饰器</h2><p>如果你不知道什么是装饰器，可以看下这篇 <a href="https://medium.com/citycoddee/python%E9%80%B2%E9%9A%8E%E6%8A%80%E5%B7%A7-3-%E7%A5%9E%E5%A5%87%E5%8F%88%E7%BE%8E%E5%A5%BD%E7%9A%84-decorator-%E5%97%B7%E5%97%9A-6559edc87bc0">文章</a>，其中有一段代码可以让你很容易理解它的原理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span>(<span class="params">a_func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之前做一些无聊的工作&quot;</span>)</span><br><span class="line"></span><br><span class="line">        a_func()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之后做一些无聊的工作&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;就是你! 来包装我吧!&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是一个需要被包装的家伙&quot;</span></span><br><span class="line">          <span class="string">&quot;快来拯救我！&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br></pre></td></tr></table></figure><h2 id="网络编程装饰器实例">网络编程装饰器实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法，即不管你传进来的啥东西，只要有 send 和 close</span></span><br><span class="line"><span class="string">       方法即可。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个常量数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP，另外还有 UDP（这属于计算机网络的知识）</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(client)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br></pre></td></tr></table></figure><p>上面的 respond 方法只关注接受的对象有没有 send, close 方法。</p><p>我们甚至可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法可以继续工作。</p><p>让我们来实现一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</p><p>下面的例子是一个网络编程实例的实现，它有一个服务端和客户端，服务端会一直处于待命状态，只要有客户端连接，服务端就会做出回应.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogSocket</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上面的 respond 方法只关注接受的对象有没有 send, close 方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    我们可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法就还是可以继续工作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    所以，我们可以写一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    下面举一个例子是在 send，close 调用的时候执行答应。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sending <span class="subst">&#123;data&#125;</span> to <span class="subst">&#123;self.socket.getpeername()[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        self.socket.send(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(LogSocket(client))  <span class="comment"># client 被包装（装饰），或者说被替换了</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用装饰器的好处是，你可以灵活的切换，比如你可以另外写一个装饰器，用于对发送的数据压缩。 然后你就可以实现类似这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GzipSocket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        buf = BytesIO(data)</span><br><span class="line">        zipfile = gzip.GzipFile(fileobj=buf, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        zipfile.write(data)</span><br><span class="line">        zipfile.close()</span><br><span class="line"></span><br><span class="line">        self.socket.send(buf.getvalues())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">client, addr = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> log_send:</span><br><span class="line">    client = LogSocket(client)</span><br><span class="line"><span class="keyword">if</span> gzip_send:</span><br><span class="line">    client = GzipSocket(client)</span><br></pre></td></tr></table></figure><h2 id="自定义打印的实例">自定义打印的实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_calls</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个新的函数，替换原来传入的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用：&#123;0&#125;, 携带参数 &#123;1&#125;, &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__, args, kwargs</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        return_value = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函数 &#123;&#125; 用时 &#123;&#125; &quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__,</span><br><span class="line">            time.time() - now</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> return_value</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用方法实现的装饰器的使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test = log_calls(test)</span><br><span class="line">result = test(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 特殊的方法使用装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@log_calls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用：<span class="built_in">test</span>, 携带参数 (2, 3), &#123;&#125;</span><br><span class="line">函数 <span class="built_in">test</span> 用时 2.002716064453125e-05</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="装饰器技巧">装饰器技巧</h2><p>想象一下，如果你需要给一个类中的所有方法添加一个装饰器，你会怎么办？也许你不会有这样的需求，但有时候，你可能需要对某几个函数添加装饰器，但你又不想在原来的类旁边添加任何代码。</p><p>这可以通过 metaclass 来实现，或者通过循环类的方法使用 setattr 方法修改，有兴趣的可以研究一下。</p><p>这里放一个 StackOverflow 上的 <a href="https://stackoverflow.com/questions/3467526/attaching-a-decorator-to-all-functions-within-a-class">讨论</a>。</p><h1 id="观察者模式">观察者模式</h1><p>观察者模式适用于<strong>状态监测</strong>和<strong>事件处理</strong>。</p><p>它有一个核心对象，以及观察者。核心对象由一组未知，并可能正在扩展的 “观察者” 对象来监控。一旦核心对象的值发生了变化，便会通过 update 方法告诉每一个观察者。观察者收到更新后，可能会做不一样的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inventory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.observers = []</span><br><span class="line">        self._product = <span class="literal">None</span></span><br><span class="line">        self._quantity = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._product</span><br><span class="line"></span><br><span class="line"><span class="meta">    @product.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._product = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._quantity</span><br><span class="line"></span><br><span class="line"><span class="meta">    @quantity.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._quantity = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_observers</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            <span class="comment"># 调用 observer 对象，为了让一个对象可以被调用，它需要实现</span></span><br><span class="line">            <span class="comment"># __call__ 方法</span></span><br><span class="line">            observer()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleObserver</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inventory</span>):</span></span><br><span class="line">        self.inventory = inventory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwds</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;观察者模式可以用于备份数据至不同的地方，比如文件、数据库或互联网应用。</span></span><br><span class="line"><span class="string">           它将正在被观察的代码，和执行的代码分离。</span></span><br><span class="line"><span class="string">           如果不使用这种模式，则必须在每个属性中处理可能出现的情况，这意味着任务代码和</span></span><br><span class="line"><span class="string">           被观察的对象耦合在一起，维护起来会很麻烦。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.inventory.product)</span><br><span class="line">        <span class="built_in">print</span>(self.inventory.quantity)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">invt = Inventory()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以很容易的添加观察者</span></span><br><span class="line">console_1 = ConsoleObserver(invt)</span><br><span class="line">console_2 = ConsoleObserver(invt)</span><br><span class="line"></span><br><span class="line">invt.attach(console_1)</span><br><span class="line">invt.attach(console_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到每次对 product 或者 quantity 的修改</span></span><br><span class="line"><span class="comment"># 都会产生两次打印，这是因为两个观察者都做出了响应</span></span><br><span class="line">invt.product = <span class="string">&#x27;元气森林&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">invt.quantity = <span class="number">100</span>,<span class="number">000</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级导入技巧</title>
    <link href="https://scottzhang.pro/article/935fa388.html"/>
    <id>https://scottzhang.pro/article/935fa388.html</id>
    <published>2021-09-21T15:33:14.000Z</published>
    <updated>2021-11-27T08:36:36.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章深入研究了 <code>import</code> 命令以及它的工作原理。</p></blockquote><span id="more"></span><h1 id="基本导入命令">基本导入命令</h1><p>在 <a href="https://wittyfans.com/article/c8bc6f6.html">Python-模块与包</a> 一文中，我们看到过 <code>import</code> 命令，它可以用来导入包和模块。</p><p><code>import</code> 命令有几种形式:</p><ul><li><code>import math</code></li><li><code>from math import pi</code></li><li><code>import math as m</code></li></ul><p>对于 <code>import</code> 命令，它不关心 <code>import</code> 的是一个包还是一个模块，因为语法是一样的，只是包在构建的时候有些不同。</p><blockquote><p>一个没有 <code>__init__.py</code> 文件的目录，也会被当做一个包，只是不是普通的包，有时候称其为命名空间包 (namespace packages)。</p></blockquote><p>通常情况下，在一个普通的包中，子模块和子包默认不会导入，除非你在 <code>__init__.py</code> 中有 <code>import</code> 子包和子模块。</p><p>举一例，有个叫 world 包的包，其目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">world/</span><br><span class="line">│</span><br><span class="line">├── africa/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── zimbabwe.py</span><br><span class="line">│</span><br><span class="line">├── europe/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── greece.py</span><br><span class="line">│   ├── norway.py</span><br><span class="line">│   └── spain.py</span><br><span class="line">│</span><br><span class="line">└── __init__.py</span><br></pre></td></tr></table></figure><p>如果你要使用 world 包，若其中没有 <code>__init__.py</code> 是不会包括子包的。</p><p>导入一个包会加载包的内容，并创建命名空间，命名空间是一个字典，你可以通过 <code>__dict__</code> 属性访问到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.__dict__[<span class="string">&quot;pi&quot;</span>]</span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>同样的，全局变量也是一个命名空间，可以通过 <code>globals()</code> 访问。</p><h1 id="常见导入问题">常见导入问题</h1><p>假设你现在有一个包，它的目录结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── files.py</span><br><span class="line">└── structure.py</span><br></pre></td></tr></table></figure><p><code>structure.py</code> 中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># structure.py</span></span><br><span class="line"><span class="keyword">import</span> files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>运行 <code>python structure.py .</code> 后的输出: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python structure.py .</span><br><span class="line">Create file: /home/gahjelle/structure/001/structure.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/files.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/__pycache__/files.cpython-38.pyc</span><br></pre></td></tr></table></figure></p><p>当你在 <code>structure.py</code> 需要用到 files 时，如果这两个文件在同一目录，这样是没有问题的。</p><p>现在为了满足 Pyinstaller guide 而创建了一个程序入口，你的目录结构变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── structure/</span><br><span class="line">│   ├── files.py</span><br><span class="line">│   └── structure.py</span><br><span class="line">│</span><br><span class="line">└── cli.py</span><br></pre></td></tr></table></figure><p>在 <code>cli.py</code> 中，你导入了 structure 中的 main 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> structure.structure <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>此时，如果你在 <code>cli.py</code> 所在目录执行 <code>python cli.py structure</code>，则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;cli.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from structure.structure import main</span><br><span class="line">  File &quot;/home/gahjelle/structure/structure/structure.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    import files</span><br><span class="line">ModuleNotFoundError: No module named &#x27;files&#x27;</span><br></pre></td></tr></table></figure><p>因为 <code>import files</code> 基于当前目录去寻找 files，而当执行目录变化以后，肯定就找不到了。</p><p>一种解决办法是，在引用文件中，找到引用文件的父目录，并将其加入到 <code>sys.path</code> 中（即 implicit relative imports，隐式相对导入）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local imports</span></span><br><span class="line"> sys.path.insert(<span class="number">0</span>, <span class="built_in">str</span>(pathlib.Path(__file__).parent))</span><br><span class="line"> <span class="keyword">import</span> files</span><br></pre></td></tr></table></figure><p>你可能会像在 <code>structure.py</code> 中，使用相对路径导入 <code>files</code>，如：<code>from . import files</code></p><p>但这样也是不行的，因为<a href="https://www.python.org/dev/peps/pep-0328/#relative-imports-and-name">相对导入在脚本中的解析方式与导入模块中的解析方式不同</a>。</p><p>一个更好的方式是使用 <code>pip</code>, 你自己创建一个包，使用起来就好像其他的包一样。</p><h1 id="何不创建自己的包">何不创建自己的包？</h1><p>当你通过 pip 安装一个包的时候，它可以在任何地方使用，事实上你也可以做到，首先在你的包文件夹旁边新建两个文件：</p><ul><li><code>setup.cfg</code></li><li><code>setup.py</code></li></ul><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># setup.cfg</span><br><span class="line"></span><br><span class="line">[metadata]</span><br><span class="line">name = local_structure</span><br><span class="line">version = 0.1.0</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line">packages = structure</span><br><span class="line"></span><br><span class="line"># setup.py</span><br><span class="line"></span><br><span class="line">import setuptools</span><br><span class="line"></span><br><span class="line">setuptools.setup()</span><br></pre></td></tr></table></figure><p>name 和 version，随意。名字的话建议打上标识，比如 local 或者你的用户名，这样可以方便的找出你自己的包。</p><p>准备好了之后，就可以创建你自己的包了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -e .</span><br></pre></td></tr></table></figure><p><code>-e</code> 的意思是 <code>editable</code>， 这个非常重要，因为这可以让你更改你的源代码，而不用重新安装你的包。</p><p>这条命令会将你的包安装到系统，你可以在任何地方使用你的包，只需执行 <code>from structure import files</code>。不用担心相对路径，绝对路径等问题。</p><blockquote><p>简单的包可以这样直接建立，但如果比较复杂的包则最好附上更多详细的信息，可参考 [<a href="https://realpython.com/pypi-publish-python-package/">How to Publish an Open-Source Python Package to PyPI</a>.</p></blockquote><h1 id="介绍命名空间包">介绍命名空间包</h1><p>命名空间包可以允许不存在 <code>__init__.py</code> 文件，特别的，它还允许文件分布在不同的文件夹。当你的文件夹中有 py 文件，但是没有 <code>__init__.py</code> 文件，命名空间包会被自动创建。</p><p>为了更理解命名空间包，我们直接实现它。</p><p>考虑一个需求，要将歌曲的信息序列化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>song = Song(song_id=<span class="string">&quot;1&quot;</span>, title=<span class="string">&quot;The Same River&quot;</span>, artist=<span class="string">&quot;Riverside&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>song.serialize()</span><br><span class="line"><span class="string">&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;title&quot;: &quot;The Same River&quot;, &quot;artist&quot;: &quot;Riverside&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在已经有第三方社区为你实现了一部分工作。</p><p>对于 <code>song.serialize()</code>，它接收一个序列化对象，这个序列化对象有基于 json 实现的，有基于 xml 实现的，可能内部实现代码不一样，但暴露的方法名一样，你可以在 <code>song.serialize()</code> 中自动处理。</p><p>这两个序列化对象，分别放在不同文件实现，文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">third_party/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    ├── json.py</span><br><span class="line">    └── xml.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前看起来不错，这时候你可能想再加一个自己的 yaml 的序列化方法，同样的创建目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    └── yaml.py</span><br></pre></td></tr></table></figure><p>这里虽然代码在不同的目录，但是对于 <code>serializers</code> 来说，在这2个目录里，都有着共同的命名空间。</p><p>所以你可以直接这样导入全部的序列化对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">&quot;third_party&quot;</span>, <span class="string">&quot;local&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> serializers <span class="keyword">import</span> json, xml, yaml</span><br></pre></td></tr></table></figure><p>再举一例：</p><p>假设你有Python代码的两个不同的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo-package/</span><br><span class="line">    spam/</span><br><span class="line">        blah.py</span><br><span class="line"></span><br><span class="line">bar-package/</span><br><span class="line">    spam/</span><br><span class="line">        grok.py</span><br></pre></td></tr></table></figure><p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有 <code>__init__.py</code> 文件。</p><p>让我们看看，如果将 <code>foo-package</code> 和 <code>bar-package</code> 都加到python 模块路径并尝试导入会发生什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.extend([&#x27;foo-package&#x27;, &#x27;bar-package&#x27;])</span><br><span class="line">&gt;&gt;&gt; import spam.blah</span><br><span class="line">&gt;&gt;&gt; import spam.grok</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>两个不同的包目录被合并到一起，你可以导入 <code>spam.blah</code> 和<code>spam.grok</code>，并且它们能够工作。</p><p>在这里工作的机制被称为“包命名空间”的一个特征。</p><p>从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p><h1 id="导入包的风格规范">导入包的风格规范</h1><p>导入包不可以太随意，建议将标准包、第三方包、用户自定义包区分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Standard library imports</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Third party imports</span></span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader imports</span></span><br><span class="line"><span class="keyword">from</span> reader <span class="keyword">import</span> URL</span><br></pre></td></tr></table></figure><h1 id="如何导入数据资源">如何导入数据资源？</h1><p>有时候你的包需要依赖一些数据，如果你想要将这些数据也一起打包分发给你的用户，可能会有一些问题：</p><ul><li>数据文件的路径不确定，这取决于用户的配置，包如何分发的，以及安装在哪里</li><li>你的数据文件可能在压缩文件或者 <code>.egg</code> 文件中无法直接使用</li></ul><p>历史上有过一些对数据资源的解决方案，包括 <a href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html"><code>setuptools.pkg_resources</code></a>，不过现在在 python3.7 中，有了官方的标准库来解决这个问题，那就是 <code>importlib.resources</code>，对于之前的版本，则需要使用 <code>importlib_resources</code></p><blockquote><p>命名空间包不支持 importlib.resources</p></blockquote><p>假设你有一个数据文件是关于书籍的，你的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">books/</span><br><span class="line">│</span><br><span class="line">├── __init__.py  # 空文件，构造包所用</span><br><span class="line">├── alice_in_wonderland.png</span><br><span class="line">└── alice_in_wonderland.txt</span><br></pre></td></tr></table></figure><p>如果需要这两个文件，只需要按如下代码操作即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="comment"># 文本文件, books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_text(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.txt&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    alice = fid.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制文件，books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_binary(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.png&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    cover = fid.read()</span><br></pre></td></tr></table></figure><p>如果是较老的版本，可以在 import 的时候换成支持的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><p>再来一个例子，你现在需要将你的程序添加一个 logo，你的包目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello_gui/</span><br><span class="line">│</span><br><span class="line">├── gui_resources/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── hand.png</span><br><span class="line">│   └── logo.png</span><br><span class="line">│</span><br><span class="line">└── __main__.py</span><br></pre></td></tr></table></figure><p>下面的代码显示了你应该如何引用你的 logo 文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">with</span> resources.path(<span class="string">&quot;hello_gui.gui_resources&quot;</span>, <span class="string">&quot;logo.png&quot;</span>) <span class="keyword">as</span> path:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># or do you work</span></span><br></pre></td></tr></table></figure><h1 id="使用动态导入">使用动态导入</h1><p>Python 是一门动态语言（尽管这有时候也算是缺点），这意味着你可以在 python 程序运行的时候，增加类的属性，修改函数的定义、模块的 docstring，甚至你可以修改 <code>print()</code> 函数让它什么都不输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello dynamic world!&quot;</span>)</span><br><span class="line">Hello dynamic world!</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Redefine the built-in print()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> = <span class="keyword">lambda</span> *args, **kwargs: <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hush, everybody!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Nothing is printed</span></span><br></pre></td></tr></table></figure><p>所以你也可以动态的导入一个包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docreader.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">module_name = <span class="built_in">input</span>(<span class="string">&quot;Name of module? &quot;</span>)</span><br><span class="line">module = importlib.import_module(module_name)</span><br><span class="line"><span class="built_in">print</span>(module.__doc__)</span><br></pre></td></tr></table></figure><h1 id="深入python-的导入系统">深入Python 的导入系统</h1><p>当你执行导入操作时候，背后主要发生了三件事：</p><ol type="1"><li>搜索</li><li>加载</li><li>绑定到命名空间</li></ol><p><code>import</code> 命令执行的时候，这三步会自动完成，而<code>importlib</code> 只会完成前两步。</p><p>有一点需要注意的是，即便你只导入了某个包中的一个属性，整个模块也会被导入，只是其余的部分没有绑定到当前命名空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[<span class="string">&quot;math&quot;</span>].cos(pi)</span><br><span class="line">-<span class="number">1.0</span></span><br></pre></td></tr></table></figure><p><code>sys.modules</code> 相当于系统对导入模块的缓存。当 python 在执行导入的时候，会先去缓存中查找，如果存在了，则不会执行导入。</p><h2 id="只导入一次">只导入一次</h2><p>你的包中有一些方法，它依赖一些数据，这些数据需要从磁盘或者网络读取，你的类在初始化的时候，可能会刷新这些数据，但如果每次初始化就刷新数据，会导致大量时间花在磁盘或网络IO上，可以设计一个单例模式来解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Population</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Prepare to read the population file&quot;&quot;&quot;</span></span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line">        self.variant = <span class="string">&quot;Medium&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment"># 创建只读属性的装饰器，名字不变，调用无需加括号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Read data from disk&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._data:  <span class="comment"># 已存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件，保存到 self._data</span></span><br><span class="line">        <span class="keyword">with</span> resources.open_text(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, <span class="string">&quot;WPP2019_TotalPopulationBySex.csv&quot;</span></span><br><span class="line">        ) <span class="keyword">as</span> fid:</span><br><span class="line">            <span class="comment"># Read data, filter the correct variant</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>property</code> 参考 <a href="https://www.tianqiweiqi.com/python-property.html">Python内置属性函数@property详解</a></p></blockquote><h2 id="刷新要导入的包">刷新要导入的包</h2><p>当模块属性或者方法有更新，可以使用 <code>importlib</code> 重载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importlib.reload(module_name)</span><br></pre></td></tr></table></figure><h2 id="理解导入顺序">理解导入顺序</h2><p>如果你的模块名字和标准库中的一样，系统会优先使用标准库的。</p><p><code>import</code> 执行时有几步：</p><ol type="1"><li>检查模块缓存，<code>sys.modules</code></li><li>通过查找器查找模块</li><li>通过加载器加载模块</li></ol><p>你可以继承 python 的查找器实现你自己的 finder，甚至是自己的 loader，当然可能目前没有必要。</p><p>这里想说明的是，导入操作是有顺序的，在执行查找操作时， <code>sys.meta_path</code> 会控制哪个查找器会被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">FrozenImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib_external</span>.<span class="title">PathFinder</span>&#x27;&gt;]</span></span><br></pre></td></tr></table></figure><p>这里可以看到，内置的模块先于自定义的被加载。</p><p>如果你把当前环境下所有查找器移除，python 就无法查找任何包了，但 python 仍然可以导入一些包，因为有些包已经位于缓冲中了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;math&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib  <span class="comment"># Autoimported at start-up, still in the module cache</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib</span><br><span class="line">&lt;module <span class="string">&#x27;importlib&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;.../python/lib/python3.8/importlib/__init__.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>咱们自定义一下系统的查找器，让它在查找的时候打印，这样我们就知道了当我导入一个包，有哪些包导入了。</p><p>对于查找器，有一个要求就是它必须要实现 <code>.find_spec()</code> 这个类方法，这个方法会尝试去查找模块，如果它不知道怎么查，它应该返回 None，如果知道，则返回 <code>nodule spec</code>, 如果模块无法找到，则发起 <code>ModuleNotFoundError</code> 错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debug_importer.py</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DebugFinder</span>:</span></span><br><span class="line"><span class="meta">     @classmethod  </span><span class="comment"># 类方法，无需示例即可使用</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">f&quot;Importing <span class="subst">&#123;name!r&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">sys.meta_path.insert(<span class="number">0</span>, DebugFinder)</span><br></pre></td></tr></table></figure><p>上面的查找器打印后，返回 None, 表示它不知道怎么查，随后会交给其他查找器查。</p><p>你可以按需要自定义 <code>sys.meta_path</code> 的加载顺序。</p><p>将这个自定义查找器，放在 <code>sys.meta_path</code> 第一位，每次执行 <code>import</code> 你就可以看到所有被导入的模块。</p><p>通过这种自定义查找的方法，我们甚至可以写一个自动安装包的查找器，把它插到 <code>sys.meta_path</code> 末尾，因为如果在末尾的位置被执行，这意味着前面的查找器都没有找到你想要的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip_importer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipFinder</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Module <span class="subst">&#123;name!r&#125;</span> not installed.  Attempting to pip install&quot;</span>)</span><br><span class="line">        cmd = <span class="string">f&quot;<span class="subst">&#123;sys.executable&#125;</span> -m pip install <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subprocess.run(cmd.split(), check=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> util.find_spec(name)</span><br><span class="line"></span><br><span class="line">sys.meta_path.append(PipFinder)</span><br></pre></td></tr></table></figure><blockquote><p>只是随便一说，不要放到自己项目中用！可能会带来灾难性后果</p></blockquote><h2 id="例子-数据文件导入">例子: 数据文件导入</h2><p>这个例子灵感的来源是 Aleksey Bilogur, 他有一篇文章(<a href="https://blog.quiltdata.com/import-almost-anything-in-python-an-intro-to-module-loaders-and-finders-f5e7b15cda47">Import Almost Anything in Python: An Intro to Module Loaders and Finders</a>)，介绍了模块的加载器和查找器。</p><p>你可能实现过自定义的加载器加载数据文件，但能不能利用加载器和查找器直接 <code>import</code> csv 文件呢？就好像下面这个代码一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv_importer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> employees</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.name  <span class="comment"># 直接访问列名</span></span><br><span class="line">(<span class="string">&#x27;John Smith&#x27;</span>, <span class="string">&#x27;Erica Meyers&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> employees.data:  <span class="comment"># 直接访问数据</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row[<span class="string">&quot;department&quot;</span>])</span><br><span class="line">...</span><br><span class="line">Accounting</span><br><span class="line">IT</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.__file__  <span class="comment"># 访问文件名</span></span><br><span class="line"><span class="string">&#x27;employees.csv&#x27;</span></span><br></pre></td></tr></table></figure><p>其实是可以的，我们可以将路径传给查找器处理路径的问题，然后通过加载器读取数据文件，最终实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> ModuleSpec</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CsvImporter</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, csv_path</span>):</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod  </span><span class="comment"># 类方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 处理路径</span></span><br><span class="line">    <span class="comment"># 其他操作</span></span><br><span class="line"><span class="keyword">return</span> ModuleSpec(name, cls(csv_path))  <span class="comment"># 此处 cls() 构造一个类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_module</span>(<span class="params">self, module</span>):</span></span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line"><span class="comment"># 绑定到模块中</span></span><br><span class="line">module.__dict__.update(fields)</span><br><span class="line">        module.__dict__[<span class="string">&quot;data&quot;</span>] = data</span><br><span class="line">        module.__dict__[<span class="string">&quot;fieldnames&quot;</span>] = fieldnames</span><br><span class="line">        module.__file__ = <span class="built_in">str</span>(self.csv_path)</span><br></pre></td></tr></table></figure><h1 id="其他导入技巧">其他导入技巧</h1><h2 id="导入特定版本">导入特定版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><h2 id="有条件导入你喜欢的包">有条件导入你喜欢的包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> ujson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line">   </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> quicktions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br></pre></td></tr></table></figure><h2 id="处理包的缺失">处理包的缺失</h2><p>你可能有一些比较酷的想法，比如利用 <a href="https://pypi.org/project/colorama/">Colorama</a> 这个包来给你的输出增加一些颜色，但是这个包并不是一个必要的，如果用户电脑上有这个包，那可以，要是没有你希望也可以正常使用你的程序。</p><p>你可以参考 <a href="https://realpython.com/python-testing/">testing</a> 中对于 <a href="https://realpython.com/python-mock-library/">mocks</a> 的使用实现这个想法。</p><h2 id="将脚本导入为模块">将脚本导入为模块</h2><p>脚本和模块的区别在于，脚本主要是去 do_something, 而模块则提供函数以供使用。他们都存在于 python 文件中，就 Python 而言，其实它们并没有什么区别。</p><blockquote><p>有时候你的模块可能比较复杂，有脚本也有模块，这时候可以考虑<a href="https://realpython.com/python-refactoring/">refactor</a>你的模块。</p></blockquote><p>但你也可以让你的模块提供两者的功能，既有函数，也可以直接执行，相信你看到过这种 python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="从-zip-文件启动脚本">从 ZIP 文件启动脚本</h2><p>新建一个 <code>__main__.py</code> 文件，打包成压缩包，你便可以直接通过 <code>python zip_file_name.zip</code> 这种形式运行。</p><p>你可以将你自己的包也按照这种方式处理，但 python 有提供了一个工具 <a href="https://docs.python.org/library/zipapp.html"><code>zipapp</code></a>，它可以帮你处理这些事情。</p><p>你只需要在你的包目录执行 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m zipapp population_quiz -m population_quiz:main</span><br></pre></td></tr></table></figure><p>它会做两件事，一是为你的程序添加入口，二是打包你的程序。</p><p>这里的 <code>__main__.py</code> 会自动生成，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> population_quiz</span><br><span class="line">population_quiz.main()</span><br></pre></td></tr></table></figure><p>上面的命令执行后，会产生 <code>.pyz</code> 的打包文件，在 windows 上应该可以直接执行，因为 <code>.pyz</code> 文件应该自动关联了运行程序，而在 Linux 或者 Mac 上，可以通过 -p 指定运行环境:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m zipapp population_quiz -m population_quiz:main \</span><br><span class="line">&gt;   -p <span class="string">&quot;/usr/bin/env python&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意在 zip 文件中，如果处理数据文件，open 方法会无法使用</p></blockquote><h2 id="处理循环导入">处理循环导入</h2><p>循环导入就是你中有我我中有你，比如</p><p><img src="https://i.loli.net/2021/09/21/V4rsyDKYe312CT7.png" /></p><p>这种情况本会发生无限递归循环，但是因为我们的老朋友模块缓存所以避免了惨剧的发生。</p><p>但是在下面这种情况，则会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yin.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yin&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yang</span><br><span class="line">number = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yang.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># yang.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yang&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yin</span><br><span class="line">number = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;yin and yang combined is <span class="subst">&#123;combine()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yang&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行 <code>import yin</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yin <span class="comment">#导入 yin 的时候，yin 中的 number 没有还没有定义</span></span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">  File <span class="string">&quot;.../yang.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> combine</span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line">AttributeError: module <span class="string">&#x27;yin&#x27;</span> has no attribute <span class="string">&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure><p>执行 <code>import yang</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yang  <span class="comment">#yang 调用 combine() 的时候，yin 已经初始化完成</span></span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Goodbye <span class="keyword">from</span> yin</span><br><span class="line">yin <span class="keyword">and</span> yang combined <span class="keyword">is</span> <span class="number">66</span></span><br><span class="line">Goodbye <span class="keyword">from</span> yang</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢？其实你的模块如果有存在互相引用，这意味着你的模块设计的不好，你需要想想怎么去组织你的代码。</p><h2 id="优化你的导入速度">优化你的导入速度</h2><p>你可能有些包导入的速度很慢，你想了解具体是在哪里速度变慢，自从 Python3.7 你可以有一个非常简单的办法了解你导入包的速度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python -X importtime -c <span class="string">&quot;import datetime&quot;</span></span><br><span class="line">import time: self [us] | cumulative | imported package</span><br><span class="line">...</span><br><span class="line">import time:        87 |         87 |   time</span><br><span class="line">import time:       180 |        180 |   math</span><br><span class="line">import time:       234 |        234 |   _datetime</span><br><span class="line">import time:       820 |       1320 | datetime</span><br></pre></td></tr></table></figure><p>cumulative 列按包显示了导入的累计时间（以微秒为单位）。</p><h1 id="总结">总结</h1><p>这篇文章主要介绍了：</p><ul><li>命名空间包</li><li>导入资源和数据文件</li><li>使用动态导入</li><li>扩展 Python 的导入机制</li><li>处理不同版本的包</li></ul><p>这里还有一些优秀的参考信息：</p><ul><li><a href="https://docs.python.org/reference/import.html">The import system</a></li><li><a href="https://docs.python.org/library/importlib.html">The <code>importlib</code> package</a></li><li><a href="https://www.python.org/dev/peps/pep-0420/">PEP 420: Implicit namespace packages</a></li><li><a href="https://docs.python.org/library/modules.html">Importing modules</a></li></ul><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-import/#basic-python-import">Python import: Advanced Techniques and Tips</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p05_separate_directories_import_by_namespace.html">利用命名空间导入目录分散的代码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章深入研究了 &lt;code&gt;import&lt;/code&gt; 命令以及它的工作原理。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="https://scottzhang.pro/categories/python/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 模块与包</title>
    <link href="https://scottzhang.pro/article/c8bc6f6.html"/>
    <id>https://scottzhang.pro/article/c8bc6f6.html</id>
    <published>2021-09-18T09:59:07.000Z</published>
    <updated>2021-11-27T08:36:33.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章会介绍 Python 中的模块和包。</p></blockquote><span id="more"></span><h1 id="python---模块与包">Python - 模块与包</h1><p>引申出模块化编程的概念，即将代码分解成小模块，各自解决不同的问题，这样使得代码更简单 (<strong>Simplicity</strong>)，容易维护 (<strong>Maintainability</strong>)，也更容易分享、重用代码 (<strong>Reusability</strong>)。</p><p>Python 中的模块主要有三种：</p><ol type="1"><li>用Python写的模块</li><li>用C 写的模块</li><li>内置的模块如 <code>itertools</code> 模块</li></ol><p>这篇文章只关注 Python 写的模块。</p><h1 id="模块的搜索路径">模块的搜索路径</h1><p>假设你写了个模块 <code>mod.py</code> , 怎么使用呢？</p><p>如果你当前工作目录在合适的位置，你可以执行 <code>import mod</code>, 然后你便可以引用其中的对象，那什么叫合适的位置？</p><ol type="1"><li>与 <code>mod.py</code> 同一位置</li><li>你的模块位置被包含在 <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> 中</li><li>模块位置在安装 Python 时标准链接库目录是定义过</li><li>你创建了一个 <code>.pth</code> 文件告诉 Python 去哪里找，此模块位于其中</li></ol><p>上面四种情况，只有 <code>PYTHONPATH</code> 环境变量和路径文件可以被用户配置。</p><p>Python 会自动去寻找这些地方是否有你需要的包，你可以通过 <code>sys.path</code> 查看它的搜索顺序。</p><p>所以还有一种方法导入包，即将你的包地址放入 <code>sys.path</code>，它是一个列表，所以你可以执行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">r&#x27;C:\Users\john&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> mod</span><br></pre></td></tr></table></figure><p>当模块被导入后，你也可以通过 <code>mod.__file__</code> 查看包的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Users\\john\\mod.py&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Python36\\lib\\re.py&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="导入模块">导入模块</h1><p>模块的存在是为了被导入 <code>import</code> 以使用, 就像钢琴的存在是被人演奏以产生音乐。</p><h2 id="import-module_name">import module_name</h2><p><code>import</code> 上面已有例子，需注意 <code>import</code> 不能让你直接使用所有模块内的内容。模块有其私有符号表 (<strong>private symbol table</strong>), 模块以此来确定各自之间的边界。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zoo</span><br><span class="line"><span class="built_in">print</span>(zoo.dog)  <span class="comment"># yes</span></span><br><span class="line"><span class="built_in">print</span>(dog)  <span class="comment"># no, dog 位于 zoo 中</span></span><br></pre></td></tr></table></figure><h2 id="from-module_name-import-name">from module_name import name</h2><p>另一种导入模块的方式是直接导入模块内的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module_name&gt; <span class="keyword">import</span> &lt;name(s)&gt;</span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> dog, pig  <span class="comment"># 只需要特定对象</span></span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> *  <span class="comment"># 需要所有对象</span></span><br></pre></td></tr></table></figure><p>需要小心 <code>from &lt;module_name&gt; import *</code> 这种方式，除非你很清楚自己在做什么。</p><h2 id="from-module_name-import-name-as-alt_name">from module_name import name as alt_name</h2><p>这种方式和上面的一样，只是多了 <code>as</code> 关键字以定义别名。</p><h2 id="导入提示">导入提示</h2><p>导入模块的语句通常写在文件首部，但也可以写在函数中，不过 Python3 不允许在函数中 <code>import *</code>。</p><p>防止模块导入失败，可以使用 <code>try...except...</code> 语句捕捉 <code>ImportError</code>错误。</p><p><code>dir()</code> 函数可以返回当前命名空间中所有的变量。</p><p>导入模块的时候，模块的代码将会执行，如果希望模块内的某些代码只是在你需要的时候才调用执行，可以加入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__name__ == <span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line"><span class="keyword">pass</span>  <span class="comment"># do you work</span></span><br></pre></td></tr></table></figure><p>导入模块的操作只会执行一次，考虑以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.a</span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br></pre></td></tr></table></figure><p>发现第二次和第三次导入并未输出，如果想要每次导入操作都重新导入，可利用 <code>importlib</code> 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib.reload(mod)</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">&lt;module <span class="string">&#x27;mod&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\Users\\john\\Documents\\Python\\doc\\mod.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>模块可以被当作脚本执行，只需要在模块所在文件夹增加一个 <code>__main__.py</code> 文件。</p><h1 id="python-包">Python 包</h1><p>包是一组或多组模块，包可以让你通过包的名字简单的访问其下面的各种模块。</p><p>下面是一个包的结构，其中有两个模块。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br></pre></td></tr></table></figure> 这时候如果你在 <code>pkg</code> 上级目录执行 <code>import pkg</code> 该包里将不会包括任何东西，无法引用 mod1 也无法引用 mod2 中的内容。</p><h2 id="init__.py"><code>__init__.py</code></h2><p>如果在 pkg 目录下新增 <code>__init__.py</code> 文件，则可以引用 <code>__init__</code>中的的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br><span class="line">__init__.py</span><br></pre></td></tr></table></figure><p>在内部 mod1 模块中，你也可以访问<code>__init__</code> 中的对象。</p><p>如果想在外部通过 <code>import pkg</code> 的方式，通过 <code>pkg</code> 访问 <code>mod1</code> 或 <code>mod2</code> 中的对象，则需要在 <code>__init__</code> 中导入 <code>mod1</code> 和 <code>mod2</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In __init__.py</span></span><br><span class="line"><span class="keyword">import</span> pkg.mod1, pkg.mod2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 Mod1 和 Mod2</span></span><br><span class="line"><span class="keyword">import</span> pkg</span><br><span class="line"></span><br><span class="line">pkg.mod1.foo()</span><br><span class="line"></span><br><span class="line">pkg.mod2.bar()</span><br></pre></td></tr></table></figure><blockquote><p>在 Python3.3 之后，<a href="https://www.python.org/dev/peps/pep-0420/">Implicit Namespace Packages</a> 发布了，定义包也可以不新建 <code>__init__</code> 了。</p></blockquote><h2 id="all__"><code>__all__</code></h2><p>你肯定写过 <code>from &lt;package_name&gt; import *</code> 这样的代码，其中 * 代表的是 import 什么？</p><p>如果在包的 <code>__init__.py</code> 中定义 <code>__all__</code> 来进行控制。</p><p><em><strong>pkg/__init__.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [</span><br><span class="line">        <span class="string">&#x27;mod1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod4&#x27;</span></span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>则所有其中的内容都会在写 <code>from pkg import *</code> 的时候，自动导入。</p><p>在模块中定义 <code>__all__</code> 亦是。</p><p><em><strong>pkg/mod1.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"><span class="comment"># 当使用 `from pkg.mod1 import *` 的时候，只有 foo 会被导入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod1] foo()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>区别是：</p><ul><li>对于一个包，如果<code>__all__</code> 没有定义，<code>import *</code> 不会导入任何对象</li><li>对于一个模块，如果<code>__all__</code> 没有定义，<code>import *</code> 默认导入所有对象</li></ul><h1 id="python-子包">Python 子包</h1><p>包中可以放子包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg1</span><br><span class="line">    │      mod1.py</span><br><span class="line">    │      mod2.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg2</span><br><span class="line">    │      mod3.py</span><br><span class="line">    │      mod4.py</span><br></pre></td></tr></table></figure><p>使用方式则需要一层一层使用 <code>.</code> 语法下钻:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg.sub_pkg1.mod1</span><br><span class="line">pkg.sub_pkg1.mod1.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1 <span class="keyword">import</span> mod2</span><br><span class="line">mod2.bar()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod3 <span class="keyword">import</span> baz</span><br><span class="line">baz()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod4 <span class="keyword">import</span> qux <span class="keyword">as</span> grault</span><br><span class="line">grault()</span><br></pre></td></tr></table></figure><p>如果是兄弟模块之间要导入模块怎么办？有两种方式：</p><p>全路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>相对路径: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> sub_pkg1</span><br><span class="line"><span class="built_in">print</span>(sub_pkg1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-modules-packages/">Real Python - Python Modules and Packages – An Introduction</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章会介绍 Python 中的模块和包。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="https://scottzhang.pro/categories/python/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 与 Go 开发环境配置</title>
    <link href="https://scottzhang.pro/article/dfea7f59.html"/>
    <id>https://scottzhang.pro/article/dfea7f59.html</id>
    <published>2021-09-14T04:50:03.000Z</published>
    <updated>2021-11-27T08:34:21.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。</p></blockquote><span id="more"></span><h1 id="centos-7-开发环境配置">CentOS 7 开发环境配置</h1><h2 id="git">Git</h2><blockquote><p>略过。</p></blockquote><h2 id="docker">Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 docker 进程</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 docker 阿里云镜像，容器镜像服务</span></span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://8szzfxmd.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 docker-compose</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html">如何检查进程？</a></p></blockquote><h2 id="mysql">Mysql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 mysql</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 mysql</span></span><br><span class="line">docker run -p 3306:3306 --name mymysql -v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d -V <span class="variable">$PWD</span>/logs:logs -v <span class="variable">$PWD</span>/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234@Abc -d mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 docker 的容器</span></span><br><span class="line">docker ps -a (ps: Process Status, from linux)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 mysql 容器并启动 bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -it a7a8e9df1270 /bin/bash</span><br><span class="line">myql -uroot -pyoupassword</span><br></pre></td></tr></table></figure><h2 id="python">Python</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anaconda in centos7</span></span><br><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh</span><br><span class="line">bash naconda3-5.3.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://linuxize.com/post/how-to-install-anaconda-on-centos-7/">Install &amp; uninstall Anaconda on centos7</a></p></blockquote><h2 id="go">Go</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go 环境变量</span></span><br><span class="line">go env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 go module</span></span><br><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello golang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行运行 </span></span><br><span class="line"><span class="keyword">go</span> run .\hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译文件, c/c++ -&gt; .so .lib .dll; java -&gt; .class; go -&gt; windows exe</span></span><br><span class="line"><span class="keyword">go</span> build .\hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="go" scheme="https://scottzhang.pro/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库-维度建模</title>
    <link href="https://scottzhang.pro/article/c721127b.html"/>
    <id>https://scottzhang.pro/article/c721127b.html</id>
    <published>2021-09-14T03:39:28.000Z</published>
    <updated>2021-11-27T08:44:53.725Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据仓库、商业智能初步，常用维度建模架构对比。</p></blockquote><span id="more"></span><h1 id="业务管理的问题">业务管理的问题</h1><p>信息系统存在的目的是解决业务的问题，对于数据仓库 Data WareHouse 和商业智能 Business Intelligence 来说，下面这些问题已经存在了几十年了：</p><ul><li>收集了很多数据却无法访问</li><li>需要对数据做切片、切块</li><li>分析师、业务人员需要方便的获取数据</li><li>怎么展示最重要的事情</li><li>花费大量时间在研究数字的正确性，而不是业务决策</li><li>希望使用信息做更多基于事实的决策</li></ul><p>这些问题对应了数据仓库与商业智能的目标，解决这些业务问题，信息系统必须做到：</p><ul><li>方便的存取信息</li><li>一致性的形式展示信息</li><li>能够适应变化</li><li>及时的展示信息</li><li>保护信息财富</li><li>成为提高决策制定能力的权威</li><li>业务群体的认可</li></ul><p>作为一个 DW/BI 管理者，你的责任则更具体：</p><ol type="1"><li>理解业务用户</li><li>对业务用户发布高质量、相关的、可访问的信息和分析</li><li>维护 DW/BI 环境</li></ol><h1 id="维度建模">维度建模</h1><blockquote><p>爱因斯坦曾说: <strong>凡事应该尽量简单，直到不能再简单为止</strong>。</p></blockquote><p>维度建模是展示分析数据的首选技术，它的优势在于能以商业用户可理解的方式发布数据并提供了高效的查询性能。它最初是用来简化数据库的，在维度建模中最开始使用的数据模型通常越简单越好，复杂的开始会导致最终的模型也很复杂。</p><p>维度模型通常建立在关系型数据库上，但这不意味着维度模型必须满足关系型数据库的要求，比如第三范式（3NF）。</p><p>3NF 是为了减少数据冗余，它会将数据划分成不同的实体，每个实体构成一个关系表。</p><p>但 3NF 不适用于 BI，主要是其模式太复杂，3NF 主要应用在操作性过程中，而不是 BI 查询，维度建模可以解决模式过分复杂的问题。</p><p>维度建模在不同的数据库系统中有不同的叫法：</p><ul><li>关系数据库 -&gt; 星型模式</li><li>多维数据库 -&gt; 联机分析处理</li></ul><h2 id="事实表与维度表">事实表与维度表</h2><p>在维度建模中，存在两类表：</p><ul><li>事实表（数量，销售额，需注意可加性和不可加性，比如账户结余不可加）</li><li>维度表（谁、什么、哪里、何时、如何、为什么）</li></ul><p>事实表中一条记录所表达的业务细节程度被称为<strong>粒度</strong>。通常粒度可以通过两种方式来表述：一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。</p><p>事实表的粒度有三类：事务周期快照累快照，个。 事实表通常只有很少的列和很多行，是一种<strong>“瘦高”</strong>型的表。事实表定义为以下三种类型之一：</p><ul><li>事务事实表:记录有关特定事件的事实（例如，销售事件，保存在原子的粒度，也称为原子事实表）</li><li>周期快照事实表记录给定时间点的事实（例如，月末的帐户详细信息）</li><li>累积快照事实表记录了给定时间点的汇总事实（例如，某产品的当月迄今总销售额）</li></ul><p>作为度量业务过程的事实，一般为整型或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完全不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚集。</p><p>一般事实表具有两个或更多外键与维度表关联，比如事实表中的产品键始终与产品维度中的特定产品键匹配。如果事实表中所有键与维度表中的都匹配，则满足了 <code>参照完整性</code>, 可以通过维度表使用连接操作访问事实表。</p><figure><img src="https://i.loli.net/2021/09/14/1GKmvWe2dBNwols.jpg" alt="事实表与维度表" /><figcaption aria-hidden="true">事实表与维度表</figcaption></figure><p>事实表通常包含外键集合的主键，具有组合键的表即事实表，事实表通常具有多对多的关系。</p><p>维度是维度建模的基础和灵魂。在维度建模中，将度量称为<strong>事实</strong>，将环境描述为<strong>维度</strong>，维度是用于分析事实所需要的多样环境。</p><p>维度表通常有很多列、属性，维度表倾向于包含少量的行，一般用维度表来作为查询的约束、分组。</p><p>多数情况下，数据仓库的好坏直接取决于维度属性的设置，也决定了 DW/BI 的分析能力，强大的维度属性等于健壮的分片、分块分析能力。</p><p>对维度表的设计重点关注简单性和可访问性，可以不满足第三范式。</p><h1 id="kimball-的-dwbi-架构">Kimball 的 DW/BI 架构</h1><figure><img src="https://i.loli.net/2021/09/14/9LHTwZXSxevy48a.png" alt="Kimball 架构" /><figcaption aria-hidden="true">Kimball 架构</figcaption></figure><h2 id="操作型源系统">操作型源系统</h2><p>该系统面对很多用户，并发事务很多。多是插入、更新操作。对数据的插入，更新性能要求更高，因此数据多是规范化的，规范化是指冗余度比较少。</p><h2 id="etl-系统">ETL 系统</h2><p>处理操作型源系统与DW/BI 之间，该系统对数据的处理分为三个部分：</p><ol type="1"><li>获取 Extract，从操作型系统导入到 DW/BI</li><li>转换 Transformation，清洗，合并，复制等</li><li>加载 Load，构建和加载数据到<code>展现区域</code>的目标维度模型</li></ol><p>展现区域用于组织、存储，用户也可以在这里制作报表，查询，这是用户主要关注的区域，关于展现区，该书作者有两点建议：</p><ol type="1"><li>数据应该以维度模型来展现（星型或OLAP多维数据库）</li><li>必须包含到最详细的原子数据级别</li></ol><h2 id="bi-应用">BI 应用</h2><p>这是最后一个主要的部件，BI 突出的是支持商业决策的能力，它可以很简单，也可以很复杂。</p><h1 id="其他-dwbi-架构">其他 DW/BI 架构</h1><p>第一种是独立数据集市，特点是以部门为架构组织，只考虑本部门的需要与业务规则，但不同部门之间的数据访问与标准各异，很多数值无法匹配。</p><p>这种架构代表了一种 DW/BI 架构，但其实属于没有结构，容易造成混乱。虽然可以低成本实现快速开发，但会存在分析数据冗余的问题，不是长远之计。</p><figure><img src="https://i.loli.net/2021/09/14/XUFEgK8xyf6VS4L.jpg" alt="简化的独立数据集市" /><figcaption aria-hidden="true">简化的独立数据集市</figcaption></figure><p>第二种是辐射状企业信息工厂(Corporate Information Factory) Inmon 架构，它的数据从操作型数据库获取，经过 ETL 会保存在满足第三范式的数据库中，称为 EDW (Enterprise Data Warehouse).</p><p>EDW 中的数据都是规范化的，原子级别的，相当于有一个中间过程协调与集成数据，缺点是它的下游数据组织形式以部门为单位，且包含的是聚集数据，非原子级别的数据，而对业务用户暴露原子级别的数据是有必要的，<strong>聚集数据比原子数据提供了更好的性能，但不能取代细节数据</strong>。</p><figure><img src="https://i.loli.net/2021/09/14/bNcup7VxdTjy1If.jpg" alt="CIF" /><figcaption aria-hidden="true">CIF</figcaption></figure><p>最后还有一种混合了 CIF 与 Kimball 模式的架构，有人说这是最好的架构因为混合了前面的两种架构，但是这也意味着更多的开销与时间，无论是开发还是运行期间，因为数据需要更多次的移动，细节数据冗余存储。</p><p>如果你已经建立了第三范式的 EDW，但无法让用户更灵活的实现报表与分析，可以采用这种模式。</p><h1 id="维度建模的误解">维度建模的误解</h1><p>维度模型被广泛使用，但也还存在很多误解，如：</p><ul><li>它仅包含汇总数据</li><li>它是部门级的，不是企业级的</li><li>它不可扩展</li><li>它仅用于预测</li><li>它不能被集成</li></ul><p>实际上，维度模型可以存储大量历史数据，按照业务过程组织即可满足企业级的要求，事实表非常容易扩展，数据库提供商也在不断优化维度模型的可扩展性和性能。</p><p>维度模型对业务的适应性也很强，业务需求可能是经常变化的，但维度模型具有对称性，只要以最细粒度级别构建事实表，加上维度结构非常灵活，可以很好的满足业务需要。</p><blockquote><p>细节就是上帝。—— 建筑师 Mies van der Rohe</p></blockquote><h1 id="参考">参考</h1><ul><li><a href="https://jiamaoxiang.top/2020/07/11/数仓-大数据时代-维度建模过时了吗/">数仓-大数据时代-维度建模过时了吗?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据仓库、商业智能初步，常用维度建模架构对比。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据工程" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="数据仓库" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    <category term="商业智能" scheme="https://scottzhang.pro/tags/%E5%95%86%E4%B8%9A%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>B 树索引与位图索引简述</title>
    <link href="https://scottzhang.pro/article/a8fa00e8.html"/>
    <id>https://scottzhang.pro/article/a8fa00e8.html</id>
    <published>2021-09-09T13:04:16.000Z</published>
    <updated>2021-11-27T08:28:55.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。</p></blockquote><span id="more"></span><p>在 Oracle 中， 可以使用 <code>CREATE INDEX</code> 创建索引，索引的类型有以下几种：</p><ul><li><p>Normal indexes (Oracle Database 默认使用的 B-tree 索引)</p></li><li><p>Bitmap indexes (用一个bit位来标记某个元素 rowid 对应的Value)</p></li></ul><blockquote><p>Refer <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5010.htm">Oracle 官方文档</a></p></blockquote><h1 id="b-tree">B-tree</h1><p>B-tree 的出现主要是为了提高访问磁盘的速度。那为什么使用 B-tree 实现而不是其他的数据结构呢？</p><p>对于二叉搜索树，红黑树，avl 树来说，每一个节点只能存储一个 key，如果你需要存储大量的 key，使用这些数据结构就会让树变得很高，但 B-tree 在一个节点内就可以存储多个 key，且可以拥有多个子节点，这就可以降低树的高度，提高磁盘访问速度。</p><p>那一个节点内可以存储多少个 key，可以拥有多少个子节点呢？</p><p>假设用 k (取值范围M-M/2)表示，则 B-tree 中的每个节点可以有 k-1 个 key，以及 k 个子树。</p><p>所谓 M 阶（m-way）B树，其中 M 就是表示 B-tree 中每个节点最多可以有几个子树。</p><h1 id="b-tree-1">B+ tree</h1><p>B+ tree 是 B-tree 的升级版，一棵 B+ 树需要满足以下条件:</p><ol type="1"><li>节点的子树数和关键字(Key)数相同（B 树是关键字数比子树数少一）</li><li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li><li>叶子节点包含了全部数据，同时符合左小右大的顺序</li></ol><p>B+ 树数据都在叶子节点，并使用一个链表将它们排列起来，这样在查询时效率更快。</p><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。</p><h1 id="bitmap-索引">Bitmap 索引</h1><p>我们知道计算机所有信息最终都是通过“位bit”来运算的，二进制位运算在计算机中非常高效。而位图索引也是用0或1来处理索引进程，故得名位图索引。 位图索引主要针对大量相同值的列而创建的，索引块的一个索引行中存储键值、起止RowId及此键值的位图，根据位图信息可以得知每一条记录的ROWID。它为列的每个键值建立位图，位图中的每一位可能对应多个列，位图中位的值为1表示此行的值为对应的键值。</p><p>特点：</p><ul><li>可以存储null值；</li><li>不适合键值较多的列（重复数据较少的列）,适合只有几个固定值的列；如性别、婚姻状况、行政区等等</li><li>相对于B*Tree索引,占用的空间非常小,创建和使用非常快；</li><li>适合静态数据，而不适合索引频繁更新的列；</li><li>使用count、and、or或in查询时,直接用索引的位图进行或运算,快速得出结果行数据。</li></ul><h1 id="参考">参考</h1><ul><li><a href="https://juejin.cn/post/6844903613915987975">理解 B 树、B+ 树特点及使用场景</a></li><li><a href="https://www.programiz.com/dsa/b-tree">B-tree 介绍与代码实现</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-tree 动态交互图</a></li><li><a href="https://bbs.huaweicloud.com/blogs/114861">Oracle 索引概述</a></li><li><a href="http://tech.jasonsoso.com/2015/01/B-tree-indexes-and-bitmap-indexes/">B 树索引与位图索引简述</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据库" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://scottzhang.pro/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>数据分析在做什么</title>
    <link href="https://scottzhang.pro/article/a31aaf3c.html"/>
    <id>https://scottzhang.pro/article/a31aaf3c.html</id>
    <published>2021-09-06T15:42:25.000Z</published>
    <updated>2021-11-27T08:43:13.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据分析即做比较。</p></blockquote><span id="more"></span><h1 id="数据分析在做什么">数据分析在做什么？</h1><p>数据分析本质上做对比，所以首先考虑的问题是和谁比，怎么比，比什么。 其次，分析对应的是分解问题，分析拆解后的复杂事物，得到拆解元素之间的联系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据分析 -&gt; 拆分、分解问题 -&gt; 比较</span><br></pre></td></tr></table></figure><p>数据的字段 (Field) 有各种类型，如：</p><ol type="1"><li>定类尺度（性别）</li><li>定序尺度（成绩优良中下）</li><li>定距尺度（30比20高10）</li><li>定比尺度（项目数，每月工时）</li></ol><p>同样，对于数据的属性也有好几种，如离散属性以及连续属性。离散属性中有频率与频数。连续属性则有：</p><ol type="1"><li>平均值</li><li>中位数、分位数</li><li>众数</li><li>方差、标准差、自由度</li><li>偏态系数</li><li>峰态系数</li></ol><h1 id="怎么比">怎么比</h1><p>首先来看怎么比的问题，简单的多少、长短也是比较，对于数据分析我们有如下几种常用的类型。</p><ol type="1"><li>假设检验，一致还是不一致</li><li>多维分析与钻取分析（Drill Down，Roll up）</li><li>交叉分析与透视表</li><li>秩次比较</li><li>相关分析</li><li>回归探索</li><li>自由分组与归类</li></ol><blockquote><p>这里说的是什么暂时不理解没关系，之后会单独拿出来讲。</p></blockquote><h2 id="一致还是不一致">一致还是不一致</h2><p>我们可以通过假设检验来回答一致还是不一致的问题，先解释假设检验中的两个单词: <code>H0</code> 和 <code>H1</code>。</p><ul><li><code>H0</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差是由自然误差引起的</li><li><code>H1</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差存在本质上的差别</li></ul><p>拒绝<code>H0</code> 的成立，就可以对数据的比较做出结论推断，通常需要确定最大概率，用 <span class="math inline">\(\alpha\)</span> 表示，常见的情况下取 0.05 或 0.01， 如果原假设发生的概率小于 <span class="math inline">\(\alpha\)</span> 则可以拒绝 <code>H0</code>。 为了拒绝原假设，需要进行检验，即检验统计量，检验统计量的方法有很多种，在不同的场景下对应着不同的检验方法，常见的检验方法及应用场景有：</p><ul><li>Z 检验， 样本均值是否与正态分布总体一致？</li><li>T 检验，样本平均数与整体平均数</li><li>F 检验，多组样本间的一致性比较</li><li>卡方检验， 两个分部是否一致的差异</li><li>秩和检验， 摆脱对总体分布的依赖，秩理解为名次</li><li>A/B Test，新功能衡量部分用户的表现，上不上？</li><li>低功效实验，P值</li></ul><p>需注意不同的检验方法的要求与统计量的计算方式不同，需要根据实际情况选择。</p><p>假设检验的结果也有可能是错的，主要有两类错误：</p><ul><li>第一类错误，是真实情况为 <em><code>H0</code></em> 成立，但判断结论为拒绝 <em><code>H0</code></em>， 也就是把真的当成了假的</li><li>第二类错误，是真实情况为 <em><code>H0</code></em> 不成立，但判断结果接受 <em><code>H0</code></em>，也就是把假的当成了真的</li></ul><p>在饱和的情况下，这两类的错误属于此消彼长的关系，当降低第一类错误发生概率时，第二类错误发生的概率会增加，反之亦然。</p><h2 id="假设检验公式">假设检验公式</h2><ul><li>Z检验, <span class="math inline">\(Z = \frac{(\bar{x}-\mu_0)}{s}\)</span> = <span class="math inline">\(\frac{(sample average-mean)}{standard\ deviation}\)</span></li></ul><h2 id="多维分析与钻取分析">多维分析与钻取分析</h2><p>多维分析的问题类似，调查北京有多少厨师？你需要列举所有可能的与厨师数量的属性，比如餐馆的数量、门店类型、分布规律等。</p><p>钻取分析的例子，假设某月，可乐的销量突然上涨，你想知道具体是在什么地区上涨（Contributing)。</p><p>多维分析是从多个角度、多个维度分析。钻取分析则是从维度变化的角度考虑，扩大或者缩小分析粒度。</p><p>多维分析可以在不同对象的相同维度下进行比较，也可以在相同对象的不同维度下，甚至是不同对象的不同维度，只要有业务支持。具体的方法可以比数值、也可以比占比。其精髓在于尽可能的罗列所有维度。</p><p>钻取分析需要注意其陷阱，因为<strong>下钻的层次越深，复合特征的样本越来越少，越少的样本代表着越高的风险，也会导致越不可靠的结论。</strong></p><p>其次钻取的顺序也需要注意，比如调查离职员工的规律，为什么先从部门开始钻取，而不是其他？这里需要有个标准，一般来说<strong>区分程度最大的下钻方式应该排在最前面</strong>，如何衡量这个区分度呢？这就属于决策树中的内容了。</p><p>另外一个钻取的陷阱是<a href="https://wiki.mbalib.com/wiki/辛普森悖论">辛普森悖论</a>， 这里不做多介绍，感兴趣的可以打开链接了解。</p><h2 id="交叉分析与透视表">交叉分析与透视表</h2><p>这部分如果会使用 Excel 的 Pivot Table，或者 Pandas 里的 <code>groupby</code>， <code>pivot</code> 或 <code>pivot_table</code> 方法就懂了，在此不做解释。</p><h2 id="秩次比较">秩次比较</h2><blockquote><p>未完待续...</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据分析即做比较。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据分析" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>统计基础概念</title>
    <link href="https://scottzhang.pro/article/4187072417.html"/>
    <id>https://scottzhang.pro/article/4187072417.html</id>
    <published>2021-08-15T15:03:54.000Z</published>
    <updated>2021-11-27T08:22:27.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概率与统计的基础概念。</p></blockquote><span id="more"></span><h1 id="统计">统计</h1><p>数据类型： - 离散类型，只能是某些既定的值 - 连续类型，可以是一个范围里任何的值</p><p>离散数据是数出来的，连续数据是测量出来的。对于离散概率分布，我们关心的是取得一个特定数值的概率。例如抛硬币正面向上的概率为:p(x=正面)=1/2</p><p>而对于连续概率分布来说，我们无法给出每一个数值的概率，因为我们不可能列举每一个精确数值。</p><h2 id="histograms直方图">1. Histograms（直方图）</h2><p>定义：是一种对数据分布情况的图形表示，横轴是统计样本，纵轴是统计样本某个属性的度量。</p><p>我们测试人的身高，把这些数据放到数轴上，并分段，把数据这个段（bins）的数据从下往上堆，就得到了直方图。</p><p>有了这个图，我们就可以预测未来的到某个身高值的概率。</p><p>比如，你敢打赌下一个测量的人，有很大的几率处在直方图靠近中间的位置。</p><p>如果你想要用一个图，来近似表示你的数据，或未来预测的测量值，就可以使用直方图。</p><p>直方图中的bins的选择，很重要，太小或太大都不行，不要仅仅依靠程序的默认值。</p><h2 id="statistical-distribution概率分布">2. Statistical distribution（概率分布）</h2><p>现在你拿到了直方图，你的bins可能需要调整一下，你从1调整为0.5，这样让你的图像更直观，同时，也让你对数据的预测更准确。</p><p>你会发现，你的数据量越多，和你的bins越小，都可以提高你对数据预测的准确率。</p><p>你可以用一条曲线来表示分布，他比直方图更准确，因为直方图总会有在某个区间的值比较少或没有的情况，而曲线是连续的，且很方便计算。</p><p>另外，当你没有足够的资源和钱做足够的测试，你其实可以用既有的数据算出这跟我曲线。曲线图和分布图都是描述分布的一种方式。</p><h2 id="normal-distribution正态分布">3. Normal Distribution（正态分布）</h2><p>我们看过身高的数据，会发现它是左右对称的，事实上人类身高是一种正态分布。</p><p>刚出生的小孩和成年人的分布不一样，成年人高矮的区间比较大，而刚出生的小孩身高区间都在一个比较小的范围。</p><p>这个分布的宽度（即身高的区间）由数据的标准差决定。</p><p>知道这个标准差很重要，如在小孩的分布中，图像标准差为0.6，成人的为4.</p><p>我们可以知道 95% 的数据会落在（平均值 +- 2* 标准差），自然界的很多事物都遵循正态分布，这是因为什么呢？这就是中心极限定理</p><h2 id="population-parameters总体参数">4. Population Parameters（总体参数）</h2><p>我们选择测量一些基因数据，得到了一个直方图，通过直方图计算概率。</p><p><img src="https://i.loli.net/2020/03/28/lbg2cPIiaHqfGBD.png" /></p><p>这个分布的 mean=20, std=10。</p><p>同样的，我们也可以根据曲线图来计算概率。</p><p><img src="https://i.loli.net/2020/03/28/FgTQjHkDPYcIoUs.png" /></p><p>因为上述的直方图和曲线图，表示了所有的基因数据分布，在统计上会叫它为population，而mean和std，叫做 population mean 和 population std.</p><p>分布有很多种，有： - 指数分布，指数分布的参数是rate,即population rate. - Gamma 分布, 参数是 shape 和 rate</p><p>知道 population 参数的原因是，你的分布可以重复计算. 如果你有机器学习基础，你可以把 population参数看作是 training dataset, 曲线则是我们想要根据我们的方法作出的预测。</p><p>事实上，你测量的数据得到的population参数，每次都是不一样的，那怎么估计真实的参数呢？事实上，当你做的测量越多，你得到的参数，就越接近真实的参数。</p><p>统计的一个目的就是，根据你现有测量的数据，你对这个真实的参数，有多大的信心估计正确了。</p><p>特别的，我们一般用 p-value 和 置信区间来描述这种信心。</p><p>数据也多，你的信心就越大，</p><h3 id="bootstrap-refresher">bootstrap refresher</h3><p>我们测量12只母老鼠的体重，并计算这组老鼠体重的的平均值，这个平均值只是这12只老鼠的，而利用sample，我们可以利用手中已有的值，去估计所有老鼠体重的平均值。</p><p>怎么做的，用 sampling with replacement，即有放回的抽样，抽12次之后，计算平均值。</p><p>重复上面的步骤很多次，对这些平均值再取平均，即得到了你想要的值。</p><p>再来说置信区间，我们一般说95%的置信区间，意思就是，那个包含了上述95%的平均值的范围。</p><p>如果你拿母老鼠和公老鼠的数据对比，分别看他们95%的平均值的范围，如果彼此没有重合，那就可以说他们是不一样的，两组值的mean是统计显著的，而如果有重合的部分，就需要做t-test了。</p><h2 id="meanvariancestd">5. Mean，Variance，STD</h2><p>我们以上面的基因例子为例，对240万个基因值计算平均值，即得到了平均值，注意，这是对所有的值计算平均值，所以不是population mean，而是 真正的mean。</p><p>注意区分：</p><ul><li>sample mean，estimated mean（x-bar）</li><li>population mean（mu）</li></ul><p>总结：</p><p>如果你有所有的值，那直接除以数量，就得到了平均值（mu） 如果你没有所有值，可以利用（x-bar）估计population mean，x-bar是你既有的值算出来的平均值。</p><p>population variance，用你的data减去population mean（mu），平方后再除以样本数。</p><p>population std则是对population variance开根号。</p><p>然而，更多的情况是，你不可能直接算出来population mean，std，variance这些值，因为你只有有限的样本。</p><p>所以你得用x-bar代替mu，并将n-1代替n作为样本空间，计算variance，以及std。</p><p>因为我们算的是sample mean，而不是population mean，所以n需要减1。</p><p>为什么呢？请看下图</p><p><img src="https://i.loli.net/2020/03/29/Dch4BEqaHNTnJ7b.png" /></p><p><img src="https://i.loli.net/2020/03/29/ElgYG5SktiePJZu.jpg" /></p><p>因为数据与sample mean之间的差值，要小于数据与population mean之间的差值。</p><h2 id="what-is-a-statistical-model">6. What is a statistical model?</h2><p>model，即模型。比如根据老鼠体重，预测体长，这就是一个 model.</p><p>在这个语境下，model是一种关系。</p><p>体重越大，体长越长。</p><p>有时候model中，x和y的关系，并不是一条直线。</p><p>model 可以很简单，也可以很复杂。</p><h2 id="sampling-a-distribution">7. Sampling A Distribution</h2><p>对一个分布进行抽样，假设你现在有一个随机的分布，我们可以从中抽样，来计算这个分布的mean值（x-bar）</p><p>你可以抽样很多次，于是你会得到一个mean值的分布，这个分布图像的mean，随着抽样的个数（sample size）的增加，抽样分布的mean，会趋向于真正的mean，即（population mean），抽样分布的图像，会接近正态分布，符合中心极限定理的定义。</p><p>这里的n增加，我们的图像的std会变小，即图像变得更窄，但更高。</p><h2 id="python-实践">Python 实践</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="population-parametersactual">Population parameters(actual)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 Numpy 自带包计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Population Mean: &#123;&#125; \nPopulation Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.mean(arr),np.var(arr)))</span><br></pre></td></tr></table></figure><pre><code>Population Mean: 50.29 Population Variance:687.2659000000001</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mean</span></span><br><span class="line">population_mean = np.mean(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># variance</span></span><br><span class="line">value_squares = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">    value = num - population_mean</span><br><span class="line">    value_square = np.square(value)</span><br><span class="line">    value_squares.append(value_square)</span><br><span class="line">    </span><br><span class="line">variance = np.<span class="built_in">sum</span>(value_squares) / <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Population Mean: &#123;&#125; \nPopulation Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(population_mean,variance))</span><br></pre></td></tr></table></figure><pre><code>Population Mean: 50.29 Population Variance:687.2659000000001</code></pre><h3 id="samples-parametersestimate">Samples parameters(estimate)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sampling</span></span><br><span class="line">sample = np.random.choice(arr,size=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample mean, x-bar</span></span><br><span class="line">sample_x_bar = np.mean(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample variance with numpy</span></span><br><span class="line">sample_var = np.var(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample variance by hand, n as denominator</span></span><br><span class="line">absolute_values = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sample:</span><br><span class="line">    absolute_value = i - np.mean(sample)</span><br><span class="line">    absolute_value_square = np.square(absolute_value)</span><br><span class="line">    absolute_values.append(absolute_value_square)</span><br><span class="line"></span><br><span class="line">biased_variance = np.<span class="built_in">sum</span>(absolute_values)/<span class="built_in">len</span>(sample)</span><br><span class="line">unbiased_variance = np.<span class="built_in">sum</span>(absolute_values)/<span class="built_in">len</span>(sample) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Mean:&#123;&#125;\nSample Variance:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(sample_x_bar,sample_var))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Variance Biased:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(biased_variance))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample Variance Unbiased:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(unbiased_variance))</span><br></pre></td></tr></table></figure><pre><code>Sample Mean:50.54Sample Variance:726.8484Sample Variance Biased:726.8484Sample Variance Unbiased:725.8484</code></pre><h3 id="sampling-distribution">Sampling Distribution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x_bars = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># sampling</span></span><br><span class="line">    sample = np.random.choice(arr,size=<span class="number">100</span>)</span><br><span class="line">    <span class="comment"># sample mean, x-bar</span></span><br><span class="line">    sample_x_bar = np.mean(sample)</span><br><span class="line">    x_bars.append(sample_x_bar)</span><br><span class="line"></span><br><span class="line">plt.hist(x_bars)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/30/FCkgKPpLjIShmrH.png" /></p><h1 id="p-values">8. P-values</h1><p>对于两个药物的测试结果如下，我们完全可以观察出，A药物明显有效果，而B无效，且无法断定说，这两者的表现，只是一种随机现象。</p><figure><img src="https://i.loli.net/2020/03/29/Ez6BOw4moXCx7gM.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这时候就可以请p value发挥作用了。</p><figure><img src="https://i.loli.net/2020/03/29/lItcEZOfhXn8Vju.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/03/29/QbJnsG5hw7TdLUp.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="calculate-p-values">Calculate P-values</h2><p>P-values有两种，One-Sided 和 Two-Sided。</p><p>我们一般谈后面那种，并避免使用第一种。</p><p>你扔了两次硬币，都是国徽面朝上，你觉得这个硬币应该是不正常的，你搞到了一个神奇硬币！</p><p>你想知道，这真的是一个神奇硬币吗？</p><p>于是你想验证，你假设，这个这个硬币和别的硬币没什么区别（Null Hypothesis）。</p><p>如果你接下，推翻了这个假设，即，这个硬币和别的是有区别的，那么你拿到的，就是神奇硬币了。</p><p>为了验证这个假设，我们来计算抛两次硬币的概率, 使用树形图来看，很明显，两枚硬币都是国徽面的概率是25%。</p><figure><img src="https://i.loli.net/2020/04/05/syJ5TqSHGOrA4pf.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在，我们再来算，我们得到两个人像面的p value,p-value 由 3 部分组成：</p><ol type="1"><li>The probability random chance would result in the observation，在这里就是一个正常硬币，扔两次得到两次人像的概率，即0.25。</li><li>The probability of observing something else that is equally rare, 这里是两个人像或是两个国徽，也是0.25.</li><li>The probability of observing something rarer or more extreme. 这里是0，因为没有其他的结果比两个人像、两个国徽的概率更低。</li></ol><p>​</p><p>现在，p-value 就是 0.25 + 0.25 + 0 = 0.5. 注意我们计算 p-value 的目的是测试假设：</p><p>我的硬币和其他硬币是一样的。</p><p>通常来说，当 p-value 小于0.05 的时候，我们会拒绝这个假设，但是现在的概率是0.5,所以这个假设是真的，也就是你拿到的，不是神奇硬币啦。</p><blockquote><p>注意， 得到两个人像面概率为0.25与得到两个人像面得p-value为0.25，这两者不一样。</p></blockquote><p>为什么我们需要关心上面得条件2和3呢？</p><p>举个例子，当你送一朵花给你得意中人，你说：这是这个品种的花中最特别的。于是你得到了它的芳心。</p><p>但当她收到了10朵花，你说：这朵花和其余9朵花一样都很特殊。那这朵花，她也许就觉得不特别了，这是2的情况，所以我们把2的概率加进来。</p><p>也有可能是这样，你跟她说：还有很多的花，比现在这朵更稀有。她也会觉得这朵花不特别，这是3的情况。</p><p>现在我们知道扔2次，得到2个人像面的情况，如果扔5次得到4次人像呢？我们计算 p-value 看看(我们不关心顺序)：</p><figure><img src="https://i.loli.net/2020/04/05/Ve46vSliGoZ7Uth.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/Ve46vSliGoZ7Uth.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/U5dWXOKJkA1Hshq.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>我们需要p-value小于0.05就可以拒绝这个假设了，但目前来看，好像还是无法拒绝:</p><figure><img src="https://i.loli.net/2020/04/05/jK7meLAH9l1WEZU.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>对于连续的数据计算p-value，我们一般通过概率分布来计算，考虑一个身高的例子：</p><figure><img src="https://i.loli.net/2020/04/05/dvnTr6PucGeQFUm.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/ReZDQBT7lgu92H5.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2020/04/05/NegynLJ7pU3xTKB.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="covariance-and-correlation">9. Covariance and Correlation</h1><p>Covariance 一般可以分为三类，斜率为正的图像，斜率为负的图像，平行于x或y轴的图像。</p><p>即 positive trends, negative trends, no trends.</p><p>但 covariance 只能告诉你，数据是positive还是 negative 的trend，无法告诉你这个图像的slope，是陡峭还是平缓。</p><p>它也无法告诉你各个点与图像之间的距离。</p><p>如果所有的图像的 x或者y 值，是一样的，则 covariance 为0.</p><p>如果我们根据x和x本身来算 Covariance, 同时对比 2*x与 2*x 本身的图像，会发现两者的图像是一致的:</p><figure><img src="https://i.loli.net/2020/04/07/1FbmP3zsrGCL8fg.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>总的来说，Covariance 是根据各个点与平均值之间的距离来算的，这意味着它会受到点与均值之间距离的影响，也会受到坐标轴的影响。解决这个问题，引入下一个概念，即 Correlation。</p><h1 id="r-squared">10. R-squared</h1><p>我们已经知道 Correlation 的概念。为什么需要 <span class="math inline">\(R^{2}\)</span> 的概念，某些时候，它更容易解释，如 0.7 是 0.5 的两倍不容易理解，而0.7方是0.5方的两倍却很简单。</p><p>另外看一个老鼠的例子：</p><figure><img src="https://i.loli.net/2020/04/16/YrKQpu8G6xnB9mj.png" alt="老鼠的例子" /><figcaption aria-hidden="true">老鼠的例子</figcaption></figure><p>我们分别计算各点对于平均值（黑线）的方差，以及平均值对于fit的蓝线的方差，然后计算<span class="math inline">\(R^{2}\)</span>。</p><p>公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var(mean) - var(blue line) / var(mean)</span><br></pre></td></tr></table></figure><p>结果是 81%, 这意味着蓝线比平均值小了81%的方差。</p><p>对于两个变量之间的关系来说，<span class="math inline">\(R^{2}\)</span> 越高，说明拟合程度越好。</p><p>需要<a href="https://www.zhihu.com/question/32021302">区别</a>: <span class="math inline">\(R^{2}\)</span> 和相关系数的关系。</p><h1 id="central-limit-theorem">11. Central Limit Theorem</h1><p>中心极限定理，如果我们对0-1之间的数据抽样20个，计算mean，得出一个结果，然后绘制在另一个<strong>直方图</strong>上，如此反复几百遍后，我们得到的mean将会是一个正态分布的图。</p><p>这个原理，对于任何分布的图都适用。</p><p>摘录几则关于中心极限定理的话：</p><blockquote><p>摘录来自: “赤裸裸的统计学。” Apple Books.</p></blockquote><ul><li>“中心极限定理是许多统计活动的“动力源泉”，这些活动存在着一个共同的特点，那就是使用样本对一个更大的数量对象进行推理”</li><li>“个大型样本的正确抽样与其所代表的群体存在相似关系。当然，每个样本之间肯定会存在差异（比如前往马拉松起点的这么多辆客车，每辆客车乘客的组成都不可能完全相同），但是任一样本与整体之间存在巨大差异的概率是较低的”</li><li>“如果我们掌握了某个正确抽取的样本的具体信息（平均数和标准差），就能对其所代表的群体做出令人惊讶的精确推理”</li><li>“如果我们掌握了某个样本的数据，以及某个群体的数据，就能推理出该样本是否就是该群体的样本之一”</li><li>“通过中心极限定理，我们就能计算出某个样本（客车上的肥胖乘客）属于某个群体（马拉松比赛选手）的概率是多少，如果概率非常低，那么我们就能自信满满地说该样本不属于该群体”</li><li>“如果我们已知两个样本的基本特性，就能推理出这两个样本是否取自同一个群体。”</li></ul><p>那么，中心极限定理的实际意义是什么呢？</p><ol type="1"><li>计算置信区间</li><li>t-test，即两个sample的mean是否不同</li><li>ANAVO,即三个sample或以上的mean是否不同</li></ol><p><em>通常来说，为了中心极限定理的有效性，sample size必须要至少大于30.</em></p><h1 id="standard-deviation-vs-standard-error">12. Standard Deviation vs Standard Error</h1><ul><li>“标准差（Standard Deviation）是用来衡量群体中所有个体的离散性”，如心脏研究中所有参与者的体重分布”</li><li>“标准误差（Standard Error）衡量的仅仅是样本平均值的离散性。如果我们反复从弗雷明汉心脏研究数据库中抽取100名参与者作为样本，并计算其平均值，那么这些样本平均值的分布会是怎样一种情况？”</li></ul><p>另外：</p><p><strong>“标准误差就是所有样本平均值的标准差！”</strong></p><p>“如果标准误差差很大，就意味着样本平均值在群体平均值周围分布得极为分散；如果标准误差差很小，就意味着样本平均值之间的聚集程度很高。”</p><p>关于这两者，还有一些图像上的规律：</p><ul><li>“样本数量越多，其平均值就越不容易偏离整体平均值。图像也就越集中，因为大型样本受极端异常值的影响相对较小”</li><li>“数据分布越分散，那么其样本平均值的聚集程度就越低。”</li></ul><p>其次，需要注意的是：</p><p><strong>“如果标准差本身的数值很大，那么标准误差的数值也不会小。取自一个高度离散群体的大规模样本，其离散程度也会很高；与之对应，如果是一个高度聚集的群体，其样本围绕平均值的聚集程度也会很高。”</strong></p><p>由于样本的平均值是正态分布的，即中心极限定理的内容，我们有以下的规律：</p><p>“差不多有68%的样本平均值会在群体平均值一个标准误差的范围之内，有95%的样本平均值会在群体平均值的两个标准误差的范围之内，有99.7%的样本平均值会在群体平均值3个标准误差的范围之内。”</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概率与统计的基础概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="https://scottzhang.pro/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://scottzhang.pro/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="统计" scheme="https://scottzhang.pro/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法参考</title>
    <link href="https://scottzhang.pro/article/1895500896.html"/>
    <id>https://scottzhang.pro/article/1895500896.html</id>
    <published>2021-08-15T14:40:06.000Z</published>
    <updated>2021-11-27T08:27:54.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统的复习一下数据结构与算法的知识，包括 Python 实现的代码模板。</p></blockquote><span id="more"></span><blockquote><p>Update: 2021-8-22, 更新链表 python 实现</p></blockquote><h1 id="数组链表跳表">数组、链表、跳表</h1><h2 id="数组">数组</h2><p>申请数组，计算机在内存中给你开辟一段 <strong>连续</strong> 的地址。如果直接访问数组中的某个元素，不管是前后，时间复杂度是一样的 O(1).</p><p>问题：</p><ul><li>在中间位置插入元素，后面的元素都要移动，导致插入操作的时间复杂度不再是常数级的了，而是 O(n)，在最坏的情况下</li><li>删除的时候，也一样，时间复杂度和插入一样</li></ul><h3 id="java-数组实现">Java 数组实现</h3><p>操作</p><ol type="1"><li>判断数组的 Size 是否够</li><li>如果够，插入元素</li><li>如果不够，申请一个新的数组，size是当前的2倍，并将原来的数组拷贝到新的数组</li><li>将后面的元素往后挪</li></ol><p>可见数组的操作中，存在大量的元素拷贝。</p><h2 id="链表">链表</h2><p>在修改，添加，删除等操作频繁的情况下，数组并不好用，这时候推荐使用链表。链表的每一个元素都有 <code>value</code> 和 <code>next</code>，其中 <code>next</code> 指向下一个元素。这个元素一般使用 <code>class</code> 来定义，叫 <code>node</code>。</p><p>如果只有一个指针叫单链表，如果有两个双向的，叫双链表，头指针叫 <code>head</code>，尾指针叫 <code>tail</code>，如果 <code>head</code> 连接了 <code>tail</code>，叫<code>循环链表</code>。</p><p>Python 实现单链表，来自<a href="https://zhuanlan.zhihu.com/p/60057180">知乎</a>，该文章还有关于双链表，循环列表的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表的结点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># next是下一个节点的标识</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始指针指向head</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 指针指向None 表示到达尾部</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针下移</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">items</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取head指针</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="comment"># 循环遍历</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 返回生成器</span></span><br><span class="line">            <span class="keyword">yield</span> cur.item</span><br><span class="line">            <span class="comment"># 指针下移</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;向链表头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 新结点指针指向原头部结点</span></span><br><span class="line">        node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="comment"># 头部结点指针修改为新结点</span></span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 先判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 空链表，_head 指向新结点</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不是空链表，则找到尾部，将尾部next结点指向新结点</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置插入元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 指定位置在第一个元素之前，在头部插入</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="comment"># 指定位置超过尾部，在尾部插入</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; (self.length() - <span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 创建元素结点</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="comment"># 循环到需要插入的位置</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除节点&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 找到指定元素</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 如果第一个就是删除的节点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                    <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 继续按链表后移节点</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self.items()</span><br></pre></td></tr></table></figure><h3 id="链表复杂度">链表复杂度</h3><p>操作</p><ol type="1"><li>将插入位置前的元素的next指向新节点，新节点的指向后节点，操作两次，常数级别，O(1)</li><li>与插入类似</li></ol><p>优点：</p><ul><li>不用群移，不需要复制元素</li><li>移动，修改的效率很高</li></ul><p>缺点</p><ul><li>访问中间节点，必须一步一步往后挪，所以复杂度为O(n)</li></ul><h2 id="跳表">跳表</h2><figure><img src="https://i.loli.net/2021/03/07/5ryvJGuCsPS4cpN.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>弥补链表的设计缺陷而设计，为了加速链表访问的速度，在节点之间搭建快速路（索引）。</li><li>索引越多，速度越快，但是也没有降到O(1)，而是 O(logn)</li><li>现实中，因为索引经常操作，维护成本较高</li><li>空间复杂度为 O(n)，但肯定还是比链表高</li></ul><h1 id="栈队列">栈、队列</h1><ul><li><p>栈相当于一个瓶子，先放进去的后面才能拿出来。</p></li><li><p>队列相当于一个管子，先放进去的先出来。</p></li></ul><p>这两个，复杂度添加删除都是 O(1)，查询则是 O(n)，因为它们内部元素是无序的，查任何元素都需要遍历整个数据结构。</p><p>实战中，其实纯粹的栈、队列用的很少，更多的用的是双端队列(Double-End queue)，一个栈和队列的结合体，它两边都可以 push，pop，复杂度和正常的栈、队列都一样。</p><figure><img src="https://i.loli.net/2021/08/12/JUxhPSH6LqB74CO.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>栈的一些操作，可以直接通过 python 中的列表实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="built_in">list</span>.append() == push</span><br><span class="line"><span class="built_in">list</span>.pop() == pop</span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] == peek</span><br></pre></td></tr></table></figure><h2 id="优先队列">优先队列</h2><p>也就是元素是有优先级的，它的插入是 O(1), 取出操作 O(logN), 因为需要按照元素的优先级取出。底层的实现方式较为多样和负责，有 heap, bst, treap.</p><h1 id="哈希表映射集合">哈希表、映射、集合</h1><p>哈希表也叫散列表，现实中用的比较多，类似字典的key value对，但它是通过哈希函数建立一个映射关系，key 相当于关键码值，value 也就是存放数据的地方叫哈希表。</p><p>现实中一般应用在电话号码，用户信息表，缓存，键值对存储（Redis）。</p><p>哈希函数有很多种，选的好可以让生成的地址比较分散，不会重复，这里重复的意思就是，比如我字符 scott 生成的地址是 9，然后 zhang 生成的也是9，这就重复了，这叫哈希碰撞。</p><p>但发生了碰撞怎么办呢？可以在相同得位置，拉出一个链表出来，把信息存在这个链表上，如果哈希函数选的不好，链表很长，复杂度会变成O(n)，而没有链表得情况下是 O(1)。</p><figure><img src="https://i.loli.net/2021/08/12/6bKBh2UTQecgLqX.png" alt="发生哈希碰撞后的哈希表" /><figcaption aria-hidden="true">发生哈希碰撞后的哈希表</figcaption></figure><figure><img src="https://i.loli.net/2021/08/12/YyGFwVB43sMe9Tj.png" alt="哈希表的复杂度" /><figcaption aria-hidden="true">哈希表的复杂度</figcaption></figure><p>哈希表在 python 中有两种，Dictionary 和 Set，在 Java 中，可能只是一个接口，比如 Set 的实现有很多种，有基于红黑树的，基于二叉树的等等。</p><h1 id="树二叉树二叉搜索树">树、二叉树、二叉搜索树</h1><blockquote><p>2 维数据结构。</p></blockquote><h2 id="树">树</h2><p>树的示意图</p><figure><img src="https://i.loli.net/2021/08/13/6bpLCrNwEKTWOvy.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>为什么会出现树呢？工程实践就是二维的,树和链表没有本质上的区别，只是从1维到了二维。。树的遍历怎么办？对于一维数组，你可以直接循环遍历，而对于树，则有好几种方式：</p><ol type="1"><li>前序 (Pre-order)：根，左边，右边</li><li>中序 (In-order)：左边，根，右边</li><li>后序 (Post-order)：左边，右边，根</li></ol><p>树的循环，效率是比较麻烦的，反倒是写递归比较简单，树的各种操作，不要害怕递归。</p><h2 id="二叉树">二叉树</h2><p>二叉树，也就是儿子节点只有两个</p><figure><img src="https://i.loli.net/2021/08/13/jGRmsLDIFeryCP9.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="二叉搜索树">二叉搜索树</h2><p>如果树要查找元素，就必须要遍历，如果树里的元素没有顺序，那和列表什么的没区别。于是为了方便搜索，我们对树进行了排序，定义了二叉搜索树，它的特点是<strong>一颗空树</strong>或者<strong>具有以下性质的二叉树</strong>：</p><ol type="1"><li>左子树上所有节点的值均小于根节点的值；</li><li>右子树上所有节点的值均大于它的根节点的值；</li><li>以此类推：左右子树也分别为二叉查找树（重复性）</li></ol><p>中序遍历：升序排列</p><p>排序后的树，查询和操作都是 logn 的复杂度，相当于是加速了，因为它在查询的时候，会将当前节点与查询的节点做比较，每次可以筛掉一般的值，所以变成logn，虽然不是 O(1)，但logn 还是比 n 是不知道快多少了。</p><p>看树的查询动画，see also <a href="https://visualgo.net/en">Visualgo</a>.</p><p>二叉搜索树遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        self.preorder(root.left)</span><br><span class="line">        self.preorder(self.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br><span class="line">        self.inorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.postorder(root.left)</span><br><span class="line">        self.postorder(root.right)</span><br><span class="line">        self.traverse_path.append(root.val)</span><br></pre></td></tr></table></figure><h2 id="图">图</h2><p>图又是什么呢？图就是上面的节点中，子节点又连接到兄弟节点甚至是父节点去了。</p><blockquote><p>Linked List 是特殊化的 Tree，Tree是特殊化的 Graph.</p></blockquote><h1 id="递归">递归</h1><p>递归本质上类似与循环，即通过循环调用自己，以前使用的汇编语言，那时候没有循环嵌套这么一说，更多的时候就是你之前的指令写在上面地方，就不断的调用，从汇编的角度看，其实汇编的代码里，循环和递归差不多。</p><p>递归的特点，类似于盗梦空间。</p><ul><li>向下进入梦境，向上回到原来那层，只能一层一层进入或者退出。</li><li>每一层的环境和周围的人都是一份拷贝</li><li>通过声音返回上一层（return）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n*Factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure><img src="https://i.loli.net/2021/08/13/7mQvWfEewTYuPjA.png" alt="执行逻辑" /><figcaption aria-hidden="true">执行逻辑</figcaption></figure><p>递归代码模板：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span>(<span class="params">level, param1, param2, ...</span>):</span></span><br><span class="line"><span class="comment"># recursion terminator 终结条件</span></span><br><span class="line"><span class="keyword">if</span> level &gt; max_level:</span><br><span class="line">process_result</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># process logic in current level 处理当前层的逻辑</span></span><br><span class="line">    process(level, data...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># drill down 下探到下一层，带上参数</span></span><br><span class="line">    self.recursion(level+<span class="number">1</span>, p1, ...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse the current level states if needed 如果需要递归完了清理当前层</span></span><br></pre></td></tr></table></figure><p>思维要点：</p><ul><li>不要人肉递归</li><li>找到最近，最简的方法，拆解成可重复解决的问题（最近重复子问题）</li><li>数学归纳法的思维</li></ul><h1 id="分治回溯">分治、回溯</h1><blockquote><p>递归里面的细分类</p></blockquote><p>碰到一个题目，我们要去找重复性，重复性有两种：</p><ul><li>最近重复性 -&gt; 分支、回溯，递归</li><li>最优重复性 -&gt; 动态规划</li></ul><h2 id="分治">分治</h2><p>大问题都是子问题、复杂问题构成的，解决问题本质上就是找重复性，分解问题，组合子问题的结果。</p><figure><img src="https://i.loli.net/2021/08/13/UJNRMharPXo53V8.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>分治的代码模板:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_conquer</span>(<span class="params">problem, param1, param2, ...</span>):</span></span><br><span class="line">    <span class="comment"># recursion terminator</span></span><br><span class="line">    <span class="keyword">if</span> problem <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   <span class="comment"># prepare data</span></span><br><span class="line">    data = prepare_data(problem)</span><br><span class="line">    subproblems = split_problem(problem, data)</span><br><span class="line">    <span class="comment"># conquer subproblems</span></span><br><span class="line">    subresult1 = self.divide_conquer(subproblems[<span class="number">0</span>], p1, ...)</span><br><span class="line">    subresult2 = self.divide_conquer(subproblems[<span class="number">1</span>], p1, ...)</span><br><span class="line">    subresult3 = self.divide_conquer(subproblems[<span class="number">2</span>], p1, ...)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># process and generate the final result</span></span><br><span class="line">    result = process_result(subresult1, subresult2, subresult3)</span><br><span class="line">    <span class="comment"># revert the current level states</span></span><br></pre></td></tr></table></figure><h2 id="回溯">回溯</h2><p>采用试错的思想，分步解决一个问题，如果分布方案不解决问题，会取消上一步或几步的计算，再通过其他可能的分步方案寻找答案。</p><p>简单来说就是，每一层我都有不同的办法，一个一个试。</p><h1 id="深度优先广度优先搜索">深度优先、广度优先搜索</h1><h2 id="深度优先">深度优先</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>深度优先就是先往最深处的节点走，发现没有子节点了，返回到有子节点的节点，继续往下面走。</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">self, tree</span>):</span></span><br><span class="line"><span class="keyword">if</span> tree.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">visited, stack = [], [tree.root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)</span><br><span class="line">        stack.push(nodes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, visited</span>):</span></span><br><span class="line"><span class="comment"># terminator</span></span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment"># already visited</span></span><br><span class="line">visited.add(node)</span><br><span class="line"><span class="comment"># process current node here</span></span><br><span class="line"><span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">dfs(next_node, visited)</span><br></pre></td></tr></table></figure><h2 id="广度优先">广度优先</h2><p>广度优先遍历，类似与一个水滴滴到根节点，然后像水波一样一层一层扩散下去，这种思想在算最短路径的时候，比深度优先效率高。遍历的方式使用队列实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)</span><br><span class="line">        queue.push(nodes)</span><br><span class="line">     <span class="comment"># othres processing work</span></span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>这里的算法为了方便理解，举个例子，就好像要访问公司的人员信息，首先先看老总的信息，老总看完了，放到 visited 数组，然后看他有没有其他下属，有的话全部取出来放到队列（先进先出）</p><h1 id="贪心算法">贪心算法</h1><p>贪心算法在每一步选择中，都采取当前状态下最好或最优的选择，从而导致结果是最好的或最优的算法。（有一定的局限性，因为当下最优不一定全局最优）</p><p>动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心法主要解决一些最优化问题，图中的最小生成树，求哈夫曼编码等。</p><p>一旦一个问题可以通过贪心算法解决，那么贪心法一般是解决这个问题的最好办法。</p><p>适用于贪心的情况，即<code>问题可以分解成子问题，子问题的最优解可以递推到最终问题的最优解</code></p><h1 id="二分查找">二分查找</h1><p>一定记住二分查找的前提（肌肉记忆）:</p><ol type="1"><li>目标函数单调性（单调递增或递减），才可以通过特征排除掉前半部分或后半部分</li><li>存在上下界（bounded），没有上下界，空间可能无限大</li><li>能够通过索引访问（index acccessible)，如果是单链表，即使有序，也比较难</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设数组是有序的</span></span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = (left + right) /<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target!</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><ul><li>Dynamic Programming（一种解决问题的办法）, 本质就是将复杂问题，分解成小问题，可以理解为动态的递推，每一步保存最优解，淘汰掉那些不怎么好的，然后最终求得总体的最优解。</li><li>直接递归的复杂度是指数级的，如果淘汰掉一些解，可以变成 n 平方</li></ul><h1 id="字典树">字典树</h1><h2 id="字典树的数据结构">字典树的数据结构</h2><p>之前我们的树，内部就是值本身，而是把字符串拆成单个得字幕存储。</p><figure><img src="https://i.loli.net/2021/08/14/zYdmwyHZCFXQovM.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>节点本身不存完整单词</li><li>根节点到某一结点，连起来即为单词</li><li>每个不同的边都是不一样的字符</li></ul><p>这种结构中，节点还可以存储其他信息，比如这个节点所得到的单词出现的频次。这种结构的核心思想是空间换时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end_of_word = <span class="string">&quot;#&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            node = node.setdefault(char, &#123;&#125;)</span><br><span class="line">        node[self.end_of_word] = self.end_of_word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">           node = node[char]</span><br><span class="line">        <span class="keyword">return</span> self.end_of_word <span class="keyword">in</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[char]</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><p>属于一种比较跳跃式的数据结构，如果你会就很简单，如果不会就很难，它使用情景主要是在组团、配对问题。</p><p>这两个个体是不是在一个集合之中。</p><h3 id="基本操作">基本操作</h3><ul><li><p>makeSets(s): 新建并查集，其中包括s个单元素集合。</p></li><li><p>unionSet(x, y): 集合合并，要求不相交才合并</p></li><li><p>find(x): 判断 x 所在集合的代表</p></li></ul><p>每个元素都有一个 parent 数组指向自己，表示自己是自己的集合。</p><h3 id="合并">合并</h3><figure><img src="https://i.loli.net/2021/08/14/rE8CmX27OjkgKcl.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="路径优化">路径优化</h3><figure><img src="https://i.loli.net/2021/08/14/aXNWL3ogTiyGZ7w.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="实现">实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">p</span>):</span></span><br><span class="line">    p = []i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, i, j</span>):</span></span><br><span class="line">    p1 = self.parent(p, i)</span><br><span class="line">    p2 = self.parent(p, j)</span><br><span class="line">    p[p1] = p2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span>(<span class="params">self, p, i</span>):</span></span><br><span class="line">    root = i</span><br><span class="line">    <span class="keyword">while</span> p[root] != root:</span><br><span class="line">        root = p[root]</span><br><span class="line">    <span class="keyword">while</span> p[i] != i:</span><br><span class="line">        x = i</span><br><span class="line">        i = p[i]</span><br><span class="line">        p[x] = root</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="高级搜索">高级搜索</h1><h2 id="剪枝">剪枝</h2><p>说高级搜索前，什么是初级搜索呢？</p><ol type="1"><li><p>朴素搜索</p></li><li><p>优化方式：不重复、剪枝，剪枝就是在搜索的时候去掉重复，或者剪去是一些没必要的访问</p></li><li><p>搜索方向</p><ol type="1"><li><p>DFS，深度优先，没有优先级，傻搜</p></li><li><p>BFS，广度优先</p></li></ol></li></ol><p>搜索的话可以通过双向搜索，启发式搜索来优化。</p><figure><img src="https://i.loli.net/2021/08/14/tUCHVGfwRDlAZIo.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="双向bfs">双向BFS</h2><p>问题：找出A到L的最短路径</p><figure><img src="https://i.loli.net/2021/08/14/24WjlLP5qa7dDKS.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这种需求，我们一般使用广度优先算法，而双向 BFS 的意思是，从两边一起进行广度优先算法的遍历，两边一起逼近中间，这样就可以提高效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image.png](https://i.loli.net/2021/08/14/J3fKMgXRkuynHOd.png)</span><br></pre></td></tr></table></figure><h2 id="启发式搜索-heuristic-search-a">启发式搜索 Heuristic Search (A*)</h2><p>只能搜索，根据某项条件，我们去优化条件，也可以理解为思考型搜索，本质上是用优先级。</p><p>这里就要用到优先队列了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AstarSearch</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line">    pq = collections.priority_queue() <span class="comment"># 优先级，估价函数</span></span><br><span class="line">    pq.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        node = pq.pop()  <span class="comment"># 能更智能一点吗？</span></span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)  <span class="comment"># 正常的BFS代码</span></span><br><span class="line"></span><br><span class="line">        unvisited=[node <span class="keyword">for</span> node <span class="keyword">in</span> nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">        pq.push(unvisited)</span><br></pre></td></tr></table></figure><p>这里怎么来定优先级呢？这就需要你按照对题目的理解把估价函数写出来。</p><h1 id="avl和红黑树">AVL和红黑树</h1><blockquote><p>二三树，B树，B+树，B-树。</p></blockquote><p>如何保持一棵树的平衡？</p><h2 id="avl">AVL</h2><ol type="1"><li>Balance Factor，因为二叉树的查找只与高度有关，平衡因子是它的左子树的高度减去右子树的高度（有时候相反）,balance factor = {-1, 0, 1}</li><li>通过旋转操作来进行平衡（四种）</li></ol><p>那么如何判断高度呢?</p><figure><img src="https://i.loli.net/2021/08/14/4GL5jIuWhpclkzS.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>通过高度的值不超过1，不小于-1来判断一棵树是否需要调整，即旋转，旋转的方式有：</p><ol type="1"><li>左旋</li><li>右选</li><li>左右旋</li><li>右左旋</li></ol><p>缺点：需要额外的信息存储，且调整次数频繁。</p><h2 id="红黑树">红黑树</h2><p>也是一种<code>近似平衡</code>的二叉搜索树，它能确保任何一个节点的左右子树高度差小于两倍，具体来说：</p><ul><li>每个节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>每个叶节点（NIL节点，空节点）是黑色的。</li><li>不能有相邻接的两个红色节点</li><li>从任何一个节点到每个叶子的所有路径都包含相同数目的黑色节点</li></ul><p>这些性质就让红黑树的时间复杂度可以保持在 logn 的水平，不会退化，需要调整的时间也是相对比较折中。</p><p>下面是 AVL 与 红黑树的对比：</p><figure><img src="https://i.loli.net/2021/08/15/8JMDFWkV2CG9dxc.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>如果读操作非常多写操作少就用 AVL，它插入、删除需要的操作比较多。</li><li>插入操作也很多，或者操作、查询需求差不多，就用红黑树</li></ul><h1 id="位运算">位运算</h1><p>位运算简单说就是进制转换，比如十进制转二进制，在进制表示中，<code>4(d)</code> 中的 d 表示的是十进制，<code>0100</code> 中零开头表示2进制。</p><p>具体转换的算法可以参考<a href="https://zh.wikihow.com/%E4%BB%8E%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6">这里</a>。</p><h2 id="位运算符">位运算符</h2><table><thead><tr class="header"><th style="text-align: center;">含义</th><th style="text-align: center;">运算符</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">左移</td><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;">0011 =&gt; 0110</td></tr><tr class="even"><td style="text-align: center;">右移</td><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;">0110 =&gt; 0011</td></tr><tr class="odd"><td style="text-align: center;">按位或，有1则1</td><td style="text-align: center;">|</td><td style="text-align: center;">0011 | 1011 =&gt; 1011</td></tr><tr class="even"><td style="text-align: center;">按位与，有0则0</td><td style="text-align: center;">&amp;</td><td style="text-align: center;">0011 &amp; 1011 =&gt; 0011</td></tr><tr class="odd"><td style="text-align: center;">按位取反，0变1，1变0</td><td style="text-align: center;">~</td><td style="text-align: center;">0011 =&gt; 1100</td></tr><tr class="even"><td style="text-align: center;">按位异或，相同0不同1</td><td style="text-align: center;">^</td><td style="text-align: center;">0011 ^ 1011 =&gt; 1000</td></tr></tbody></table><h2 id="异或特点">异或特点</h2><p>异或操作的一些特点：</p><ul><li><code>x^0 = x</code>, 只要 <code>x</code> 和 <code>0</code> 相同的就为 <code>0</code>，不同的为 <code>1</code>，所以这里 <code>x^0</code> 就等于 <code>x</code></li><li><code>x^1s = ~x</code>, <code>1s</code> 指的是全1，也就是等于0取反 <code>~</code></li><li><code>x^(~x)=1s</code>, 取反后，所有位置都不一样，所有都不同，都是1，1s</li><li><code>x^x=0</code>, 异或相同为0，所有都是0</li><li><code>c=a^b</code> ,<code>a^c=b</code> 则 <code>b^c=a</code>, 交换两数</li><li><code>a^b^c = a^(b^c) = (a^b)^c</code>, associative</li></ul><h2 id="指定位置的位运算">指定位置的位运算</h2><figure><img src="https://i.loli.net/2021/08/15/Us8dBF7LNfHVIbh.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="实战运算要点">实战运算要点</h2><figure><img src="https://i.loli.net/2021/08/15/yvDgQ5d7JhCejr1.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="布隆过滤器lru-cache">布隆过滤器，LRU Cache</h1><h2 id="布隆过滤器">布隆过滤器</h2><p>在说布隆过滤器之前，回顾一下哈希表，前面说过哈希表在哈希操作的时候，有可能会得到一样的地址（整数），这时候会采用拉链的办法，也就是在同样的地址上叠罗汉。</p><p>在哈希表的应用中，我们发现，有时候我们并不需要去存储元素的信息本身，而是只需要知道某个信息在我们的表中有没有。</p><p>如果我们只是需要知道某个信息在表里有没有，这时候 Bloom filter 就设计出来了。</p><h3 id="布隆过滤器具-vs-哈希表">布隆过滤器具 vs 哈希表</h3><ul><li>空间效率和查询时间都远远超过一般算法</li><li>缺点是有一定的误识别率和删除困难</li></ul><h3 id="布隆过滤器具原理">布隆过滤器具原理</h3><figure><img src="https://i.loli.net/2021/08/15/zMKNUgRTZF73ht4.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在有 xyz 三个元素需要存储，布隆过滤器会对每一个元素执行哈希，得到一组值，然后再将这组值插入到下面的框框中，y 和 z 也是同理，这样下次查询的时候，只需要查看这些对应的位置是否为1就好了，而且查询的时候，我只需要判断任意一个元素是0，那么就可以判断这个元素是不在这个表中的。</p><p>但是这种查法可能会有问题，比如下面的这个B：</p><figure><img src="https://i.loli.net/2021/08/15/Hw9t4BfN3cp2OWe.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>对于一个元素，布隆过滤器可以确定一个元素不存在，但只可以说某个元素有可能存在。</p><p>布隆过滤器一般放在数据库的外层当作缓存使用。</p><h3 id="布隆过滤器具案例">布隆过滤器具案例</h3><ol type="1"><li>比特币网络</li><li>分布式系统（Map-Reduce）- Hadooop，search engine</li><li>Redis 缓存</li><li>垃圾邮件、评论等的过滤</li></ol><h3 id="布隆过滤器具-python实现">布隆过滤器具 Python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bfrom bitarray <span class="keyword">import</span> bitarray</span><br><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size, hash_num</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.hash_num = hash_num</span><br><span class="line">        self.bit_array = bitarray(size)</span><br><span class="line">        self.bit_array.setall(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_num):</span><br><span class="line">            result = mmh3.<span class="built_in">hash</span>(s, seed) % self.size</span><br><span class="line">            self.bit_array[result] = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookup</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_num):</span><br><span class="line">            result = mmh3.<span class="built_in">hash</span>(s, seed) % self.size</span><br><span class="line">            <span class="keyword">if</span> self.bit_array[result] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Nope&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Probably&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bf = BloomFilter(500000, 7)</span><br><span class="line">bf.add(&quot;scott&quot;)</span><br><span class="line">bf.lookup(&quot;scott&quot;)</span><br><span class="line">&#x27;Probably&#x27;</span><br><span class="line"></span><br><span class="line">bf.lookup(&quot;zhang&quot;)</span><br><span class="line">&#x27;Nope&#x27;</span><br></pre></td></tr></table></figure><h2 id="lru-cache-缓存">LRU Cache 缓存</h2><blockquote><p>Least Rencent Used,</p></blockquote><ul><li>两个要素：大小、替换策略</li><li>使用 Hash Table + Double LinkedList 实现</li><li>O(1) 查询，O(1) 更新、更新</li></ul><h3 id="工作示例">工作示例</h3><figure><img src="https://i.loli.net/2021/08/15/noydHrUWJNVbB3F.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="排序算法">排序算法</h1><blockquote><p>To be continued.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;系统的复习一下数据结构与算法的知识，包括 Python 实现的代码模板。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://scottzhang.pro/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
