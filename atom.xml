<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>学则不固, 知则不惑</subtitle>
  <link href="https://scottzhang.pro/atom.xml" rel="self"/>
  
  <link href="https://scottzhang.pro/"/>
  <updated>2022-01-15T14:35:39.913Z</updated>
  <id>https://scottzhang.pro/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Socket 入门</title>
    <link href="https://scottzhang.pro/article/4317dd1.html"/>
    <id>https://scottzhang.pro/article/4317dd1.html</id>
    <published>2022-01-15T13:43:59.000Z</published>
    <updated>2022-01-15T14:35:39.913Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章带你了解如何建立 Python Socket 服务端与客户端，编写一个简单的多用户聊天程序，以及如何使用 Socket 模拟 http 请求。</p></blockquote><span id="more"></span><h1 id="理论介绍">理论介绍</h1><p>计算机网络基础知识，推荐一本书《TCP/IP 详解》。</p><p>HTTP，Socket，TCP 的区别，HTTP 是应用层的协议。Socket可理解为操作系统提供的应用层与传输层打交道的插座。而 TCP 属于传输层。 通过 Socket 编程，我们可以自己与传输层打交道，定义自己的协议进行通信。</p><p>Client 端涉及的操作：</p><figure><img src="https://s2.loli.net/2022/01/15/sXuIOz8T12n5DfB.png" alt="Socket编程" /><figcaption aria-hidden="true">Socket编程</figcaption></figure><p>服务端：</p><ul><li>socket：socket 是应用层和传输层之间的接口，传输层有 tcp 和 udp；</li><li>bind(协议，地址，端口)：地址可在本机 IP，也可以指定；每一个应用程序只能占用一个端口，网络 来的数据，操作系统会转发给相应的端口。</li><li>listen(监听客户端 socket 请求)</li><li>accept()</li><li>阻塞等待连续请求（新套接字）</li><li>recv()</li><li>send(), socket 建立了连接后，可以一直发送数据；http 则不行。</li><li>close()</li></ul><p>客户端：</p><ul><li>socket</li><li>connect()</li><li>send()</li><li>recv()</li><li>close()</li></ul><h1 id="socket-实现聊天">Socket 实现聊天</h1><p>来看一个 socket 实现聊天的例子，第一个是服务端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Socket Server</span></span><br><span class="line"><span class="comment"># 先启动 Server，否则 Client 会无法连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”.  &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    response_str = <span class="string">&quot;From Server, Admin:&quot;</span> + response_str</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen()</span><br><span class="line">sock_client, addr = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 这里才是用户拿到的 sock，上面的 server 则是用来监听的</span></span><br><span class="line">    data = sock_client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    respond(sock_client)</span><br></pre></td></tr></table></figure><p>然后是客户端的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># Client, 第一次会尝试连接 Server Say Hi</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">client.send(<span class="string">f&quot;From Client, Scott: Hi!&quot;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 客户端，先发信息</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    client_id = <span class="string">&quot;From Client, Scott:&quot;</span></span><br><span class="line">    client_new_msg = client_id + <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    client.send(client_new_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>当客户端起来之后，服务端会收到一条消息，来看看他们的对话吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 服务端</span><br><span class="line">From Client, Scott: Hi!</span><br><span class="line">New msg:Hi Scott!</span><br><span class="line">From Client, Scott:Are you admin from the server?</span><br><span class="line">New msg:Yes, i am.</span><br><span class="line">From Client, Scott:Nice to meet you!!!</span><br><span class="line">New msg:Me too. How can i help you?</span><br><span class="line">From Client, Scott:Just test the connection, bye~</span><br><span class="line">New msg:Ok, Have a great day!</span><br><span class="line">From Client, Scott:You too!</span><br><span class="line"></span><br><span class="line"># 客户端</span><br><span class="line">From Server, Admin:Hi Scott!</span><br><span class="line">New msg:Are you admin from the server?</span><br><span class="line">From Server, Admin:Yes, i am.</span><br><span class="line">New msg:Nice to meet you!!!</span><br><span class="line">From Server, Admin:Me too. How can i help you?</span><br><span class="line">New msg:Just test the connection, bye~</span><br><span class="line">From Server, Admin:Ok, Have a great day!</span><br><span class="line">New msg:You too!</span><br></pre></td></tr></table></figure><h1 id="socket-实现多用户聊天">Socket 实现多用户聊天</h1><p>上面的 server 只支持一个用户，如何支持多个用户呢？可以使用线程来实现，背后的思想是，每当遇到一个新的连接 请求，就让一个线程去处理, 也就是这一段 <code>sock_client, addr = server.accept()</code> 交给一个新的线程去处理。</p><p>这是一个多线程的 server，客户端的代码是一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Socket Server</span></span><br><span class="line"><span class="comment"># 先启动 Server，否则 Client 会无法连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”.  &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;New msg:&quot;</span>)</span><br><span class="line">    response_str = <span class="string">&quot;From Server, Admin:&quot;</span> + response_str</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_sock</span>(<span class="params">sock_client, addr</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 这里才是用户拿到的 sock，上面的 server 则是用来监听的</span></span><br><span class="line">        data = sock_client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        respond(sock_client)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">    server.listen()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sock_client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 用线程处理新来的用户</span></span><br><span class="line">        client_thread = threading.Thread(</span><br><span class="line">            target=handle_sock,</span><br><span class="line">            args=(sock_client, addr)</span><br><span class="line">        )</span><br><span class="line">        client_thread.start()</span><br></pre></td></tr></table></figure><p>来看服务端与不同客户端的通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">From Client 1, Scott: Hi!</span><br><span class="line">New msg:Hi Scott!</span><br><span class="line">From Client 2, The Weeknd: Hi!</span><br><span class="line">New msg:Hi The Weeknd!</span><br><span class="line">From Client 1, Scott:I really like the weeknd!</span><br><span class="line">New msg:Me too!</span><br><span class="line">From Client 2, The Weeknd:I just adds three tracks to my new album: Dawn FM.</span><br><span class="line">New msg:Great!</span><br></pre></td></tr></table></figure><h1 id="socket-模拟-http-请求">Socket 模拟 http 请求</h1><p>你应该听说过 Python 中 request 这个包，它其实底层是依赖 urllib 实现的，而 urllib 又是依赖于 socket。</p><p>既然是模拟 http 请求，还是需要做 url 解析，我们将会用到 urllib 中的部分函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 解析 url</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc   <span class="comment"># host</span></span><br><span class="line">    path = url.path     <span class="comment"># 子路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:      <span class="comment"># 子路径为空</span></span><br><span class="line">        path = <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立 socket 连接, 一般网站都使用 8000 端口</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造请求内容，并开始发送请求</span></span><br><span class="line">    <span class="comment"># 关于请求的内容，可以通过 Chrome 的调试工具打开目标网站</span></span><br><span class="line">    <span class="comment"># 再查看 Headers，具体某个网站必须构造哪些请求内容，各有不同</span></span><br><span class="line">    <span class="comment"># 比如百度必须有: host, connection,</span></span><br><span class="line">    client.send(</span><br><span class="line">        <span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            path, host</span><br><span class="line">    ).encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回的数据不一定是 1024， 有可能是 &gt; 1024 的</span></span><br><span class="line">    <span class="comment"># client.recv(1024), 这样写会出问题，特殊处理一下</span></span><br><span class="line">    data = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 先接受 1024 个数据</span></span><br><span class="line">        d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    data = data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章带你了解如何建立 Python Socket 服务端与客户端，编写一个简单的多用户聊天程序，以及如何使用 Socket 模拟 http 请求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Python 浅拷贝与深拷贝</title>
    <link href="https://scottzhang.pro/article/c5dc05db.html"/>
    <id>https://scottzhang.pro/article/c5dc05db.html</id>
    <published>2022-01-15T13:38:58.000Z</published>
    <updated>2022-01-16T06:46:55.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章以 list，dict，class 为例，带你了解 Python 中的浅拷贝与深拷贝。</p></blockquote><span id="more"></span><h1 id="变量与指针">变量与指针</h1><p>在理解下面的例子之前，我们需要对 Python 中的变量有一个基本的理解。</p><p>对变量赋值，在其他语言中，我们可能理解为开辟一个区域（理解为容器、或者是一个篮子），再将值放进去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言：在内存中开辟一个区域，将值放进去</span></span><br><span class="line"><span class="keyword">int</span> x <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>在 Python 中，写法是一样的，但是最好的理解是将一个指针指向了这个区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python：定义了一个指针 x，指向了内存中</span></span><br><span class="line"><span class="comment"># 这个包含 4 的容器的地方</span></span><br><span class="line">x = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>因为 Python 变量相当于一个指针，指向这个内存区域，所以无需提前声明好变量是什么类型，指针中间也可以指向别的值，这也是大家收 Python 是动态类型的原因。</p><p>所以你可以这么做:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>         <span class="comment"># x is an integer</span></span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>   <span class="comment"># now x is a string</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># now x is a list</span></span><br></pre></td></tr></table></figure><p>但是动态类型也有确定，那就是如果两个变量名指向同一个数据，那么一个变量所做的修改，另一个变量所指向的值也会发生变化。</p><p>下面来看具体的例子：</p><h1 id="以-list-为例">以 list 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------- 浅拷贝 ------------------ #</span></span><br><span class="line"><span class="comment"># 构造一个列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- New List XS, YS&quot;</span>)</span><br><span class="line">xs = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">ys = <span class="built_in">list</span>(xs)  <span class="comment"># Make a shallow copy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 添加元素: 不会影响 ys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Append Element To XS&quot;</span>)</span><br><span class="line">xs.append([<span class="string">&#x27;I am new&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 修改元素：两者都会影响</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To XS&quot;</span>)</span><br><span class="line">xs[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 yx 修改元素：两者会影响</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To YS&quot;</span>)</span><br><span class="line">ys[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;y&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ys:&quot;</span>, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- Deep Copy --------------- #</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">zs = copy.deepcopy(xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Deep Copy ZS from XS&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span>, xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 zs 修改元素，不会影响 xz</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To ZS&quot;</span>)</span><br><span class="line">zs[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span> , xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 xs 修改元素，也不会影响 xs</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------- Modified To XS&quot;</span>)</span><br><span class="line">xs[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xs:&quot;</span>, xs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zs:&quot;</span>, zs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------- New List XS, YS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">--------- Append Element To XS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">--------- Modified To XS</span><br><span class="line">xs: [[1, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[1, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9]]</span><br><span class="line">--------- Modified To YS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">ys: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">--------- Deep Copy ZS from XS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">--------- Modified To ZS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [&#x27;z&#x27;, 8, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">--------- Modified To XS</span><br><span class="line">xs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [7, &#x27;z&#x27;, 9], [&#x27;I am new&#x27;]]</span><br><span class="line">zs: [[&#x27;y&#x27;, 2, 3], [4, 5, &#x27;x&#x27;], [&#x27;z&#x27;, 8, 9], [&#x27;I am new&#x27;]]</span><br></pre></td></tr></table></figure><h1 id="以-dict-为例">以 dict 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个 dict，用来演示深拷贝与浅拷贝</span></span><br><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&#x27;name1&#x27;</span>: &#123;<span class="string">&quot;scott zhang&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;name2&#x27;</span>: &#123;<span class="string">&quot;the weeknd&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A new dict:&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 d 中 name1 的 id</span></span><br><span class="line">d_id = <span class="built_in">id</span>(d[<span class="string">&#x27;name1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(d_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝，更详细的说是</span></span><br><span class="line"><span class="comment"># 将 d[&#x27;name1&#x27;] 所在内存区域的地址绑定给 d_copy1</span></span><br><span class="line"><span class="comment"># 摘自 realpython：</span></span><br><span class="line"><span class="comment"># (Assignment statements in Python do not create copies of objects</span></span><br><span class="line"><span class="comment"># they only bind names to an object.)</span></span><br><span class="line"><span class="comment"># 浅拷贝内部值只是指针, 所以对 d_copy1 内部 name1 字典内的修改，会将 d 中的值也修改</span></span><br><span class="line">d_copy1 = d.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示</span></span><br><span class="line"><span class="comment"># 对 copy 过来的 dict 修改，再打印原来的数据</span></span><br><span class="line">d_copy1[<span class="string">&#x27;name1&#x27;</span>][<span class="string">&#x27;scott zhang&#x27;</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么？</span></span><br><span class="line"><span class="comment"># 因为其实内部指向的是同一个 dict</span></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">id</span>(d_copy1[<span class="string">&#x27;name1&#x27;</span>]) == <span class="built_in">id</span>(d[<span class="string">&#x27;name1&#x27;</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要指向同一个 dict?</span></span><br><span class="line"><span class="comment"># 因为浅拷贝指向的是指针，深拷贝会将数据重新赋值，非常耗费系统资源。</span></span><br></pre></td></tr></table></figure><p>上面代码的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A new dict: &#123;&#x27;name1&#x27;: &#123;&#x27;scott zhang&#x27;: 1&#125;, &#x27;name2&#x27;: &#123;&#x27;the weeknd&#x27;: 2&#125;&#125;</span><br><span class="line">1901449775104</span><br><span class="line">&#123;&#x27;name1&#x27;: &#123;&#x27;scott zhang&#x27;: 0&#125;, &#x27;name2&#x27;: &#123;&#x27;the weeknd&#x27;: 2&#125;&#125;</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h1 id="以-class-为例">以 class 为例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Point(<span class="subst">&#123;self.x!r&#125;</span>, <span class="subst">&#123;self.y!r&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># A Rectagle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, topleft, bottomright</span>):</span></span><br><span class="line">        self.topleft = topleft</span><br><span class="line">        self.bottomright = bottomright</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&#x27;Rectangle(<span class="subst">&#123;self.topleft!r&#125;</span>, &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;<span class="subst">&#123;self.bottomright!r&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Make a point and it copy obj</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Point&quot;</span>)</span><br><span class="line">    point = Point(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    point_copy = copy.copy(point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point:&quot;</span>, point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point copy:&quot;</span>, point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># point is point_copy?</span></span><br><span class="line">    <span class="comment"># no, because class Point using int in x and y</span></span><br><span class="line">    <span class="comment"># int is immutable type in python</span></span><br><span class="line">    <span class="comment"># so there is no difference between deep/shallow copy for Point class</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point is point copy？&quot;</span>, point <span class="keyword">is</span> point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># modified point</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified Point&quot;</span>)</span><br><span class="line">    point.x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point:&quot;</span>, point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;point copy:&quot;</span>, point_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是 Rectangle 内部的 Pointer 呢?</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Rectangle&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># new rectangle and a copy from it</span></span><br><span class="line">    rect = Rectangle(topleft=Point(<span class="number">0</span>, <span class="number">1</span>), bottomright=Point(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    rect_copy = copy.copy(rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect:&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy:&quot;</span>, rect_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># rect is rect_copy?</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect_copy is rect?&quot;</span>, rect_copy <span class="keyword">is</span> rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified rect&quot;</span>)</span><br><span class="line">    rect.topleft.x = <span class="number">999</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect:&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy:&quot;</span>, rect_copy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># using deep copy</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- New Deep Copy Rect&quot;</span>)</span><br><span class="line">    rect_copy_deep = copy.deepcopy(rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy deep:&quot;</span>, rect_copy_deep)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># modified a deep copy obj</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---- Modified Deep Copy Rect&quot;</span>)</span><br><span class="line">    rect.bottomright.x = <span class="number">666</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect&quot;</span>, rect)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rect copy deep:&quot;</span>, rect_copy_deep)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---- Point</span><br><span class="line">point: Point(0, 0)</span><br><span class="line">point copy: Point(0, 0)</span><br><span class="line">point is point copy？ False</span><br><span class="line">---- Modified Point</span><br><span class="line">point: Point(1, 0)</span><br><span class="line">point copy: Point(0, 0)</span><br><span class="line"></span><br><span class="line">---- Rectangle</span><br><span class="line">rect: Rectangle(Point(0, 1), Point(1, 0))</span><br><span class="line">rect copy: Rectangle(Point(0, 1), Point(1, 0))</span><br><span class="line">rect_copy is rect? False</span><br><span class="line">---- Modified rect</span><br><span class="line">rect: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">rect copy: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">---- New Deep Copy Rect</span><br><span class="line">rect Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">rect copy deep: Rectangle(Point(999, 1), Point(1, 0))</span><br><span class="line">---- Modified Deep Copy Rect</span><br><span class="line">rect Rectangle(Point(999, 1), Point(666, 0))</span><br><span class="line">rect copy deep: Rectangle(Point(999, 1), Point(1, 0))</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><ul><li>浅拷贝（shallow copy）并不会克隆对象中的子对象，因此原对象和对象中，被拷贝的内部对象不是独立两份，而是同一份。</li><li>深拷贝（Deep copy）会递归的拷贝所有子对象，这保证了内部对象的独立性，但是这样速度很慢。</li><li>你可以使用 copy 模块拷贝任意对象（包括你自定义的类），你还可以通过实现 <code>__copy()__</code> 或 <code>__deepcopy()__</code> 来自定义拷贝的过程。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章以 list，dict，class 为例，带你了解 Python 中的浅拷贝与深拷贝。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="https://scottzhang.pro/categories/python/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P3</title>
    <link href="https://scottzhang.pro/article/4074d0e9.html"/>
    <id>https://scottzhang.pro/article/4074d0e9.html</id>
    <published>2021-12-20T09:13:01.000Z</published>
    <updated>2021-12-20T09:19:39.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.</p></blockquote><span id="more"></span><h1 id="方法">方法</h1><p>Go 没有类。不过你可以为结构体类型定义方法，Go 中方法是带特殊的 {接收者} 参数的函数（方法其实就是函数，只是带了个接收者）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------后续代码将省略上面的部分------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 位于 func 关键字和方法名之间</span></span><br><span class="line"><span class="comment">// 在下面的例子中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：方法相当于函数，所以下面的写法功能是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是在使用的时候，不再是 v.Abs(), 而是 Abs(v)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非结构体也是可以声明方法的，比如对于 float：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;接收者&#125; 为 (f MyFloat)，方法名为 Abs, 返回 float64</span></span><br><span class="line"><span class="comment">// 没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">f := MyFloat(<span class="number">-1</span>)</span><br><span class="line">f.Abs()</span><br></pre></td></tr></table></figure><p>但是，你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。</p><p>上面的接收者为值接收者，实际上接收者还有一种叫做指针接收者，因为使用指针接收者，你可以在方法内部修改值，所以指针接收者比值接收者更常用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值接收者 (v Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取值、计算</span></span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者 (v *Vertex)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析输出</span></span><br><span class="line"><span class="comment">// 如果是指针接收者:</span></span><br><span class="line"><span class="comment">// Scale: 3*10 = 30; 4*10 = 40</span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果将指针接收者改为值接收者</span></span><br><span class="line"><span class="comment">// 即 (v *Vertex) -&gt; (v Vertex)</span></span><br><span class="line"><span class="comment">// Scale: 3 ; 4 </span></span><br><span class="line"><span class="comment">// Abs: Sqrt(30*30 + 40*40) = 50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法和指针重定向; 在函数中，如果要求的参数是指针，传值会报错；如果使用指针接收者，则既可以传值，也可以传指针；反之如果要求的参数是值，在函数中传指针也会出错，指针接收者则也可以避免这种情况。</p><p>使用指针接收者的好处是：</p><ol type="1"><li>指针能够修改传进来的值</li><li>因为传的是指针，避免了值的复制，更高效</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 因为参数指定为指针，直接传值会出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="comment">// 下面这两种方式都可以工作</span></span><br><span class="line"><span class="comment">// v.Scale(10), (&amp;v).scale(10)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口">接口</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个几何形状的接口，拥有面积和</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形和圆的结构体</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 rect 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，实现 circle 的 area() 和 perim() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// measure 函数，基于 geometory 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">    c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    measure(r)</span><br><span class="line">    measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接口的另一个例子, 首先是完整的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们逐一来看，方便研究，首先是直接将变量赋值给接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">a = f</span><br><span class="line"></span><br><span class="line">fmt.Println(f.Abs()) <span class="comment">// 为 MyFload 实现了 Abs 方法, 即</span></span><br><span class="line">fmt.Println(a.Abs()) <span class="comment">// MyFloat 实现了 Abser</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是将结构体赋值给接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line"></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它们不同的地方在于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件</span></span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义不同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;  <span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同</span></span><br><span class="line">a = f  <span class="comment">// a.Abs(), work; a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a.Abs(), work; a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">a = v </span><br><span class="line"><span class="comment">// a.Abs(), Error; Vertex does not implement Abser; 如果将</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() float64 改为</span></span><br><span class="line"><span class="comment">// func (v *Vertex) Abs() 则可以正常运行</span></span><br></pre></td></tr></table></figure><p>接口的隐式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事</span></span><br><span class="line"><span class="comment">// 直接将 func 的名字设置成 接口中的名字即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也是值，所以可以像值一样传递。可以用作参数和函数的返回值。</p><p>接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组 <code>(value, type)</code>, 接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 接口 I，其中规定了需要实现 M() 方法</span></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体 T，其中有 string 类型的 S</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为结构体 T 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (t *T) 为指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 float64 增加了 M() 方法</span></span><br><span class="line"><span class="comment">// (f F) 为值接收者</span></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印函数，参数为接口 I</span></span><br><span class="line"><span class="comment">// %v：值的 value</span></span><br><span class="line"><span class="comment">// %T: 值的 type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复习</span></span><br><span class="line"><span class="comment">// &amp; 符号的意思是对变量取地址，如：变量a的地址是&amp;a</span></span><br><span class="line"><span class="comment">// * 符号的意思是对指针取值，如:*&amp;a，就是a变量所在地址的值，当然也就是a的值了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I        <span class="comment">// 声明接口 i</span></span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125; <span class="comment">// 定了结构体 -&gt; 取该结构体的地址 -&gt; 给 i</span></span><br><span class="line">describe(i)     <span class="comment">// 打印结构体地址的值，以及 type</span></span><br><span class="line">i.M()           <span class="comment">// 结构体增加了 M() 方法，运行成功</span></span><br><span class="line"></span><br><span class="line">i = F(math.Pi)  <span class="comment">// F 是自定义的 float64，初始化值为 math.pi -&gt; 给 i</span></span><br><span class="line">describe(i)        <span class="comment">// 打印 i 的值和地址</span></span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层值为 nil 的接口值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I     <span class="comment">// 声明接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T    <span class="comment">// 初始化一个结构体指针 t，零值为 nil</span></span><br><span class="line">i = t       <span class="comment">// 隐式实现了接口，使得 i 有了 M() 方法</span></span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, *main.T)</span></span><br><span class="line"><span class="comment">&lt;nil&gt;</span></span><br><span class="line"><span class="comment">(&amp;&#123;hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>空接口, 它没有规定接口的方法，空接口可保存任何类型的值； 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 指定了零个方法的接口值</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于类型断言，它提供了访问接口值底层值的具体方式，并可以进行检测断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型选择，可以按顺序从接口值中选择值的类型，文法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个类型选择的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 类型选择中的 case 为类型（而非值</span></span><br><span class="line"><span class="comment">// 类型选择中的声明与类型断言 i.(T) 的语法相同</span></span><br><span class="line"><span class="comment">// 只是具体类型 T 被替换成了关键字 type</span></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Twice 21 is 42</span></span><br><span class="line"><span class="comment">&quot;hello&quot; is 5 bytes long</span></span><br><span class="line"><span class="comment">I don&#x27;t know about type bool!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面介绍一个普遍使用的接口，即 fmt 包中的 Stringer。一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">fmt.Println(a.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span></span><br><span class="line"><span class="comment">Arthur Dent (42 years)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关于 Go 中的错误处理:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rror 为 nil 时表示成功；非 nil 的 error 表示失败。</span></span><br><span class="line">i, err := strconv.Atoi(<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure><p>关于文件读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line">        <span class="comment">// 在遇到数据流的结尾时，它会返回一个 io.EOF 错误</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于图像处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;image&quot;</span>  <span class="comment">// image 包定义了 Image 接口</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">// Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明</span></span><br><span class="line">fmt.Println(m.Bounds())</span><br><span class="line">fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并发">并发</h1><p>说到并发，首先介绍Go 中的 Go 程（goroutine），它是由 Go 运行时管理的轻量级线程。当你写 <code>go f(x, y, z)</code> 会启动一个新的 Go 程并执行 <code>f(x, y, z)</code>。</p><p>在 Go 程的运行过程中，f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p></blockquote><p>关于信道，在 Go 中，实质上是带有类型的管道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>信道操作符有 <code>-&gt;</code>, <code>&lt;-</code>，箭头的方向预示着数据流的方向。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收值并赋予 v。</span></span><br></pre></td></tr></table></figure><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于带缓冲的信道, 使用 make 创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br><span class="line"><span class="comment">// ch &lt;- 3</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于使用信道来说，还有两个基本的操作，即关闭信道，或者是检查一个信道是否关闭了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个求斐波拉契数列的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)  <span class="comment">// 使用 close 关闭信道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// 循环 for i := range c 会不断从信道接收值，直到它被关闭</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>注意：只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p></li><li><p>信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。</p></li></ul><p>关于 Go 总的 Select 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go&#x27;s _select_ lets you wait on multiple channel</span></span><br><span class="line"><span class="comment">// operations. Combining goroutines and channels with</span></span><br><span class="line"><span class="comment">// select is a powerful feature of Go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For our example we&#x27;ll select across two channels.</span></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each channel will receive a value after some amount</span></span><br><span class="line"><span class="comment">// of time, to simulate e.g. blocking RPC operations</span></span><br><span class="line"><span class="comment">// executing in concurrent goroutines.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// We&#x27;ll use `select` to await both of these values</span></span><br><span class="line"><span class="comment">// simultaneously, printing each one as it arrives.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中信道非常适合在不同的 Go 程中进行通信。但如果我们不需要通信呢？若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这个概念叫互斥，Go 中有一个专门的数据结构来提供这一功能，互斥锁 Mutex，<code>sync.Mutex</code>.</p><p><code>sync.Mutex</code> 中有两个方法，Lock 和 Ulock。</p><p>我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行</p><p>我们也可以用 defer 语句来保证互斥锁一定会被解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P3, 内容较长,包括了 Go 中的方法、接口、并发等内容.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P2</title>
    <link href="https://scottzhang.pro/article/3773e07f.html"/>
    <id>https://scottzhang.pro/article/3773e07f.html</id>
    <published>2021-12-15T14:07:40.000Z</published>
    <updated>2022-01-07T14:06:02.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P2, 包括了指针、结构体、数组、切片、映射和闭包等内容。</p></blockquote><span id="more"></span><h1 id="指针">指针</h1><p>指针, 指针保存了值的地址:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针声明</span></span><br><span class="line"><span class="comment">// *int 是指向 int 类型的指针，其初始值（零值）为 nil</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp; 操作符会生成一个指向其操作数的指针</span></span><br><span class="line"><span class="comment">// 此处生成一个指向整数 42 的指针，赋值给 p</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取指针指向的值，操作也是 *</span></span><br><span class="line">fmt.Print(*p) <span class="comment">// 通过指针读取值</span></span><br><span class="line">*p = <span class="number">52</span>       <span class="comment">// 通过指针设置值</span></span><br></pre></td></tr></table></figure><h1 id="结构体">结构体</h1><p>结构体 struct，即一组字段 field:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">v = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 初始化赋值</span></span><br><span class="line">v.X = <span class="number">4</span>          <span class="comment">// 结构内元素赋值</span></span><br><span class="line">fmt.Print(v.X)   <span class="comment">// 取值</span></span><br><span class="line">fmt.Print(v.Y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的特殊文法：</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们第一次看到了 <code>type</code>，可以<a href="https://thenewstack.io/understanding-golang-type-system/">点击</a>这篇文章了解更多。</p><p>使用指针访问结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问结构体，需要结构提指针</span></span><br><span class="line"><span class="comment">// 还是以上面定义的结构体 Vertex 为例</span></span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结构体指针 p</span></span><br><span class="line"><span class="comment">// 赋值，本质是 (*p).X，为了避免繁琐，简化了操作（隐式间接调用）</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结构体的多种方式</span></span><br><span class="line"><span class="keyword">var</span> s1 Vertex&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s2 Vertex</span><br><span class="line"><span class="keyword">var</span> s3 *Vertex = <span class="built_in">new</span>(Vertex)</span><br></pre></td></tr></table></figure><blockquote><p>注意：结构体内部的变量名的大小写，会影响外部访问结构体内部的权限。</p></blockquote><p>结构体占用内存的大小是如何计算的？在 Go 中可以使用 sizeof 函数查看对象占用的对象类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占用 8 字节</span></span><br><span class="line">unsafe.Sizeof(x: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 不管字符串多长，都是 16，为什么？</span></span><br><span class="line">unsafe.Sizeof(x: <span class="string">&quot;scottzhang.pro&quot;</span>)</span><br></pre></td></tr></table></figure><p>其实 go 语言中的 string 是一个结构体:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">string</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span>  <span class="comment">// 指针，占用8个字节</span></span><br><span class="line">    Len <span class="keyword">int</span>       <span class="comment">//长度，64位占用8个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至 slice 也是一个结构体，类似这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 底层数组的地址 8</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>              <span class="comment">// 长度          8</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span>              <span class="comment">// 容量          8</span></span><br><span class="line">&#125;                        <span class="comment">//    永远都是 = 24</span></span><br></pre></td></tr></table></figure><h1 id="数组">数组</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明形式 [n]T</span></span><br><span class="line"><span class="comment">// 数组的长度是其类型的一部分，因此数组不能改变大小</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问内容的文法与其它语言一致</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;Scott&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的同时设置初始值</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(primes)</span><br></pre></td></tr></table></figure><h1 id="切片">切片</h1><p>切片为数组提供动态大小, 在实践中，切片比数组更常用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片与 Python Pandas 中 iloc 的语法类似</span></span><br><span class="line"><span class="comment">// 语法为 []T, 包括第一个元素，排除最后一个元素</span></span><br><span class="line">a[low:high]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择下标1-3的元素</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个例子</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片只是提供一个视角，所以它并不存储数据</span></span><br><span class="line"><span class="comment">// 但是对切片的修改，会修改底层数据</span></span><br><span class="line">names := [<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;Scott&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sam&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片的文法与没有写数组长度的类似</span></span><br><span class="line">[<span class="number">3</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;  <span class="comment">// 数组文法</span></span><br><span class="line">[]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;   <span class="comment">// 切片文法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 numpy, pandas 类似，取同样的值有多种写法</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">a[:]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片本身有属性，如长度和容量</span></span><br><span class="line"><span class="comment">// 长度：包含的元素个数</span></span><br><span class="line"><span class="comment">// 容量: 从它的第一个元素开始数，到其底层数组元素末尾的个数（注意区别 numpy）</span></span><br><span class="line"><span class="comment">// 长度和容量可通过表达式 len(s) 和 cap(s) 来获取</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 拓展其长度</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 舍弃前两个值</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//nil 切片</span></span><br><span class="line"><span class="comment">// 切片的零值是 nil</span></span><br><span class="line"><span class="comment">// nil 切片的长度和容量为 0 且没有底层数组</span></span><br></pre></td></tr></table></figure><p>使用 make 创建切片, make 函数会分配一个元素为零值的数组并返回一个引用了它的切片, 这也是在 Go 中使用动态数组的方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 make</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分别打印 abcd</span></span><br><span class="line"><span class="comment">a len=5 cap=5 [0 0 0 0 0]</span></span><br><span class="line"><span class="comment">b len=0 cap=5 []</span></span><br><span class="line"><span class="comment">c len=2 cap=5 [0 0]</span></span><br><span class="line"><span class="comment">d len=3 cap=3 [0 0 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>切片的切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似操作 dataframe</span></span><br><span class="line">board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment">_ _ _</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个下标设置值后得到改变后的图案</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X _ X</span></span><br><span class="line"><span class="comment">O _ X</span></span><br><span class="line"><span class="comment">_ _ O</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>向切片追加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>for 循环的 range 形式, 类似于 Python 中的 enumrate，但它是一个关键字而不是函数：</p><h1 id="映射">映射</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次迭代都会返回两个值</span></span><br><span class="line"><span class="comment">// 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</span></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">    fmt.Printf(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想忽略某个值，可以使用 _ </span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你只需要索引</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure><p>映射，类似 Python 中的字典，但需要规定 Key 和 Value 的类型，假设值是 struct，则需提前定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构体，用来存值</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明映射，键是 string，值是 struct</span></span><br><span class="line"><span class="comment">// 映射的零值为 nil 。nil 映射既没有键，也不能添加键。</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构体</span></span><br><span class="line"><span class="comment">// make 函数会返回给定类型的映射，并将其初始化备用</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">    <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 make 函数</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体内部，Vertex 可以省略</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取、编辑映射内部的值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除值</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双赋值检测, elem, ok = m[key]</span></span><br><span class="line"><span class="comment">// 若 key 在 m 中，ok 为 true ；否则，ok 为 false。</span></span><br><span class="line"><span class="comment">// 若 key 不在映射中，那么 elem 是该映射元素类型的零值。</span></span><br><span class="line"><span class="comment">// 同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</span></span><br><span class="line"><span class="comment">// 若 elem 或 ok 还未声明，你可以使用短变量声明：elem, ok := m[key]</span></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br></pre></td></tr></table></figure><h1 id="闭包">闭包</h1><p>函数值，Go 中函数也可以被传到另一个函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compute 函数接收另外一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute 接收了 hypot 作为参数</span></span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(compute(hypot))</span><br></pre></td></tr></table></figure><p>函数的闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><p>来一步一步理解 Go 中的闭包： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个普通的函数 send 并调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">&#125;</span><br><span class="line">send(<span class="string">&quot;hi, scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个匿名版本的 send 函数并立即调用</span></span><br><span class="line"><span class="comment">// 注意这个函数并没有函数名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">&#125;(<span class="string">&quot;hi, scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，返回一个函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func give_me_a_func() |func(string)| &lt;---- 这里规定了返回值</span></span><br><span class="line"><span class="comment">                                           即为一个接收 string 的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">give_me_a_func</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以把 give_me_a_func() 传给另外一个函数</span></span><br><span class="line">send_func := give_me_a_func()</span><br><span class="line">send_func(<span class="string">&quot;hi scott&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解了上面函数的工作方式后，我们来介绍闭包</span></span><br><span class="line"><span class="comment">// 先定义一个函数, 它返回一个函数(return int)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在定义另外一个变量来存储 incrementor 返回的函数</span></span><br><span class="line">next := incrementor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印每次调用 next() 返回的值</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 1</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 2</span></span><br><span class="line">fmt.Println(next())  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="comment">// 这里 i 看起来应该无法工作的</span></span><br><span class="line">        <span class="comment">// 因为 i 是定义在 incrementor 中的</span></span><br><span class="line">        <span class="comment">// 但闭包拥有其被创建环境下的作用域</span></span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://thenewstack.io/understanding-golang-type-system/">Understanding Golang Type System</a></li><li><a href="https://medium.com/m/global-identity?redirectUrl=https%3A%2F%2Fbetterprogramming.pub%2Fclosures-made-simple-with-golang-69db3017cd7b">Closures Made Simple With Golang</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P2, 包括了指针、结构体、数组、切片、映射和闭包等内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语法概览 P1</title>
    <link href="https://scottzhang.pro/article/ae7ab1c5.html"/>
    <id>https://scottzhang.pro/article/ae7ab1c5.html</id>
    <published>2021-12-14T15:55:09.000Z</published>
    <updated>2021-12-20T09:19:01.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 <a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a>的笔记 P1, 包含两大部分的语法介绍：一个是包、变量和函数，另外一个是流程控制语句，如 for, if-else, switch。</p></blockquote><span id="more"></span><h1 id="包变量和函数">包、变量和函数</h1><p>关于包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// 每个程序由包构成，从 main 开始</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span> </span><br><span class="line">    <span class="comment">// 在这个包中，肯定以 package rand 开始</span></span><br><span class="line">    <span class="comment">// 申明包的名字</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>关于导出名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(math.Pi) <span class="comment">//一个名字以大写字母开头，那么它就是已导出的</span></span><br><span class="line">fmt.Println(math.pi) <span class="comment">//未导出</span></span><br></pre></td></tr></table></figure><p>函数的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型相同的参数可以简写</span></span><br><span class="line">x <span class="keyword">int</span>, y <span class="keyword">int</span></span><br><span class="line">x,y <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以返回任意数量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接写 return 会返回函数中定义了的所有变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">    <span class="comment">// 返回 x 和 y, 此处是 7,10</span></span><br><span class="line">    <span class="comment">// 此处返回值会转成 int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span> <span class="comment">// 默认赋值为 false</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> <span class="comment">// 默认赋值为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始值</span></span><br><span class="line">vari, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span> <span class="comment">// 可以设置初始值</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&#x27;no!&#x27;</span> <span class="comment">// 不指定类型而直接指定初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量简单法，用 := 替代 var</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用语法块声明变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有给初始值，默认会赋值, 数值是0， 布尔 false，字符串是空字符</span></span><br></pre></td></tr></table></figure><p>类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int -&gt; float -&gt; uint</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f float = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的形式</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)</span><br><span class="line">u := <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>类型推导:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以准确推导的情况下，直接使用</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">j := i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能准确推导或者因为值运算的结果，需要改变精度</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">j := <span class="number">3.142</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> </span><br><span class="line"><span class="comment">// 注意: g = 0.867 + 0.5i 会报错</span></span><br></pre></td></tr></table></figure><p>常量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> Pi := <span class="number">3.14</span> <span class="comment">//syntax error: unexpected :=, expecting =</span></span><br></pre></td></tr></table></figure><p>数值常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line"><span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br></pre></td></tr></table></figure><h1 id="流程控制">流程控制</h1><p>Go 只有一种循环结构即 for 循环，分成三部分</p><ul><li><p>初始化语句：在第一次迭代前执行</p></li><li><p>条件表达式：在每次迭代前求值</p></li><li><p>后置语句：在每次迭代的结尾执行</p></li></ul><p>它有三种写法，for 后面没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的</p><ul><li><strong>for init; condition; post{}</strong></li><li><strong>for condition {}</strong></li><li><strong>for {}</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for init; condition; post&#123;&#125;</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for condition &#123;&#125;</span></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for &#123;&#125; 无限循环</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 If 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无(), 必须有 &#123;&#125;</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件表达式前可以执行一个简单的语句</span></span><br><span class="line"><span class="keyword">if</span> v := add(x, y); v &lt; <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else 语法</span></span><br><span class="line"><span class="keyword">if</span> v:= add(x, y) &#123;</span><br><span class="line">    <span class="comment">// do a</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处不可以使用 v 了</span></span><br></pre></td></tr></table></figure><p>关于 switch:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// freebsd, openbsd,</span></span><br><span class="line">        <span class="comment">// plan9, windows...</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Go 只运行选定的 case，而非之后所有的 case</span></span><br><span class="line"><span class="comment">// switch 的 case 无需为常量，且取值不必为整数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求值顺序从上到下，找到匹配成功</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> f(): <span class="comment">// f() 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有条件的 switch</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 defer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer 会将函数推迟到外层函数返回之后执行</span></span><br><span class="line"><span class="comment">// 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</span></span><br><span class="line"><span class="comment">// 下面的代码输出 hello \n world</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推迟的函数被压入栈，先进后出</span></span><br><span class="line"><span class="comment">// 所以下面的函数会以 987.. 的顺序打印</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&quot;https://tour.go-zh.org/welcome/1&quot;&gt;Go 语言之旅&lt;/a&gt;的笔记 P1, 包含两大部分的语法介绍：一个是包、变量和函数，另外一个是流程控制语句，如 for, if-else, switch。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 笔记: Module</title>
    <link href="https://scottzhang.pro/article/4b8d4d9.html"/>
    <id>https://scottzhang.pro/article/4b8d4d9.html</id>
    <published>2021-12-14T14:33:51.000Z</published>
    <updated>2021-12-20T09:11:58.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Understand Module in Golang.</p></blockquote><span id="more"></span><h1 id="code-example">Code example</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">quoteV3 <span class="string">&quot;rsc.io/quote/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> quoteV3.HelloV3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Proverb</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> quoteV3.Concurrency()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">want := <span class="string">&quot;Hello, world.&quot;</span></span><br><span class="line"><span class="keyword">if</span> got := Hello(); got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Hello() = %q, want %q&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProverb</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">want := <span class="string">&quot;Concurrency is not parallelism.&quot;</span></span><br><span class="line"><span class="keyword">if</span> got := Proverb(); got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Proverb() = %q, want %q&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go.mod</span></span><br><span class="line">module scottzhang.pro/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.17</span></span><br><span class="line"></span><br><span class="line">require rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="use-go-modules">Use Go Modules</h1><p>What is module?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module：a collection of Go packages</span><br><span class="line">  |</span><br><span class="line">go.mod:</span><br><span class="line">    - module&#x27;s module path</span><br><span class="line">    - dependency requirements</span><br></pre></td></tr></table></figure><p>The Running ENV for a module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. outside $GOPATH/src &lt;--</span><br><span class="line">2. inside any folder     |</span><br><span class="line">   with:                 |</span><br><span class="line">       - go.mod --------&gt;|</span><br></pre></td></tr></table></figure><p>How to creating a new module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. create you file.  // status: contains a package</span><br><span class="line">2. cmd: go mod init scottzhang.pro/hello  // make the current directory the root of a module</span><br><span class="line">3. cmd: go test  // test the module</span><br></pre></td></tr></table></figure><ul><li>Packages in subdirectories have import paths consisting of the module path plus the path to the subdirectory.</li><li>So you don't need to run <strong>go mod init</strong> in subdirectories.</li></ul><p>Understand go.mod content:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example.com/hello //main module</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c //an example of a pseudo-version</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.3.0</span><br><span class="line"></span><br><span class="line">// go <span class="built_in">command</span> maintains a file named go.sum</span><br><span class="line">// containing the expected cryptographic hashes of the content of specific module versions.</span><br><span class="line">// ensure that future downloads of these modules retrieve the same bits as the first download</span><br></pre></td></tr></table></figure><p>How to import dependencies module:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;rsc.io/quote&quot;</span></span><br><span class="line"><span class="comment">// to check  indirect dependencies</span></span><br><span class="line"><span class="comment">// cmd: go list -m all</span></span><br></pre></td></tr></table></figure><p>How to upgrading dependencies:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// here is a example to upgrade text and sampler</span><br><span class="line">cmd: go get golang.org/x/text</span><br><span class="line">cmd: go get rsc.io/sampler</span><br></pre></td></tr></table></figure><p>Now depends on both <strong>rsc.io/quote</strong> and <strong>rsc.io/quote/v3</strong>.</p><p>why here is V3?, because:</p><ul><li>Each different major version (v1, v2, and so on) of a Go module uses a different module path</li><li>v3 of rsc.io/quote = rsc.io/quote/v3, Know more visit <a href="https://research.swtch.com/vgo-import">here</a></li></ul><blockquote><p>You can have v1, v2, v3 in same module, but can't with v1.1 and v1.2</p></blockquote><p>To know what new changes in new version, type <strong>go doc rsc.io/quote/v3</strong>.</p><p>Remove no need module:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go list -m all  # check</span><br><span class="line">go mod tidy  # cleans up these unused dependencies</span><br></pre></td></tr></table></figure><h1 id="conclusion">Conclusion</h1><ul><li><strong>go mod init</strong> creates a new module, initializing the go.mod file that describes it.</li><li><strong>go build</strong>, go test, and other package-building commands add new dependencies to go.mod as needed.</li><li><strong>go list -m all</strong> prints the current module’s dependencies.</li><li><strong>go get</strong> changes the required version of a dependency (or adds a new dependency).</li><li><strong>go mod tidy</strong> removes unused dependencies.</li></ul><h1 id="ref">Ref</h1><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-go-modules">How to Use Go Modules</a></li><li><a href="https://go.dev/blog/using-go-modules">Using Go Modules</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Understand Module in Golang.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Go" scheme="https://scottzhang.pro/categories/Go/"/>
    
    
    <category term="Go" scheme="https://scottzhang.pro/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-抽象工厂与组合模式</title>
    <link href="https://scottzhang.pro/article/72c6f483.html"/>
    <id>https://scottzhang.pro/article/72c6f483.html</id>
    <published>2021-11-28T13:44:50.000Z</published>
    <updated>2021-11-28T13:50:30.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="抽象工厂模式">抽象工厂模式</h1><p>想让你的系统根据配置或平台的问题有多个可能的实现，就可以利用抽象工厂模式。</p><p>你调用抽象工厂会返回一个对象，这个对象的实现会基于你的需求而变化。</p><ul><li>对于一个在线的商城，它对于不同的国家有不同的语言、货币以及税收的计算方式。</li><li>对于一套 GUI 工具，在 Windows 上可能返回的是 WinForm，在 Mac 上返回的则是 Cocoa 组件。</li><li>对于 Django，它会根据当前站点的配置而返回相关的对象以对不同数据库后端的支持。</li></ul><p>想象一个格式化日期与货币的需求，我们需要支持中英文两种情况下的货币和日期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaDateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot; &#123;&#125; 年 &#123;&#125; 月 &#123;&#125; 日 &quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USADateFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_date</span>(<span class="params">self, y, m, d</span>):</span></span><br><span class="line">        y, m, d = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (y, m, d))</span><br><span class="line">        y = <span class="string">&#x27;20&#x27;</span> + y <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">2</span> <span class="keyword">else</span> y</span><br><span class="line">        m = <span class="string">&#x27;0&#x27;</span> + m <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">1</span> <span class="keyword">else</span> m</span><br><span class="line">        d = <span class="string">&#x27;0&#x27;</span> + d <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">1</span> <span class="keyword">else</span> d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y, m, d))</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27; 2021 年 01 月 01 日 &#x27;</span></span><br><span class="line">ChinaDateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;27&#x27;</span>)  <span class="comment"># &#x27; 2021 年 11 月 27 日 &#x27;</span></span><br><span class="line"></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)  <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br><span class="line">USADateFormatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>) <span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>再来定义两个处理货币的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaCurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¥ &#123;&#125;.&#123;&#125; 元&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USACurrencyFormatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, base, cents</span>):</span></span><br><span class="line">        base, cents = (<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (base, cents))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cents) == <span class="number">0</span>:</span><br><span class="line">            cents = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(cents) == <span class="number">1</span>:</span><br><span class="line">            cents = <span class="string">&#x27;0&#x27;</span> + cents</span><br><span class="line"></span><br><span class="line">        digits = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>(base))):</span><br><span class="line">            <span class="comment"># i 计算位数，千位 == 3</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> <span class="keyword">not</span> i % <span class="number">3</span>:</span><br><span class="line">                digits.append(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            digits.append(c)</span><br><span class="line">        base = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(digits))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;$ &#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(base, cents)</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChinaCurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;¥ 143,958,766,111,111.05 元&#x27;</span></span><br><span class="line">USACurrencyFormatter().<span class="built_in">format</span>(<span class="number">1432</span>, <span class="number">5</span>)  <span class="comment"># &#x27;$ 143,958,766,111,111.05&#x27;</span></span><br></pre></td></tr></table></figure><p>将上面的代码按照国家组织在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USAFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USADateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> USACurrencyFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaFormatterFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_date_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaDateFormatter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_currency_formatter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ChinaCurrencyFormatter()</span><br></pre></td></tr></table></figure><p>在使用的时候，可以直接使用字典去找对应的抽象工厂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factory_map = &#123;</span><br><span class="line">    <span class="string">&#x27;US&#x27;</span>: USAFormatterFactory,</span><br><span class="line">    <span class="string">&#x27;China&#x27;</span>: ChinaFormatterFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置区域为中国：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = &#x27;China&#x27;</span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(&#x27;21&#x27;, &#x27;1&#x27;, &#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line"># &#x27; 2021 年 01 月 01 日 &#x27;</span><br></pre></td></tr></table></figure><p>设置区域为美国：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">country_code = <span class="string">&#x27;US&#x27;</span></span><br><span class="line">formatter_factor = factory_map.get(country_code)()</span><br><span class="line">formatter_factor.create_date_formatter().format_date(<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;2021-01-01&#x27;</span></span><br></pre></td></tr></table></figure><p>在实际的项目架构中，我们会有一个后端的模块来支持对不同国家提供服务，它的结构可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">localize/</span><br><span class="line">__init__.py</span><br><span class="line">backends/</span><br><span class="line">__init__.py</span><br><span class="line">USA.py</span><br><span class="line">China.py</span><br></pre></td></tr></table></figure><p>那么我们可以在 localize 下面的 <code>__init__.py</code> 文件中，动态的选择区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .backends <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> country_code == <span class="string">&#x27;China&#x27;</span>:</span><br><span class="line">current_backend = <span class="string">&#x27;China&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="组合模式">组合模式</h1><p>组合模式一般通过组建来构造复杂的树状结构，它在文件夹和文件夹树中的应用比较多。</p><p>文件目录中通常有两种类型的对象，文件和文件夹。首先来定义这两个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.children = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">sejlf</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把一些常用的方法抽象到基类中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compoment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      get_path 方法会在外部实现</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">        new_folder = get_path(new_path)</span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br><span class="line">        new_folder.children[self.name] = self</span><br><span class="line">        self.parent = new_folder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self.parent.children[self.name]</span><br></pre></td></tr></table></figure><p>这样 File 和 Folder 类就可以少去一些代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span>(<span class="params">self, child</span>):</span></span><br><span class="line">        child.parent = self</span><br><span class="line">        self.children[child.name] = child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params">Compoment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, contents</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, new_path</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这种方式，我们使用的时候，可以进行任意的组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root = Folder(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">folder1 = Folder(<span class="string">&#x27;F1&#x27;</span>)</span><br><span class="line">folder2 = Folder(<span class="string">&#x27;F2&#x27;</span>)</span><br><span class="line">hello_file = File(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line">folder2.add_child(hello_file)</span><br><span class="line">folder1.add_child(folder2)</span><br><span class="line">root.add_child(folder1)</span><br><span class="line"></span><br><span class="line">root.children[<span class="string">&#x27;F1&#x27;</span>].children[<span class="string">&#x27;F2&#x27;</span>].children[<span class="string">&#x27;hello&#x27;</span>].contents</span><br></pre></td></tr></table></figure><p>当你在编程的时候，遇到了树状结构的时候，可以想想是否可以应用组合模式。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;抽象工厂模式让你的代码一键部署为不同区域的和语言，组合模式则擅长处理树状结构的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-适配器与外观模式</title>
    <link href="https://scottzhang.pro/article/2b511f30.html"/>
    <id>https://scottzhang.pro/article/2b511f30.html</id>
    <published>2021-11-26T09:46:19.000Z</published>
    <updated>2021-11-28T13:50:12.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="适配器模式">适配器模式</h1><p>适配器模式，顾名思义就好像是电脑的转接头一样，目的就是让不同的系统之间可以协同工作。</p><p>比如现在已经存在一些代码了，但你不想对它做任何更改，因为这意味着你要修改大量的内容，这时候你可以写一个适配器，将输入转化成现有代码可以直接使用的，这就叫适配器。</p><p>举个例子，假设我们有一个奇怪的日期格式，它的年和月中间有一个14，现在有一个代码的逻辑是得到初始日期和结束日期中间的天数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysCalculator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        start = datetime.datetime.strptime(self.start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strptime(self.end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (end - start).days</span><br><span class="line"></span><br><span class="line">DaysCalculator(start=<span class="string">&#x27;20211403&#x27;</span>, end=<span class="string">&#x27;20211409&#x27;</span>).get_days()</span><br><span class="line"><span class="comment"># 输出 184</span></span><br></pre></td></tr></table></figure><p>现在你有一些方法需要依赖这段代码，你不得不也按照这个奇怪的格式工作，那么这时候你可以写一个适配器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaysAdaptor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        start = datetime.datetime.strftime(start, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        end = datetime.datetime.strftime(end, <span class="string">&#x27;%Y14%m&#x27;</span>)</span><br><span class="line">        self.calculator = DaysCalculator(start, end)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.calculator.get_days()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造两个标准日期对象作为输入</span></span><br><span class="line">start = datetime.datetime.strptime(<span class="string">&#x27;2021/3&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line">end = datetime.datetime.strptime(<span class="string">&#x27;2021/9&#x27;</span>, <span class="string">&#x27;%Y/%m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里传入的日期类的日期，但也可以正常工作</span></span><br><span class="line">DaysAdaptor(start, end).get_days()</span><br></pre></td></tr></table></figure><h1 id="外观模式">外观模式</h1><p>外观模式更关注外部的体验，为了用户体验的方便，它将复杂的内部代码封装起来，只暴露一个简单的方法接受参数供用户调用，从而实现不同的功能。</p><p>一个例子是，你想编写一个接受/发送邮件的客户端，对于用户而言，它只需关心：</p><ul><li>发件人地址</li><li>邮件内容</li><li>接受人地址</li></ul><p>所以我们可以编写一个简单的方法，只关心这几个参数，而其余的对于地址的处理、检查，对于用户密码的验证等等则隐藏在函数内部。</p><p>相信你已经在自己的代码中使用过外观模式，此处不在举例。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;适配器模式让你可以兼容现有代码，外观模式则是为了封装代码而设计。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-享元与命令模式</title>
    <link href="https://scottzhang.pro/article/56f28bda.html"/>
    <id>https://scottzhang.pro/article/56f28bda.html</id>
    <published>2021-11-26T09:42:59.000Z</published>
    <updated>2021-11-28T13:50:17.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章讨论了享元模式与命令模式。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="享元模式">享元模式</h1><p>元、气之始，引申为元气。享元模式即共享最初的那部分，哪部分呢？</p><p>假设你有一个需求需要创建大量的类实例，利用享元模式，就可以保证<strong>共享同一状态的对象，可以同时使用该共享状态的内存。</strong></p><p>举个例子，之前聊过的汽车销售系统。对于每一辆车，我们可以加装不同的配置，比如有尊享版、豪华版等等。</p><p>不同版本之间，其实是大同小异。</p><p>如果对于每辆车我们都去统计它有什么功能，没有什么功能，则会产生巨大的浪费。</p><p>我们可以通过共享对象去存储那些与型号相关的特性列表。</p><p>享元在 Python 中的实现类似单例模式。</p><p>但单例模式返回的是一个类的实例，而享元模式则是根据指定的不同参数，返回对应的实例。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc  <span class="comment"># 垃圾回收器</span></span><br><span class="line"><span class="keyword">import</span> weakref <span class="comment"># 弱引用数据结构包</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarModel</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;弱引用的字典，内部的对象弱没有被引用，则会被回收。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _models = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, model_name, *avgs, **kvargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;这里对新实例的创建自定义，与单例模式有点类似</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        model = cls._models.get(model_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> model:</span><br><span class="line">            model = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">            cls._models[model_name] = model</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name, air=<span class="literal">False</span>, title=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 cruise_control=<span class="literal">False</span>, power_locks=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 allow_whells=<span class="literal">False</span>, use_charger=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例的初始化，在这里完成</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.model_name = model_name</span><br><span class="line">        self.air = air</span><br><span class="line">        self.title = title</span><br><span class="line">        self.cruise_control = cruise_control</span><br><span class="line">        self.power_locks = power_locks</span><br><span class="line">        self.allow_whells = allow_whells</span><br><span class="line">        self.use_charger = use_charger</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self, serial_number</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Sorry We are anble to check&quot;</span>,</span><br><span class="line">            <span class="string">&quot;the seria number &#123;0&#125; on the &#123;1&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;at this time&quot;</span>.<span class="built_in">format</span>(self.number, self.model_name)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model, color, serial</span>):</span></span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = color</span><br><span class="line">        self.serial = serial</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_serial</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model.check_serial(self.serial)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>上面定义了两个类，一个是汽车模版，一个是汽车。我们来生产几辆车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dx = CarModel(<span class="string">&quot;FIT DX&quot;</span>)</span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产一些车</span></span><br><span class="line">car1 = Car(model=dx, color=<span class="string">&#x27;blue&#x27;</span>, serial=<span class="string">&#x27;DX001&#x27;</span>)</span><br><span class="line">car2 = Car(model=dx, color=<span class="string">&#x27;black&#x27;</span>, serial=<span class="string">&#x27;DX002&#x27;</span>)</span><br><span class="line">car3 = Car(model=lx, color=<span class="string">&quot;red&quot;</span>, serial=<span class="string">&quot;LX003&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在来观察他们的内存地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># display(id(lx)) -&gt; 4402294352</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 lx 和对它的引用，让垃圾回收器回收</span></span><br><span class="line"><span class="keyword">del</span> lx</span><br><span class="line"><span class="keyword">del</span> car3</span><br><span class="line">gc.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新创建一个新的 lx，其地址已经变了，因为生成了新的 lx</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>, air=<span class="literal">True</span>, cruise_control=<span class="literal">True</span>, power_locks=<span class="literal">True</span>, title=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个其它版本的 lx，没有 air 和其他的选项，发现返回的还是第二遍创建的</span></span><br><span class="line">lx = CarModel(<span class="string">&quot;FIT LX&quot;</span>)</span><br><span class="line"><span class="comment"># display(id(lx)) -&gt; 4401731376</span></span><br></pre></td></tr></table></figure><p>享元模式使用起来比普通的类实现更负责，但如果你有成百上千的类实例需要创建的时候，享元模式可以极大的节省你的内存，可以说享元模式是专为节省内存而设计的。</p><h1 id="命令模式">命令模式</h1><p>命令模式在<strong>必须被完成的行为</strong>和<strong>调用这些动作的对象</strong>之间添加了一个抽象层，这句话可能比较难理解，我们看一个例子。</p><p>这个模式在图形窗口中的操作中应用的比较多。</p><p>我们实现一个窗口程序，它有退出和保存的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_name</span>):</span></span><br><span class="line">        self.file_name = file_name</span><br><span class="line">        self.content = <span class="string">&quot;This file can not be modified&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToolBarButton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, iconname</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.iconname = iconname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, menu_name, manu_itemname</span>):</span></span><br><span class="line">        self.manu_name = menu_name</span><br><span class="line">        self.menu_itemname = manu_itemname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyboardShortCut</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, modifier</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.modifier = modifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keypress</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExitCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.document.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个窗口</span></span><br><span class="line">window = Window()</span><br><span class="line"><span class="comment"># 新建一个文档</span></span><br><span class="line">document = Document(<span class="string">&quot;A Great Document!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建两个指令，需要传入文档</span></span><br><span class="line">save_command = SaveCommand(document)</span><br><span class="line">exit_command = ExitCommand(document)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定操作</span></span><br><span class="line"><span class="comment"># 举例：当 ToolBarButton 内部的 click 被调用</span></span><br><span class="line"><span class="comment"># click -&gt; save_command.execute（内部引用了document） -&gt; document.save</span></span><br><span class="line">save_button = ToolBarButton(<span class="string">&#x27;save&#x27;</span>, <span class="string">&#x27;save.png&#x27;</span>)</span><br><span class="line">save_button.command = save_command</span><br><span class="line"></span><br><span class="line">save_keystroke = KeyboardShortCut(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;ctrl&#x27;</span>)</span><br><span class="line">save_keystroke.command = save_command</span><br><span class="line"></span><br><span class="line">exit_menu = MenuItem(<span class="string">&#x27;File&#x27;</span>, <span class="string">&#x27;Exit&#x27;</span>)</span><br><span class="line">exit_menu.command = exit_command</span><br></pre></td></tr></table></figure><p>还有一种更简洁、更 Python 的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.command()</span><br><span class="line"></span><br><span class="line">window = Window()</span><br><span class="line">menu_item = MenuItem()</span><br><span class="line">menu_item.command = window.exit</span><br></pre></td></tr></table></figure><p>或者直接调用类，只需实现 <code>__call__</code> 方法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, document</span>):</span></span><br><span class="line">        self.document = document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;实现了 call 方法的类可以直接被调用&quot;&quot;&quot;</span></span><br><span class="line">        self.document.save()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章讨论了享元模式与命令模式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记录 Airflow 的部署</title>
    <link href="https://scottzhang.pro/article/c6a5215a.html"/>
    <id>https://scottzhang.pro/article/c6a5215a.html</id>
    <published>2021-11-26T07:06:25.000Z</published>
    <updated>2021-11-27T08:28:31.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个 Python 编写的调度工具，在此记录它的部署过程。</p></blockquote><span id="more"></span><h1 id="部署">部署</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy new server</span></span><br><span class="line">From vultr</span><br><span class="line"></span><br><span class="line"><span class="comment"># win10 generate ssh key</span></span><br><span class="line">ssh-keygen</span><br><span class="line">cat | Users/YourUserName/.ssh/id_rsa.pub | set-clibboard</span><br><span class="line"></span><br><span class="line">使用 Docker 配置 Airflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull puckel/docker-airflow</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -d -p 8080:8080 puckel/docker-airflow webserver</span><br><span class="line"><span class="comment"># 进入启动的容器并启动 shell</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置登录密码</span></span><br><span class="line"><span class="comment">## 创建 py 文件</span></span><br><span class="line">vim set_password.py</span><br><span class="line"></span><br><span class="line"><span class="comment">## 贴入代码</span></span><br><span class="line">import airflow</span><br><span class="line">from airflow import models, settings</span><br><span class="line">from airflow.contrib.auth.backends.password_auth import PasswordUser</span><br><span class="line"></span><br><span class="line">user = PasswordUser(models.User())</span><br><span class="line">user.username = <span class="string">&#x27;new_user_name&#x27;</span></span><br><span class="line">user.email = <span class="string">&#x27;new_user_email@example.com&#x27;</span></span><br><span class="line">user.password = <span class="string">&#x27;set_the_password&#x27;</span></span><br><span class="line">session = settings.Session()</span><br><span class="line">session.add(user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件，将配置文件拷贝出来用vim修改</span></span><br><span class="line">sudo docker cp a3a3dc6b79fe:/usr/<span class="built_in">local</span>/airflow/airflow.cfg .</span><br><span class="line">vim airflow.cfg . <span class="comment"># 修改</span></span><br><span class="line">sudo docker cp airflow.cfg  dc8b159da311:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 py 文件拷贝到容器</span></span><br><span class="line">sudo docker cp set_password.py  1291e03f85fc:/usr/<span class="built_in">local</span>/airflow/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t 1291e03f85fc bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码</span></span><br><span class="line">python set_password.py <span class="comment"># 提示缺少包 flask_bcrypt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 flask_bcrypt 包</span></span><br><span class="line">pip intall flask_bcrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行配置登录的代码, 重启</span></span><br><span class="line">python set_password.py</span><br><span class="line">docker container restart 1291e03f85fc</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"><span class="comment"># list dags</span></span><br><span class="line"></span><br><span class="line">airflow list_dags</span><br><span class="line"></span><br><span class="line">Filling up the DagBag from /home/repl/workspace/dags , 加粗部分为 dags 所在文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置文件</span></span><br><span class="line">cat ~/airflow/airflow.cfg</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line"><span class="comment"># 容器启动失败查看日志</span></span><br><span class="line">sudo docker logs <span class="variable">$&#123;container_id&#125;</span></span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://notbe.cn/2019/05/12/1557726443776.html">airflow 使用心得，从环境到部署上线</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个 Python 编写的调度工具，在此记录它的部署过程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="docker" scheme="https://scottzhang.pro/tags/docker/"/>
    
    <category term="airflow" scheme="https://scottzhang.pro/tags/airflow/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-模版模式</title>
    <link href="https://scottzhang.pro/article/ebf9c4b3.html"/>
    <id>https://scottzhang.pro/article/ebf9c4b3.html</id>
    <published>2021-11-21T07:51:22.000Z</published>
    <updated>2021-11-28T13:50:07.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><p>模版模式有助于去除重复代码，并满足了”DRY-不要重复自己“原则。</p><p>平时遇到数据处理的需求，我们需要执行一些常见的任务，如：</p><ol type="1"><li>去数据库取数，并将某些结果打印至控制台</li><li>去数据库取数，简单处理后，将结果保存到 csv 文件</li></ol><p>在这两个步骤中，有些子步骤是一样的，比如连接数据库，发出查询请求，执行 query 语句等。</p><p>可以将这部分功能集成到基类中，而其他特殊的功能可以放到子类中。</p><p>我们举例来说明，首先准备一个数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;CREATE TABLE sales&quot;</span></span><br><span class="line">    <span class="string">&quot;(&quot;</span></span><br><span class="line">    <span class="string">&quot;salespersion txt,&quot;</span></span><br><span class="line">    <span class="string">&quot;amt currency,&quot;</span></span><br><span class="line">    <span class="string">&quot;year integer,&quot;</span></span><br><span class="line">    <span class="string">&quot;model text,&quot;</span></span><br><span class="line">    <span class="string">&quot;new boolen&quot;</span></span><br><span class="line">    <span class="string">&quot;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入一些假数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete all rows from db before any new rows insert into table</span></span><br><span class="line">conn.execute(<span class="string">&quot;delete from sales&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert rows</span></span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Scott&#x27;, 1400, 2007, &#x27;Toyota&#x27;, &#x27;false&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Desmond&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Burney&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line">conn.execute(</span><br><span class="line">    <span class="string">&quot;insert into sales values&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#x27;Austin&#x27;, 1600, 2010, &#x27;Honda fit&#x27;, &#x27;true&#x27;)&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cursor = conn.execute(<span class="string">&quot;select * from sales&quot;</span>)</span><br><span class="line">cursor.fetchall()</span><br></pre></td></tr></table></figure><p>查询结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&#x27;Scott&#x27;</span>, 1400, 2007, <span class="string">&#x27;Toyota&#x27;</span>, <span class="string">&#x27;false&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Desmond&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Burney&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;Austin&#x27;</span>, 1600, 2010, <span class="string">&#x27;Honda fit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>现在我们设计一个 query 的模版类，想想它需要有哪些功能？</p><p>一个可能的基类是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_format</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;暴露给外部调用的方法，用来保证每个方法按照顺序执行。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.connect()</span><br><span class="line">        self.construct_query()</span><br><span class="line">        self.do_query()</span><br><span class="line">        self.format_results()</span><br><span class="line">        self.output_results()</span><br></pre></td></tr></table></figure><p>基类定义了我们需要有哪些功能，现在根据我们的需求，将其中一些可以共用的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryTemplate</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个类提供了连接数据库、执行 query，格式化结果的功能</span></span><br><span class="line"><span class="string">       而对于构造 query、导出结果的功能，则抽象成接口交给子类去实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conn = sqlite3.connect(<span class="string">&quot;sales.db&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.conn.execute(self.query)  <span class="comment"># query 待 construct_query 实现</span></span><br><span class="line">        self.result = result.fetchall()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> self.result:</span><br><span class="line">            row = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> row]</span><br><span class="line">            output.append(row)</span><br><span class="line">        self.formated_result = <span class="string">&#x27;\n&#x27;</span>.join(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>现在实现我们自己的需求就很容易了，因为我们只需要将精力放在构造 query 和 输出结果这两个方法上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewVehiclesQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.query = <span class="string">&quot;select * from sales where new = &#x27;true&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.format_result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherQuery</span>(<span class="params">QueryTemplate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_query</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.do_query = <span class="string">&quot;select * from sales&quot;</span>  <span class="comment"># do what you want to do</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        file_name = <span class="string">&quot;output_file.csv&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span> (file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(self.formated_result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;模版模式一般利用继承实现。比如我们有不同的任务要完成，其中有一些任务是相同的，我们可以将这些任务放在公共的基类中完成，其余特殊的任务设计在子类中。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-单例模式及其实现原理</title>
    <link href="https://scottzhang.pro/article/18dbdeeb.html"/>
    <id>https://scottzhang.pro/article/18dbdeeb.html</id>
    <published>2021-11-18T13:25:00.000Z</published>
    <updated>2021-11-28T13:50:00.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="面向对象">面向对象</h1><h2 id="方法是怎么工作的">方法是怎么工作的？</h2><p>方法是绑定在类中的函数。你可以像下面这样声明一个 pizza 类以及它的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接访问类的 get_size 方法，会告诉你这个方法未绑定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 中不会提示</span></span><br><span class="line">Pizza.get_size</span><br><span class="line">&lt;unbound method Pizza.get_size&gt;</span><br></pre></td></tr></table></figure><p>我们无法调用这个方法，因为它没有绑定给任何 Pizza 的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 会直接报错</span></span><br><span class="line">Pizza.get_size()</span><br><span class="line">TypeError: unbound method get_size() must be called <span class="keyword">with</span> Pizza instance <span class="keyword">as</span> first argument (got nothing instead)</span><br></pre></td></tr></table></figure><p>它提示你第一个参数必须是 Pizza 的实例，那我们将它的 Pizza 的实例传进去看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用类的 get_size 方法，同时传入实例，正常</span></span><br><span class="line">Pizza.get_size(Pizza(<span class="number">42</span>))</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>成功了! 不过这样使用也太麻烦了，好在 Python 会帮我们自动实现这些繁琐的工作。它会自动将 Pizza 中所有的方法绑定给任何 Pizza 的实例，当我们定义类方法的时候，其中写的 self 就等于类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = Pizza(<span class="number">42</span>).get_size</span><br><span class="line">m()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p>如果你想知道方法被绑定给了那个对象，可以通过 <code>m.__self__</code> 来查看方法被绑定到了哪个对象。</p><h2 id="静态方法">静态方法</h2><p>静态方法不需要提供 self 或 cls 等参数，因为声明为静态方法后，它不会绑定给任何实例或者类, 这减少了类实例创建时候的开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mix_ingredients</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mix_ingredients(self.cheese, self.vegetables)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到两个实例的方法是不想等的，而静态方法的对于实例和类都是相等的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pizza().cook <span class="keyword">is</span> Pizza().cook</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza.mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Pizza().mix_ingredients <span class="keyword">is</span> Pizza().mix_ingredients</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="类方法">类方法</h2><p>类方法的概念和实例方法类似，不同的是它会被绑定给类本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    radius = <span class="number">42</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">cls</span>):</span>  <span class="comment"># cls 为类</span></span><br><span class="line">        <span class="keyword">return</span> cls.radius</span><br></pre></td></tr></table></figure><p>对于类方法来说，不管你通过类还是类的实例调用，它引用的也都是同一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pizza.get_radius</span><br><span class="line">&lt;bound method <span class="built_in">type</span>.get_radius of &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">type</span>.<span class="title">get_radius</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Pizza</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span> == <span class="title">Pizza</span>().<span class="title">get_radius</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class"><span class="title">Pizza</span>.<span class="title">get_radius</span>()</span></span><br><span class="line"><span class="class">42</span></span><br></pre></td></tr></table></figure><p>什么时候使用类方法呢？</p><p>第一种情况是工厂模式中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ingredients</span>):</span></span><br><span class="line">        self.ingredients = ingredients</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_fridge</span>(<span class="params">cls, fridge</span>):</span></span><br><span class="line">        <span class="comment"># 会返回一个新的类的实例，这允许你在类的实例被初始化之前做一些事情，</span></span><br><span class="line">        <span class="comment"># 它的初始化参数来自于fridge 的两个方法 get_cheese() + get_vegetables()</span></span><br><span class="line">        <span class="keyword">return</span> cls(fridge.get_cheese() + fridge.get_vegetables())</span><br></pre></td></tr></table></figure><p>这样写的好处是，你可以通过 <code>Pizza.from_fridge(...)</code> 的方式生成实例。</p><p>第二种情况是调用静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius, height</span>):</span></span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.height = height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span>(<span class="params">radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> math.pi * (radius ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_volume</span>(<span class="params">cls, height, radius</span>):</span></span><br><span class="line">         <span class="keyword">return</span> height * cls.compute_area(radius)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_volume</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.compute_volume(self.height, self.radius)</span><br></pre></td></tr></table></figure><p>这里的 cls 可以写成 Pizza, 但通过 cls 的方式避免将 Pizza 类写死在类中。</p><h2 id="抽象方法">抽象方法</h2><p>抽象方法（Abstract methods）是定义在基类中的，未实现的方法，它有点类似于 java 中的接口。它规定了一种方法的形式，任何继承基类的子类都必须实现此方法才可以工作。</p><p>一个简单的抽象方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>根据这个定义，任何继承了 Pizza 类的子类，都必须实现并重写 get_redius 方法，如果你忘记实现，实例调用 get_radius 就会出错。</p><p>如果你想要让这种错误发生的更早一点，比如发生在实例刚创建的时候，那么可以设置 Pizza 的 metaclass 为 abc 模块中的 ABCMeta。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePizza</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __metaclass__  = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_radius</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="string">&quot;&quot;&quot;Method that should do something.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这里继承自 BasePizza 的类中，必须实现 get_radius 方法。BasePizza 对实现的细节并不关心，可以是类方法，实例方法，或者是静态方法。同样它也不关心返回的结果。</p><blockquote><p>参考: <a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">The definitive guide on how to use static, class or abstract methods in Python.</a></p></blockquote><h2 id="super-类">super 类</h2><p>是的，这标题没有错！super 是一个类，实例化之后得到的是一个代理的对象，而不是得到了父类，我们使用这个代理对象来调用父类或者兄弟类的方法。</p><p>但是当继承的父类比较多时，去哪个父类中调用方法就是个问题。对于子类的实例来说，可以通过 <code>obj.__mro__</code> 或者是 <code>cls.mro()</code> 访问父类的列表，python 通过它用管理类的继承顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问一个实例的 MRO 列表</span></span><br><span class="line"><span class="built_in">type</span>(B()).__mro__</span><br><span class="line">(__main__.B, __main__.A, <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>如果你提供一个 MRO 列表以及一个 MRO 中的类 C 给 super()，它将返回一个从 MRO 列表中 C 之后的类中查找到的方法的对象。</p><p>假设有个MRO列表为 [A, B, C, D, E, object]，执行 super(C, A).foo() 它只会从 C 之后查找，即: 只会在 D 或 E 或 object 中查找 foo 方法。</p><p>super() 它有几种使用方法：</p><ul><li>super() -&gt; same as super(<strong>class</strong>, <first argument>)</li><li>super(type) -&gt; unbound super object</li><li>super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</li><li>super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</li></ul><p>举个 super(type, obj) 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Base&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 super 的 func</span></span><br><span class="line"><span class="built_in">super</span>(A, C()).func()  <span class="comment"># 输出 &#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么是 B 呢？首先看一下 MRO 列表，Python 会根据第二个参数来计算 MRO，也就是这里提供的 C() 产生的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C.mro()</span><br><span class="line">[__main__.C, __main__.A, __main__.B, __main__.Base, <span class="built_in">object</span>]</span><br></pre></td></tr></table></figure><p>super 会计算出来的 mro 列表中，跳过参数A，从后面开始找父类的 func 方法，所以这里会执行 B 的 func。</p><p>然后再来说说 super(type, obj) 和 super(type, type2)的区别，他们的区别是第二个参数，super的第二个参数传递的是类，得到的是函数，super的第二个参数传递的是对象，得到的是绑定方法。</p><blockquote><p>理解绑定方法，有兴趣的再可以深入了解<a href="(https://docs.python.org/zh-cn/3.7/howto/descriptor.html)">描述器</a>的介绍。</p></blockquote><h1 id="单例模式">单例模式</h1><p>掌握了面向对象的知识和 super 的使用，就可以介绍单例模式了。单例模式是一种确保一个类只有一个实例会被创建出来的模式。</p><p>在其他语言中，单例通过构造函数私有化实现，Python 中没有私有构造函数，但可以通过类方法 <code>__new__</code> 实现。</p><p>我们知道 <code>__init__</code> 函数，但 <code>__init__</code> 是对创建好的实例初始化，而 <code>__new__</code> 才创建实例。</p><p>摘录网上一段关于这两个方法的解释：</p><ul><li>new (cls[, ...]) 是在一个对象实例化的时候所调用的第一个方法，在调用 init 初始化前，先调用new 。</li><li>new 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给 init 。</li><li>new 对当前类进行了实例化，并将实例返回，传给 init 的self。但是，执行了new ，并不一定会进入 init ，只有new 返回了，当前类cls的实例，当前类的 init 才会进入。</li><li>若new 没有正确返回当前类cls的实例，那 init 是不会被调用的，即使是父类的实例也不行，将没有 init 被调用。</li><li>new 方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径。</li></ul><blockquote><p>为 markdown 渲染方便，这里的 new 即 <code>__new__</code>, init 即 <code>__init__</code></p></blockquote><p>来看一个实现了这两个方法的类的调用顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Scott&quot;</span>, <span class="number">25</span>)</span><br><span class="line">__new__</span><br><span class="line">__init__</span><br></pre></td></tr></table></figure><p>可以看到先调用了 <code>__new__</code>, 才是 <code>__init__</code>，利用 new 的特性，我们可以用它来实现单例模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span>:</span></span><br><span class="line">    _singleton = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># super(OnlyOne, cls) 即上面的 super(type, type2) 模式</span></span><br><span class="line">        <span class="comment"># 这里相当于根据 cls 找 MRO 列表中，OnlyOne后的父类</span></span><br><span class="line">        <span class="comment"># 使用它的 __new__ 方法创建一个 cls（即本类）的实例</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._singleton:</span><br><span class="line">            cls._singleton = <span class="built_in">super</span>(</span><br><span class="line">                OnlyOne, cls</span><br><span class="line">            ).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._singleton</span><br></pre></td></tr></table></figure><p>我们首先检查这个单件的实例是否被创建出来，如果没有，我们用 super 函数来创建它。因此，每当我们调用 OnlyOne 的时候，总是可以得到完全相同的实例。</p><p>单例模式还有其他的实现，比如装饰器、MetaClass，感兴趣的可以看<a href="https://zhuanlan.zhihu.com/p/37534850">这篇</a>文章。</p><p>单例的这种思想，可以用在模块中。比如对于我们前面状态模式中的例子，状态模式中对于不同的状态，我们都有对应的类会初始化作为对状态的记录（如 First tag, Open tag）。</p><p>其实我们可以将状态设置为变量，这就避免了每次都初始化状态类产生一个新的实例，同时在每一个状态类内部，不再对解析器做引用，具体的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildNode</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remaining_str, parser</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        parser.state = child_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">child_node = ChildNode()</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>单例模式设计的内容还是挺多的，如装饰器、静态方法、类方法、继承、多态、MRO、装饰器、super 方法等。为了理解单例模式，我也是花了不少时间复习这块的内容，希望整理的这些笔记可以帮到你，如果要彻底理解这些内容，重要的还是要多去练习、多动手写代码。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/37534850">Python单例模式 Singleton 的N种实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/261579683">python魔法方法，详解 new 和 init 方法</a></li><li><a href="https://www.cnblogs.com/maple-shaw/p/9288018.html">你会使用super()吗？你确定你了解它吗？</a></li><li><a href="https://docs.python.org/zh-cn/3.7/howto/descriptor.html">实现描述器</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了 Python 中的单例模式，虽然单例模式的实现代码很简单，但是要理解它背后实现的原理，我们还需要理解面向对象中众多的概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="OOP" scheme="https://scottzhang.pro/tags/OOP/"/>
    
    <category term="singleton" scheme="https://scottzhang.pro/tags/singleton/"/>
    
    <category term="super" scheme="https://scottzhang.pro/tags/super/"/>
    
    <category term="staticmethod" scheme="https://scottzhang.pro/tags/staticmethod/"/>
    
    <category term="classmethod" scheme="https://scottzhang.pro/tags/classmethod/"/>
    
    <category term="Abstract methods" scheme="https://scottzhang.pro/tags/Abstract-methods/"/>
    
    <category term="abc" scheme="https://scottzhang.pro/tags/abc/"/>
    
    <category term="MRO" scheme="https://scottzhang.pro/tags/MRO/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-策略与状态模式</title>
    <link href="https://scottzhang.pro/article/8a706eb8.html"/>
    <id>https://scottzhang.pro/article/8a706eb8.html</id>
    <published>2021-11-16T13:32:21.000Z</published>
    <updated>2021-11-28T13:49:55.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="策略模式">策略模式</h1><p>策略模式是一种面向对象编程中的抽象模式。针对同样的问题，它实现了不同的解决方案，你的代码可以在运行的时候自由选择最恰当的方案。</p><p>策略模式的一个应用是排序，比如你要实现一个排序算法，它可以自动选择排序方法来对输入的数组进行排序，排序的方法是自动选择的，而结果是不变的。</p><p>还有一个例子是设置电脑的墙纸，当你设置墙纸的时候，你的电脑会自动帮你设置很多事情：</p><ol type="1"><li>根据屏幕的分辨率，自动将图片缩放到合适的大小</li><li>自动处理图片与系统组件之间的缩放、虚化关系</li><li>图片与背景色的结合</li></ol><p>你可以定义不同的对象，它们接受的 input 是一样的（目标图片，屏幕分辨率），不管怎样，这些对象都都能达到设置屏幕壁纸的目的。</p><p>有人说我通过 if 判断也可以达到同样的目的，但是这意味着你需要将你的代码放到一个巨大的方法中，随着新的策略的增加，你的函数将变得非常笨重。</p><p>这里略过策略模式的实例。</p><h1 id="状态模式">状态模式</h1><p>状态模式的目的是实现“状态切换”，对象的状态可以被外面知道，并且可能会被一些活动改变。来一个例子，需求是要对一个 <a href="https://www.w3.org/XML/">xml 文件</a>进行解析，一个简单的 xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>welcome to scott&#x27;s blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想把这样的文件解析出来，结果是我可以通过 node.attr 的方式访问 xml 文件的内容。比如 xml_file.body 作为一个节点。该节点有一个属性叫子节点，我可以通过 xml_file.body.children 的方式拿到，对于 title 中的内容，我已通过 xml_file.body.title.text 的方式拿到。</p><p>首先需要一个节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点类，记录节点的名字，文本，节点之间有上下级关系，所以它</span></span><br><span class="line"><span class="string">       还需要一个指向父节点的指针。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tagname, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.parent=parent</span><br><span class="line">        self.tagname = tagname</span><br><span class="line">        <span class="comment"># text 和 children 都由其他组件操作</span></span><br><span class="line">        self.children = []</span><br><span class="line">        self.text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.text:</span><br><span class="line">            <span class="keyword">return</span> self.tagname + <span class="string">&#x27;:&#x27;</span> + self.text</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.tagname</span><br></pre></td></tr></table></figure><p>有了节点后，我们还需要一个解析器，解析器会一层一层的解析字符串，我们可以定义解析器有几种状态，即处于：</p><ul><li>开始节点</li><li>子节点</li><li>结束节点</li></ul><p>如何根据解析器的状态判断是否还可以深入一步呢？可以这么定义：</p><ul><li>开始节点</li><li>子节点</li><li>打开的节点</li><li>结束节点</li><li>文本节点（最底层无子节点的节点）</li></ul><p>来看代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parser 是一个解析器。它会负责去切换状态，下图的状态之间会互相转换。</span></span><br><span class="line"><span class="string">       第一个状态是 First Tag，它永远将切换至子节点，再由子节点来决定切换到其他哪个状态。</span></span><br><span class="line"><span class="string">       每一个状态都会用自己的方法处理收到的剩余字符，然后将状态再设置为 Children Node，告诉解析器来处理剩下的部分。</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">        |                     .-------------.                      |</span></span><br><span class="line"><span class="string">        |                    (   First Tag   )                     |</span></span><br><span class="line"><span class="string">        |                     `-------------&#x27;                      |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                            |                             |</span></span><br><span class="line"><span class="string">        |                     .------v------.                      |</span></span><br><span class="line"><span class="string">        |         +---------&gt;( Children Node )&lt;----------+         |</span></span><br><span class="line"><span class="string">        |         |           `-------------&#x27;            |         |</span></span><br><span class="line"><span class="string">        |         |                  ^                   |         |</span></span><br><span class="line"><span class="string">        |         v                  v                   v         |</span></span><br><span class="line"><span class="string">        |  .-------------.    .-------------.     .-------------.  |</span></span><br><span class="line"><span class="string">        | (   Open tag    )  (  Closed tag   )   (     Text      ) |</span></span><br><span class="line"><span class="string">        |  `-------------&#x27;    `-------------&#x27;     `-------------&#x27;  |</span></span><br><span class="line"><span class="string">        |                                                          |</span></span><br><span class="line"><span class="string">        +----------------------------------------------------------+</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parse_str</span>):</span></span><br><span class="line">        self.parse_str = parse_str</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.current_node = <span class="literal">None</span></span><br><span class="line">        self.state = FirstTag()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str</span>):</span></span><br><span class="line">        remainning = self.state.process(remain_str, self)</span><br><span class="line">        <span class="keyword">if</span> remainning:</span><br><span class="line">            self.process(remainning)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.process(self.parse_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理剩余的字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str (string): 剩余需要解析的字符</span></span><br><span class="line"><span class="string">            parser (Parser): parser 即上面定义的的 Parser，它会被闯进来修改它的属性，如current_node, root, state</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 剩余需要解析的字符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line"></span><br><span class="line">        root = Node(tag_name)</span><br><span class="line">        parser.root = parser.current_node = root</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;同样只需要一个 process 方法来处理字符串。</span></span><br><span class="line"><span class="string">           作为 ChildrenNode，它需要根据字符来判断需要使用什么样的类状态器，</span></span><br><span class="line"><span class="string">           类状态器的 process 方法将会完成对剩余字符的处理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remain_str ([type]): [description]</span></span><br><span class="line"><span class="string">            parser ([type]): [description]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        striped = remain_str.strip()</span><br><span class="line">        <span class="keyword">if</span> striped.startswith(<span class="string">&#x27;&lt;&#x27;</span>):</span><br><span class="line">            parser.state = OpenTag()</span><br><span class="line">        <span class="keyword">elif</span> striped.startswith(<span class="string">&#x27;&gt;&#x27;</span>):</span><br><span class="line">            parser.state = CloseTag()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parser.state = TextNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        tag_name  = remain_str[i_start_tag+<span class="number">1</span>:i_end_tag]</span><br><span class="line">        <span class="comment"># parser.current_node 未被更改还是上一层节点，将其设为父节点</span></span><br><span class="line">        node = Node(tag_name, parser.current_node)</span><br><span class="line">        parser.current_node.children.append(node)</span><br><span class="line">        parser.current_node = node</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseTag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">        i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        i_end_tag = remain_str.find(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        <span class="comment"># assert 断言中</span></span><br><span class="line">        <span class="comment"># 第一个确保 &lt; 后是/，如 &lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 第二个确保以同一个tag名开始结束，如 &lt;h1&gt;Hi&lt;/h1&gt;</span></span><br><span class="line">        <span class="comment"># 以及因当前是结束tag，重置parser当前节点为其父节点</span></span><br><span class="line">        <span class="keyword">assert</span> remain_str[i_start_tag+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        tagname = remain_str[i_end_tag+<span class="number">2</span>:i_end_tag]</span><br><span class="line">        <span class="keyword">assert</span> tagname == parser.current_node.tagname</span><br><span class="line">        parser.current_node = parser.current_node.parent</span><br><span class="line">        parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain_str[i_end_tag+<span class="number">1</span>:].strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, remain_str, parser</span>):</span></span><br><span class="line">         i_start_tag = remain_str.find(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">         text = remain_str[:i_start_tag]</span><br><span class="line">         parser.current_node.text = text</span><br><span class="line">         parser.state = ChildrenNode()</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> remain_str[i_start_tag:]</span><br></pre></td></tr></table></figure><p>启动代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.xml&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        p = Parser(file.read())</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">        nodes = [p.root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            nodes = node.children + nodes</span><br></pre></td></tr></table></figure><p>将会产生下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">title:welcome to scott&#x27;s blog</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两种设计模式非常相似，它们的 UML 图都是完全相同的。策略模式注重于对算法的选择，而状态模式注重对状态的切换，可以理解为状态的切换会改变处理的策略。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式-装饰器与观察者模式</title>
    <link href="https://scottzhang.pro/article/140cd416.html"/>
    <id>https://scottzhang.pro/article/140cd416.html</id>
    <published>2021-11-15T12:50:18.000Z</published>
    <updated>2021-11-28T13:50:21.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。</p></blockquote><span id="more"></span><p>这是设计模式系列文章的一部分，<a href="https://scottzhang.pro/categories/设计模式/">点击</a>查看该系列的其他文章。</p><h1 id="装饰器模式">装饰器模式</h1><p>装饰器可以将一个提供核心功能的对象，和其他可以改变这个功能的对象“包裹”在一起使用。</p><p>它主要有两种用途：</p><ul><li>增强一个组件给另一个组件发送数据时的<strong>响应能力</strong></li><li>支持<strong>多种可选的行为</strong>（适当的代替多重继承）</li></ul><h2 id="装饰器">装饰器</h2><p>如果你不知道什么是装饰器，可以看下这篇 <a href="https://medium.com/citycoddee/python%E9%80%B2%E9%9A%8E%E6%8A%80%E5%B7%A7-3-%E7%A5%9E%E5%A5%87%E5%8F%88%E7%BE%8E%E5%A5%BD%E7%9A%84-decorator-%E5%97%B7%E5%97%9A-6559edc87bc0">文章</a>，其中有一段代码可以让你很容易理解它的原理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span>(<span class="params">a_func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之前做一些无聊的工作&quot;</span>)</span><br><span class="line"></span><br><span class="line">        a_func()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在 a_func() 执行之后做一些无聊的工作&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;就是你! 来包装我吧!&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是一个需要被包装的家伙&quot;</span></span><br><span class="line">          <span class="string">&quot;快来拯救我！&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br></pre></td></tr></table></figure><h2 id="网络编程装饰器实例">网络编程装饰器实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用传入对象 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法，即不管你传进来的啥东西，只要有 send 和 close</span></span><br><span class="line"><span class="string">       方法即可。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个常量数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP，另外还有 UDP（这属于计算机网络的知识）</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(client)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br></pre></td></tr></table></figure><p>上面的 respond 方法只关注接受的对象有没有 send, close 方法。</p><p>我们甚至可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法可以继续工作。</p><p>让我们来实现一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</p><p>下面的例子是一个网络编程实例的实现，它有一个服务端和客户端，服务端会一直处于待命状态，只要有客户端连接，服务端就会做出回应.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于 socket，socket.AF_APPLETALK 等内容请参考：</span></span><br><span class="line"><span class="comment"># https://docs.oracle.com/cd/E19120-01/open.solaris/817-4415/sockets-18552/index.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respond</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 client 的发送方法，作出“回应”，它只关心 client 的</span></span><br><span class="line"><span class="string">       send 和 close 方法。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response_str = <span class="built_in">input</span>(<span class="string">&quot;有连接请求，输出你的回应：&quot;</span>)</span><br><span class="line">    client.send(<span class="built_in">bytes</span>(response_str, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogSocket</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上面的 respond 方法只关注接受的对象有没有 send, close 方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    我们可以传入一个自定义的对象，只要它有 send, close 方法，respond 方法就还是可以继续工作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    所以，我们可以写一个自己的对象，它拥有 send，close 方法，这两个方法是对 client 的 send, close 方法的包装，这样我们就可以在调用 client 的 send，close 方法之前或者之后做一些事情。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    下面举一个例子是在 send，close 调用的时候执行答应。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sending <span class="subst">&#123;data&#125;</span> to <span class="subst">&#123;self.socket.getpeername()[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        self.socket.send(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># AF_INET 是协议族的规定，本质上上是一个数字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 指定为 TCP</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2401</span>))</span><br><span class="line">server.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        respond(LogSocket(client))  <span class="comment"># client 被包装（装饰），或者说被替换了</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    server.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用装饰器的好处是，你可以灵活的切换，比如你可以另外写一个装饰器，用于对发送的数据压缩。 然后你就可以实现类似这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GzipSocket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, socket</span>):</span></span><br><span class="line">        self.socket = socket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        buf = BytesIO(data)</span><br><span class="line">        zipfile = gzip.GzipFile(fileobj=buf, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        zipfile.write(data)</span><br><span class="line">        zipfile.close()</span><br><span class="line"></span><br><span class="line">        self.socket.send(buf.getvalues())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">client, addr = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> log_send:</span><br><span class="line">    client = LogSocket(client)</span><br><span class="line"><span class="keyword">if</span> gzip_send:</span><br><span class="line">    client = GzipSocket(client)</span><br></pre></td></tr></table></figure><h2 id="自定义打印的实例">自定义打印的实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_calls</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个新的函数，替换原来传入的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用：&#123;0&#125;, 携带参数 &#123;1&#125;, &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__, args, kwargs</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        return_value = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函数 &#123;&#125; 用时 &#123;&#125; &quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func.__name__,</span><br><span class="line">            time.time() - now</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> return_value</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用方法实现的装饰器的使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test = log_calls(test)</span><br><span class="line">result = test(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 特殊的方法使用装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@log_calls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">test(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用：<span class="built_in">test</span>, 携带参数 (2, 3), &#123;&#125;</span><br><span class="line">函数 <span class="built_in">test</span> 用时 2.002716064453125e-05</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="装饰器技巧">装饰器技巧</h2><p>想象一下，如果你需要给一个类中的所有方法添加一个装饰器，你会怎么办？也许你不会有这样的需求，但有时候，你可能需要对某几个函数添加装饰器，但你又不想在原来的类旁边添加任何代码。</p><p>这可以通过 metaclass 来实现，或者通过循环类的方法使用 setattr 方法修改，有兴趣的可以研究一下。</p><p>这里放一个 StackOverflow 上的 <a href="https://stackoverflow.com/questions/3467526/attaching-a-decorator-to-all-functions-within-a-class">讨论</a>。</p><h1 id="观察者模式">观察者模式</h1><p>观察者模式适用于<strong>状态监测</strong>和<strong>事件处理</strong>。</p><p>它有一个核心对象，以及观察者。核心对象由一组未知，并可能正在扩展的 “观察者” 对象来监控。一旦核心对象的值发生了变化，便会通过 update 方法告诉每一个观察者。观察者收到更新后，可能会做不一样的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inventory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.observers = []</span><br><span class="line">        self._product = <span class="literal">None</span></span><br><span class="line">        self._quantity = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._product</span><br><span class="line"></span><br><span class="line"><span class="meta">    @product.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._product = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._quantity</span><br><span class="line"></span><br><span class="line"><span class="meta">    @quantity.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quantity</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._quantity = value</span><br><span class="line">        self._update_observers()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_observers</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">            <span class="comment"># 调用 observer 对象，为了让一个对象可以被调用，它需要实现</span></span><br><span class="line">            <span class="comment"># __call__ 方法</span></span><br><span class="line">            observer()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleObserver</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inventory</span>):</span></span><br><span class="line">        self.inventory = inventory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwds</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;观察者模式可以用于备份数据至不同的地方，比如文件、数据库或互联网应用。</span></span><br><span class="line"><span class="string">           它将正在被观察的代码，和执行的代码分离。</span></span><br><span class="line"><span class="string">           如果不使用这种模式，则必须在每个属性中处理可能出现的情况，这意味着任务代码和</span></span><br><span class="line"><span class="string">           被观察的对象耦合在一起，维护起来会很麻烦。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.inventory.product)</span><br><span class="line">        <span class="built_in">print</span>(self.inventory.quantity)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">invt = Inventory()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以很容易的添加观察者</span></span><br><span class="line">console_1 = ConsoleObserver(invt)</span><br><span class="line">console_2 = ConsoleObserver(invt)</span><br><span class="line"></span><br><span class="line">invt.attach(console_1)</span><br><span class="line">invt.attach(console_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到每次对 product 或者 quantity 的修改</span></span><br><span class="line"><span class="comment"># 都会产生两次打印，这是因为两个观察者都做出了响应</span></span><br><span class="line">invt.product = <span class="string">&#x27;元气森林&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">invt.quantity = <span class="number">100</span>,<span class="number">000</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">元气森林</span></span><br><span class="line"><span class="string">(100, 0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;设计模式就像建筑师决定建造一座桥、一座塔、一栋楼时，他们会遵循的原则。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://scottzhang.pro/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="设计模式" scheme="https://scottzhang.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级导入技巧</title>
    <link href="https://scottzhang.pro/article/935fa388.html"/>
    <id>https://scottzhang.pro/article/935fa388.html</id>
    <published>2021-09-21T15:33:14.000Z</published>
    <updated>2021-11-27T08:36:36.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章深入研究了 <code>import</code> 命令以及它的工作原理。</p></blockquote><span id="more"></span><h1 id="基本导入命令">基本导入命令</h1><p>在 <a href="https://wittyfans.com/article/c8bc6f6.html">Python-模块与包</a> 一文中，我们看到过 <code>import</code> 命令，它可以用来导入包和模块。</p><p><code>import</code> 命令有几种形式:</p><ul><li><code>import math</code></li><li><code>from math import pi</code></li><li><code>import math as m</code></li></ul><p>对于 <code>import</code> 命令，它不关心 <code>import</code> 的是一个包还是一个模块，因为语法是一样的，只是包在构建的时候有些不同。</p><blockquote><p>一个没有 <code>__init__.py</code> 文件的目录，也会被当做一个包，只是不是普通的包，有时候称其为命名空间包 (namespace packages)。</p></blockquote><p>通常情况下，在一个普通的包中，子模块和子包默认不会导入，除非你在 <code>__init__.py</code> 中有 <code>import</code> 子包和子模块。</p><p>举一例，有个叫 world 包的包，其目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">world/</span><br><span class="line">│</span><br><span class="line">├── africa/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── zimbabwe.py</span><br><span class="line">│</span><br><span class="line">├── europe/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── greece.py</span><br><span class="line">│   ├── norway.py</span><br><span class="line">│   └── spain.py</span><br><span class="line">│</span><br><span class="line">└── __init__.py</span><br></pre></td></tr></table></figure><p>如果你要使用 world 包，若其中没有 <code>__init__.py</code> 是不会包括子包的。</p><p>导入一个包会加载包的内容，并创建命名空间，命名空间是一个字典，你可以通过 <code>__dict__</code> 属性访问到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.__dict__[<span class="string">&quot;pi&quot;</span>]</span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>同样的，全局变量也是一个命名空间，可以通过 <code>globals()</code> 访问。</p><h1 id="常见导入问题">常见导入问题</h1><p>假设你现在有一个包，它的目录结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── files.py</span><br><span class="line">└── structure.py</span><br></pre></td></tr></table></figure><p><code>structure.py</code> 中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># structure.py</span></span><br><span class="line"><span class="keyword">import</span> files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>运行 <code>python structure.py .</code> 后的输出: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python structure.py .</span><br><span class="line">Create file: /home/gahjelle/structure/001/structure.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/files.py</span><br><span class="line">Create file: /home/gahjelle/structure/001/__pycache__/files.cpython-38.pyc</span><br></pre></td></tr></table></figure></p><p>当你在 <code>structure.py</code> 需要用到 files 时，如果这两个文件在同一目录，这样是没有问题的。</p><p>现在为了满足 Pyinstaller guide 而创建了一个程序入口，你的目录结构变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">structure/</span><br><span class="line">│</span><br><span class="line">├── structure/</span><br><span class="line">│   ├── files.py</span><br><span class="line">│   └── structure.py</span><br><span class="line">│</span><br><span class="line">└── cli.py</span><br></pre></td></tr></table></figure><p>在 <code>cli.py</code> 中，你导入了 structure 中的 main 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> structure.structure <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>此时，如果你在 <code>cli.py</code> 所在目录执行 <code>python cli.py structure</code>，则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;cli.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from structure.structure import main</span><br><span class="line">  File &quot;/home/gahjelle/structure/structure/structure.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    import files</span><br><span class="line">ModuleNotFoundError: No module named &#x27;files&#x27;</span><br></pre></td></tr></table></figure><p>因为 <code>import files</code> 基于当前目录去寻找 files，而当执行目录变化以后，肯定就找不到了。</p><p>一种解决办法是，在引用文件中，找到引用文件的父目录，并将其加入到 <code>sys.path</code> 中（即 implicit relative imports，隐式相对导入）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local imports</span></span><br><span class="line"> sys.path.insert(<span class="number">0</span>, <span class="built_in">str</span>(pathlib.Path(__file__).parent))</span><br><span class="line"> <span class="keyword">import</span> files</span><br></pre></td></tr></table></figure><p>你可能会像在 <code>structure.py</code> 中，使用相对路径导入 <code>files</code>，如：<code>from . import files</code></p><p>但这样也是不行的，因为<a href="https://www.python.org/dev/peps/pep-0328/#relative-imports-and-name">相对导入在脚本中的解析方式与导入模块中的解析方式不同</a>。</p><p>一个更好的方式是使用 <code>pip</code>, 你自己创建一个包，使用起来就好像其他的包一样。</p><h1 id="何不创建自己的包">何不创建自己的包？</h1><p>当你通过 pip 安装一个包的时候，它可以在任何地方使用，事实上你也可以做到，首先在你的包文件夹旁边新建两个文件：</p><ul><li><code>setup.cfg</code></li><li><code>setup.py</code></li></ul><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># setup.cfg</span><br><span class="line"></span><br><span class="line">[metadata]</span><br><span class="line">name = local_structure</span><br><span class="line">version = 0.1.0</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line">packages = structure</span><br><span class="line"></span><br><span class="line"># setup.py</span><br><span class="line"></span><br><span class="line">import setuptools</span><br><span class="line"></span><br><span class="line">setuptools.setup()</span><br></pre></td></tr></table></figure><p>name 和 version，随意。名字的话建议打上标识，比如 local 或者你的用户名，这样可以方便的找出你自己的包。</p><p>准备好了之后，就可以创建你自己的包了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -e .</span><br></pre></td></tr></table></figure><p><code>-e</code> 的意思是 <code>editable</code>， 这个非常重要，因为这可以让你更改你的源代码，而不用重新安装你的包。</p><p>这条命令会将你的包安装到系统，你可以在任何地方使用你的包，只需执行 <code>from structure import files</code>。不用担心相对路径，绝对路径等问题。</p><blockquote><p>简单的包可以这样直接建立，但如果比较复杂的包则最好附上更多详细的信息，可参考 [<a href="https://realpython.com/pypi-publish-python-package/">How to Publish an Open-Source Python Package to PyPI</a>.</p></blockquote><h1 id="介绍命名空间包">介绍命名空间包</h1><p>命名空间包可以允许不存在 <code>__init__.py</code> 文件，特别的，它还允许文件分布在不同的文件夹。当你的文件夹中有 py 文件，但是没有 <code>__init__.py</code> 文件，命名空间包会被自动创建。</p><p>为了更理解命名空间包，我们直接实现它。</p><p>考虑一个需求，要将歌曲的信息序列化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>song = Song(song_id=<span class="string">&quot;1&quot;</span>, title=<span class="string">&quot;The Same River&quot;</span>, artist=<span class="string">&quot;Riverside&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>song.serialize()</span><br><span class="line"><span class="string">&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;title&quot;: &quot;The Same River&quot;, &quot;artist&quot;: &quot;Riverside&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在已经有第三方社区为你实现了一部分工作。</p><p>对于 <code>song.serialize()</code>，它接收一个序列化对象，这个序列化对象有基于 json 实现的，有基于 xml 实现的，可能内部实现代码不一样，但暴露的方法名一样，你可以在 <code>song.serialize()</code> 中自动处理。</p><p>这两个序列化对象，分别放在不同文件实现，文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">third_party/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    ├── json.py</span><br><span class="line">    └── xml.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前看起来不错，这时候你可能想再加一个自己的 yaml 的序列化方法，同样的创建目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local/</span><br><span class="line">│</span><br><span class="line">└── serializers/</span><br><span class="line">    └── yaml.py</span><br></pre></td></tr></table></figure><p>这里虽然代码在不同的目录，但是对于 <code>serializers</code> 来说，在这2个目录里，都有着共同的命名空间。</p><p>所以你可以直接这样导入全部的序列化对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">&quot;third_party&quot;</span>, <span class="string">&quot;local&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> serializers <span class="keyword">import</span> json, xml, yaml</span><br></pre></td></tr></table></figure><p>再举一例：</p><p>假设你有Python代码的两个不同的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo-package/</span><br><span class="line">    spam/</span><br><span class="line">        blah.py</span><br><span class="line"></span><br><span class="line">bar-package/</span><br><span class="line">    spam/</span><br><span class="line">        grok.py</span><br></pre></td></tr></table></figure><p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有 <code>__init__.py</code> 文件。</p><p>让我们看看，如果将 <code>foo-package</code> 和 <code>bar-package</code> 都加到python 模块路径并尝试导入会发生什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.extend([&#x27;foo-package&#x27;, &#x27;bar-package&#x27;])</span><br><span class="line">&gt;&gt;&gt; import spam.blah</span><br><span class="line">&gt;&gt;&gt; import spam.grok</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>两个不同的包目录被合并到一起，你可以导入 <code>spam.blah</code> 和<code>spam.grok</code>，并且它们能够工作。</p><p>在这里工作的机制被称为“包命名空间”的一个特征。</p><p>从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p><h1 id="导入包的风格规范">导入包的风格规范</h1><p>导入包不可以太随意，建议将标准包、第三方包、用户自定义包区分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Standard library imports</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Third party imports</span></span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader imports</span></span><br><span class="line"><span class="keyword">from</span> reader <span class="keyword">import</span> URL</span><br></pre></td></tr></table></figure><h1 id="如何导入数据资源">如何导入数据资源？</h1><p>有时候你的包需要依赖一些数据，如果你想要将这些数据也一起打包分发给你的用户，可能会有一些问题：</p><ul><li>数据文件的路径不确定，这取决于用户的配置，包如何分发的，以及安装在哪里</li><li>你的数据文件可能在压缩文件或者 <code>.egg</code> 文件中无法直接使用</li></ul><p>历史上有过一些对数据资源的解决方案，包括 <a href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html"><code>setuptools.pkg_resources</code></a>，不过现在在 python3.7 中，有了官方的标准库来解决这个问题，那就是 <code>importlib.resources</code>，对于之前的版本，则需要使用 <code>importlib_resources</code></p><blockquote><p>命名空间包不支持 importlib.resources</p></blockquote><p>假设你有一个数据文件是关于书籍的，你的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">books/</span><br><span class="line">│</span><br><span class="line">├── __init__.py  # 空文件，构造包所用</span><br><span class="line">├── alice_in_wonderland.png</span><br><span class="line">└── alice_in_wonderland.txt</span><br></pre></td></tr></table></figure><p>如果需要这两个文件，只需要按如下代码操作即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="comment"># 文本文件, books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_text(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.txt&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    alice = fid.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制文件，books 为目录名</span></span><br><span class="line"><span class="keyword">with</span> resources.open_binary(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;alice_in_wonderland.png&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    cover = fid.read()</span><br></pre></td></tr></table></figure><p>如果是较老的版本，可以在 import 的时候换成支持的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><p>再来一个例子，你现在需要将你的程序添加一个 logo，你的包目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello_gui/</span><br><span class="line">│</span><br><span class="line">├── gui_resources/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── hand.png</span><br><span class="line">│   └── logo.png</span><br><span class="line">│</span><br><span class="line">└── __main__.py</span><br></pre></td></tr></table></figure><p>下面的代码显示了你应该如何引用你的 logo 文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">with</span> resources.path(<span class="string">&quot;hello_gui.gui_resources&quot;</span>, <span class="string">&quot;logo.png&quot;</span>) <span class="keyword">as</span> path:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># or do you work</span></span><br></pre></td></tr></table></figure><h1 id="使用动态导入">使用动态导入</h1><p>Python 是一门动态语言（尽管这有时候也算是缺点），这意味着你可以在 python 程序运行的时候，增加类的属性，修改函数的定义、模块的 docstring，甚至你可以修改 <code>print()</code> 函数让它什么都不输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello dynamic world!&quot;</span>)</span><br><span class="line">Hello dynamic world!</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Redefine the built-in print()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> = <span class="keyword">lambda</span> *args, **kwargs: <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hush, everybody!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Nothing is printed</span></span><br></pre></td></tr></table></figure><p>所以你也可以动态的导入一个包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docreader.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">module_name = <span class="built_in">input</span>(<span class="string">&quot;Name of module? &quot;</span>)</span><br><span class="line">module = importlib.import_module(module_name)</span><br><span class="line"><span class="built_in">print</span>(module.__doc__)</span><br></pre></td></tr></table></figure><h1 id="深入python-的导入系统">深入Python 的导入系统</h1><p>当你执行导入操作时候，背后主要发生了三件事：</p><ol type="1"><li>搜索</li><li>加载</li><li>绑定到命名空间</li></ol><p><code>import</code> 命令执行的时候，这三步会自动完成，而<code>importlib</code> 只会完成前两步。</p><p>有一点需要注意的是，即便你只导入了某个包中的一个属性，整个模块也会被导入，只是其余的部分没有绑定到当前命名空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[<span class="string">&quot;math&quot;</span>].cos(pi)</span><br><span class="line">-<span class="number">1.0</span></span><br></pre></td></tr></table></figure><p><code>sys.modules</code> 相当于系统对导入模块的缓存。当 python 在执行导入的时候，会先去缓存中查找，如果存在了，则不会执行导入。</p><h2 id="只导入一次">只导入一次</h2><p>你的包中有一些方法，它依赖一些数据，这些数据需要从磁盘或者网络读取，你的类在初始化的时候，可能会刷新这些数据，但如果每次初始化就刷新数据，会导致大量时间花在磁盘或网络IO上，可以设计一个单例模式来解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Population</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Prepare to read the population file&quot;&quot;&quot;</span></span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line">        self.variant = <span class="string">&quot;Medium&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment"># 创建只读属性的装饰器，名字不变，调用无需加括号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Read data from disk&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._data:  <span class="comment"># 已存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件，保存到 self._data</span></span><br><span class="line">        <span class="keyword">with</span> resources.open_text(</span><br><span class="line">            <span class="string">&quot;data&quot;</span>, <span class="string">&quot;WPP2019_TotalPopulationBySex.csv&quot;</span></span><br><span class="line">        ) <span class="keyword">as</span> fid:</span><br><span class="line">            <span class="comment"># Read data, filter the correct variant</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>property</code> 参考 <a href="https://www.tianqiweiqi.com/python-property.html">Python内置属性函数@property详解</a></p></blockquote><h2 id="刷新要导入的包">刷新要导入的包</h2><p>当模块属性或者方法有更新，可以使用 <code>importlib</code> 重载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importlib.reload(module_name)</span><br></pre></td></tr></table></figure><h2 id="理解导入顺序">理解导入顺序</h2><p>如果你的模块名字和标准库中的一样，系统会优先使用标准库的。</p><p><code>import</code> 执行时有几步：</p><ol type="1"><li>检查模块缓存，<code>sys.modules</code></li><li>通过查找器查找模块</li><li>通过加载器加载模块</li></ol><p>你可以继承 python 的查找器实现你自己的 finder，甚至是自己的 loader，当然可能目前没有必要。</p><p>这里想说明的是，导入操作是有顺序的，在执行查找操作时， <code>sys.meta_path</code> 会控制哪个查找器会被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">FrozenImporter</span>&#x27;&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib_external</span>.<span class="title">PathFinder</span>&#x27;&gt;]</span></span><br></pre></td></tr></table></figure><p>这里可以看到，内置的模块先于自定义的被加载。</p><p>如果你把当前环境下所有查找器移除，python 就无法查找任何包了，但 python 仍然可以导入一些包，因为有些包已经位于缓冲中了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.meta_path</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;math&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib  <span class="comment"># Autoimported at start-up, still in the module cache</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib</span><br><span class="line">&lt;module <span class="string">&#x27;importlib&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;.../python/lib/python3.8/importlib/__init__.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>咱们自定义一下系统的查找器，让它在查找的时候打印，这样我们就知道了当我导入一个包，有哪些包导入了。</p><p>对于查找器，有一个要求就是它必须要实现 <code>.find_spec()</code> 这个类方法，这个方法会尝试去查找模块，如果它不知道怎么查，它应该返回 None，如果知道，则返回 <code>nodule spec</code>, 如果模块无法找到，则发起 <code>ModuleNotFoundError</code> 错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debug_importer.py</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DebugFinder</span>:</span></span><br><span class="line"><span class="meta">     @classmethod  </span><span class="comment"># 类方法，无需示例即可使用</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">f&quot;Importing <span class="subst">&#123;name!r&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">sys.meta_path.insert(<span class="number">0</span>, DebugFinder)</span><br></pre></td></tr></table></figure><p>上面的查找器打印后，返回 None, 表示它不知道怎么查，随后会交给其他查找器查。</p><p>你可以按需要自定义 <code>sys.meta_path</code> 的加载顺序。</p><p>将这个自定义查找器，放在 <code>sys.meta_path</code> 第一位，每次执行 <code>import</code> 你就可以看到所有被导入的模块。</p><p>通过这种自定义查找的方法，我们甚至可以写一个自动安装包的查找器，把它插到 <code>sys.meta_path</code> 末尾，因为如果在末尾的位置被执行，这意味着前面的查找器都没有找到你想要的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip_importer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipFinder</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Module <span class="subst">&#123;name!r&#125;</span> not installed.  Attempting to pip install&quot;</span>)</span><br><span class="line">        cmd = <span class="string">f&quot;<span class="subst">&#123;sys.executable&#125;</span> -m pip install <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subprocess.run(cmd.split(), check=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> util.find_spec(name)</span><br><span class="line"></span><br><span class="line">sys.meta_path.append(PipFinder)</span><br></pre></td></tr></table></figure><blockquote><p>只是随便一说，不要放到自己项目中用！可能会带来灾难性后果</p></blockquote><h2 id="例子-数据文件导入">例子: 数据文件导入</h2><p>这个例子灵感的来源是 Aleksey Bilogur, 他有一篇文章(<a href="https://blog.quiltdata.com/import-almost-anything-in-python-an-intro-to-module-loaders-and-finders-f5e7b15cda47">Import Almost Anything in Python: An Intro to Module Loaders and Finders</a>)，介绍了模块的加载器和查找器。</p><p>你可能实现过自定义的加载器加载数据文件，但能不能利用加载器和查找器直接 <code>import</code> csv 文件呢？就好像下面这个代码一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv_importer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> employees</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.name  <span class="comment"># 直接访问列名</span></span><br><span class="line">(<span class="string">&#x27;John Smith&#x27;</span>, <span class="string">&#x27;Erica Meyers&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> employees.data:  <span class="comment"># 直接访问数据</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row[<span class="string">&quot;department&quot;</span>])</span><br><span class="line">...</span><br><span class="line">Accounting</span><br><span class="line">IT</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>employees.__file__  <span class="comment"># 访问文件名</span></span><br><span class="line"><span class="string">&#x27;employees.csv&#x27;</span></span><br></pre></td></tr></table></figure><p>其实是可以的，我们可以将路径传给查找器处理路径的问题，然后通过加载器读取数据文件，最终实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> ModuleSpec</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CsvImporter</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, csv_path</span>):</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod  </span><span class="comment"># 类方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_spec</span>(<span class="params">cls, name, path, target=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 处理路径</span></span><br><span class="line">    <span class="comment"># 其他操作</span></span><br><span class="line"><span class="keyword">return</span> ModuleSpec(name, cls(csv_path))  <span class="comment"># 此处 cls() 构造一个类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_module</span>(<span class="params">self, module</span>):</span></span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line"><span class="comment"># 绑定到模块中</span></span><br><span class="line">module.__dict__.update(fields)</span><br><span class="line">        module.__dict__[<span class="string">&quot;data&quot;</span>] = data</span><br><span class="line">        module.__dict__[<span class="string">&quot;fieldnames&quot;</span>] = fieldnames</span><br><span class="line">        module.__file__ = <span class="built_in">str</span>(self.csv_path)</span><br></pre></td></tr></table></figure><h1 id="其他导入技巧">其他导入技巧</h1><h2 id="导入特定版本">导入特定版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="keyword">from</span> importlib <span class="keyword">import</span> resources</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> importlib_resources <span class="keyword">as</span> resources</span><br></pre></td></tr></table></figure><h2 id="有条件导入你喜欢的包">有条件导入你喜欢的包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> ujson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line">   </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> quicktions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br></pre></td></tr></table></figure><h2 id="处理包的缺失">处理包的缺失</h2><p>你可能有一些比较酷的想法，比如利用 <a href="https://pypi.org/project/colorama/">Colorama</a> 这个包来给你的输出增加一些颜色，但是这个包并不是一个必要的，如果用户电脑上有这个包，那可以，要是没有你希望也可以正常使用你的程序。</p><p>你可以参考 <a href="https://realpython.com/python-testing/">testing</a> 中对于 <a href="https://realpython.com/python-mock-library/">mocks</a> 的使用实现这个想法。</p><h2 id="将脚本导入为模块">将脚本导入为模块</h2><p>脚本和模块的区别在于，脚本主要是去 do_something, 而模块则提供函数以供使用。他们都存在于 python 文件中，就 Python 而言，其实它们并没有什么区别。</p><blockquote><p>有时候你的模块可能比较复杂，有脚本也有模块，这时候可以考虑<a href="https://realpython.com/python-refactoring/">refactor</a>你的模块。</p></blockquote><p>但你也可以让你的模块提供两者的功能，既有函数，也可以直接执行，相信你看到过这种 python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="从-zip-文件启动脚本">从 ZIP 文件启动脚本</h2><p>新建一个 <code>__main__.py</code> 文件，打包成压缩包，你便可以直接通过 <code>python zip_file_name.zip</code> 这种形式运行。</p><p>你可以将你自己的包也按照这种方式处理，但 python 有提供了一个工具 <a href="https://docs.python.org/library/zipapp.html"><code>zipapp</code></a>，它可以帮你处理这些事情。</p><p>你只需要在你的包目录执行 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m zipapp population_quiz -m population_quiz:main</span><br></pre></td></tr></table></figure><p>它会做两件事，一是为你的程序添加入口，二是打包你的程序。</p><p>这里的 <code>__main__.py</code> 会自动生成，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> population_quiz</span><br><span class="line">population_quiz.main()</span><br></pre></td></tr></table></figure><p>上面的命令执行后，会产生 <code>.pyz</code> 的打包文件，在 windows 上应该可以直接执行，因为 <code>.pyz</code> 文件应该自动关联了运行程序，而在 Linux 或者 Mac 上，可以通过 -p 指定运行环境:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m zipapp population_quiz -m population_quiz:main \</span><br><span class="line">&gt;   -p <span class="string">&quot;/usr/bin/env python&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意在 zip 文件中，如果处理数据文件，open 方法会无法使用</p></blockquote><h2 id="处理循环导入">处理循环导入</h2><p>循环导入就是你中有我我中有你，比如</p><p><img src="https://i.loli.net/2021/09/21/V4rsyDKYe312CT7.png" /></p><p>这种情况本会发生无限递归循环，但是因为我们的老朋友模块缓存所以避免了惨剧的发生。</p><p>但是在下面这种情况，则会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yin.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yin&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yang</span><br><span class="line">number = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yang.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># yang.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello from yang&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> yin</span><br><span class="line">number = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>():</span></span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;yin and yang combined is <span class="subst">&#123;combine()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Goodbye from yang&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行 <code>import yin</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yin <span class="comment">#导入 yin 的时候，yin 中的 number 没有还没有定义</span></span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">  File <span class="string">&quot;.../yang.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> combine</span><br><span class="line">    <span class="keyword">return</span> number + yin.number</span><br><span class="line">AttributeError: module <span class="string">&#x27;yin&#x27;</span> has no attribute <span class="string">&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure><p>执行 <code>import yang</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> yang  <span class="comment">#yang 调用 combine() 的时候，yin 已经初始化完成</span></span><br><span class="line">Hello <span class="keyword">from</span> yang</span><br><span class="line">Hello <span class="keyword">from</span> yin</span><br><span class="line">Goodbye <span class="keyword">from</span> yin</span><br><span class="line">yin <span class="keyword">and</span> yang combined <span class="keyword">is</span> <span class="number">66</span></span><br><span class="line">Goodbye <span class="keyword">from</span> yang</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢？其实你的模块如果有存在互相引用，这意味着你的模块设计的不好，你需要想想怎么去组织你的代码。</p><h2 id="优化你的导入速度">优化你的导入速度</h2><p>你可能有些包导入的速度很慢，你想了解具体是在哪里速度变慢，自从 Python3.7 你可以有一个非常简单的办法了解你导入包的速度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python -X importtime -c <span class="string">&quot;import datetime&quot;</span></span><br><span class="line">import time: self [us] | cumulative | imported package</span><br><span class="line">...</span><br><span class="line">import time:        87 |         87 |   time</span><br><span class="line">import time:       180 |        180 |   math</span><br><span class="line">import time:       234 |        234 |   _datetime</span><br><span class="line">import time:       820 |       1320 | datetime</span><br></pre></td></tr></table></figure><p>cumulative 列按包显示了导入的累计时间（以微秒为单位）。</p><h1 id="总结">总结</h1><p>这篇文章主要介绍了：</p><ul><li>命名空间包</li><li>导入资源和数据文件</li><li>使用动态导入</li><li>扩展 Python 的导入机制</li><li>处理不同版本的包</li></ul><p>这里还有一些优秀的参考信息：</p><ul><li><a href="https://docs.python.org/reference/import.html">The import system</a></li><li><a href="https://docs.python.org/library/importlib.html">The <code>importlib</code> package</a></li><li><a href="https://www.python.org/dev/peps/pep-0420/">PEP 420: Implicit namespace packages</a></li><li><a href="https://docs.python.org/library/modules.html">Importing modules</a></li></ul><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-import/#basic-python-import">Python import: Advanced Techniques and Tips</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p05_separate_directories_import_by_namespace.html">利用命名空间导入目录分散的代码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章深入研究了 &lt;code&gt;import&lt;/code&gt; 命令以及它的工作原理。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="https://scottzhang.pro/categories/python/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 模块与包</title>
    <link href="https://scottzhang.pro/article/c8bc6f6.html"/>
    <id>https://scottzhang.pro/article/c8bc6f6.html</id>
    <published>2021-09-18T09:59:07.000Z</published>
    <updated>2021-11-27T08:36:33.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章会介绍 Python 中的模块和包。</p></blockquote><span id="more"></span><h1 id="python---模块与包">Python - 模块与包</h1><p>引申出模块化编程的概念，即将代码分解成小模块，各自解决不同的问题，这样使得代码更简单 (<strong>Simplicity</strong>)，容易维护 (<strong>Maintainability</strong>)，也更容易分享、重用代码 (<strong>Reusability</strong>)。</p><p>Python 中的模块主要有三种：</p><ol type="1"><li>用Python写的模块</li><li>用C 写的模块</li><li>内置的模块如 <code>itertools</code> 模块</li></ol><p>这篇文章只关注 Python 写的模块。</p><h1 id="模块的搜索路径">模块的搜索路径</h1><p>假设你写了个模块 <code>mod.py</code> , 怎么使用呢？</p><p>如果你当前工作目录在合适的位置，你可以执行 <code>import mod</code>, 然后你便可以引用其中的对象，那什么叫合适的位置？</p><ol type="1"><li>与 <code>mod.py</code> 同一位置</li><li>你的模块位置被包含在 <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> 中</li><li>模块位置在安装 Python 时标准链接库目录是定义过</li><li>你创建了一个 <code>.pth</code> 文件告诉 Python 去哪里找，此模块位于其中</li></ol><p>上面四种情况，只有 <code>PYTHONPATH</code> 环境变量和路径文件可以被用户配置。</p><p>Python 会自动去寻找这些地方是否有你需要的包，你可以通过 <code>sys.path</code> 查看它的搜索顺序。</p><p>所以还有一种方法导入包，即将你的包地址放入 <code>sys.path</code>，它是一个列表，所以你可以执行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">r&#x27;C:\Users\john&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> mod</span><br></pre></td></tr></table></figure><p>当模块被导入后，你也可以通过 <code>mod.__file__</code> 查看包的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Users\\john\\mod.py&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.__file__</span><br><span class="line"><span class="string">&#x27;C:\\Python36\\lib\\re.py&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="导入模块">导入模块</h1><p>模块的存在是为了被导入 <code>import</code> 以使用, 就像钢琴的存在是被人演奏以产生音乐。</p><h2 id="import-module_name">import module_name</h2><p><code>import</code> 上面已有例子，需注意 <code>import</code> 不能让你直接使用所有模块内的内容。模块有其私有符号表 (<strong>private symbol table</strong>), 模块以此来确定各自之间的边界。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zoo</span><br><span class="line"><span class="built_in">print</span>(zoo.dog)  <span class="comment"># yes</span></span><br><span class="line"><span class="built_in">print</span>(dog)  <span class="comment"># no, dog 位于 zoo 中</span></span><br></pre></td></tr></table></figure><h2 id="from-module_name-import-name">from module_name import name</h2><p>另一种导入模块的方式是直接导入模块内的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module_name&gt; <span class="keyword">import</span> &lt;name(s)&gt;</span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> dog, pig  <span class="comment"># 只需要特定对象</span></span><br><span class="line"><span class="keyword">from</span> zoo <span class="keyword">import</span> *  <span class="comment"># 需要所有对象</span></span><br></pre></td></tr></table></figure><p>需要小心 <code>from &lt;module_name&gt; import *</code> 这种方式，除非你很清楚自己在做什么。</p><h2 id="from-module_name-import-name-as-alt_name">from module_name import name as alt_name</h2><p>这种方式和上面的一样，只是多了 <code>as</code> 关键字以定义别名。</p><h2 id="导入提示">导入提示</h2><p>导入模块的语句通常写在文件首部，但也可以写在函数中，不过 Python3 不允许在函数中 <code>import *</code>。</p><p>防止模块导入失败，可以使用 <code>try...except...</code> 语句捕捉 <code>ImportError</code>错误。</p><p><code>dir()</code> 函数可以返回当前命名空间中所有的变量。</p><p>导入模块的时候，模块的代码将会执行，如果希望模块内的某些代码只是在你需要的时候才调用执行，可以加入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__name__ == <span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line"><span class="keyword">pass</span>  <span class="comment"># do you work</span></span><br></pre></td></tr></table></figure><p>导入模块的操作只会执行一次，考虑以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.a</span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br></pre></td></tr></table></figure><p>发现第二次和第三次导入并未输出，如果想要每次导入操作都重新导入，可利用 <code>importlib</code> 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mod</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>importlib.reload(mod)</span><br><span class="line">a = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">&lt;module <span class="string">&#x27;mod&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\Users\\john\\Documents\\Python\\doc\\mod.py&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>模块可以被当作脚本执行，只需要在模块所在文件夹增加一个 <code>__main__.py</code> 文件。</p><h1 id="python-包">Python 包</h1><p>包是一组或多组模块，包可以让你通过包的名字简单的访问其下面的各种模块。</p><p>下面是一个包的结构，其中有两个模块。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br></pre></td></tr></table></figure> 这时候如果你在 <code>pkg</code> 上级目录执行 <code>import pkg</code> 该包里将不会包括任何东西，无法引用 mod1 也无法引用 mod2 中的内容。</p><h2 id="init__.py"><code>__init__.py</code></h2><p>如果在 pkg 目录下新增 <code>__init__.py</code> 文件，则可以引用 <code>__init__</code>中的的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">mod1.py</span><br><span class="line">mod2.py</span><br><span class="line">__init__.py</span><br></pre></td></tr></table></figure><p>在内部 mod1 模块中，你也可以访问<code>__init__</code> 中的对象。</p><p>如果想在外部通过 <code>import pkg</code> 的方式，通过 <code>pkg</code> 访问 <code>mod1</code> 或 <code>mod2</code> 中的对象，则需要在 <code>__init__</code> 中导入 <code>mod1</code> 和 <code>mod2</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In __init__.py</span></span><br><span class="line"><span class="keyword">import</span> pkg.mod1, pkg.mod2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 Mod1 和 Mod2</span></span><br><span class="line"><span class="keyword">import</span> pkg</span><br><span class="line"></span><br><span class="line">pkg.mod1.foo()</span><br><span class="line"></span><br><span class="line">pkg.mod2.bar()</span><br></pre></td></tr></table></figure><blockquote><p>在 Python3.3 之后，<a href="https://www.python.org/dev/peps/pep-0420/">Implicit Namespace Packages</a> 发布了，定义包也可以不新建 <code>__init__</code> 了。</p></blockquote><h2 id="all__"><code>__all__</code></h2><p>你肯定写过 <code>from &lt;package_name&gt; import *</code> 这样的代码，其中 * 代表的是 import 什么？</p><p>如果在包的 <code>__init__.py</code> 中定义 <code>__all__</code> 来进行控制。</p><p><em><strong>pkg/__init__.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [</span><br><span class="line">        <span class="string">&#x27;mod1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mod4&#x27;</span></span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>则所有其中的内容都会在写 <code>from pkg import *</code> 的时候，自动导入。</p><p>在模块中定义 <code>__all__</code> 亦是。</p><p><em><strong>pkg/mod1.py</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"><span class="comment"># 当使用 `from pkg.mod1 import *` 的时候，只有 foo 会被导入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod1] foo()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>区别是：</p><ul><li>对于一个包，如果<code>__all__</code> 没有定义，<code>import *</code> 不会导入任何对象</li><li>对于一个模块，如果<code>__all__</code> 没有定义，<code>import *</code> 默认导入所有对象</li></ul><h1 id="python-子包">Python 子包</h1><p>包中可以放子包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─pkg</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg1</span><br><span class="line">    │      mod1.py</span><br><span class="line">    │      mod2.py</span><br><span class="line">    │</span><br><span class="line">    ├─sub_pkg2</span><br><span class="line">    │      mod3.py</span><br><span class="line">    │      mod4.py</span><br></pre></td></tr></table></figure><p>使用方式则需要一层一层使用 <code>.</code> 语法下钻:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg.sub_pkg1.mod1</span><br><span class="line">pkg.sub_pkg1.mod1.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1 <span class="keyword">import</span> mod2</span><br><span class="line">mod2.bar()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod3 <span class="keyword">import</span> baz</span><br><span class="line">baz()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg2.mod4 <span class="keyword">import</span> qux <span class="keyword">as</span> grault</span><br><span class="line">grault()</span><br></pre></td></tr></table></figure><p>如果是兄弟模块之间要导入模块怎么办？有两种方式：</p><p>全路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg.sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>相对路径: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baz</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[mod3] baz()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> sub_pkg1</span><br><span class="line"><span class="built_in">print</span>(sub_pkg1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..sub_pkg1.mod1 <span class="keyword">import</span> foo</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://realpython.com/python-modules-packages/">Real Python - Python Modules and Packages – An Introduction</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章会介绍 Python 中的模块和包。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="https://scottzhang.pro/categories/python/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 与 Go 开发环境配置</title>
    <link href="https://scottzhang.pro/article/dfea7f59.html"/>
    <id>https://scottzhang.pro/article/dfea7f59.html</id>
    <published>2021-09-14T04:50:03.000Z</published>
    <updated>2021-11-27T08:34:21.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。</p></blockquote><span id="more"></span><h1 id="centos-7-开发环境配置">CentOS 7 开发环境配置</h1><h2 id="git">Git</h2><blockquote><p>略过。</p></blockquote><h2 id="docker">Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 docker 进程</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 docker 阿里云镜像，容器镜像服务</span></span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://8szzfxmd.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 docker-compose</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html">如何检查进程？</a></p></blockquote><h2 id="mysql">Mysql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 mysql</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 mysql</span></span><br><span class="line">docker run -p 3306:3306 --name mymysql -v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d -V <span class="variable">$PWD</span>/logs:logs -v <span class="variable">$PWD</span>/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234@Abc -d mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 docker 的容器</span></span><br><span class="line">docker ps -a (ps: Process Status, from linux)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 mysql 容器并启动 bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -it a7a8e9df1270 /bin/bash</span><br><span class="line">myql -uroot -pyoupassword</span><br></pre></td></tr></table></figure><h2 id="python">Python</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anaconda in centos7</span></span><br><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh</span><br><span class="line">bash naconda3-5.3.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://linuxize.com/post/how-to-install-anaconda-on-centos-7/">Install &amp; uninstall Anaconda on centos7</a></p></blockquote><h2 id="go">Go</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go 环境变量</span></span><br><span class="line">go env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 go module</span></span><br><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello golang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行运行 </span></span><br><span class="line"><span class="keyword">go</span> run .\hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译文件, c/c++ -&gt; .so .lib .dll; java -&gt; .class; go -&gt; windows exe</span></span><br><span class="line"><span class="keyword">go</span> build .\hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;简要记录我的 Git, Docker, Mysql, Python, Go 开发环境配置。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="项目记录" scheme="https://scottzhang.pro/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="https://scottzhang.pro/tags/python/"/>
    
    <category term="go" scheme="https://scottzhang.pro/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库-维度建模</title>
    <link href="https://scottzhang.pro/article/c721127b.html"/>
    <id>https://scottzhang.pro/article/c721127b.html</id>
    <published>2021-09-14T03:39:28.000Z</published>
    <updated>2021-11-27T08:44:53.725Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据仓库、商业智能初步，常用维度建模架构对比。</p></blockquote><span id="more"></span><h1 id="业务管理的问题">业务管理的问题</h1><p>信息系统存在的目的是解决业务的问题，对于数据仓库 Data WareHouse 和商业智能 Business Intelligence 来说，下面这些问题已经存在了几十年了：</p><ul><li>收集了很多数据却无法访问</li><li>需要对数据做切片、切块</li><li>分析师、业务人员需要方便的获取数据</li><li>怎么展示最重要的事情</li><li>花费大量时间在研究数字的正确性，而不是业务决策</li><li>希望使用信息做更多基于事实的决策</li></ul><p>这些问题对应了数据仓库与商业智能的目标，解决这些业务问题，信息系统必须做到：</p><ul><li>方便的存取信息</li><li>一致性的形式展示信息</li><li>能够适应变化</li><li>及时的展示信息</li><li>保护信息财富</li><li>成为提高决策制定能力的权威</li><li>业务群体的认可</li></ul><p>作为一个 DW/BI 管理者，你的责任则更具体：</p><ol type="1"><li>理解业务用户</li><li>对业务用户发布高质量、相关的、可访问的信息和分析</li><li>维护 DW/BI 环境</li></ol><h1 id="维度建模">维度建模</h1><blockquote><p>爱因斯坦曾说: <strong>凡事应该尽量简单，直到不能再简单为止</strong>。</p></blockquote><p>维度建模是展示分析数据的首选技术，它的优势在于能以商业用户可理解的方式发布数据并提供了高效的查询性能。它最初是用来简化数据库的，在维度建模中最开始使用的数据模型通常越简单越好，复杂的开始会导致最终的模型也很复杂。</p><p>维度模型通常建立在关系型数据库上，但这不意味着维度模型必须满足关系型数据库的要求，比如第三范式（3NF）。</p><p>3NF 是为了减少数据冗余，它会将数据划分成不同的实体，每个实体构成一个关系表。</p><p>但 3NF 不适用于 BI，主要是其模式太复杂，3NF 主要应用在操作性过程中，而不是 BI 查询，维度建模可以解决模式过分复杂的问题。</p><p>维度建模在不同的数据库系统中有不同的叫法：</p><ul><li>关系数据库 -&gt; 星型模式</li><li>多维数据库 -&gt; 联机分析处理</li></ul><h2 id="事实表与维度表">事实表与维度表</h2><p>在维度建模中，存在两类表：</p><ul><li>事实表（数量，销售额，需注意可加性和不可加性，比如账户结余不可加）</li><li>维度表（谁、什么、哪里、何时、如何、为什么）</li></ul><p>事实表中一条记录所表达的业务细节程度被称为<strong>粒度</strong>。通常粒度可以通过两种方式来表述：一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。</p><p>事实表的粒度有三类：事务周期快照累快照，个。 事实表通常只有很少的列和很多行，是一种<strong>“瘦高”</strong>型的表。事实表定义为以下三种类型之一：</p><ul><li>事务事实表:记录有关特定事件的事实（例如，销售事件，保存在原子的粒度，也称为原子事实表）</li><li>周期快照事实表记录给定时间点的事实（例如，月末的帐户详细信息）</li><li>累积快照事实表记录了给定时间点的汇总事实（例如，某产品的当月迄今总销售额）</li></ul><p>作为度量业务过程的事实，一般为整型或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完全不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚集。</p><p>一般事实表具有两个或更多外键与维度表关联，比如事实表中的产品键始终与产品维度中的特定产品键匹配。如果事实表中所有键与维度表中的都匹配，则满足了 <code>参照完整性</code>, 可以通过维度表使用连接操作访问事实表。</p><figure><img src="https://i.loli.net/2021/09/14/1GKmvWe2dBNwols.jpg" alt="事实表与维度表" /><figcaption aria-hidden="true">事实表与维度表</figcaption></figure><p>事实表通常包含外键集合的主键，具有组合键的表即事实表，事实表通常具有多对多的关系。</p><p>维度是维度建模的基础和灵魂。在维度建模中，将度量称为<strong>事实</strong>，将环境描述为<strong>维度</strong>，维度是用于分析事实所需要的多样环境。</p><p>维度表通常有很多列、属性，维度表倾向于包含少量的行，一般用维度表来作为查询的约束、分组。</p><p>多数情况下，数据仓库的好坏直接取决于维度属性的设置，也决定了 DW/BI 的分析能力，强大的维度属性等于健壮的分片、分块分析能力。</p><p>对维度表的设计重点关注简单性和可访问性，可以不满足第三范式。</p><h1 id="kimball-的-dwbi-架构">Kimball 的 DW/BI 架构</h1><figure><img src="https://i.loli.net/2021/09/14/9LHTwZXSxevy48a.png" alt="Kimball 架构" /><figcaption aria-hidden="true">Kimball 架构</figcaption></figure><h2 id="操作型源系统">操作型源系统</h2><p>该系统面对很多用户，并发事务很多。多是插入、更新操作。对数据的插入，更新性能要求更高，因此数据多是规范化的，规范化是指冗余度比较少。</p><h2 id="etl-系统">ETL 系统</h2><p>处理操作型源系统与DW/BI 之间，该系统对数据的处理分为三个部分：</p><ol type="1"><li>获取 Extract，从操作型系统导入到 DW/BI</li><li>转换 Transformation，清洗，合并，复制等</li><li>加载 Load，构建和加载数据到<code>展现区域</code>的目标维度模型</li></ol><p>展现区域用于组织、存储，用户也可以在这里制作报表，查询，这是用户主要关注的区域，关于展现区，该书作者有两点建议：</p><ol type="1"><li>数据应该以维度模型来展现（星型或OLAP多维数据库）</li><li>必须包含到最详细的原子数据级别</li></ol><h2 id="bi-应用">BI 应用</h2><p>这是最后一个主要的部件，BI 突出的是支持商业决策的能力，它可以很简单，也可以很复杂。</p><h1 id="其他-dwbi-架构">其他 DW/BI 架构</h1><p>第一种是独立数据集市，特点是以部门为架构组织，只考虑本部门的需要与业务规则，但不同部门之间的数据访问与标准各异，很多数值无法匹配。</p><p>这种架构代表了一种 DW/BI 架构，但其实属于没有结构，容易造成混乱。虽然可以低成本实现快速开发，但会存在分析数据冗余的问题，不是长远之计。</p><figure><img src="https://i.loli.net/2021/09/14/XUFEgK8xyf6VS4L.jpg" alt="简化的独立数据集市" /><figcaption aria-hidden="true">简化的独立数据集市</figcaption></figure><p>第二种是辐射状企业信息工厂(Corporate Information Factory) Inmon 架构，它的数据从操作型数据库获取，经过 ETL 会保存在满足第三范式的数据库中，称为 EDW (Enterprise Data Warehouse).</p><p>EDW 中的数据都是规范化的，原子级别的，相当于有一个中间过程协调与集成数据，缺点是它的下游数据组织形式以部门为单位，且包含的是聚集数据，非原子级别的数据，而对业务用户暴露原子级别的数据是有必要的，<strong>聚集数据比原子数据提供了更好的性能，但不能取代细节数据</strong>。</p><figure><img src="https://i.loli.net/2021/09/14/bNcup7VxdTjy1If.jpg" alt="CIF" /><figcaption aria-hidden="true">CIF</figcaption></figure><p>最后还有一种混合了 CIF 与 Kimball 模式的架构，有人说这是最好的架构因为混合了前面的两种架构，但是这也意味着更多的开销与时间，无论是开发还是运行期间，因为数据需要更多次的移动，细节数据冗余存储。</p><p>如果你已经建立了第三范式的 EDW，但无法让用户更灵活的实现报表与分析，可以采用这种模式。</p><h1 id="维度建模的误解">维度建模的误解</h1><p>维度模型被广泛使用，但也还存在很多误解，如：</p><ul><li>它仅包含汇总数据</li><li>它是部门级的，不是企业级的</li><li>它不可扩展</li><li>它仅用于预测</li><li>它不能被集成</li></ul><p>实际上，维度模型可以存储大量历史数据，按照业务过程组织即可满足企业级的要求，事实表非常容易扩展，数据库提供商也在不断优化维度模型的可扩展性和性能。</p><p>维度模型对业务的适应性也很强，业务需求可能是经常变化的，但维度模型具有对称性，只要以最细粒度级别构建事实表，加上维度结构非常灵活，可以很好的满足业务需要。</p><blockquote><p>细节就是上帝。—— 建筑师 Mies van der Rohe</p></blockquote><h1 id="参考">参考</h1><ul><li><a href="https://jiamaoxiang.top/2020/07/11/数仓-大数据时代-维度建模过时了吗/">数仓-大数据时代-维度建模过时了吗?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据仓库、商业智能初步，常用维度建模架构对比。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据工程" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="数据仓库" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    <category term="商业智能" scheme="https://scottzhang.pro/tags/%E5%95%86%E4%B8%9A%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>B 树索引与位图索引简述</title>
    <link href="https://scottzhang.pro/article/a8fa00e8.html"/>
    <id>https://scottzhang.pro/article/a8fa00e8.html</id>
    <published>2021-09-09T13:04:16.000Z</published>
    <updated>2021-11-27T08:28:55.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。</p></blockquote><span id="more"></span><p>在 Oracle 中， 可以使用 <code>CREATE INDEX</code> 创建索引，索引的类型有以下几种：</p><ul><li><p>Normal indexes (Oracle Database 默认使用的 B-tree 索引)</p></li><li><p>Bitmap indexes (用一个bit位来标记某个元素 rowid 对应的Value)</p></li></ul><blockquote><p>Refer <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5010.htm">Oracle 官方文档</a></p></blockquote><h1 id="b-tree">B-tree</h1><p>B-tree 的出现主要是为了提高访问磁盘的速度。那为什么使用 B-tree 实现而不是其他的数据结构呢？</p><p>对于二叉搜索树，红黑树，avl 树来说，每一个节点只能存储一个 key，如果你需要存储大量的 key，使用这些数据结构就会让树变得很高，但 B-tree 在一个节点内就可以存储多个 key，且可以拥有多个子节点，这就可以降低树的高度，提高磁盘访问速度。</p><p>那一个节点内可以存储多少个 key，可以拥有多少个子节点呢？</p><p>假设用 k (取值范围M-M/2)表示，则 B-tree 中的每个节点可以有 k-1 个 key，以及 k 个子树。</p><p>所谓 M 阶（m-way）B树，其中 M 就是表示 B-tree 中每个节点最多可以有几个子树。</p><h1 id="b-tree-1">B+ tree</h1><p>B+ tree 是 B-tree 的升级版，一棵 B+ 树需要满足以下条件:</p><ol type="1"><li>节点的子树数和关键字(Key)数相同（B 树是关键字数比子树数少一）</li><li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li><li>叶子节点包含了全部数据，同时符合左小右大的顺序</li></ol><p>B+ 树数据都在叶子节点，并使用一个链表将它们排列起来，这样在查询时效率更快。</p><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。</p><h1 id="bitmap-索引">Bitmap 索引</h1><p>我们知道计算机所有信息最终都是通过“位bit”来运算的，二进制位运算在计算机中非常高效。而位图索引也是用0或1来处理索引进程，故得名位图索引。 位图索引主要针对大量相同值的列而创建的，索引块的一个索引行中存储键值、起止RowId及此键值的位图，根据位图信息可以得知每一条记录的ROWID。它为列的每个键值建立位图，位图中的每一位可能对应多个列，位图中位的值为1表示此行的值为对应的键值。</p><p>特点：</p><ul><li>可以存储null值；</li><li>不适合键值较多的列（重复数据较少的列）,适合只有几个固定值的列；如性别、婚姻状况、行政区等等</li><li>相对于B*Tree索引,占用的空间非常小,创建和使用非常快；</li><li>适合静态数据，而不适合索引频繁更新的列；</li><li>使用count、and、or或in查询时,直接用索引的位图进行或运算,快速得出结果行数据。</li></ul><h1 id="参考">参考</h1><ul><li><a href="https://juejin.cn/post/6844903613915987975">理解 B 树、B+ 树特点及使用场景</a></li><li><a href="https://www.programiz.com/dsa/b-tree">B-tree 介绍与代码实现</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-tree 动态交互图</a></li><li><a href="https://bbs.huaweicloud.com/blogs/114861">Oracle 索引概述</a></li><li><a href="http://tech.jasonsoso.com/2015/01/B-tree-indexes-and-bitmap-indexes/">B 树索引与位图索引简述</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章简述了索引相关的知识，强烈推荐阅读引用的参考文章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据库" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://scottzhang.pro/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>数据分析在做什么</title>
    <link href="https://scottzhang.pro/article/a31aaf3c.html"/>
    <id>https://scottzhang.pro/article/a31aaf3c.html</id>
    <published>2021-09-06T15:42:25.000Z</published>
    <updated>2021-11-27T08:43:13.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据分析即做比较。</p></blockquote><span id="more"></span><h1 id="数据分析在做什么">数据分析在做什么？</h1><p>数据分析本质上做对比，所以首先考虑的问题是和谁比，怎么比，比什么。 其次，分析对应的是分解问题，分析拆解后的复杂事物，得到拆解元素之间的联系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据分析 -&gt; 拆分、分解问题 -&gt; 比较</span><br></pre></td></tr></table></figure><p>数据的字段 (Field) 有各种类型，如：</p><ol type="1"><li>定类尺度（性别）</li><li>定序尺度（成绩优良中下）</li><li>定距尺度（30比20高10）</li><li>定比尺度（项目数，每月工时）</li></ol><p>同样，对于数据的属性也有好几种，如离散属性以及连续属性。离散属性中有频率与频数。连续属性则有：</p><ol type="1"><li>平均值</li><li>中位数、分位数</li><li>众数</li><li>方差、标准差、自由度</li><li>偏态系数</li><li>峰态系数</li></ol><h1 id="怎么比">怎么比</h1><p>首先来看怎么比的问题，简单的多少、长短也是比较，对于数据分析我们有如下几种常用的类型。</p><ol type="1"><li>假设检验，一致还是不一致</li><li>多维分析与钻取分析（Drill Down，Roll up）</li><li>交叉分析与透视表</li><li>秩次比较</li><li>相关分析</li><li>回归探索</li><li>自由分组与归类</li></ol><blockquote><p>这里说的是什么暂时不理解没关系，之后会单独拿出来讲。</p></blockquote><h2 id="一致还是不一致">一致还是不一致</h2><p>我们可以通过假设检验来回答一致还是不一致的问题，先解释假设检验中的两个单词: <code>H0</code> 和 <code>H1</code>。</p><ul><li><code>H0</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差是由自然误差引起的</li><li><code>H1</code> 表示，在我们比较的数据中（样本与总体或样本与样本）的偏差存在本质上的差别</li></ul><p>拒绝<code>H0</code> 的成立，就可以对数据的比较做出结论推断，通常需要确定最大概率，用 <span class="math inline">\(\alpha\)</span> 表示，常见的情况下取 0.05 或 0.01， 如果原假设发生的概率小于 <span class="math inline">\(\alpha\)</span> 则可以拒绝 <code>H0</code>。 为了拒绝原假设，需要进行检验，即检验统计量，检验统计量的方法有很多种，在不同的场景下对应着不同的检验方法，常见的检验方法及应用场景有：</p><ul><li>Z 检验， 样本均值是否与正态分布总体一致？</li><li>T 检验，样本平均数与整体平均数</li><li>F 检验，多组样本间的一致性比较</li><li>卡方检验， 两个分部是否一致的差异</li><li>秩和检验， 摆脱对总体分布的依赖，秩理解为名次</li><li>A/B Test，新功能衡量部分用户的表现，上不上？</li><li>低功效实验，P值</li></ul><p>需注意不同的检验方法的要求与统计量的计算方式不同，需要根据实际情况选择。</p><p>假设检验的结果也有可能是错的，主要有两类错误：</p><ul><li>第一类错误，是真实情况为 <em><code>H0</code></em> 成立，但判断结论为拒绝 <em><code>H0</code></em>， 也就是把真的当成了假的</li><li>第二类错误，是真实情况为 <em><code>H0</code></em> 不成立，但判断结果接受 <em><code>H0</code></em>，也就是把假的当成了真的</li></ul><p>在饱和的情况下，这两类的错误属于此消彼长的关系，当降低第一类错误发生概率时，第二类错误发生的概率会增加，反之亦然。</p><h2 id="假设检验公式">假设检验公式</h2><ul><li>Z检验, <span class="math inline">\(Z = \frac{(\bar{x}-\mu_0)}{s}\)</span> = <span class="math inline">\(\frac{(sample average-mean)}{standard\ deviation}\)</span></li></ul><h2 id="多维分析与钻取分析">多维分析与钻取分析</h2><p>多维分析的问题类似，调查北京有多少厨师？你需要列举所有可能的与厨师数量的属性，比如餐馆的数量、门店类型、分布规律等。</p><p>钻取分析的例子，假设某月，可乐的销量突然上涨，你想知道具体是在什么地区上涨（Contributing)。</p><p>多维分析是从多个角度、多个维度分析。钻取分析则是从维度变化的角度考虑，扩大或者缩小分析粒度。</p><p>多维分析可以在不同对象的相同维度下进行比较，也可以在相同对象的不同维度下，甚至是不同对象的不同维度，只要有业务支持。具体的方法可以比数值、也可以比占比。其精髓在于尽可能的罗列所有维度。</p><p>钻取分析需要注意其陷阱，因为<strong>下钻的层次越深，复合特征的样本越来越少，越少的样本代表着越高的风险，也会导致越不可靠的结论。</strong></p><p>其次钻取的顺序也需要注意，比如调查离职员工的规律，为什么先从部门开始钻取，而不是其他？这里需要有个标准，一般来说<strong>区分程度最大的下钻方式应该排在最前面</strong>，如何衡量这个区分度呢？这就属于决策树中的内容了。</p><p>另外一个钻取的陷阱是<a href="https://wiki.mbalib.com/wiki/辛普森悖论">辛普森悖论</a>， 这里不做多介绍，感兴趣的可以打开链接了解。</p><h2 id="交叉分析与透视表">交叉分析与透视表</h2><p>这部分如果会使用 Excel 的 Pivot Table，或者 Pandas 里的 <code>groupby</code>， <code>pivot</code> 或 <code>pivot_table</code> 方法就懂了，在此不做解释。</p><h2 id="秩次比较">秩次比较</h2><blockquote><p>未完待续...</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据分析即做比较。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析" scheme="https://scottzhang.pro/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据分析" scheme="https://scottzhang.pro/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
