<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"scottzhang.pro","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="关于 Linux 的设备文件系统、系统设备路径与设备名、udev, SCSI 等内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 是如何工作的-管理设备">
<meta property="og:url" content="https://scottzhang.pro/article/d7967d77.html">
<meta property="og:site_name" content="Scott&#39;s Blog">
<meta property="og:description" content="关于 Linux 的设备文件系统、系统设备路径与设备名、udev, SCSI 等内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/03/13/5Iuy2Kewt6jAJqX.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/17/hYZJzEHWNAUKQXp.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png">
<meta property="article:published_time" content="2022-03-20T15:11:55.000Z">
<meta property="article:modified_time" content="2022-03-20T15:13:42.225Z">
<meta property="article:author" content="Scott">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Operating System">
<meta property="article:tag" content="udev">
<meta property="article:tag" content="SCSI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/03/13/5Iuy2Kewt6jAJqX.png">

<link rel="canonical" href="https://scottzhang.pro/article/d7967d77.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux 是如何工作的-管理设备 | Scott's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Scott's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Scott's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学则不固, 知则不惑</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://scottzhang.pro/article/d7967d77.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/instagram_profile_image.png">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux 是如何工作的-管理设备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-20 23:11:55 / 修改时间：23:13:42" itemprop="dateCreated datePublished" datetime="2022-03-20T23:11:55+08:00">2022-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/How-Linux-Works/" itemprop="url" rel="index"><span itemprop="name">How Linux Works</span></a>
                </span>
            </span>

          
            <span id="/article/d7967d77.html" class="post-meta-item leancloud_visitors" data-flag-title="Linux 是如何工作的-管理设备" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/article/d7967d77.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/article/d7967d77.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>关于 Linux 的设备文件系统、系统设备路径与设备名、udev, SCSI 等内容。</p>
</blockquote>
<span id="more"></span>
<p>Linux 设备</p>
<h2 id="设备文件系统device-files">设备文件系统（Device files）</h2>
<p>操作系统负责帮我们管理设备，将其抽象成类似文件的形式放在磁盘上，所以当往设备中输出内容，就像我们往一个文件中写内容一样，这些设备文件存放于 <code>/dev</code> 中, 执行 <code>ls /dev</code> 可以看到这些设备。</p>
<p>Linux启动的时候，会动态的在/dev目录下创建好各种设备的设备文件节点（也就是说，系统启动后/dev目录下就有了各种设备的设备文件，直接就可使用了）。</p>
<p>除此之外，他还可以在设备卸载后自动的删除/dev下对应的设备文件节点（这对于一些热插拔设备很有用，插上的时候自动创建，拔掉的时候又自动删除）。</p>
<p>在我们编写设备驱动的时候，不必再去为设备指定主设备号，在设备注册时用0来动态的获取可用的主设备号，然后在驱动中来实现创建和销毁设备文件（一般在驱动模块加载和卸载函数中来实现）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">brw-rw----   1 root disk 8, 1 Sep  6 08:37 sda1</span><br><span class="line">crw-rw-rw-   1 root root 1, 3 Sep  6 08:37 null</span><br><span class="line">prw-r--r--   1 root root    0 Mar  3 19:17 fdata</span><br><span class="line">srw-rw-rw-   1 root root    0 Dec 18 07:43 log</span><br></pre></td></tr></table></figure>
<p>第一个字母，<code>b, c, p, s</code> 分别代表 block, character, pipe, and socket。</p>
<p>block 设备：Programs access data from a block device in fixed chunks，block device’s total size is fixed and easy to index, processes have quick random access to any block in the device with the help of the kernel.</p>
<p>character 设备：work with data streams，only character, don’t have a size. Like printer; kernel cannot back up and reexamine the data stream after it has passed data to a device or process.</p>
<p>Pipe device: like character device, work with IO process instead of kernel.</p>
<p>Socket device: special-purpose interfaces that are frequently used for interprocess communication. They’re often found outside of the /dev directory.</p>
<h2 id="系统设备路径">系统设备路径</h2>
<p>/dev 下面的名字所能告诉你的信息很有限，而且内核根据设备被发现的顺序来给设备命名，所以一旦计算机重启，这些设备的名字有可能会不一样。</p>
<p>Linux 根据设备的属性，提供了一个统一的视图来访问所有的设备，即： <code>/sys/devices</code>。</p>
<p>/dev 下的文件让用户进程可以与设备交互。/sys/devices 用来查看和管理设备。</p>
<p>sys 目录下还有一些分类，比如 <code>/sys/block</code> 下面都是块设备。</p>
<p>在 /dev 目录下，找到设备的路径上有点不容易，不过可以通过 <code>udevadm</code> 命令查看，我们将会在之后介绍更多关于这个命令的知识。</p>
<h2 id="dd-和-设备">dd 和 设备</h2>
<p><code>dd</code> 程序在与块设备与字符设备时非常方便，但它也是一个非常强大的命令，需要特别小心的使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从块数据中复制固定大小的数据</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=new_file bs=1024 count=1</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li>if, 输入文件，默认是标准输入</li>
<li>of, 输出文件，默认是标准输出</li>
<li>bs, 块大小，可以使用 b 或者 k</li>
<li>count=num，块的个数，当使用大文件或者文件流，需要用 count 或下面的 skip 来控制大小</li>
<li>skip=num, 另外一个控制大小的选项</li>
</ul>
<h2 id="设备名">设备名</h2>
<h3 id="找到设备名">找到设备名</h3>
<p>找到设备名有时候很麻烦，这里提供了集中方式：</p>
<ol type="1">
<li>使用 <code>udevadm</code></li>
<li>检查 /sys 目录</li>
<li>通过 <code>journalctl -k</code> 命令打印系统内核的消息、日志，猜测设备名</li>
<li>对于存储设备，可以通过 mount 命令查看</li>
<li>通过 <code>cat /proc/devices</code> 命令查看块设备和字符设备的驱动。</li>
</ol>
<p>其中只有第一种方式是最可靠的，建议主要还是用第一种方式，如果你的系统中实在是没有 <code>udevadm</code> 可以使用，可以再参考其他的方式。</p>
<p>下面的内容会例举出 Linux 中最常见的一些设备，以及它们的命名。</p>
<h3 id="存储设备-devsd">存储设备 /dev/sd*</h3>
<p>存储设备的命名一般以 sd 开头，即 SCSI disk 的简写, SCSI 的意思是：Small Computer System Interface。SCSI 是最早被开发用来在存储设备和外围设备之间进行通讯。</p>
<p><code>lsscsi</code> 命令可以用来检查设备中的存储设备，它的输出如下：</p>
<p><img src="https://s2.loli.net/2022/03/13/5Iuy2Kewt6jAJqX.png" /></p>
<p>其中 1 表示设备在系统中的位置；2 表示设备描述； 3 表示去哪里找到这个设备；</p>
<h3 id="虚拟存储-devxvd-devvd">虚拟存储 /dev/xvd*, /dev/vd*</h3>
<p>有的磁盘设备是为了虚拟机优化而存在的，例如 AWS 实例，Virtual-Box.</p>
<h3 id="non-volatile-memory-devices-devnvme">Non-Volatile Memory Devices: /dev/nvme*</h3>
<p>有一些系统现在使用 Non-Volatile memory，即 NVMe 接口与某些类型的固态存储通信。</p>
<p>可以用 <code>nvme list</code> 命令列出这些设备。</p>
<h3 id="device-mapper-devdm--devmapper">Device Mapper: /dev/dm-*, /dev/mapper/*</h3>
<p>Device Mapper 并不是一个文件系统（File System），而是 Linux 内核映射块设备的一种技术框架。提供的一种从逻辑设备（虚拟设备）到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。</p>
<p>使用了这种映射的名字一般以 <code>/dev/dm-</code> 或者 <code>/dev/mapper</code> 命名。</p>
<h3 id="cd-和-dvd-devsr">CD 和 DVD: /dev/sr*</h3>
<p>一般命名为 /dev/sr0, /dev/sr1，只读。如果是可以写的，可能会命名为：/dev/sg0.</p>
<h3 id="pata-hard-disks-devhd">PATA Hard Disks: /dev/hd*</h3>
<p>Older type of storage bus. <code>/dev/hda, /dev/hdb, /dev/hdc, and /dev/hdd</code> , 如果你发现你的 SATA 驱动被识别成上面的格式，则代表它工作在钱荣模式下，这会影响性能，你可以查看 BIOS 设置是否正确。</p>
<h3 id="终端devtty-devpts-and-devtty">终端：/dev/tty*, /dev/pts/*, and /dev/tty</h3>
<p>终端是一种设备，它在用户进程和 I/O 设备间传输字符。而且大部分终端属于伪设备，它不是一个真的硬件。</p>
<p>两个常见的终端设备是 /dev/tty1（第一个虚拟控制台）和 /dev/pts/0（第一个伪终端设备）。 /dev/pts 目录本身就是一个专用的文件系统。</p>
<p>显示模式和虚拟终端：</p>
<p>Linux 主要有两种显示模式，文本和图形。</p>
<p>Linux 系统传统上是在文本模式下启动的，现在分发的大部分的系统则会隐藏文本模式。</p>
<p>这里的控制台或终端都是计算机产生早期的遗留下来的概念。为了充分使用计算机提供的计算资源，早期很多计算机会连接若干终端控制台，这些终端控制台从硬件上构造很简单，只包括键盘和显示器，不执行计算的任务，只简单的把用户的输入发送到主计算机去处理，然后再把计算结果返回给用户。</p>
<h3 id="串行端口-devttys-devttyusb-devttyacm">串行端口: /dev/ttyS*, /dev/ttyUSB*, /dev/ttyACM*</h3>
<p>串行接口（Serial port），主要用于串行式逐位数据传输。按电气标准及协议来分包括RS-232-C、RS-422、RS485、USB等。 RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接外挂程式、电缆或协议。USB是近几年发展起来的新型接口标准，主要应用于高速数据传输领域。</p>
<p>可以使用 screen 来连接 usb 串口设备。</p>
<blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/304629">命令行界面、终端、Shell、TTY 的区别</a></p>
</blockquote>
<h3 id="并行端口devlp0-and-devlp1">并行端口：/dev/lp0 and /dev/lp1</h3>
<p>计算机上数据以并行方式传递的端口，也就是说至少应该有两条连接线用于传递数据。 与只使用一根线传递数据（这里没有包括用于接地、控制等的连接线）的串行端口相比，并口在相同的数据传送速率下，并口可以更快地传输数据。所以在21世纪之前，在需要较大传输速度的地方，例如打印机，并口得到广泛使用。但是随着速度迅速提高，并且上导线之间数据同步成为一个很难处理的难题，导致并口在速度竞赛中逐渐被淘汰。USB等改进的串口逐渐代替了并口。</p>
<h3 id="音频设备devsnd-devdsp-devaudio-and-more">音频设备：/dev/snd/*, /dev/dsp, /dev/audio, and More</h3>
<p>Linux 有两种音频设备，ALSA 和 OSS。分别代表了 Advanced Linux Sound Architecture 和 Open Sound System.</p>
<p>The ALSA devices are in the /dev/snd directory, but it’s difficult to work with them directly. Linux systems that use ALSA support OSS backward-compatible devices if the OSS kernel support is currently loaded.</p>
<h3 id="创建设备文件">创建设备文件</h3>
<p>在绝大多数情况下，你不需要自己创建设备文件，它们会被 devtmpfs 和 udev 自动创建。但我们至少可以学习一下如何做。</p>
<p><code>mknod</code> 命令可以用来创建一个设备。你必须知道设备的名字，以及它的主要、次要版本号，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b 8 1, 指定了 block 设备，major 版本为8，minor 版本为1</span></span><br><span class="line">mknod /dev/dda1 b 8 1</span><br></pre></td></tr></table></figure>
<p>对于linux 来说管理如此多的设备以及版本是非常复杂的，特别是当linux系统在升级的时候，后来出现了 devfs，一个内核空间中的 /dev 的实现，它包括了所有现在内核支持的设备，可以指定设备号、所有者、用户空间等信息，devfs 运行在内核环境中，并有不少缺点：可能出现主/辅设备号不够，命名不灵活，不能指定设备名称等问题。</p>
<p>所以后人又开发了 udev 和 devtmpfs.</p>
<h2 id="udev">udev</h2>
<p>关于 udev 的相关介绍，可以参考这篇文章: <a target="_blank" rel="noopener" href="https://www.pianshen.com/article/5062954066/">Linux 文件系统与设备文件系统 （一）—— udev 设备文件系统</a></p>
<h3 id="devtmpfs">devtmpfs</h3>
<p>The devtmpfs filesystem was developed in response to the problem of device availability during boot.</p>
<h3 id="udevd-操作和配置">udevd 操作和配置</h3>
<p>在 GNU/Linux 系统中，虽然设备的底层支持是在内核层面处理的，但是，它们相关的事件管理是在用户空间中通过 udev 来管理的。确切地说是由 udevd 守护进程来完成的。</p>
<p>Udevd 守护进程所作的操作如下：</p>
<ol type="1">
<li>内核通过内部的网络连接向 udevd 发送一个名为 uevent 的通知事件</li>
<li>udevd 从 uevent 中加载所有的属性</li>
<li>udevd 从 rule 中提取、过滤或者是更新相关内容</li>
</ol>
<p>可以使用 <code>udevadm monitor --property</code> 得到一个 uevent 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ACTION=change</span><br><span class="line">DEVNAME=sde</span><br><span class="line">DEVPATH=/devices/pci0000:00/0000:00:1a.0/usb1/1-1/1-1.2/1-1.2:1.0/host4/</span><br><span class="line">target4:0:0/4:0:0:3/block/sde</span><br><span class="line">DEVTYPE=disk</span><br><span class="line">DISK_MEDIA_CHANGE=1</span><br><span class="line">MAJOR=8</span><br><span class="line">MINOR=64</span><br><span class="line">SEQNUM=2752</span><br><span class="line">SUBSYSTEM=block</span><br><span class="line">UDEV_LOG=3</span><br></pre></td></tr></table></figure>
<p>udev 规则是定义在一个以 .rules 为扩展名的文件中。那些文件主要放在两个位置：/usr/lib/udev/rules.d，这个目录用于存放系统安装的规则；/etc/udev/rules.d/ 这个目录是保留给自定义规则的。</p>
<p>定义那些规则的文件的命名惯例是使用一个数字作为前缀（比如，50-udev-default.rules），并且以它们在目录中的词汇顺序进行处理的。在 /etc/udev/rules.d 中安装的文件，会覆盖安装在系统默认路径中的同名文件。</p>
<p>下面是 udevd 规则的行为逻辑：</p>
<ol type="1">
<li>udevd reads rules from start to finish of a rules file.</li>
<li>After reading a rule and possibly executing its action, udevd continues reading the current rules file for more applicable rules.</li>
<li>There are directives (such as GOTO) to skip over parts of rules files if necessary. These are usually placed at the top of a rules file to skip over the entire file if it’s irrelevant to a particular device that udevd is configuring.</li>
</ol>
<p>我们来看一下一个 /dev/sda 下面的符号链接，它被定义在 <code>lib/udev/rules.d/60-persistent-storage.rules</code> 当中，这个文件中有几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ATA</span><br><span class="line">KERNEL==&quot;sd*[!0-9]|sr*&quot;, ENV&#123;ID_SERIAL&#125;!=&quot;?*&quot;, SUBSYSTEMS==&quot;scsi&quot;, ATTRS&#123;vendor&#125;==&quot;ATA&quot;, IMPORT&#123;program&#125;=&quot;ata_id --export $devnode&quot;</span><br><span class="line"></span><br><span class="line"># ATAPI devices (SPC-3 or later)</span><br><span class="line">KERNEL==&quot;sd*[!0-9]|sr*&quot;, ENV&#123;ID_SERIAL&#125;!=&quot;?*&quot;, SUBSYSTEMS==&quot;scsi&quot;, ATTRS&#123;type&#125;==&quot;5&quot;,ATTRS&#123;scsi_level&#125;==&quot;[6-9]*&quot;, IMPORT&#123;program&#125;=&quot;ata_id --export $devnode&quot;</span><br></pre></td></tr></table></figure>
<p>通过内核的 SCSI 子系统，这些规则会与 AKA 硬盘以及 optical media 设备匹配，一般是通过文本的模式来匹配，比如 <code>"sd*[!0-9]|sr*"</code>.</p>
<blockquote>
<p>ATA 是一个广为使用的 IDE 和 EIDE设备相关的标准，意思是高级技术附件规格。ATA的硬盘分为 PATA 和 SATA，其中 P 代表的是并行、S代表的串行。目前 SATA 使用广泛，它的速度比 PATA 快太多，而且体积小、散热也更好。</p>
</blockquote>
<p>更多关于编写 udev 的规则，可参考这篇文章:&gt; <a target="_blank" rel="noopener" href="https://linux.cn/article-9365-1.html">在 Linux 中如何编写基本的 udev 规则</a></p>
<h3 id="udev管理工具udevadm">udev管理工具：udevadm</h3>
<p>Udevadm 程序是 udev 的一个管理工具。你可以重新加载 udev 的规则，触发事件，最重要的一个特性是，你可以查找和探索系统的设备，或者是监控内核发出的 uevents 事件。</p>
<p>我们首先来看看怎么使用 udevadm 检查系统设备。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info --query=all --name=/dev/sda </span><br></pre></td></tr></table></figure>
<p>下面是这条命令在我电脑上的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@scott-pc:/mnt/c/Users/Scott# udevadm info --query=all --name=/dev/sda</span><br><span class="line">P: /devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:0/block/sda</span><br><span class="line">N: sda</span><br><span class="line">L: 0</span><br><span class="line">E: DEVPATH=/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/fd1d2cbd-ce7c-535c-966b-eb5f811c95f0/host0/target0:0:0/0:0:0:0/block/sda</span><br><span class="line">E: DEVNAME=/dev/sda</span><br><span class="line">E: DEVTYPE=disk</span><br><span class="line">E: MAJOR=8</span><br><span class="line">E: MINOR=0</span><br><span class="line">E: SUBSYSTEM=block</span><br></pre></td></tr></table></figure>
<p>其中每一行代表了一个设备的属性，在上面的例子中：</p>
<ul>
<li>P: 最开始的那行，是 sysfs 设备路径</li>
<li>N: 设备节点，也就是给 /dev 下面文件的名字</li>
<li>S: 表明了设备节点的符号链接</li>
<li>E： 从 udevd 规则中找到的附加的信息</li>
</ul>
<h3 id="使用-udevadm-监控设备">使用 udevadm 监控设备</h3>
<p>你可以使用 <code>udevadm monitor</code> 来监控电脑上的设备，下面是它的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">KERNEL[658299.569485] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2 (usb)</span><br><span class="line">KERNEL[658299.569667] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0 (usb)</span><br><span class="line">KERNEL[658299.570614] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/host15 </span><br><span class="line">(scsi)</span><br><span class="line">KERNEL[658299.570645] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/ </span><br><span class="line">host15/scsi_host/host15 (scsi_host)</span><br><span class="line">UDEV [658299.622579] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2 (usb)</span><br><span class="line">UDEV [658299.623014] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0 (usb)</span><br><span class="line">UDEV [658299.623673] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/host15 </span><br><span class="line">(scsi)</span><br><span class="line">UDEV [658299.623690] add /devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/</span><br><span class="line">host15/scsi_host/host15 (scsi_host)</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure>
<p>这里有重复的输出，因为默认会输出来自内核的消息，以及 udevd 处理的消息，可以指定 --kernel 选项只查看内核的消息，--udev 查看 udevd处理的消息，以及--property 则可以让你查看整个 uevent, 包括属性。</p>
<p>你也可以通过 subsystem 来 filter 这些消息,比如你只想要看到 SCSI 子系统的 kernel 的消息，可执行下面的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ udevadm monitor --kernel --subsystem-match=scsi</span><br></pre></td></tr></table></figure>
<p>关于更多 Udevadm 的使用，可以查看 udevadm(8) 的操作手册。udev 本身还有很多其他的知识，例如有一个守护进程叫做 udisksd, 它会监听事件，当有新的磁盘接入的时候，会自动向进程发送消息。</p>
<h2 id="深入理解scsi-和-linux-内核">深入理解：SCSI 和 Linux 内核</h2>
<p>这一小节我们会探讨 Linux 内核对于 SCSI 的支持，以增加对 Linux 内核架构的理解。如果是为了学习如何使用磁盘，你无需学习本小节中的内容。</p>
<p>我们先讲一个小背景，传统的SCSi硬件配置是一个主机适配器通过 SCSI总线连接了一系列的设备，如下图所示:</p>
<p><img src="https://s2.loli.net/2022/03/17/hYZJzEHWNAUKQXp.png" /></p>
<p>其中的电脑通过 SCSI Host Adapter 来与其他的 Disk 通信，每一个 Disk 都有唯一的 ID，对于每一个单独的 Disk，他们之间可以通过 SCSI 命令进行点对点的通信。</p>
<p>新版本的 SCSI，也就是 Serial Attached SCSI （SAS）提供了更好的性能，但在大部分机器上，也许找不到任何真正意义上的 SCSI 设备。</p>
<p>SATA 磁盘在你的系统上，也已 SCSI 设备的形式出现，但是它们还是有一点不同的，因为它们中大部分都是通过 libata 库 中的翻译层通信。</p>
<p>这些说明了什么呢？假设我们查看系统上的设备，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lsscsi</span><br><span class="line">[0:0:0:0]   disk    ATA       WDC WD3200AAJS-2  01.0  /dev/sda</span><br><span class="line">[1:0:0:0]   cd/dvd  Slimtype  DVD A DS8A5SH     XA15  /dev/sr0</span><br><span class="line">[2:0:0:0]   disk    USB2.0    CardReader CF     0100  /dev/sdb</span><br><span class="line">[2:0:0:1]   disk    USB2.0    CardReader SM XD  0100  /dev/sdc</span><br><span class="line">[2:0:0:2]   disk    USB2.0    CardReader MS     0100  /dev/sdd</span><br><span class="line">[2:0:0:3]   disk    USB2.0    CardReader SD     0100  /dev/sde</span><br><span class="line">[3:0:0:0]   disk    FLASH     Drive UT_USB20    0.00  /dev/sdf</span><br></pre></td></tr></table></figure>
<p>先看方括号中的内容，从左至右分别是 SCSI 适配器号，SCSI 总线号，设备的 SCSI ID，以及 LUN（Logical Unit Number）逻辑快号。</p>
<p>上面的例子中，可以看到有四个适配器(scsi0-3)，每一个都有一个总线（号码都从0开始），每一个总线上，也只有一个设备。USB 读卡器在 2:0:0 上有四个逻辑单元，通过LUN 编号可以很容易看出这一点，即内核给每个逻辑单元都分配了一个 device file.</p>
<p>Figure 3-2 是内核中的驱动与接口的结构：</p>
<figure>
<img src="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png" alt="Figure 3-2" /><figcaption aria-hidden="true">Figure 3-2</figcaption>
</figure>
<ul>
<li>图中上面的层负责处理设备集的操作，比如 sd(SCSI Disk) 在这层；它知道如何翻译来自内核块设备接口的命令，将它变成磁盘特定的、SCSI 协议的指令</li>
<li>中间层，连接顶层和底层，传输 SCSI 消息，track 所有的SCSI总线，以及插入到系统上的设备</li>
<li>执行特定的硬件操作。</li>
</ul>
<blockquote>
<p>The top and bottom layers contain many different drivers, but it’s important to remember that, for any given device file on your system, the kernel (nearly always) uses one top-layer driver and one lower-layer driver. For the disk at /dev/sda in our example, the kernel uses the sd top-layer driver and the ATA bridge lower-layer driver.</p>
</blockquote>
<h3 id="usb-存储-and-scsi">USB 存储 and SCSI</h3>
<p>为了使 SCSI 子系统与常见的 USB 存储硬件通信，如图 3-2 所示，内核需要的不仅仅是一个较低层的 SCSI 驱动程序。 以 /dev/sdf 为代表的 USB 闪存驱动器可以理解 SCSI 命令，但要真正与驱动器通信，内核需要知道如何通过 USB 系统进行通信。</p>
<p>从抽象结构上来看，USB 和 SCSI 很像，它们都有 device classes, buses, host controller。 所以 Linux 在内核中一个 USB Subsystem.</p>
<p>就像 SCSI 子系统在其组件之间传递 SCSI 命令一样，USB 子系统在其组件之间传递 USB 消息。 甚至还有一个类似于 lsscsi 的 lsusb 命令。</p>
<p>这里有趣的在于，USB 子系统在一头使用的是 USB 命令，而另外一头则使用的是 SCSI 命令。</p>
<p>在结构上，USB 子系统和 SCSI 子系统是分开的，因为两个子系统不应该共享同一个驱动，为了让它们可以通信，在 SCSI 子系统中，还有一个 lower-layer 的 SCSI bridge.</p>
<h3 id="scsi-和-ata">SCSI 和 ATA</h3>
<p>SATA 硬盘和其他的CD/DVD设备都使用了 SATA 接口。为了连接内核中 SATA 专用的驱动与 SCSI 子系统，内核利用了一个 bridge driver, 内核使用了一个桥接驱动程序，就像 USB 驱动器一样，但具有不同的机制和额外的复杂性。 光驱使用 ATAPI，一种以 ATA 协议编码的 SCSI 命令版本。 但是，硬盘不使用 ATAPI，也不编码任何 SCSI 命令！</p>
<p>Linux 内核使用名为 libata 的库的一部分来协调 SATA（和 ATA）驱动器与 SCSI 子系统。</p>
<h3 id="通用-scsi-设备">通用 SCSI 设备</h3>
<p>当用户空间进程与 SCSI 子系统通信时，它通常通过块设备层和/或位于 SCSI 设备类驱动程序（如 sd 或 sr）之上的另一个其他内核服务来进行。 换句话说，大多数用户进程从不需要知道关于 SCSI 设备或其命令的任何信息。</p>
<p>但是，用户进程可以绕过设备类驱动程序,直接向设备提供 SCSI 协议命令。 例如可以在 lsscsi 命令后添加 -g 选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lsscsi -g</span><br><span class="line">[0:0:0:0]   disk    ATA       WDC WD3200AAJS-2  01.0  /dev/sda 1/dev/sg0</span><br><span class="line">[1:0:0:0]   cd/dvd  Slimtype  DVD A DS8A5SH     XA15  /dev/sr0   /dev/sg1</span><br><span class="line">[2:0:0:0]   disk    USB2.0    CardReader CF     0100  /dev/sdb   /dev/sg2</span><br><span class="line">[2:0:0:1]   disk    USB2.0    CardReader SM XD  0100  /dev/sdc   /dev/sg3</span><br><span class="line">[2:0:0:2]   disk    USB2.0    CardReader MS     0100  /dev/sdd   /dev/sg4</span><br><span class="line">[2:0:0:3]   disk    USB2.0    CardReader SD     0100  /dev/sde   /dev/sg5</span><br><span class="line">[3:0:0:0]   disk    FLASH     Drive UT_USB20    0.00  /dev/sdf   /dev/sg6</span><br></pre></td></tr></table></figure>
<p>为什么要使用通用设备？ 答案与内核中代码的复杂性有关。 随着任务变得越来越复杂，最好将它们排除在内核之外。 考虑 CD/DVD 写入和读取。 读取光盘是一个相当简单的操作，并且有一个专门的内核驱动程序。</p>
<p>然而，写入光盘比读取要困难得多，并且没有关键的系统服务依赖于写入的动作。 没有理由用这个活动来增加内核空间。 因此，要在 Linux 中写入光盘，您需要运行一个与通用 SCSI 设备（例如 /dev/sg1）对话的用户空间程序。 这个程序可能比内核驱动程序效率低一点，但它更容易构建和维护。</p>
<h3 id="单个设备的多种访问方法">单个设备的多种访问方法</h3>
<p>图 3-3 显示了 Linux SCSI 子系统从用户空间访问光驱的两个方法（sr 和 sg）（省略了 SCSI 底层以下的任何驱动程序）。</p>
<p>进程 A 使用 sr 驱动程序从驱动器读取，进程 B 使用 sg 驱动程序写入驱动器。 但是，像这样的进程通常不会同时运行以访问同一设备。</p>
<figure>
<img src="https://s2.loli.net/2022/03/17/XQPdsrIfNbOKVG8.png" alt="3-3" /><figcaption aria-hidden="true">3-3</figcaption>
</figure>
<p>在图 3-3 中，进程 A 从块设备中读取数据。 但是用户进程真的以这种方式读取数据吗？ 通常，答案是否定的。这种访问不是直接的，因为在块设备之上还有更多的层，甚至更多的硬盘访问点，我们将在下一章中学习。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/uploads/wechat-reward-image.png" alt="Scott 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Operating-System/" rel="tag"># Operating System</a>
              <a href="/tags/udev/" rel="tag"># udev</a>
              <a href="/tags/SCSI/" rel="tag"># SCSI</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/article/ec2d337d.html" rel="prev" title="设计数据密集型应用-数据系统 P2">
      <i class="fa fa-chevron-left"></i> 设计数据密集型应用-数据系统 P2
    </a></div>
      <div class="post-nav-item">
    <a href="/article/28c39ad6.html" rel="next" title="Spark-浅析API 与工具集P1">
      Spark-浅析API 与工具集P1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdevice-files"><span class="nav-number">1.</span> <span class="nav-text">设备文件系统（Device files）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%B7%AF%E5%BE%84"><span class="nav-number">2.</span> <span class="nav-text">系统设备路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dd-%E5%92%8C-%E8%AE%BE%E5%A4%87"><span class="nav-number">3.</span> <span class="nav-text">dd 和 设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%90%8D"><span class="nav-number">4.</span> <span class="nav-text">设备名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E8%AE%BE%E5%A4%87%E5%90%8D"><span class="nav-number">4.1.</span> <span class="nav-text">找到设备名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87-devsd"><span class="nav-number">4.2.</span> <span class="nav-text">存储设备 &#x2F;dev&#x2F;sd*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8-devxvd-devvd"><span class="nav-number">4.3.</span> <span class="nav-text">虚拟存储 &#x2F;dev&#x2F;xvd*, &#x2F;dev&#x2F;vd*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#non-volatile-memory-devices-devnvme"><span class="nav-number">4.4.</span> <span class="nav-text">Non-Volatile Memory Devices: &#x2F;dev&#x2F;nvme*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#device-mapper-devdm--devmapper"><span class="nav-number">4.5.</span> <span class="nav-text">Device Mapper: &#x2F;dev&#x2F;dm-*, &#x2F;dev&#x2F;mapper&#x2F;*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cd-%E5%92%8C-dvd-devsr"><span class="nav-number">4.6.</span> <span class="nav-text">CD 和 DVD: &#x2F;dev&#x2F;sr*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pata-hard-disks-devhd"><span class="nav-number">4.7.</span> <span class="nav-text">PATA Hard Disks: &#x2F;dev&#x2F;hd*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E7%AB%AFdevtty-devpts-and-devtty"><span class="nav-number">4.8.</span> <span class="nav-text">终端：&#x2F;dev&#x2F;tty*, &#x2F;dev&#x2F;pts&#x2F;*, and &#x2F;dev&#x2F;tty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3-devttys-devttyusb-devttyacm"><span class="nav-number">4.9.</span> <span class="nav-text">串行端口: &#x2F;dev&#x2F;ttyS*, &#x2F;dev&#x2F;ttyUSB*, &#x2F;dev&#x2F;ttyACM*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%AB%AF%E5%8F%A3devlp0-and-devlp1"><span class="nav-number">4.10.</span> <span class="nav-text">并行端口：&#x2F;dev&#x2F;lp0 and &#x2F;dev&#x2F;lp1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87devsnd-devdsp-devaudio-and-more"><span class="nav-number">4.11.</span> <span class="nav-text">音频设备：&#x2F;dev&#x2F;snd&#x2F;*, &#x2F;dev&#x2F;dsp, &#x2F;dev&#x2F;audio, and More</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="nav-number">4.12.</span> <span class="nav-text">创建设备文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#udev"><span class="nav-number">5.</span> <span class="nav-text">udev</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#devtmpfs"><span class="nav-number">5.1.</span> <span class="nav-text">devtmpfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#udevd-%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">5.2.</span> <span class="nav-text">udevd 操作和配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#udev%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7udevadm"><span class="nav-number">5.3.</span> <span class="nav-text">udev管理工具：udevadm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-udevadm-%E7%9B%91%E6%8E%A7%E8%AE%BE%E5%A4%87"><span class="nav-number">5.4.</span> <span class="nav-text">使用 udevadm 监控设备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3scsi-%E5%92%8C-linux-%E5%86%85%E6%A0%B8"><span class="nav-number">6.</span> <span class="nav-text">深入理解：SCSI 和 Linux 内核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#usb-%E5%AD%98%E5%82%A8-and-scsi"><span class="nav-number">6.1.</span> <span class="nav-text">USB 存储 and SCSI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scsi-%E5%92%8C-ata"><span class="nav-number">6.2.</span> <span class="nav-text">SCSI 和 ATA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8-scsi-%E8%AE%BE%E5%A4%87"><span class="nav-number">6.3.</span> <span class="nav-text">通用 SCSI 设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E8%AE%BE%E5%A4%87%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">单个设备的多种访问方法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Scott"
      src="/uploads/instagram_profile_image.png">
  <p class="site-author-name" itemprop="name">Scott</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wittyfans" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wittyfans" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/wittyfans" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;wittyfans" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/wittyfans0" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;wittyfans0" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Scott</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"7sScl0n1AlEtVDaUHuXzxPqc-gzGzoHsz","app_key":"qKXpoqGbK1sdFYMiik7Evuan","server_url":"https://7sscl0n1.lc-cn-n1-shared.com","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '7sScl0n1AlEtVDaUHuXzxPqc-gzGzoHsz',
      appKey     : 'qKXpoqGbK1sdFYMiik7Evuan',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
